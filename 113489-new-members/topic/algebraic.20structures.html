---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/algebraic.20structures.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html">algebraic structures</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="211863042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211863042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211863042">(Oct 01 2020 at 02:30)</a>:</h4>
<p>Is it possible, as an example, to define the notion of a group, prove properties that all groups have, prove that ℤ is a group under addition, and thus have proofs of those properties for ℤ under addition? The definition of a group that I know uses a set, so I'm not sure how that translates to type theory. Would a group be a type class?</p>



<a name="211863201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211863201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211863201">(Oct 01 2020 at 02:33)</a>:</h4>
<p>Type classes are a feature that let you attach structure to already existing things.  Group structures are a perfect use for type classes.</p>



<a name="211863252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211863252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211863252">(Oct 01 2020 at 02:34)</a>:</h4>
<p>My first thought was like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">closure</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">))</span>
<span class="o">(</span><span class="n">assoc</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">)))</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span>
<span class="o">(</span><span class="n">ident_1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">ident_2</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>
</code></pre></div>

<p>But then a set didn't seem right.</p>



<a name="211863338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211863338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211863338">(Oct 01 2020 at 02:36)</a>:</h4>
<p>With classes, it's this sort of setup:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">unit</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_unit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">op</span> <span class="n">x</span> <span class="n">unit</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">unit_op</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">op</span> <span class="n">unit</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">inv</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">unit</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_op</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">op</span> <span class="o">(</span><span class="n">inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">unit</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">group</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">op</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">+</span><span class="o">),</span>
 <span class="n">unit</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span>
 <span class="n">inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="o">,</span>
 <span class="bp">...</span>
<span class="o">}</span>
</code></pre></div>



<a name="211863378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211863378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211863378">(Oct 01 2020 at 02:37)</a>:</h4>
<p>Inverse is a function?</p>



<a name="211863422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211863422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211863422">(Oct 01 2020 at 02:38)</a>:</h4>
<p>You can define a group as an operation on a set, but with Lean you can lift sets up to being types (with <code>subtype</code>), so you may as well work with an operation on a type.</p>



<a name="211863446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211863446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211863446">(Oct 01 2020 at 02:39)</a>:</h4>
<p>I made inverse be a function, but you can use <code>classical.some</code> and the rest with your <code>inv_1</code> axiom to define it.</p>



<a name="211863516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211863516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211863516">(Oct 01 2020 at 02:40)</a>:</h4>
<p>My definition is the constructible version, since to form a group you would need to show you can give an explicit inverse function.  If you only care about classical reasoning, then this distinction doesn't matter.</p>



<a name="211863621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211863621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211863621">(Oct 01 2020 at 02:42)</a>:</h4>
<p>(By the way, type classes are just structures, but they plug into a special mechanism that lets Lean automatically locate relevant terms (called instances) of the structure.)</p>



<a name="211863745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211863745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211863745">(Oct 01 2020 at 02:45)</a>:</h4>
<p>Thank you. I'll see if I can make the classical version as you described.</p>



<a name="211864211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211864211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211864211">(Oct 01 2020 at 02:55)</a>:</h4>
<p>Actually, that is really cool.</p>



<a name="211864451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211864451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211864451">(Oct 01 2020 at 03:00)</a>:</h4>
<p>Here's an example of a generic lemma to get you started, if you didn't know the syntax already:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">group</span>

<span class="kd">lemma</span> <span class="n">unit_unique</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">unit'</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">op</span> <span class="n">unit'</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">unit'</span> <span class="bp">=</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">transitivity</span> <span class="n">op</span> <span class="n">unit'</span> <span class="n">unit</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">op_unit</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h_left</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="211864550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211864550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211864550">(Oct 01 2020 at 03:02)</a>:</h4>
<p>Thank you!</p>



<a name="211864575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211864575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211864575">(Oct 01 2020 at 03:03)</a>:</h4>
<p>I forgot the <code>open group</code> line.  This takes everything that's inside the <code>group</code> namespace (i.e., the fields of <code>group</code>) and makes them accessible without needing to write things like <code>group.op</code>.</p>



<a name="211865488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211865488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211865488">(Oct 01 2020 at 03:24)</a>:</h4>
<p>Did you mean that the classical version is just:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">group_classical</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">unit</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_unit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">op</span> <span class="n">x</span> <span class="n">unit</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">unit_op</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">op</span> <span class="n">unit</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="bp">∃</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">op</span> <span class="n">x</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">unit</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_op</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="bp">∃</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">},</span> <span class="n">op</span> <span class="n">b</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">unit</span><span class="o">)</span>
</code></pre></div>

<p>and that it is the instance that would have to use classical.some?</p>



<a name="211865518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211865518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211865518">(Oct 01 2020 at 03:25)</a>:</h4>
<p>actually you can drop the unit too</p>



<a name="211865563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211865563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211865563">(Oct 01 2020 at 03:26)</a>:</h4>
<p>but the two inverses generally have to be in the same existential</p>



<a name="211865576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/211865576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#211865576">(Oct 01 2020 at 03:26)</a>:</h4>
<p>groups I think are special because you can prove that the left and right inverse are the same, but for weaker structures you have to assume this</p>



<a name="212179372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212179372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212179372">(Oct 03 2020 at 16:35)</a>:</h4>
<p>Sorry, do you know how I would fix the syntax here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">total_order</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">T</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">asymm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">,</span> <span class="n">le</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">le</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">T</span><span class="o">,</span> <span class="n">le</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">le</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span>
<span class="o">(</span><span class="n">conn</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">,</span> <span class="n">le</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∨</span> <span class="n">le</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">is_upper_bound</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">le</span> <span class="n">s</span> <span class="n">t</span>
</code></pre></div>



<a name="212179436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212179436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212179436">(Oct 03 2020 at 16:37)</a>:</h4>
<p>They syntax for the <code>is_upper_bound</code> definition that is.</p>



<a name="212179750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212179750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212179750">(Oct 03 2020 at 16:46)</a>:</h4>
<p>I guess I just needed to change it to:<br>
<code>def is_upper_bound {T : Type*} [@total_order T] (S : set T) (t : T) : Prop := sorry</code>.</p>



<a name="212179957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212179957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212179957">(Oct 03 2020 at 16:53)</a>:</h4>
<p>Change the binder type in <code>total_order</code> to <code>(T : Type*)</code> instead, otherwise you'll have to write <code>@total_order</code> every time.</p>



<a name="212180072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212180072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212180072">(Oct 03 2020 at 16:56)</a>:</h4>
<p>Ok.</p>



<a name="212512635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212512635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212512635">(Oct 07 2020 at 03:54)</a>:</h4>
<p>I know I could use rewrite, but I can't figure out why t6 and s8 don't check here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">left_group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_unit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">e</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>


<span class="kn">open</span> <span class="n">left_group</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">left_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a'</span> <span class="bp">=</span> <span class="n">e</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">a'</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">op_inv</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">a'</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">s1</span> <span class="n">a</span><span class="o">,</span>
<span class="n">exists.elim</span> <span class="n">s2</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a'</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a'</span> <span class="k">in</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">op</span> <span class="n">y</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span>
    <span class="k">have</span> <span class="n">t1</span> <span class="o">:</span> <span class="n">op</span> <span class="n">y</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">a'</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">y</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">t2</span> <span class="o">:</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">a'</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">a'</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">a'</span><span class="o">))</span> <span class="o">:=</span> <span class="n">eq.symm</span> <span class="o">(</span><span class="n">assoc</span> <span class="n">a</span> <span class="n">a'</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">a'</span><span class="o">)),</span>
    <span class="k">have</span> <span class="n">t3</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a'</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a'</span> <span class="n">a</span><span class="o">)</span> <span class="n">a'</span> <span class="o">:=</span> <span class="n">assoc</span> <span class="n">a'</span> <span class="n">a</span> <span class="n">a'</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">t4</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">a'</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">a'</span><span class="o">))</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a'</span> <span class="n">a</span><span class="o">)</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">t3</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">a'</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">a'</span><span class="o">)))),</span>
    <span class="k">have</span> <span class="n">t5</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a'</span> <span class="n">a</span><span class="o">)</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">a1</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a'</span> <span class="n">a</span><span class="o">)</span> <span class="n">a'</span><span class="o">))),</span>
    <span class="k">have</span> <span class="n">t6</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a'</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">op_unit</span> <span class="n">a'</span><span class="o">)</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">))),</span>
    <span class="n">sorry</span>
  <span class="o">),</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">y'</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">y'</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">op_inv</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">exists.elim</span> <span class="n">s4</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">y'</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">op</span> <span class="n">y'</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">e</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">e</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.symm</span> <span class="o">(</span><span class="n">op_unit</span> <span class="n">y</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">op</span> <span class="n">e</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">y'</span> <span class="n">y</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">a2</span><span class="o">)</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">y</span><span class="o">)),</span>
    <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">y'</span> <span class="n">y</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">y'</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.symm</span> <span class="o">(</span><span class="n">assoc</span> <span class="n">y'</span> <span class="n">y</span> <span class="n">y</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">op</span> <span class="n">y'</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">y'</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s3</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="n">op</span> <span class="n">y'</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">y</span><span class="o">))),</span>
    <span class="n">sorry</span>
  <span class="o">)</span>
<span class="o">)</span>
</code></pre></div>



<a name="212512989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212512989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212512989">(Oct 07 2020 at 04:02)</a>:</h4>
<p>Any reason you're not using tactics?  Here's something you can do, for example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="k">have</span> <span class="n">t6</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">op_unit</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">op</span> <span class="n">y'</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">y'</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">s3</span><span class="o">,</span>
</code></pre></div>

<p>Though, here's how you can fix those two lines:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="k">have</span> <span class="n">t6</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a'</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">op_unit</span> <span class="n">a'</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">a'</span><span class="o">)),</span>
    <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">op</span> <span class="n">y'</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">y'</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s3.symm</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="n">op</span> <span class="n">y'</span> <span class="n">y</span><span class="o">)),</span>
</code></pre></div>



<a name="212513167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212513167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212513167">(Oct 07 2020 at 04:05)</a>:</h4>
<p>Why doesn't it work the way I had it?</p>



<a name="212513197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212513197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212513197">(Oct 07 2020 at 04:05)</a>:</h4>
<p>It seems like the one or more equalities might be backwards. I didn't look too carefully.</p>



<a name="212513366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212513366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212513366">(Oct 07 2020 at 04:08)</a>:</h4>
<p>By the way, to save yourself some typing, you can use underscores in places where Lean can infer what should go there:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="k">have</span> <span class="n">t6</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a'</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">op_unit</span> <span class="n">a'</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">_</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">op</span> <span class="n">y'</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">y'</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s3.symm</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">_</span><span class="o">),</span>
</code></pre></div>

<p>There's even a function precisely for this called <code>rfl</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="k">have</span> <span class="n">t6</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a'</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">op_unit</span> <span class="n">a'</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">op</span> <span class="n">y'</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">y'</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s3.symm</span> <span class="n">rfl</span><span class="o">,</span>
</code></pre></div>



<a name="212513492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212513492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212513492">(Oct 07 2020 at 04:11)</a>:</h4>
<p>Hmm.</p>



<a name="212513580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212513580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212513580">(Oct 07 2020 at 04:13)</a>:</h4>
<p>In case you're not familiar with the dot notation: <code>(op_unit a').symm</code> is short for <code>eq.symm (op_unit a')</code>.  Lean knows <code>op_unit a'</code> is an <code>eq</code> so it looks for something called <code>symm</code> in the <code>eq</code> namespace.</p>



<a name="212513958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212513958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212513958">(Oct 07 2020 at 04:20)</a>:</h4>
<p>I think I must be misunderstanding how eq.subst works. I'm trying to extrapolate from the example in <a href="https://leanprover.github.io/logic_and_proof/first_order_logic_in_lean.html#equality-and-calculational-proofs">https://leanprover.github.io/logic_and_proof/first_order_logic_in_lean.html#equality-and-calculational-proofs</a></p>



<a name="212514236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212514236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212514236">(Oct 07 2020 at 04:28)</a>:</h4>
<p>Well, let's look at the type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">eq.subst</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">P</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">b</span>
</code></pre></div>

<p>This is saying, giving an equality <code>a = b</code> and that <code>P a</code> is true, then <code>P b</code> is true.  Lean will try to figure out what <code>P</code> is automatically , and if you want to use <code>eq.subst</code> it can be useful using <code>@eq.subst</code> to explicitly give the <code>P</code> you want.</p>
<p>You have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">op_unit</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">op</span> <span class="n">e</span> <span class="n">a'</span> <span class="bp">=</span> <span class="n">a'</span>
</code></pre></div>

<p>and you are trying to prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a'</span>
</code></pre></div>

<p>The issue is that in <code>eq.subst (op_unit a') (eq.refl (op a (op e a')))</code>, Lean doesn't figure out the correct <code>P</code> (I don't know it's algorithm to derive a <code>P</code>, so I have no idea why).  I believe it happens to find</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">P</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="n">x</span>
</code></pre></div>



<a name="212514315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212514315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212514315">(Oct 07 2020 at 04:31)</a>:</h4>
<p>Oh, that's actually the <code>P</code> that you wanted, and Lean found a different one.  This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="k">have</span> <span class="n">t6</span> <span class="o">:</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">eq.subst</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">e</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">op_unit</span> <span class="n">a'</span><span class="o">)</span> <span class="n">rfl</span><span class="o">,</span>
</code></pre></div>



<a name="212514528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/212514528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#212514528">(Oct 07 2020 at 04:36)</a>:</h4>
<p>I see. Thank you.</p>



<a name="213629828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213629828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213629828">(Oct 17 2020 at 01:44)</a>:</h4>
<p>How do you define something like a subgroup with this form of definition?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">left_group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_unit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">e</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">a'</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>
</code></pre></div>



<a name="213629966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213629966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213629966">(Oct 17 2020 at 01:49)</a>:</h4>
<p>I suggest to look at how subgroups are defined in mathlib <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup">docs#subgroup</a></p>



<a name="213630017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213630017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213630017">(Oct 17 2020 at 01:50)</a>:</h4>
<p>I had. I was confused that it referred to a set.</p>



<a name="213630030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213630030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213630030">(Oct 17 2020 at 01:51)</a>:</h4>
<p>Well, a subgroup is a subset of a group such that blah blah blah...</p>



<a name="213630080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213630080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213630080">(Oct 17 2020 at 01:52)</a>:</h4>
<p><code>set G</code> is the type of subsets of a type <code>G</code>.</p>



<a name="213630093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213630093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213630093">(Oct 17 2020 at 01:53)</a>:</h4>
<p>Oh. I see. Thank you.</p>



<a name="213631927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213631927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213631927">(Oct 17 2020 at 02:49)</a>:</h4>
<p>There is some coercion magic involved in making subgroups "be" groups.  There's a <code>has_coe_to_sort</code> instance that turns the carrier set into a type, and then that type is given a group instance.</p>
<p>I think I extracted most of what goes into subobjects here, except for the copy and ext lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">foo</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">foo</span>

<span class="kd">structure</span> <span class="n">subfoo</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">foo</span> <span class="n">X</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_mem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">,</span> <span class="n">foo.op</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">subfoo</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">foo</span> <span class="n">X</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">subfoo</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">subfoo.carrier</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">X</span> <span class="o">(</span><span class="n">subfoo</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">Y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">@[simp, norm_cast]</span>
<span class="kd">lemma</span> <span class="n">mem_coe</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="n">subfoo</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp, norm_cast]</span>
<span class="kd">lemma</span> <span class="n">coe_coe</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">subfoo</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="n">to_foo</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">subfoo</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">Y</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">op</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">op</span> <span class="n">x.1</span><span class="o">,</span> <span class="n">Y.op_mem</span> <span class="n">x.1</span> <span class="n">x.2</span><span class="o">⟩</span> <span class="o">}</span>

<span class="kd">@[simp, norm_cast]</span>
<span class="kd">lemma</span> <span class="n">coe_op</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="n">subfoo</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">op</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="bp">↑</span><span class="n">y</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp, norm_cast]</span>
<span class="kd">lemma</span> <span class="n">coe_mk</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="n">subfoo</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="o">((⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">end</span> <span class="n">subfoo</span>
</code></pre></div>



<a name="213632040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213632040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213632040">(Oct 17 2020 at 02:53)</a>:</h4>
<p>Then you'd probably also want to define the lattice of subobjects (take a look at the <code>complete_lattice</code> instance for subgroups).</p>



<a name="213662429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213662429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213662429">(Oct 17 2020 at 17:44)</a>:</h4>
<p>Thank you. I may have to come back to this when I understand more.</p>



<a name="213662474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213662474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213662474">(Oct 17 2020 at 17:45)</a>:</h4>
<p>Why doesn't the type of <code>e</code> match in this lemma definition?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">left_group_set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">closure</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span>
<span class="o">(</span><span class="n">assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_unit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="n">e</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">left_group_set</span>

<span class="kd">lemma</span> <span class="n">idempotent</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">left_group_set</span> <span class="n">α</span> <span class="n">S</span> <span class="n">op</span><span class="o">]</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="213663081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663081">(Oct 17 2020 at 17:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">left_group_set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">closure</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span>
<span class="o">(</span><span class="n">assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_unit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="n">e</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">left_group_set</span>

<span class="kd">lemma</span> <span class="n">idempotent</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">left_group_set</span> <span class="n">α</span> <span class="n">S</span> <span class="n">op</span><span class="o">]</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">e</span> <span class="n">S</span> <span class="n">op</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="213663090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663090">(Oct 17 2020 at 17:58)</a>:</h4>
<p><code>e</code> turns out to be a function which takes two explicit variables</p>



<a name="213663107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663107">(Oct 17 2020 at 17:59)</a>:</h4>
<p>Because of the way I defined <code>left_group_set</code> with two parameters?</p>



<a name="213663152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663152">(Oct 17 2020 at 18:00)</a>:</h4>
<p>Yeah exactly.</p>



<a name="213663155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663155">(Oct 17 2020 at 18:00)</a>:</h4>
<p>Thank you.</p>



<a name="213663251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663251">(Oct 17 2020 at 18:02)</a>:</h4>
<p>Why if I move <code>S</code> and <code>op</code> into the body does <code>e</code> not need <code>α</code>. Why does it become implicit?</p>



<a name="213663274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663274">(Oct 17 2020 at 18:03)</a>:</h4>
<p>Because lean knows about <code>\alpha</code> from <code>a</code> (which has type <code>\alpha</code>).</p>



<a name="213663332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663332">(Oct 17 2020 at 18:04)</a>:</h4>
<p>When in doubt, you can just use <code>#check e</code> to see exactly what it's type is. Or maybe <code>#check @e</code>.</p>



<a name="213663379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663379">(Oct 17 2020 at 18:05)</a>:</h4>
<p>If you're trying to simulate subgroups, the usual way to do it is like this... (one sec, I'll write up some code)</p>



<a name="213663439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663439">(Oct 17 2020 at 18:06)</a>:</h4>
<p>I think Kyle already did.</p>



<a name="213663459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663459">(Oct 17 2020 at 18:07)</a>:</h4>
<p>I wanted to try proving a lemma with the set version and then coerceing it to the type version.</p>



<a name="213663524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663524">(Oct 17 2020 at 18:09)</a>:</h4>
<p>So I didn't introduce <code>α</code> with curly brackets in the class definition, but it still took it as implicit for <code>e</code>?</p>



<a name="213663585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663585">(Oct 17 2020 at 18:10)</a>:</h4>
<p>Usually you would prove a lemma about groups, and deduce them for subgroups by proving that subgroups are groups.</p>



<a name="213663606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663606">(Oct 17 2020 at 18:10)</a>:</h4>
<p>I don't think I understand what you're trying to do here...</p>



<a name="213663638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663638">(Oct 17 2020 at 18:11)</a>:</h4>
<p>I'm not looking at subgroups here. Well, maybe later. I just like that the set version requires the usual closure axiom, and wanted to try to use it.</p>



<a name="213663684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663684">(Oct 17 2020 at 18:12)</a>:</h4>
<p>Why are you defining a set version in the first place?</p>



<a name="213663728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663728">(Oct 17 2020 at 18:13)</a>:</h4>
<p>Playing around I guess. It is the usual definition given in books, so I wanted to see if I could use it.</p>



<a name="213663801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663801">(Oct 17 2020 at 18:15)</a>:</h4>
<p>It's not the usual definition given in books though.</p>



<a name="213663809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663809">(Oct 17 2020 at 18:15)</a>:</h4>
<p>It's not?</p>



<a name="213663823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213663823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213663823">(Oct 17 2020 at 18:15)</a>:</h4>
<p>This is like defining a group to be the data of a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> and a subset <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> has a operation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>p</mi><mo>:</mo><mi>α</mi><mo>→</mo><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">op : \alpha \to \alpha \to \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> and an element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">e : \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">e \in S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> and such that the operation and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> induce a group structure on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>.</p>



<a name="213664161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664161">(Oct 17 2020 at 18:22)</a>:</h4>
<p>So instead we make <code>α</code> simulate the set in the usual definition right? Then the closure axiom becomes implicit right? I mainly wanted to have to prove things explicitly using the closure axiom.</p>



<a name="213664176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664176">(Oct 17 2020 at 18:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">class</span> <span class="n">left_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_assoc</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">}</span> <span class="o">:</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span>
<span class="o">(</span><span class="n">e_op</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="o">:</span> <span class="n">op</span> <span class="n">e</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_linv</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">op</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">left_group</span>

<span class="kd">structure</span> <span class="n">sub_left_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">left_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_mem</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">op</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">e_mem</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">linv_mem</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">op</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="c1">-- I don't know what you want to actually put for linv_mem, but you get the point.</span>

<span class="kd">instance</span> <span class="n">foo1</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">left_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">sub_left_group</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="kt">Type</span><span class="bp">*</span><span class="o">,</span><span class="bp">λ</span> <span class="n">S</span><span class="o">,</span> <span class="n">subtype</span> <span class="n">S.carrier</span><span class="o">⟩</span>

<span class="kn">open</span> <span class="n">sub_left_group</span>

<span class="kd">instance</span> <span class="n">foo2</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">left_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">sub_left_group</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">left_group</span> <span class="n">H</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">op</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">⟨</span><span class="n">op</span> <span class="n">x.1</span> <span class="n">y.1</span><span class="o">,</span> <span class="n">op_mem</span> <span class="n">_</span> <span class="n">x.2</span> <span class="n">y.2</span><span class="o">⟩,</span>
  <span class="n">e</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">e_mem</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">op_assoc</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">op_assoc</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">e_op</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="o">⟨⟩,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">e_op</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">exists_linv</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="o">⟨⟩,</span>
    <span class="n">rcases</span> <span class="n">exists_linv</span> <span class="n">a_val</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span><span class="n">hb</span><span class="o">⟩,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">H.carrier</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">linv_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a_property</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">hb</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">e_mem</span> <span class="o">},</span>
    <span class="n">use</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span><span class="n">this</span><span class="o">⟩,</span>
    <span class="n">simpa</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="213664222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664222">(Oct 17 2020 at 18:24)</a>:</h4>
<p>That's a sketch.</p>



<a name="213664230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664230">(Oct 17 2020 at 18:24)</a>:</h4>
<p>Or I should say the closure axiom is automatically included by the definition of op. I wanted to avoid making it automatic.</p>



<a name="213664246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664246">(Oct 17 2020 at 18:25)</a>:</h4>
<p>There is no closure axiom. A group operation is by definition just a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>α</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha \to \alpha \to \alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.</p>



<a name="213664253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664253">(Oct 17 2020 at 18:25)</a>:</h4>
<p>When you go to define a subgroup, you need an axiom that tells you the subset is closed under the operation.</p>



<a name="213664310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664310">(Oct 17 2020 at 18:26)</a>:</h4>
<p>It usually has to be given that that function is closed (in the set version) right?</p>



<a name="213664322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664322">(Oct 17 2020 at 18:26)</a>:</h4>
<p>What is a closed function?</p>



<a name="213664395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664395">(Oct 17 2020 at 18:28)</a>:</h4>
<p>Takes members of the set to members of the set.<br>
<a href="https://proofwiki.org/wiki/Definition:Group">https://proofwiki.org/wiki/Definition:Group</a><br>
G0</p>



<a name="213664451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664451">(Oct 17 2020 at 18:30)</a>:</h4>
<p>This assumes all sets are subsets of some universe <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">U</mi></mrow><annotation encoding="application/x-tex">\mathbb{U}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">U</span></span></span></span></span>.</p>



<a name="213664507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664507">(Oct 17 2020 at 18:30)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Binary_operation">https://en.wikipedia.org/wiki/Binary_operation</a></p>



<a name="213664688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664688">(Oct 17 2020 at 18:34)</a>:</h4>
<p>I honestly don't know whether there is any mathematician out there that thinks of a group operation on a group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> as a function  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>:</mo><mi>G</mi><mo>×</mo><mi>G</mi><mo>→</mo><mi mathvariant="double-struck">U</mi></mrow><annotation encoding="application/x-tex">\mu : G \times G \to \mathbb{U}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">U</span></span></span></span></span> into some universe <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">U</mi></mrow><annotation encoding="application/x-tex">\mathbb{U}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">U</span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> is a subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">U</mi></mrow><annotation encoding="application/x-tex">\mathbb{U}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">U</span></span></span></span></span> and it just so happens that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\mu(g,h) \in G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">μ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">g,h \in G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>.</p>



<a name="213664719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664719">(Oct 17 2020 at 18:35)</a>:</h4>
<p>Maybe the model theorists will prove me wrong with their monster models ;)</p>



<a name="213664792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213664792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213664792">(Oct 17 2020 at 18:37)</a>:</h4>
<p>But in any case, if you do go this route with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">U</mi></mrow><annotation encoding="application/x-tex">\mathbb{U}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">U</span></span></span></span></span>, you would be really going against what type theory is all about, and it will be very difficult to work with the object you define.</p>



<a name="213665200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213665200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213665200">(Oct 17 2020 at 18:46)</a>:</h4>
<p>Here's a definition of (sub)monoids, using this "subsets of the universe approach."</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">UNIVERSE</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">class</span> <span class="n">monoid'</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">UNIVERSE</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_assoc</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">}</span> <span class="o">:</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>
<span class="o">(</span><span class="n">e_op</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">op</span> <span class="n">e</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_e</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">op</span> <span class="n">x</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">monoid'</span>

<span class="kd">structure</span> <span class="n">submonoid'</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">UNIVERSE</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid'</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">set</span> <span class="n">UNIVERSE</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_subset</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">⊆</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_mem</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">:</span> <span class="n">x.1</span> <span class="bp">∈</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">y.1</span> <span class="bp">∈</span> <span class="n">H</span> <span class="bp">→</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">∈</span> <span class="n">H</span><span class="o">)</span>
<span class="o">(</span><span class="n">e_mem</span> <span class="o">:</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">∈</span> <span class="n">H</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">foo</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">UNIVERSE</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid'</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">submonoid'</span> <span class="n">G</span><span class="o">}</span> <span class="o">:</span> <span class="n">monoid'</span> <span class="o">(</span><span class="n">H.H</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">op</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">⟨(</span><span class="n">op</span> <span class="o">⟨</span><span class="n">x.1</span><span class="o">,</span><span class="n">H.is_subset</span> <span class="n">x.2</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">y.1</span><span class="o">,</span><span class="n">H.is_subset</span> <span class="n">y.2</span><span class="o">⟩)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">H.op_mem</span> <span class="n">x.2</span> <span class="n">y.2</span><span class="o">⟩,</span>
  <span class="n">e</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span><span class="n">H.e_mem</span><span class="o">⟩,</span>
  <span class="n">op_assoc</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">e_op</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">op_e</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="213665470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213665470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213665470">(Oct 17 2020 at 18:50)</a>:</h4>
<p>But again, I should stress that this is not the right way to go about defining monoids.</p>



<a name="213666252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213666252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213666252">(Oct 17 2020 at 19:07)</a>:</h4>
<p>Ok. Thank you.</p>



<a name="213667255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213667255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213667255">(Oct 17 2020 at 19:33)</a>:</h4>
<p>The closure axiom for groups is a holdover from an earlier time, and in modern books on algebra it's omitted since it's superfluous like <span class="user-mention" data-user-id="243562">@Adam Topaz</span> already explained.  My understanding is that most groups arose from a pre-existing (associative) binary operation, for example matrix multiplication, and so you would want to restrict this operation to some subset of, following the example, invertible matrices that's closed under matrix multiplication.</p>
<p>Doing this from the modern point of view, you would first show that you can restrict your pre-existing binary operation to your set-of-interest <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>, and then from there you'd check the group axioms.  In Lean, you can create a type from a set <em>very</em> easily.  You can use a set anywhere Lean expects a type and it will be automatically coerced, and for places this doesn't work there's a coercion arrow <code>↥</code> for places this.  You can also use <code>subtype</code> to explicitly convert predicates into types.</p>
<p>Here's an example of restricting the addition operation of the natural numbers to the set of natural numbers that are greater than or equal to some fixed natural number.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ℕge</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">ℕge.add</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕge</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕge</span> <span class="n">n</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">a.1</span> <span class="bp">+</span> <span class="n">b.1</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">a</span><span class="o">,</span> <span class="n">cases</span> <span class="n">b</span><span class="o">,</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">ℕge</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">}⟩</span>
</code></pre></div>

<p>The definition has two parts: the first is the operation, and the second is the proof of closure.</p>
<p>Checking the type, we see it's</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ℕge.add</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="bp">↥</span><span class="o">(</span><span class="n">ℕge</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">↥</span><span class="o">(</span><span class="n">ℕge</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">↥</span><span class="o">(</span><span class="n">ℕge</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>

<p>and the up-arrows indicate Lean has coerced each of the sets to types.  There's some special notation for immediate coercion of a set constructed with set builder notation to a type, and that's using <code>//</code> instead of <code>|</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">↥</span><span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">//</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span><span class="o">}</span>
</code></pre></div>



<a name="213668232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213668232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213668232">(Oct 17 2020 at 19:58)</a>:</h4>
<p>The closure axiom is superfluous because we can prove interesting things without it, and it can be moved from the definition of a group to a requirement of the operation on the set of interest?</p>



<a name="213668976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213668976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213668976">(Oct 17 2020 at 20:16)</a>:</h4>
<p>Pretty much -- just to clarify a bit more, in the modern approach we're comfortable with the process of restricting functions to subsets as needed, so in the definition of a group we can simply state there is an operation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>×</mo><mi>G</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">G\times G\to G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> that's associative, has an identity, and has left and right inverses.  You only need to think about closure if you're restricting a pre-existing operation.</p>
<p>(Said differently, the old approach seems to start with a monoid, then you find a subset that forms a submonoid ("closure"), and then you prove the modern group axioms for this monoid.  The first two steps are not essential in the definition of a group.)</p>



<a name="213669226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/213669226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#213669226">(Oct 17 2020 at 20:22)</a>:</h4>
<p>Thank you.</p>



<a name="214128320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214128320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214128320">(Oct 21 2020 at 23:42)</a>:</h4>
<p>Why does it seem that I need to choose a class name other than <code>group</code> here, when I put it in a namespace?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">class</span> <span class="n">group'</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">unit</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">unit_op</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">unit</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_op</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">unit</span><span class="o">)</span>


<span class="kn">open</span> <span class="n">group'</span>


<span class="kd">lemma</span> <span class="n">idempotent</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group'</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">op</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
<span class="k">let</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">inv</span> <span class="n">x</span> <span class="k">in</span>
<span class="k">calc</span>
<span class="n">x</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">unit</span> <span class="n">x</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">eq.symm</span> <span class="o">(</span><span class="n">unit_op</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x'</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">(</span><span class="n">inv_op</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">x'</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">eq.symm</span> <span class="o">(</span><span class="n">assoc</span> <span class="n">x'</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">x'</span> <span class="n">x</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">a1</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">unit</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exact</span> <span class="o">(</span><span class="n">inv_op</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="214128856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214128856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214128856">(Oct 21 2020 at 23:50)</a>:</h4>
<p>Lean doesn't know that you intended for <code>open group</code> to refer to the namespace <code>hidden.group</code> rather than <code>group</code>.</p>



<a name="214128893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214128893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214128893">(Oct 21 2020 at 23:51)</a>:</h4>
<p>Ah. Yes, changing it to <code>hidden.group</code> works. Thank you!</p>



<a name="214440505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214440505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214440505">(Oct 24 2020 at 17:56)</a>:</h4>
<p>If I define a field by extending the definition of a group, do I have to keep the names used by the group (op, e, etc.) in the definition of the field? If so, can I instead reuse the theorems proved for a group with a separate definition of a field?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>


<span class="kd">class</span> <span class="n">group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_unit_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">e</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>


<span class="kn">open</span> <span class="n">hidden.group</span>


<span class="kd">lemma</span> <span class="n">group.idempotent</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">e</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">op</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
<span class="k">let</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">inv</span> <span class="n">x</span> <span class="k">in</span>
<span class="k">calc</span>
<span class="n">x</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">e</span> <span class="n">x</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">eq.symm</span> <span class="o">(</span><span class="n">op_unit_left</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x'</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">(</span><span class="n">op_inv_left</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">x'</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">eq.symm</span> <span class="o">(</span><span class="n">assoc</span> <span class="n">x'</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">x'</span> <span class="n">x</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">a1</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">e</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exact</span> <span class="o">(</span><span class="n">op_inv_left</span> <span class="n">x</span><span class="o">)</span>


<span class="kd">class</span> <span class="n">field</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_inv</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">add</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">add</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_zero_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">zero</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="o">(</span><span class="n">add_inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">mul</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mul</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">mul</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_one_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">one</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span> <span class="bp">→</span> <span class="n">mul</span> <span class="o">(</span><span class="n">mul_inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">one</span><span class="o">)</span>
<span class="o">(</span><span class="n">dist</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>


<span class="kn">open</span> <span class="n">hidden.field</span>


<span class="kd">lemma</span> <span class="n">field.add_idempotent</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">sorry</span>


<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="214440825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214440825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214440825">(Oct 24 2020 at 18:02)</a>:</h4>
<p>You actually can, with <code>old_structure_cmd</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kd">class</span> <span class="n">group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_unit_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">e</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span>


<span class="kn">open</span> <span class="n">hidden.group</span>


<span class="kd">lemma</span> <span class="n">group.idempotent</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">e</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">op</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
<span class="k">let</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">inv</span> <span class="n">x</span> <span class="k">in</span>
<span class="k">calc</span>
<span class="n">x</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">e</span> <span class="n">x</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">eq.symm</span> <span class="o">(</span><span class="n">op_unit_left</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x'</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">(</span><span class="n">op_inv_left</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">x'</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">eq.symm</span> <span class="o">(</span><span class="n">assoc</span> <span class="n">x'</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">x'</span> <span class="n">x</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">a1</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">e</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exact</span> <span class="o">(</span><span class="n">op_inv_left</span> <span class="n">x</span><span class="o">)</span>


<span class="kd">class</span> <span class="n">field</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">group</span> <span class="n">F</span>
  <span class="kn">renaming</span>
    <span class="n">op</span> <span class="bp">→</span> <span class="n">add</span>
    <span class="n">e</span> <span class="bp">→</span> <span class="n">zero</span>
    <span class="n">inv</span> <span class="bp">→</span> <span class="n">add_inv</span>
    <span class="n">assoc</span> <span class="bp">→</span> <span class="n">add_assoc</span>
    <span class="n">op_unit_left</span> <span class="bp">→</span> <span class="n">add_zero_left</span>
    <span class="n">op_inv_left</span> <span class="bp">→</span> <span class="n">add_inv_left</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">add</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">mul</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mul</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">mul</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_one_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">one</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span> <span class="bp">→</span> <span class="n">mul</span> <span class="o">(</span><span class="n">mul_inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">one</span><span class="o">)</span>
<span class="o">(</span><span class="n">dist</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>


<span class="kn">open</span> <span class="n">hidden.field</span>

<span class="kd">lemma</span> <span class="n">field.add_idempotent</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span> <span class="o">:=</span>
<span class="n">group.idempotent</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="214440935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214440935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214440935">(Oct 24 2020 at 18:05)</a>:</h4>
<p><code>renaming</code> doesn't seem to ever be used in mathlib!</p>



<a name="214440954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214440954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214440954">(Oct 24 2020 at 18:05)</a>:</h4>
<p>Yeah, I think I discovered this feature while trying to figure out why the <code>a</code> -&gt; <code>_x</code> change was causing Lean to crash</p>



<a name="214440955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214440955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214440955">(Oct 24 2020 at 18:05)</a>:</h4>
<p>Nice! Is there a way I can make it work for mul too, with the condition on the mul_inv_left?</p>



<a name="214441007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214441007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214441007">(Oct 24 2020 at 18:06)</a>:</h4>
<p>But a field isn't a group under multiplication</p>



<a name="214441017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214441017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214441017">(Oct 24 2020 at 18:06)</a>:</h4>
<p>I know, hence the condition.</p>



<a name="214441030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214441030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214441030">(Oct 24 2020 at 18:06)</a>:</h4>
<p>If you add the condition then you're not putting a group structure on F.</p>



<a name="214441040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214441040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214441040">(Oct 24 2020 at 18:07)</a>:</h4>
<p>Ok.</p>



<a name="214441065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214441065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214441065">(Oct 24 2020 at 18:07)</a>:</h4>
<p>But if you also have a <code>monoid</code> class then I think you could extend both while renaming both.</p>



<a name="214441111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214441111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214441111">(Oct 24 2020 at 18:08)</a>:</h4>
<p>You could make a new type, a subtype of F, and try to put a group structure on this, but before this will work you'll need to prove some theorems guaranteeing that the product of two non-zero things is non-zero etc.</p>



<a name="214441116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214441116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214441116">(Oct 24 2020 at 18:08)</a>:</h4>
<p>See <a href="https://github.com/leanprover-community/lean/blob/master/tests/lean/run/record10.lean">https://github.com/leanprover-community/lean/blob/master/tests/lean/run/record10.lean</a> (which also uses some other feature <code>private</code> which I don't know about).</p>



<a name="214441208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214441208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214441208">(Oct 24 2020 at 18:10)</a>:</h4>
<p>I'll try the monoid. Thank you!</p>



<a name="214442317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214442317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214442317">(Oct 24 2020 at 18:34)</a>:</h4>
<p>Hmm, it seems that a monoid defines both the left and right identity property, which a group and field do not.</p>



<a name="214442417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214442417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214442417">(Oct 24 2020 at 18:37)</a>:</h4>
<p>there is no one definition of a group/field -- no "official list of axioms" (not least because mathematicians can't tell the difference between the left identity and right identity assertions for symmetry reasons). The left and right identity property are true in a group. If you don't want to add both as axioms then you could prove them from what you have decided to use as axioms.</p>



<a name="214466645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214466645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214466645">(Oct 25 2020 at 03:58)</a>:</h4>
<p>Would this be a correct definition of a complete ordered field, that is an axiomatic approach to defining the real numbers?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">class</span> <span class="n">total_order</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">T</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_asymm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_conn</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>


<span class="kd">class</span> <span class="n">field</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_inv</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">add</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">add</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_zero_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">zero</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="o">(</span><span class="n">add_inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">mul</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mul</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">mul</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_one_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">one</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span> <span class="bp">→</span> <span class="n">mul</span> <span class="o">(</span><span class="n">mul_inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">one</span><span class="o">)</span>
<span class="o">(</span><span class="n">dist_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span>


<span class="kd">class</span> <span class="n">ordered_field</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">field</span> <span class="n">F</span><span class="o">,</span> <span class="n">total_order</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="o">(</span><span class="n">add</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>
<span class="o">(</span><span class="n">mul_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">le</span> <span class="n">zero</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">zero</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">zero</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span>


<span class="kn">open</span> <span class="n">total_order</span>

<span class="kd">def</span> <span class="n">is_ub</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">le</span> <span class="n">s</span> <span class="n">t</span>

<span class="kd">def</span> <span class="n">is_lub</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">T</span><span class="o">,</span> <span class="o">(</span><span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">t</span> <span class="n">r</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">complete_ordered_field</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">ordered_field</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">has_lub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">F</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">is_ub</span> <span class="n">S</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="214467186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214467186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214467186">(Oct 25 2020 at 04:12)</a>:</h4>
<p>Looks right to me, mathlib calls this property conditional completeness <a href="https://leanprover-community.github.io/mathlib_docs/order/conditionally_complete_lattice.html">https://leanprover-community.github.io/mathlib_docs/order/conditionally_complete_lattice.html</a></p>



<a name="214467345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214467345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214467345">(Oct 25 2020 at 04:16)</a>:</h4>
<p>Thank you.</p>



<a name="214467410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214467410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214467410">(Oct 25 2020 at 04:18)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/conditionally_complete_linear_order">docs#conditionally_complete_linear_order</a></p>



<a name="214467708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214467708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214467708">(Oct 25 2020 at 04:26)</a>:</h4>
<p>I introduced condititonally_complete_linear_ordered_field in <a href="https://github.com/leanprover-community/mathlib/issues/3292">#3292</a> which should be equivalent to what you have, but haven't had time to finish it unfortunately.</p>



<a name="214471502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214471502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214471502">(Oct 25 2020 at 06:00)</a>:</h4>
<p>Unfortunately I'm struggling to find the similar smallest sets of axioms for the natural numbers and integers. I think the ordered_field definition fills that role for the rationals?</p>



<a name="214471625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214471625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214471625">(Oct 25 2020 at 06:03)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Peano_axioms">https://en.wikipedia.org/wiki/Peano_axioms</a></p>



<a name="214471975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214471975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214471975">(Oct 25 2020 at 06:11)</a>:</h4>
<p>I was looking at that earlier, I'll give it another try. Thank you.</p>



<a name="214474075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214474075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214474075">(Oct 25 2020 at 07:01)</a>:</h4>
<p>Is this right for the natural numbers? <code>add one n</code> in <code>ind</code> is kind of ugly, but I'm not sure if I'm supposed to define <code>succ</code> here?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">class</span> <span class="n">total_order</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">T</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_asymm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_conn</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">total_order</span>

<span class="kd">def</span> <span class="n">lt</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>


<span class="kd">class</span> <span class="n">something</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">total_order</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">add</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">add</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_zero_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">add</span> <span class="n">zero</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">mul</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mul</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">mul</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_one_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">mul</span> <span class="n">one</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">dist_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span>
<span class="o">(</span><span class="n">add_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="o">(</span><span class="n">add</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>
<span class="o">(</span><span class="n">mul_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>
<span class="o">(</span><span class="n">zero_lt_one</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">zero</span> <span class="n">one</span><span class="o">)</span>
<span class="o">(</span><span class="n">ge_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">lt</span> <span class="n">zero</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">one</span> <span class="n">n</span><span class="o">)</span>
<span class="o">(</span><span class="n">zero_min</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">le</span> <span class="n">zero</span> <span class="n">n</span><span class="o">)</span>
<span class="o">(</span><span class="n">ind</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">zero</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">add</span> <span class="n">n</span> <span class="n">one</span><span class="o">)))</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="214474214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214474214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214474214">(Oct 25 2020 at 07:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>
<span class="kd">class</span> <span class="n">natlike</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_zero</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">succ</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">succ_inj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">succ</span><span class="o">)</span>
<span class="o">(</span><span class="n">succ_ne_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">succ</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">ind</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)),</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">natlike</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">natlike</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">of_nat</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">of_nat_inj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">nat.rec_on</span> <span class="n">m</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat.cases_on</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span> <span class="o">(</span><span class="n">natlike.succ_ne_zero</span> <span class="n">_</span> <span class="n">hn.symm</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">ih</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat.cases_on</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hm</span><span class="o">,</span> <span class="o">(</span><span class="n">natlike.succ_ne_zero</span> <span class="n">_</span> <span class="n">hm</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">congr_arg</span> <span class="n">nat.succ</span> <span class="bp">$</span> <span class="n">ih</span> <span class="bp">$</span> <span class="n">natlike.succ_inj</span> <span class="n">hmn</span><span class="o">))</span>

<span class="kd">theorem</span> <span class="n">of_nat_surj</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">natlike.ind</span> <span class="n">_</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">hn</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hn</span> <span class="bp">▸</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">natlike</span>
</code></pre></div>



<a name="214474531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214474531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214474531">(Oct 25 2020 at 07:13)</a>:</h4>
<p>This is a different kind of formulation right? It leaves out addition, multiplication and order?</p>



<a name="214474690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214474690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214474690">(Oct 25 2020 at 07:17)</a>:</h4>
<p>Well, as usual lean's axiomatics are too strong to allow for writing these things in a way that doesn't imply far more than you intended. You may as well define <code>def natlike A := A ~= nat</code></p>



<a name="214474758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214474758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214474758">(Oct 25 2020 at 07:19)</a>:</h4>
<p>You can define addition, multiplication and order from kenny's structure, although addition and multiplication will be noncomputable (a concept foreign to PA) because there is no recursion principle</p>



<a name="214474825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214474825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214474825">(Oct 25 2020 at 07:21)</a>:</h4>
<p>You can define addition, multiplication and order from my version as well, and they will be computable, but you might wonder what other properties of nat you are inheriting, and the answer is "all of them, with all three formulations"</p>



<a name="214474844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214474844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214474844">(Oct 25 2020 at 07:21)</a>:</h4>
<p>in particular you can prove Con(PA) with any of these formulations, which should worry you</p>



<a name="214475285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214475285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214475285">(Oct 25 2020 at 07:33)</a>:</h4>
<p>I have to go to sleep. I'll try to think about this more tomorrow. Thank you.</p>



<a name="214500951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214500951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214500951">(Oct 25 2020 at 17:21)</a>:</h4>
<p>What does Con(PA) mean?</p>



<a name="214501335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501335">(Oct 25 2020 at 17:28)</a>:</h4>
<p>Consistency of PA</p>



<a name="214501469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501469">(Oct 25 2020 at 17:31)</a>:</h4>
<p>Why is that worrying?</p>



<a name="214501476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501476">(Oct 25 2020 at 17:31)</a>:</h4>
<p>I think the bigger worry is that you can prove that any instance of <code>something</code> is in fact isomorphic to <code>nat</code></p>



<a name="214501530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501530">(Oct 25 2020 at 17:32)</a>:</h4>
<p>if your goal was to define what a (first order!) model of PA is, that's presumably not what you wanted</p>



<a name="214501621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501621">(Oct 25 2020 at 17:34)</a>:</h4>
<p>and the problem is that <code>ind</code> is way too strong because it applies to <em>all</em> <code>P : N -&gt; Prop</code>, which includes everything that can be defined in Lean</p>



<a name="214501642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501642">(Oct 25 2020 at 17:34)</a>:</h4>
<p>But, it's not clear to me that defining "model of PA" really is your goal</p>



<a name="214501740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501740">(Oct 25 2020 at 17:36)</a>:</h4>
<p>I'm not sure. I defined the axioms for a complete ordered field so that I could use them to prove properties of the reals without having to define the reals. I was then going to do the same for the other number systems.</p>



<a name="214501772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501772">(Oct 25 2020 at 17:37)</a>:</h4>
<p>Maybe that is a bad approach?</p>



<a name="214501837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501837">(Oct 25 2020 at 17:38)</a>:</h4>
<p>In that case I think your definition is okay, but it might be longer than just defining <code>nat</code>, <code>nat.add</code> and <code>nat.mul</code></p>



<a name="214501914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501914">(Oct 25 2020 at 17:40)</a>:</h4>
<p>Yeah.</p>



<a name="214501919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501919">(Oct 25 2020 at 17:40)</a>:</h4>
<p>while for the reals, the abstract description is simpler than the object being described</p>



<a name="214501933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214501933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214501933">(Oct 25 2020 at 17:40)</a>:</h4>
<p>Yeah.</p>



<a name="214505043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505043">(Oct 25 2020 at 18:36)</a>:</h4>
<p>If I add this notation and use <code>0</code>then I get an ambiguous  overload. Is there a way to add this notation and avoid that when I am only working with my definition of a field?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">x</span> <span class="bp">`+`</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span>
<span class="kd">notation</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">zero</span>

<span class="kd">notation</span> <span class="n">x</span> <span class="bp">`*`</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mul</span> <span class="n">x</span> <span class="n">y</span>
<span class="kd">notation</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">one</span>
</code></pre></div>



<a name="214505084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505084">(Oct 25 2020 at 18:37)</a>:</h4>
<p>What you are doing in this thread is that you are rewriting a whole bunch of things which are already in Lean, in your own way.</p>



<a name="214505105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505105">(Oct 25 2020 at 18:37)</a>:</h4>
<p>Lean has fields and groups, and they're done a bit differently to the way you've done them, but this isn't really a problem because your definitions can coexist with Lean's.</p>



<a name="214505122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505122">(Oct 25 2020 at 18:38)</a>:</h4>
<p>Lean has 0 and 1, and they're done a bit differently to the way you've done them, and this time it is a problem.</p>



<a name="214505166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505166">(Oct 25 2020 at 18:38)</a>:</h4>
<p>Instead of doing this part your own way, I would definitely recommend that you used Lean's way of doing it, which would be by adding instances of the <code>has_zero</code>, <code>has_one</code>, <code>has_add</code> and <code>has_mul</code> typeclasses.</p>



<a name="214505182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505182">(Oct 25 2020 at 18:39)</a>:</h4>
<p>e.g. <code>instance : has_add X := \&lt;add\&gt;</code> if <code>add : X -&gt; X -&gt; X</code></p>



<a name="214505271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505271">(Oct 25 2020 at 18:41)</a>:</h4>
<p>And then there is existing notation for has_add, etc.?</p>



<a name="214505273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505273">(Oct 25 2020 at 18:41)</a>:</h4>
<p>Or letting your field extend <code>has_add</code> like it's done in mathlib. You're working in some hidden namespace so you can define <code>field</code> in that namespace any way you like. But <code>+</code> is already taken, it means <code>has_add.add</code>, and this is clever, because it means you can use <code>+</code> on any type; all you have to do is to make it an instance of the <code>has_add</code> typeclass.</p>



<a name="214505334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505334">(Oct 25 2020 at 18:42)</a>:</h4>
<p>Right. <code>has_add</code> is in core Lean so it will always be imported, and <code>+</code> is notation for <code>has_add.add</code>.</p>



<a name="214505349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505349">(Oct 25 2020 at 18:42)</a>:</h4>
<p>You could either use some weird unicode + instead, or you could stick to the traditional method and add an instance.</p>



<a name="214505806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505806">(Oct 25 2020 at 18:53)</a>:</h4>
<p>I'm sorry, what is the syntax? This doesn't seem to be working: <code>instance : has_add hidden.field := ⟨hidden.field.add⟩</code>.</p>



<a name="214505811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505811">(Oct 25 2020 at 18:53)</a>:</h4>
<p>MWE?</p>



<a name="214505843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505843">(Oct 25 2020 at 18:54)</a>:</h4>
<p>oh, you're missing an F</p>



<a name="214505874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505874">(Oct 25 2020 at 18:54)</a>:</h4>
<p><code>hidden.field</code> is a function, which eats a type F and outputs the type of field structures on F</p>



<a name="214505889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505889">(Oct 25 2020 at 18:54)</a>:</h4>
<p>posting errors helps -- and learning to read them helps even more.</p>



<a name="214505906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505906">(Oct 25 2020 at 18:55)</a>:</h4>
<p>hmm</p>



<a name="214505914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505914">(Oct 25 2020 at 18:55)</a>:</h4>
<p>the usual way to do this would be to <code>extend</code> has_add.</p>



<a name="214505916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505916">(Oct 25 2020 at 18:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>


<span class="kd">class</span> <span class="n">field</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_inv</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">add</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">add</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_zero_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="n">zero</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">add</span> <span class="o">(</span><span class="n">add_inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">→</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">mul</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mul</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">mul</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_one_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">one</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span> <span class="bp">→</span> <span class="n">mul</span> <span class="o">(</span><span class="n">mul_inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">one</span><span class="o">)</span>
<span class="o">(</span><span class="n">dist_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="n">x</span> <span class="n">z</span><span class="o">))</span>


<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">hidden.field</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">hidden.field.add</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="214505988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214505988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214505988">(Oct 25 2020 at 18:57)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">F</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">hidden.field.add</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="c1">-- F</span>
</code></pre></div>



<a name="214506070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214506070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214506070">(Oct 25 2020 at 18:58)</a>:</h4>
<p>Thank you!</p>



<a name="214506099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214506099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214506099">(Oct 25 2020 at 18:59)</a>:</h4>
<p>If you use <code>extends has_add F</code> in the definition of <code>field</code>, you can use the <code>+</code> notation even in the structure definition</p>



<a name="214506171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214506171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214506171">(Oct 25 2020 at 19:00)</a>:</h4>
<p>Ah. Ok.</p>



<a name="214506951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214506951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214506951">(Oct 25 2020 at 19:16)</a>:</h4>
<p>Nice.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">field</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_zero</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_neg</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_mul</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_one</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_inv</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_zero_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_neg_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_one_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">dist_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">z</span><span class="o">))</span>
</code></pre></div>



<a name="214507072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214507072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214507072">(Oct 25 2020 at 19:18)</a>:</h4>
<p>Now you're really close to the <code>import algebra.field</code> definition.</p>



<a name="214507097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214507097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214507097">(Oct 25 2020 at 19:19)</a>:</h4>
<p>In this repo here <a href="https://github.com/ImperialCollegeLondon/group-theory-game">https://github.com/ImperialCollegeLondon/group-theory-game</a>, me and some undergraduates defined a group ourselves in a random namespace, and then developed all of the theory of groups up to Sylow's theorems.</p>



<a name="214507241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214507241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214507241">(Oct 25 2020 at 19:22)</a>:</h4>
<p>Cool.</p>



<a name="214507259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214507259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214507259">(Oct 25 2020 at 19:23)</a>:</h4>
<p>(my point is: I'm not suggesting that you use Lean's definition -- indeed I've worked with my own definitions before in order to teach people)</p>



<a name="214507820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214507820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214507820">(Oct 25 2020 at 19:36)</a>:</h4>
<p>you are encouraged (by me) to include an axiom saying that the inverse of 0 is 0.</p>



<a name="214508156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214508156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214508156">(Oct 25 2020 at 19:42)</a>:</h4>
<p>Why? Isn't that undefined?</p>



<a name="214508177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214508177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214508177">(Oct 25 2020 at 19:43)</a>:</h4>
<p>Define undefined</p>



<a name="214508284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214508284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214508284">(Oct 25 2020 at 19:45)</a>:</h4>
<p>Contradictory? Or at least unexpected to most mathematicians?</p>



<a name="214508364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214508364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214508364">(Oct 25 2020 at 19:46)</a>:</h4>
<p>well, the axioms already imply it is a real number</p>



<a name="214508376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214508376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214508376">(Oct 25 2020 at 19:47)</a>:</h4>
<p>so if it's not 0, what is it?</p>



<a name="214508381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214508381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214508381">(Oct 25 2020 at 19:47)</a>:</h4>
<p>If you haven't already seen it, here's a related blog post by Kevin: <a href="https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>



<a name="214509303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509303">(Oct 25 2020 at 20:06)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> How many field structures are there on the real numbers (with the usual addition and multiplication)?</p>



<a name="214509395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509395">(Oct 25 2020 at 20:08)</a>:</h4>
<p>I don't know, it has been a long time since I studied abstract algebra, and I'm not sure if we covered this. Why?</p>



<a name="214509417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509417">(Oct 25 2020 at 20:09)</a>:</h4>
<p>I'm not sure what field structure on the real numbers means.</p>



<a name="214509486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509486">(Oct 25 2020 at 20:10)</a>:</h4>
<p>I think he is asking what is <code>card (field real)</code></p>



<a name="214509522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509522">(Oct 25 2020 at 20:11)</a>:</h4>
<p>Sorry, I'm not sure what that means either.</p>



<a name="214509585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509585">(Oct 25 2020 at 20:12)</a>:</h4>
<p><code>field real</code> is a type, whose elements are (0,1,+,*) tuples satisfying the field axioms</p>



<a name="214509599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509599">(Oct 25 2020 at 20:12)</a>:</h4>
<p>the question is, how many such tuples are there, holding fixed that the base type is <code>real</code> and <code>+</code> and <code>*</code> are the usual ones</p>



<a name="214509719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509719">(Oct 25 2020 at 20:15)</a>:</h4>
<p>I'm not sure what is allowed to vary.</p>



<a name="214509745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509745">(Oct 25 2020 at 20:15)</a>:</h4>
<p>everything else: 0, 1, neg, inv, but whatever is chosen must be consistent with the addition and multiplication</p>



<a name="214509816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509816">(Oct 25 2020 at 20:17)</a>:</h4>
<p>Here's a simpler version of the same question: how many group structures are there if you fix G and * but allow 1 and inv to vary?</p>



<a name="214509904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214509904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214509904">(Oct 25 2020 at 20:18)</a>:</h4>
<p>What does it mean to fix G?</p>



<a name="214510298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214510298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214510298">(Oct 25 2020 at 20:28)</a>:</h4>
<p>Let <code>(G, *, 1, inv)</code> be a group. How many elements <code>1' : G</code> and functions <code>inv' : G -&gt; G</code> are there such that <code>(G, *, 1', inv')</code> is a group?</p>



<a name="214510849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214510849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214510849">(Oct 25 2020 at 20:38)</a>:</h4>
<p>If the operation (*) is fixed, doesn't that fix everything?</p>



<a name="214510859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214510859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214510859">(Oct 25 2020 at 20:38)</a>:</h4>
<p>Indeed.</p>



<a name="214510886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214510886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214510886">(Oct 25 2020 at 20:39)</a>:</h4>
<p>I'm not sure I see where this leads.</p>



<a name="214510966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214510966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214510966">(Oct 25 2020 at 20:40)</a>:</h4>
<p>Now do the same thing for your definition of a field structure on <code>real</code>, fixing the definitions of <code>0</code>, <code>1</code>, <code>add</code>, <code>mul</code> to be the usual ones</p>



<a name="214511155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511155">(Oct 25 2020 at 20:44)</a>:</h4>
<p>Ok. So there is only one possible inverse function because it is defined by mul?</p>



<a name="214511186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511186">(Oct 25 2020 at 20:45)</a>:</h4>
<p>Depends...</p>



<a name="214511191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511191">(Oct 25 2020 at 20:45)</a>:</h4>
<p>That's what you would like to be true, but the key point is that it isn't true for your definition as stated</p>



<a name="214511198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511198">(Oct 25 2020 at 20:45)</a>:</h4>
<p>do you see why?</p>



<a name="214511384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511384">(Oct 25 2020 at 20:49)</a>:</h4>
<p>There are any number of elements it could take zero to.</p>



<a name="214511452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511452">(Oct 25 2020 at 20:50)</a>:</h4>
<p>This is the meaning of <img alt=":37:" class="emoji" src="https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/18469.png" title="37"></p>



<a name="214511495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511495">(Oct 25 2020 at 20:51)</a>:</h4>
<p>We can just leave it undefined for 0 though. Why is that bad?</p>



<a name="214511540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511540">(Oct 25 2020 at 20:52)</a>:</h4>
<p>In math we would say that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x^{-1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> is undefined for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. But in Lean, you wrote <code>inv : F -&gt; F</code> so <code>inv x</code> is valid for every <code>x : F</code>.</p>



<a name="214511566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511566">(Oct 25 2020 at 20:53)</a>:</h4>
<p>Patrick, did you read that blogpost that was pointed out to you?</p>



<a name="214511583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511583">(Oct 25 2020 at 20:53)</a>:</h4>
<p>Yeah, I was in the middle of it. I need to reread it a couple of times.</p>



<a name="214511601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511601">(Oct 25 2020 at 20:53)</a>:</h4>
<p>One way to bring the Lean closer to the math version is to pin down the "bad" values by adding axioms like <code>inv 0 = 0</code> (or <code>inv 0 = 37</code>) so that at least we're not providing more information in <code>inv</code> than there is in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x^{-1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>.</p>



<a name="214511674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511674">(Oct 25 2020 at 20:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/algebraic.20structures/near/214511495">said</a>:</p>
<blockquote>
<p>We can just leave it undefined for 0 though. Why is that bad?</p>
</blockquote>
<p>If I have two field extensions of degree two of <code>real</code>, are they isomorphic? What does it mean for two field extensions to be isomorphic?</p>



<a name="214511690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214511690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214511690">(Oct 25 2020 at 20:55)</a>:</h4>
<p>Another way, that is closer to the math version, is to define <code>inv : \all x : F, x != 0 -&gt; F</code>, and then it really is undefined at zero. The blog post answers the question of why lean's version is more convenient</p>



<a name="214522018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214522018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214522018">(Oct 26 2020 at 00:41)</a>:</h4>
<p>This doesn't seem to work. For some reason the error gives the goal as <code>has_inv ℕ</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>


<span class="kd">class</span> <span class="n">field</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_zero</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_neg</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_mul</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_one</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_inv</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_zero_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_neg_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_one_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">dist_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">z</span><span class="o">))</span>
<span class="o">(</span><span class="n">zero_inv</span> <span class="o">:</span> <span class="mi">0</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="214522133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214522133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214522133">(Oct 26 2020 at 00:44)</a>:</h4>
<p>It seems I have to make the type of 0 explicit?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>


<span class="kd">class</span> <span class="n">field</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_zero</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_neg</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_mul</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_one</span> <span class="n">F</span><span class="o">,</span> <span class="n">has_inv</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_zero_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_neg_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_one_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">dist_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">z</span><span class="o">))</span>
<span class="o">(</span><span class="n">zero_inv</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="214522301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214522301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214522301">(Oct 26 2020 at 00:48)</a>:</h4>
<p>I guess there is no other element in the definition to infer the type from?</p>



<a name="214522322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214522322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214522322">(Oct 26 2020 at 00:49)</a>:</h4>
<p>Yes, by default, a numeric value like <code>0</code>, <code>37</code> is assumed to be <code>nat</code> unless a different type can be inferred. Such inferring usually happens more on the RHS.</p>



<a name="214522374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214522374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214522374">(Oct 26 2020 at 00:50)</a>:</h4>
<p><code>zero_inv</code> can't know that your LHS will be about <code>F</code> as opposed to anything else.</p>



<a name="214522385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214522385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214522385">(Oct 26 2020 at 00:50)</a>:</h4>
<p>I see.</p>



<a name="214621751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214621751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214621751">(Oct 26 2020 at 19:28)</a>:</h4>
<p>So here there is no <code>has_ge</code> and <code>has_gt</code> to extend and I will end up with ambiguous overloads if I define the notation for them. Is there another way around it?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">total_order</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_le</span> <span class="n">T</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_asymm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_conn</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="214621813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214621813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214621813">(Oct 26 2020 at 19:29)</a>:</h4>
<p>Never ever use ge or gt?</p>



<a name="214621829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214621829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214621829">(Oct 26 2020 at 19:29)</a>:</h4>
<p>(that's the approach used in mathlib)</p>



<a name="214621909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214621909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214621909">(Oct 26 2020 at 19:30)</a>:</h4>
<p>Note that x &gt;= y is just defined to mean y &lt;= x, so you can use it if you want, but basically you end up doubling the number of lemmas in the &lt;= part of the library for no obvious gain</p>



<a name="214622080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214622080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214622080">(Oct 26 2020 at 19:31)</a>:</h4>
<p>Hmm. I suppose.</p>



<a name="214622241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214622241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214622241">(Oct 26 2020 at 19:33)</a>:</h4>
<p>In fact I think <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\forall \epsilon&gt;0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> might show up in some places -- somehow this was allowed, because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mn>0</mn><mo>&lt;</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\forall 0 &lt; \epsilon</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> is a bit weird</p>



<a name="214622510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214622510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214622510">(Oct 26 2020 at 19:35)</a>:</h4>
<p>I thought that it's allowed because Lean can't parse <code>∀ 0 &lt; ε, p ε</code> correctly and <code>∀ ε, 0 &lt; ε → p ε</code> is weird.</p>



<a name="214622906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214622906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214622906">(Oct 26 2020 at 19:38)</a>:</h4>
<p>Is there any way to disable the existing defined notation?</p>



<a name="214622971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214622971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214622971">(Oct 26 2020 at 19:38)</a>:</h4>
<p>you can use <code>local notation</code></p>



<a name="214623077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214623077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214623077">(Oct 26 2020 at 19:39)</a>:</h4>
<p>but why would you want to do anything different than the core definition of <code>ge</code>?</p>



<a name="214623146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214623146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214623146">(Oct 26 2020 at 19:40)</a>:</h4>
<p>because it will be tremendously confusing if <code>y &gt;= x</code> means anything other than <code>x &lt;= y</code></p>



<a name="214623259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214623259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214623259">(Oct 26 2020 at 19:41)</a>:</h4>
<p>Also, if you really want to reinvent lean core you might consider just slapping <code>prelude</code> at the top and rolling your own everything</p>



<a name="214623528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214623528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214623528">(Oct 26 2020 at 19:43)</a>:</h4>
<p>It was <code>gt</code> that I was going to change for symmetry to be similar to <code>lt</code>. I was going to make it <code>def gt {T : Type} [total_order T] (x y : T) : Prop := x ≥ y ∧ ¬ x = y</code>.</p>



<a name="214623644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214623644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214623644">(Oct 26 2020 at 19:44)</a>:</h4>
<p>if you have <code>lt</code> defined already, then <code>gt</code> should just work</p>



<a name="214623656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214623656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214623656">(Oct 26 2020 at 19:44)</a>:</h4>
<p>Not having <code>a &gt; b</code> for preorders looks strange.</p>



<a name="214623731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214623731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214623731">(Oct 26 2020 at 19:45)</a>:</h4>
<p>I suggest that you add an <code>iff</code> lemma instead of changing the definition.</p>



<a name="214624273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214624273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214624273">(Oct 26 2020 at 19:50)</a>:</h4>
<p>What does prelude do exactly?</p>



<a name="214624307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214624307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214624307">(Oct 26 2020 at 19:50)</a>:</h4>
<p>It prevents Lean from importing the default prelude library.</p>



<a name="214624334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214624334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214624334">(Oct 26 2020 at 19:50)</a>:</h4>
<p>The one that comes with lean.</p>



<a name="214624364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214624364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214624364">(Oct 26 2020 at 19:50)</a>:</h4>
<p>I see.</p>



<a name="214624416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214624416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214624416">(Oct 26 2020 at 19:51)</a>:</h4>
<p>Of course, if you use <code>prelude</code>, the you'll have to redo or <code>import</code> all parts of the prelude library you need.</p>



<a name="214624582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214624582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214624582">(Oct 26 2020 at 19:52)</a>:</h4>
<p>Hmm. Ok.</p>



<a name="214625060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214625060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214625060">(Oct 26 2020 at 19:56)</a>:</h4>
<p>But I suggest reusing existing code as much as possible instead of reinventing wheels.</p>



<a name="214625091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214625091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214625091">(Oct 26 2020 at 19:57)</a>:</h4>
<p>Unless you have some very special needs.</p>



<a name="214628281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214628281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214628281">(Oct 26 2020 at 20:24)</a>:</h4>
<p>Yeah, I was just hoping to keep these beautiful symmetric lemmas unchanged except for the notation :)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">total_order</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">T</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_asymm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_conn</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">},</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">total_order</span>


<span class="c1">-- x &lt; y</span>
<span class="kd">def</span> <span class="n">lt</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>

<span class="c1">-- x ≥ y</span>
<span class="kd">def</span> <span class="n">ge</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span>

<span class="c1">-- x &gt; y</span>
<span class="kd">def</span> <span class="n">gt</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>


<span class="kd">lemma</span> <span class="n">ne_symm</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.symm</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">a1</span> <span class="n">s1</span>


<span class="kd">lemma</span> <span class="n">lt_to_gt</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">gt</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">s1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">ne_symm</span> <span class="n">s3</span><span class="o">,</span>
<span class="n">and.intro</span> <span class="n">s1</span> <span class="n">s4</span>

<span class="kd">lemma</span> <span class="n">gt_to_lt</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">lt</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">s1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">ne_symm</span> <span class="n">s3</span><span class="o">,</span>
<span class="n">and.intro</span> <span class="n">s1</span> <span class="n">s4</span>


<span class="kd">lemma</span> <span class="n">ge_asymm</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">x</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">a2</span><span class="o">,</span>
<span class="n">le_asymm</span> <span class="n">s2</span> <span class="n">s1</span>


<span class="kd">lemma</span> <span class="n">ge_trans</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">z</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">a2</span><span class="o">,</span>
<span class="n">le_trans</span> <span class="n">s2</span> <span class="n">s1</span>


<span class="kd">lemma</span> <span class="n">ge_conn</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">le_conn</span><span class="o">,</span>
<span class="n">or.elim</span> <span class="n">s1</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">a1</span><span class="o">,</span>
  <span class="n">or.intro_right</span> <span class="o">(</span><span class="n">ge</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">s2</span>
<span class="o">)</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">a2</span><span class="o">,</span>
  <span class="n">or.intro_left</span> <span class="o">(</span><span class="n">ge</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span> <span class="n">s3</span>
<span class="o">)</span>


<span class="kd">lemma</span> <span class="n">le_refl</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">∨</span> <span class="n">le</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">le_conn</span><span class="o">,</span>
<span class="n">or.elim</span> <span class="n">s1</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">a1</span>
<span class="o">)</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">a2</span>
<span class="o">)</span>

<span class="kd">lemma</span> <span class="n">ge_refl</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">∨</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">ge_conn</span><span class="o">,</span>
<span class="n">or.elim</span> <span class="n">s1</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">a1</span>
<span class="o">)</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">a2</span>
<span class="o">)</span>


<span class="kd">lemma</span> <span class="n">not_lt_refl</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">x</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="n">x</span><span class="o">,</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s1</span> <span class="n">s2</span>

<span class="kd">lemma</span> <span class="n">not_gt_refl</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">x</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="n">x</span><span class="o">,</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s1</span> <span class="n">s2</span>


<span class="kd">lemma</span> <span class="n">le_lt_trans</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">lt</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">le_trans</span> <span class="n">a1</span> <span class="n">s1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span>
<span class="n">by_contradiction</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">a3</span><span class="o">:</span> <span class="bp">¬</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">not_not_1</span> <span class="n">a3</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">le</span> <span class="n">z</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s5</span> <span class="n">a1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">le_asymm</span> <span class="n">s1</span> <span class="n">s6</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s2</span> <span class="n">s7</span>
<span class="o">),</span>
<span class="n">and.intro</span> <span class="n">s3</span> <span class="n">s4</span>

<span class="kd">lemma</span> <span class="n">lt_le_trans</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">le_trans</span> <span class="n">s1</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span>
<span class="n">by_contradiction</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">not_not_1</span> <span class="n">a3</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">s5</span><span class="o">)</span> <span class="n">a2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">le_asymm</span> <span class="n">s1</span> <span class="n">s6</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s2</span> <span class="n">s7</span>
<span class="o">),</span>
<span class="n">and.intro</span> <span class="n">s3</span> <span class="n">s4</span>

<span class="kd">lemma</span> <span class="n">lt_lt_trans</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">lt</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a1</span><span class="o">,</span>
<span class="n">le_lt_trans</span> <span class="n">s1</span> <span class="n">a2</span>


<span class="kd">lemma</span> <span class="n">ge_gt_trans</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">gt</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">ge_trans</span> <span class="n">a1</span> <span class="n">s1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span>
<span class="n">by_contradiction</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">a3</span><span class="o">:</span> <span class="bp">¬</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">not_not_1</span> <span class="n">a3</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">z</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s5</span> <span class="n">a1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">ge_asymm</span> <span class="n">s1</span> <span class="n">s6</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s2</span> <span class="n">s7</span>
<span class="o">),</span>
<span class="n">and.intro</span> <span class="n">s3</span> <span class="n">s4</span>

<span class="kd">lemma</span> <span class="n">gt_ge_trans</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">ge_trans</span> <span class="n">s1</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span>
<span class="n">by_contradiction</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">not_not_1</span> <span class="n">a3</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">s5</span><span class="o">)</span> <span class="n">a2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">ge_asymm</span> <span class="n">s1</span> <span class="n">s6</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s2</span> <span class="n">s7</span>
<span class="o">),</span>
<span class="n">and.intro</span> <span class="n">s3</span> <span class="n">s4</span>

<span class="kd">lemma</span> <span class="n">gt_gt_trans</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">gt</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a1</span><span class="o">,</span>
<span class="n">ge_gt_trans</span> <span class="n">s1</span> <span class="n">a2</span>


<span class="kd">lemma</span> <span class="n">le_to_or</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="o">(</span><span class="n">lt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="n">by_contradiction</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">lt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">dm_3_a</span> <span class="n">a2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">s1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">s1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">dm_1_b</span> <span class="n">s2</span><span class="o">,</span>
  <span class="n">or.elim</span> <span class="n">s4</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">a3</span> <span class="n">a1</span>
  <span class="o">)</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s3</span> <span class="n">a4</span>
  <span class="o">)</span>
<span class="o">)</span>


<span class="kd">lemma</span> <span class="n">or_to_le</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">lt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
<span class="n">or.elim</span> <span class="n">a1</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">a2</span><span class="o">,</span>
  <span class="n">and.left</span> <span class="n">s1</span>
<span class="o">)</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">le_refl</span><span class="o">,</span>
  <span class="n">eq.subst</span> <span class="n">a3</span> <span class="n">s2</span>
<span class="o">)</span>


<span class="kd">lemma</span> <span class="n">ge_to_or</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="o">(</span><span class="n">gt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="n">by_contradiction</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">gt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">dm_3_a</span> <span class="n">a2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">s1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">s1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">dm_1_b</span> <span class="n">s2</span><span class="o">,</span>
  <span class="n">or.elim</span> <span class="n">s4</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">a3</span> <span class="n">a1</span>
  <span class="o">)</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s3</span> <span class="n">a4</span>
  <span class="o">)</span>
<span class="o">)</span>

<span class="kd">lemma</span> <span class="n">or_to_ge</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">gt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
<span class="n">or.elim</span> <span class="n">a1</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">a2</span><span class="o">,</span>
  <span class="n">and.left</span> <span class="n">s1</span>
<span class="o">)</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">ge_refl</span><span class="o">,</span>
  <span class="n">eq.subst</span> <span class="n">a3</span> <span class="n">s2</span>
<span class="o">)</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">lt</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">le_asymm</span> <span class="n">s1</span> <span class="n">s3</span><span class="o">,</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s2</span> <span class="n">s4</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">ge_refl</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">a2</span> <span class="n">s1</span><span class="o">,</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">a1</span> <span class="n">s2</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">le_conn</span><span class="o">,</span>
<span class="n">or.elim</span> <span class="n">s2</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">a2</span>
<span class="o">)</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">le</span> <span class="n">y</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">false.elim</span> <span class="o">(</span><span class="n">s1</span> <span class="n">a3</span><span class="o">)</span>
<span class="o">)</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">gt</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">ge_asymm</span> <span class="n">s1</span> <span class="n">s3</span><span class="o">,</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s2</span> <span class="n">s4</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">le_refl</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">a2</span> <span class="n">s1</span><span class="o">,</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">a1</span> <span class="n">s2</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">total_order</span> <span class="n">T</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">le</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">ge_conn</span><span class="o">,</span>
<span class="n">or.elim</span> <span class="n">s2</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">a2</span>
<span class="o">)</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">ge</span> <span class="n">y</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">false.elim</span> <span class="o">(</span><span class="n">s1</span> <span class="n">a3</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div>



<a name="214630580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214630580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214630580">(Oct 26 2020 at 20:44)</a>:</h4>
<p>Can I petition <code>gt</code> to be redefined in mathlib :)</p>



<a name="214630627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214630627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214630627">(Oct 26 2020 at 20:45)</a>:</h4>
<p>feel free to make the refactor and pull request.</p>



<a name="214630746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214630746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214630746">(Oct 26 2020 at 20:46)</a>:</h4>
<p>I'm guessing that would be a nightmare?</p>



<a name="214630802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214630802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214630802">(Oct 26 2020 at 20:46)</a>:</h4>
<p>Actually that's a silly thing to say -- this issue has been thought about seriously and people are very happy with the situation we have now. There is a trade-off between getting something which is acceptable to mathematicians and getting something which is acceptable to computer scientists. Right now everyone is happy with how <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&gt;</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span> is being handled.</p>



<a name="214630914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214630914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214630914">(Oct 26 2020 at 20:47)</a>:</h4>
<p>I see.</p>



<a name="214630986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214630986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214630986">(Oct 26 2020 at 20:48)</a>:</h4>
<p>Definitely people do come along and say "I think that this should be done differently" and if the idea has enough merit and someone cares enough to implement it, it gets implemented.</p>



<a name="214631008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214631008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214631008">(Oct 26 2020 at 20:48)</a>:</h4>
<p>What exactly is your proposal for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&gt;</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span>?</p>



<a name="214631126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214631126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214631126">(Oct 26 2020 at 20:49)</a>:</h4>
<p>Something along the lines of <code>def gt {T : Type*} [total_order T] (x y : T) : Prop := x ≥ y ∧ ¬ x = y</code>.</p>



<a name="214631237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214631237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214631237">(Oct 26 2020 at 20:50)</a>:</h4>
<p>and what is your definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>?</p>



<a name="214631335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214631335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214631335">(Oct 26 2020 at 20:51)</a>:</h4>
<p><code>def ge {T : Type*} [total_order T] (x y : T) : Prop := y ≤ x</code></p>



<a name="214631449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214631449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214631449">(Oct 26 2020 at 20:52)</a>:</h4>
<p>So then your definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&gt;</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span> will be equal to Lean's definition, but because of a theorem rather than by definition.</p>



<a name="214631524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214631524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214631524">(Oct 26 2020 at 20:52)</a>:</h4>
<p>So every time that someone doing analysis in Lean writes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\forall \epsilon&gt;0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> there is a risk that you'll have to now apply a theorem to get mathlib compiling again.</p>



<a name="214631557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214631557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214631557">(Oct 26 2020 at 20:53)</a>:</h4>
<p>I see no reason at all to do this refactor. What do you gain?</p>



<a name="214631627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214631627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214631627">(Oct 26 2020 at 20:53)</a>:</h4>
<p><code>gt</code> <em>is</em> equal to what you say -- just not by definition. (in fact it probably _will_ be equal by definition in many cases, but not for the naturals)</p>



<a name="214631747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214631747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214631747">(Oct 26 2020 at 20:54)</a>:</h4>
<p>How is it equal by definition for some things and not others?</p>



<a name="214631946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214631946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214631946">(Oct 26 2020 at 20:56)</a>:</h4>
<p>Because <code>x &gt; y</code> is by definition <code>y &lt; x</code> right now, and <code>&lt;</code> is a typeclass, so on a given type it is defined however it was chosen to be defined. For example on the naturals there's some funky inductive definition IIRC which is easier to compute with than your definition.</p>



<a name="214632054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214632054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214632054">(Oct 26 2020 at 20:57)</a>:</h4>
<p>We have flexibility with the <code>&lt;</code> typeclass to define it how we like; in different situations one might want different definitions which behave better from a computer science viewpoint.</p>



<a name="214632356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214632356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214632356">(Oct 26 2020 at 20:59)</a>:</h4>
<p>There's simply no point in changing the definition. What you want to be true is true by a theorem. Why do you care whether it's the definition or not? Computer scientists have thought hard about appropriate definitions and they choose ones which are optimal for the given situation, for reasons which I don't even understand. As a mathematician I only care about what is true, not what is defined to be what. Why would you want to change a definition to something equivalent but in some cases less efficient?</p>



<a name="214632455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214632455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214632455">(Oct 26 2020 at 21:00)</a>:</h4>
<p>Note also that your definition of <code>gt</code> is incorrect for preorders</p>



<a name="214632487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214632487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214632487">(Oct 26 2020 at 21:00)</a>:</h4>
<p>and the restriction to <code>total_order T</code> is silly</p>



<a name="214632784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214632784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214632784">(Oct 26 2020 at 21:03)</a>:</h4>
<p>the definition in lean now: <code>def gt {A} [has_lt A] (x y : A) := y &lt; x</code> is extremely general: it says whenever you have a less-than-able type A you can use &gt; just like &lt;. It doesn't care about whether <code>lt</code> has any structure at all. If you add anything like your <code>x &gt;= y /\ x != y</code> you will have to ask for a lot of structure for the predicate to be sensible</p>



<a name="214632999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214632999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214632999">(Oct 26 2020 at 21:04)</a>:</h4>
<p>I think my definition of <code>lt</code> may be wrong for a preorder to?</p>



<a name="214633007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214633007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214633007">(Oct 26 2020 at 21:04)</a>:</h4>
<p>it is</p>



<a name="214633323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/algebraic%20structures/near/214633323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/algebraic.20structures.html#214633323">(Oct 26 2020 at 21:08)</a>:</h4>
<p>Ok.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html">Unfolding set constructor notation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="197796904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197796904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197796904">(May 16 2020 at 13:59)</a>:</h4>
<p>I understand what set constructor notation is doing, but I can't figure out where it is defined so I can't figure out what definition to tell lean to unfold. I know how to find definitions of simple notation like <code>#print notation *</code> but I don't know how to do it for complicated notation like the set constructor notation. So where is set constructor notation defined/how can I unfold it?</p>



<a name="197796995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197796995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197796995">(May 16 2020 at 14:01)</a>:</h4>
<p>I totally agree that this is annoying and frustrating. I went through a phase of trying to understand what Lean was by unfolding everything in sight and set notation, and stuff like there exists and inf stuff are very hard to see through: they are just some "scoped something". But in the set case you can just <code>set_option pp.notation false</code> and find out what's going on. It's something like <code>set_of</code> that you're looking for.</p>



<a name="197797169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197797169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197797169">(May 16 2020 at 14:04)</a>:</h4>
<p>Thanks! Your answer implies that I usually shouldn't have to unfold stuff to prove something, is there a better way to show something like: </p>
<div class="codehilite"><pre><span></span><code><span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">B</span><span class="o">}</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">A</span><span class="o">}</span> <span class="n">x</span>
</code></pre></div>


<p>without <code>unfold set_of</code>?</p>



<a name="197797845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197797845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197797845">(May 16 2020 at 14:21)</a>:</h4>
<p>In some sense your goal should never be that, because it's not in canonical form</p>



<a name="197797980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197797980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197797980">(May 16 2020 at 14:24)</a>:</h4>
<p>If I found myself in that state I would probably first do <code>show x \in A \and x \in B = x \in B and x \in A</code> to get things back into some kind of normality, and then use the <code>ext</code> tactic.</p>



<a name="197797988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197797988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197797988">(May 16 2020 at 14:24)</a>:</h4>
<p><span class="user-mention" data-user-id="300684">@Keefer Rowan</span> How did you end up with that goal?</p>



<a name="197798004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197798004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197798004">(May 16 2020 at 14:24)</a>:</h4>
<p>I think that 1 or 2 lines before it, you should have written <code>ext x</code>.</p>



<a name="197798012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197798012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197798012">(May 16 2020 at 14:24)</a>:</h4>
<p>Here again there are two kinds of approaches depending on whether or not you want to exploit your knowledge of the definition of <code>{ | }</code>:</p>
<ol>
<li>Using that knowledge:</li>
</ol>
<ul>
<li>You could compute mentally that the goal is really just <code>x ∈ A ∧ x ∈ B = x ∈ B ∧ x ∈ A</code>. So use <code>change x ∈ A ∧ x ∈ B = x ∈ B ∧ x ∈ A</code> to make that the new goal.</li>
<li>Alternatively, you can see that the new goal is going to be closed by something like <code>and.comm</code> (this might be phrased in terms of iff, though, not sure) so just apply that directly.</li>
</ul>
<ol start="2">
<li>Not using that knowledge:</li>
</ol>
<ul>
<li>find some lemma that rewrites <code>{a | p a} x</code> to <code>p x</code>.</li>
</ul>
<p>In this case (and also in the <code>compl</code> one earlier) it's better to just do 1, since the definition of this notation is so basic.</p>



<a name="197798028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197798028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197798028">(May 16 2020 at 14:25)</a>:</h4>
<p>There are 100 ways to say everything in Lean, and a proper subset of them are "canonical". If you stick to the canonical ways then the <code>simp</code> tactic will be of much more help to you.</p>



<a name="197798081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197798081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197798081">(May 16 2020 at 14:26)</a>:</h4>
<p>You learn the canonical ways by looking at statements of lemmas in the library</p>



<a name="197798097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197798097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197798097">(May 16 2020 at 14:26)</a>:</h4>
<p><code>show</code> and <code>change</code> do the same thing, by the way</p>



<a name="197801101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197801101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197801101">(May 16 2020 at 15:34)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  This is where I was:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">inter_comm</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∩</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">B</span> <span class="err">∩</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">unfold</span> <span class="n">has_inter</span><span class="bp">.</span><span class="n">inter</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>(BTW: I know this is almost certainly already in the library)</p>
<p>Also <code>ext x</code> gives an "unknown identifier". I'm working with very basic imports, so maybe isn't imported.</p>



<a name="197801352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197801352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197801352">(May 16 2020 at 15:40)</a>:</h4>
<p>I think I see what's going on though, you're saying that if I prove the theorem by set extensionality, I won't run into this state. What do I need to import to get <code>ext</code>? I was able to prove <code>theorem setext {α : Type u} (A B : set α) : (∀ (x : α), x ∈ A ↔ x ∈ B) → A = B</code>, which allows me to do this, but I should probably be using the proper tactic.</p>



<a name="197801365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197801365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197801365">(May 16 2020 at 15:41)</a>:</h4>
<p>Yeah, <code>ext</code> is a mathlib tactic. You would have to use <code>apply set.ext</code> instead. <a href="https://github.com/leanprover-community/mathlib/blob/4b71428/src/data/set/basic.lean#L446">Here's the proof in mathlib</a>.</p>



<a name="197802342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197802342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197802342">(May 16 2020 at 16:02)</a>:</h4>
<p>Oh hmm, <a href="https://github.com/leanprover-community/mathlib/blob/4b71428/src/data/set/basic.lean#L130"><code>set.ext</code> is proved in mathlib</a> too.</p>



<a name="197803359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Unfolding%20set%20constructor%20notation/near/197803359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Unfolding.20set.20constructor.20notation.html#197803359">(May 16 2020 at 16:28)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">theorem</span> <span class="n">inter_comm</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∩</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">B</span> <span class="err">∩</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">set</span><span class="bp">.</span><span class="n">mem_inter_iff</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_inter_iff</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">and_comm</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>In this proof nothing ever leaves the canonical form.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/submodule.2Espan.20as_sum.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html">submodule.span as_sum</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="227978597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/227978597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#227978597">(Feb 26 2021 at 19:24)</a>:</h4>
<p>Dear All,</p>
<p>is something like the lemma below already available in mathlib?</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">lemma</span> <span class="n">submodule.span_as_sum</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">submodule.span</span> <span class="n">R</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">su</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">M</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span>
    <span class="n">c.support</span> <span class="bp">=</span> <span class="n">su</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">c.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="o">((</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">su</span><span class="o">,</span> <span class="n">c</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="227985273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/227985273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#227985273">(Feb 26 2021 at 20:08)</a>:</h4>
<p>I think the forward direction of <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.mem_span_iff_total">docs#finsupp.mem_span_iff_total</a> might help?</p>



<a name="227986873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/227986873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#227986873">(Feb 26 2021 at 20:18)</a>:</h4>
<p>Thank you, this seems very close to what I want!</p>



<a name="227993035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/227993035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#227993035">(Feb 26 2021 at 20:59)</a>:</h4>
<p>You could probably drop <code>su</code> completely and just sum over <code>c.support</code> (assuming this is a <code>finset</code>).</p>



<a name="227994944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/227994944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#227994944">(Feb 26 2021 at 21:13)</a>:</h4>
<p>Kevin, yes, thanks!  I initially have  a version where the support of <code>c</code> was contained in <code>su</code>, but not necessarily equal to it, since it seemed useful, but then I managed to prove it in this form and did not look back at it.  You are right that, as is, <code>su</code> is determined by everything else!</p>



<a name="228039864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228039864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228039864">(Feb 27 2021 at 07:09)</a>:</h4>
<p>It is not pretty, but it works...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">submodule.span_as_sum</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">submodule.span</span> <span class="n">R</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">c.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">c.support</span><span class="o">,</span> <span class="n">c</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">T</span><span class="o">,</span> <span class="n">Tv</span><span class="o">,</span> <span class="n">mT</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_span_finite_of_mem_span</span> <span class="n">hm</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">mT</span> <span class="n">Tv</span> <span class="n">m</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">finset.induction_on</span> <span class="n">T</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">s</span> <span class="n">ms</span> <span class="n">es</span> <span class="n">me</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span> <span class="n">using</span> <span class="n">me</span><span class="o">⟩)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">S</span> <span class="n">ms</span> <span class="n">ih</span> <span class="n">m1</span> <span class="n">s</span> <span class="n">m1s</span> <span class="n">ims</span> <span class="n">m1i</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.coe_insert</span><span class="o">]</span> <span class="n">at</span> <span class="n">m1i</span><span class="o">,</span>
  <span class="n">choose</span> <span class="n">a</span> <span class="n">z</span> <span class="n">hz</span> <span class="n">ide</span> <span class="n">using</span> <span class="n">mem_span_insert.mp</span> <span class="n">m1i</span><span class="o">,</span>
  <span class="n">subst</span> <span class="n">ide</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">c1</span><span class="o">,</span> <span class="n">c1ss</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ih</span> <span class="n">z</span> <span class="n">S</span> <span class="n">hz</span> <span class="n">rfl.subset</span> <span class="n">hz</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">a0</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">c1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">hg</span><span class="o">,</span> <span class="n">ims</span> <span class="o">(</span><span class="n">finset.mem_insert_of_mem</span> <span class="o">(</span><span class="n">c1ss</span> <span class="n">hg</span><span class="o">)),</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">a0</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">]</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">mc1</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∉</span> <span class="n">c1.support</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">ms</span> <span class="o">(</span><span class="n">finset.mem_coe.mp</span> <span class="o">(</span><span class="n">set.mem_of_mem_of_subset</span> <span class="n">h</span> <span class="n">c1ss</span><span class="o">)),</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">c1</span> <span class="bp">+</span> <span class="n">finsupp.single</span> <span class="n">m</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">hs</span><span class="o">,</span> <span class="n">ims</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">finset.insert_eq</span><span class="o">,</span> <span class="n">finset.mem_union</span><span class="o">,</span> <span class="n">finset.mem_singleton</span><span class="o">],</span>
    <span class="n">obtain</span> <span class="n">F</span> <span class="o">:</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">h</span> <span class="bp">∈</span> <span class="n">c1.support.val</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">finsupp.support_single_ne_zero</span> <span class="n">a0</span><span class="o">,</span>
      <span class="n">finset.union_comm</span><span class="o">]</span> <span class="n">using</span> <span class="n">set.mem_of_mem_of_subset</span> <span class="n">hs</span> <span class="n">finsupp.support_add</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">F</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">or.inl</span> <span class="n">F</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">or.inr</span> <span class="o">(</span><span class="n">finset.coe_subset.mp</span> <span class="n">c1ss</span> <span class="n">F</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">clear</span> <span class="n">m1i</span> <span class="n">m1s</span> <span class="n">hz</span> <span class="n">ih</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">dc1m</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">c1.support</span> <span class="o">(</span><span class="n">finsupp.single</span> <span class="n">m</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.support_single_ne_zero</span> <span class="n">a0</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">finset.disjoint_singleton.mpr</span> <span class="n">mc1</span> <span class="o">},</span>
    <span class="k">have</span> <span class="n">cpa</span> <span class="o">:</span> <span class="o">(</span><span class="n">c1</span> <span class="bp">+</span> <span class="n">finsupp.single</span> <span class="n">m</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="bp">=</span> <span class="n">c1.support</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">m</span><span class="o">},</span>
    <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span> <span class="n">finsupp.support_single_ne_zero</span> <span class="n">a0</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">finsupp.support_add</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="n">refine</span> <span class="n">finset.mem_of_subset</span> <span class="o">(</span><span class="n">eq.subset</span> <span class="n">_</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">finsupp.support_add_eq</span> <span class="n">dc1m</span> <span class="o">},</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="k">in</span> <span class="o">{</span><span class="n">m</span><span class="o">},</span> <span class="o">(</span><span class="n">c1</span> <span class="bp">+</span> <span class="n">finsupp.single</span> <span class="n">m</span> <span class="n">a</span><span class="o">)</span> <span class="n">x</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">m</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.sum_singleton</span><span class="o">,</span> <span class="n">finsupp.coe_add</span><span class="o">,</span> <span class="n">pi.add_apply</span><span class="o">,</span> <span class="n">add_smul</span><span class="o">,</span> <span class="n">finsupp.single_eq_same</span><span class="o">],</span>
      <span class="n">refine</span> <span class="n">add_left_eq_self.mpr</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.not_mem_support_iff.mp</span> <span class="n">mc1</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">cpa</span><span class="o">,</span> <span class="n">finset.sum_union</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rwa</span> <span class="n">finsupp.support_single_ne_zero</span> <span class="n">a0</span> <span class="n">at</span> <span class="n">dc1m</span><span class="o">),</span> <span class="n">add_comm</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">finsupp.coe_add</span><span class="o">],</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">pi.add_apply</span><span class="o">,</span> <span class="n">add_smul</span><span class="o">,</span> <span class="n">finset.sum_add_distrib</span><span class="o">],</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">add_right_inj</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">add_right_eq_self.mpr</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">refine</span> <span class="n">finset.sum_eq_zero</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">xc1</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">convert</span> <span class="n">zero_smul</span> <span class="n">_</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finsupp.not_mem_support_iff</span><span class="o">,</span> <span class="n">finsupp.support_single_ne_zero</span> <span class="n">a0</span><span class="o">,</span> <span class="n">finset.not_mem_singleton</span><span class="o">],</span>
    <span class="n">rintros</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">mc1</span> <span class="n">xc1</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="228057549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228057549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228057549">(Feb 27 2021 at 13:10)</a>:</h4>
<p>Damiano surely the first line is <code>  apply span_induction hm,</code> and then you should have four straightforward goals.</p>



<a name="228057567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228057567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228057567">(Feb 27 2021 at 13:10)</a>:</h4>
<p>If you can't get it from what is already there then it should be straightforward to prove directly by induction.</p>



<a name="228058737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228058737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228058737">(Feb 27 2021 at 13:33)</a>:</h4>
<p>I'm trying it and it seems a bit shorter but it's still a struggle :-(</p>



<a name="228059033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059033">(Feb 27 2021 at 13:39)</a>:</h4>
<p>I agree, it puts stuff in the right places, but the proof does not seem much shorter.  It is more "guided", certainly!</p>



<a name="228059073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059073">(Feb 27 2021 at 13:40)</a>:</h4>
<p>You should be using <code>finsupp.sum</code> I think</p>



<a name="228059109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059109">(Feb 27 2021 at 13:40)</a>:</h4>
<p>Of course in my opinion you should be avoiding finsets completely and using finsum ;-)</p>



<a name="228059121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059121">(Feb 27 2021 at 13:41)</a>:</h4>
<p>ok, but, to be honest, I lost the strength to continue with this, now that it is proved and proof irrelevance will not look at how...  <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="228059136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059136">(Feb 27 2021 at 13:41)</a>:</h4>
<p>Besides, this is simply a step to prove something for the liquid project</p>



<a name="228059191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059191">(Feb 27 2021 at 13:42)</a>:</h4>
<p>Your goal is <code>∃ c : M →₀ R, (c.support : set M) ⊆ s ∧ (finsupp.sum c (λ m r, r • m)) = m</code></p>



<a name="228059202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059202">(Feb 27 2021 at 13:42)</a>:</h4>
<p>I can now prove that if, in a Z-module with a pairing, you take the dual of a set containing a basis, then the dual is entirely on one side of a hyperplane!</p>



<a name="228059212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059212">(Feb 27 2021 at 13:42)</a>:</h4>
<p>Not especially exciting, but it is getting the machinery working for lattice stuff</p>



<a name="228059306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059306">(Feb 27 2021 at 13:44)</a>:</h4>
<p>Ok, I may give this <code>finsupp.sum</code> instead of <code>finset.sum</code> a go, but later.  I actually did not know that there was a difference and simply went for what Lean accepted as a well-formed statement and that was correct mathematically...</p>



<a name="228059333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059333">(Feb 27 2021 at 13:45)</a>:</h4>
<p><code>finsupp.sum</code> is much better because it knows the key fact that summing over <code>support f</code> is the same as summing over any set containing <code>support f</code>.</p>



<a name="228059406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059406">(Feb 27 2021 at 13:46)</a>:</h4>
<p>Ah, this would save indeed a few lines, certainly towards the bottom of the proof, and likely earlier than that as well!</p>



<a name="228059760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059760">(Feb 27 2021 at 13:52)</a>:</h4>
<p>Another trick with <code>finsupp.sum</code> (which I'm learning as I'm proving) is that it's better to work with </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">R</span> <span class="bp">→+</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span> <span class="bp">•</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">zero_smul</span> <span class="n">_</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">add_smul</span> <span class="n">x</span> <span class="n">y</span> <span class="n">m</span><span class="o">}</span>
</code></pre></div>
<p>Does this map already have a name?</p>



<a name="228059952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059952">(Feb 27 2021 at 13:56)</a>:</h4>
<p>Is this the "orbit of <code>m</code>" map?  I am simply trying to parse the math side, not implying that if it is, then I know what it is in Lean!</p>



<a name="228059954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059954">(Feb 27 2021 at 13:56)</a>:</h4>
<p><code>(smul_add_hom R M).flip m</code></p>



<a name="228059996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228059996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228059996">(Feb 27 2021 at 13:57)</a>:</h4>
<p>Thanks Scott. The reason it's useful is that stuff like <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.sum_add_index'">docs#finsupp.sum_add_index'</a> needs not just that the map you're summing over is M -&gt; R -&gt; M but M -&gt; R -&gt;+ M.</p>



<a name="228061543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228061543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228061543">(Feb 27 2021 at 14:28)</a>:</h4>
<p>Here's my effort:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kn">open</span> <span class="n">submodule</span>

<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">finsupp</span>

<span class="kd">lemma</span> <span class="n">submodule.span_as_sum</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">submodule.span</span> <span class="n">R</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">c.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">c.support</span><span class="o">,</span> <span class="n">c</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">change</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">c.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span>
    <span class="o">(</span><span class="n">finsupp.sum</span> <span class="n">c</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span> <span class="n">m</span><span class="o">))</span> <span class="bp">=</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">span_induction</span> <span class="n">hm</span><span class="bp">;</span> <span class="n">clear</span> <span class="n">hm</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">finsupp.single</span> <span class="n">m</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">mem_support_single</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">rwa</span> <span class="n">hx.1</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="mi">0</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">hd</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">set.subset.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.union_subset</span> <span class="n">hc</span> <span class="n">hd</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.coe_union</span><span class="o">,</span> <span class="n">finset.coe_subset</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">support_add</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">r</span> <span class="n">m</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="n">r</span> <span class="bp">•</span> <span class="n">c</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hc</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">mem_support_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span> <span class="bp">⊢</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">h1</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">h1</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">sum_smul_index'</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
      <span class="n">convert</span> <span class="o">(</span><span class="n">add_monoid_hom.map_finsupp_sum</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span> <span class="n">r</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
      <span class="n">ext</span> <span class="n">m</span> <span class="n">s</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>It taught me a bunch about <code>finsupp.sum</code> (e.g. its existence!)</p>



<a name="228061705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228061705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228061705">(Feb 27 2021 at 14:32)</a>:</h4>
<p>I wonder if it would have been less painful if the support was just a set -- several times I had to do a finset &lt;-&gt; set dance. The goal is (exists x, X and Y) so after the induction and the split there are eight goals; each one only took a few lines but it all adds up...</p>



<a name="228065338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228065338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228065338">(Feb 27 2021 at 15:40)</a>:</h4>
<p>Thanks Kevin!  I like how structured your proof is.  Besides, it can be broken into 4 shorter lemmas, which is good!</p>
<p>Do you think it should be in mathlib?  I am using it in <code>toric</code>.</p>



<a name="228067789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228067789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228067789">(Feb 27 2021 at 16:25)</a>:</h4>
<p>Whenever I see a lemma like this I wonder whether in fact it's needed in the intended application or whether one can get away with just doing induction. I would definitely consider changing the statement of the lemma to what I <code>change</code> it to on line 1, but I don't see why it can't go in mathlib, I would imagine that there's a better way of proving <code>r • (c x) ≠ 0 -&gt; (c x) ≠ 0</code> rather than <code>intro h1, apply hx, simp [h1]</code> but everything else looks OK to me.</p>



<a name="228068069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228068069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228068069">(Feb 27 2021 at 16:30)</a>:</h4>
<p>Does <code>rw [finsupp.coe_smul] at hx,   exact right_ne_zero_of_mul hx</code> appear better?</p>



<a name="228068804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228068804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228068804">(Feb 27 2021 at 16:43)</a>:</h4>
<p>If it seems alright, this is a slightly shortened version of your proof that, I think, is still readable.  I could compress it further, but not much, I think.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">submodule.span_as_sum</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">submodule.span</span> <span class="n">R</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">c.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">c.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span> <span class="n">m</span><span class="o">))</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">span_induction</span> <span class="n">hm</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">_</span><span class="bp">;</span> <span class="n">clear</span> <span class="n">hm</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">finsupp.single</span> <span class="n">x</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">mem_support_single</span><span class="o">]</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="n">hy.1</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">hd</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="n">set.subset.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.union_subset</span> <span class="n">hc</span> <span class="n">hd</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.coe_union</span><span class="o">,</span> <span class="n">finset.coe_subset</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">support_add</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">r</span> <span class="n">m</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">•</span> <span class="n">c</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hc</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">mem_support_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span> <span class="bp">⊢</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.coe_smul</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">right_ne_zero_of_mul</span> <span class="n">hx</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">sum_smul_index'</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">_</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">convert</span> <span class="o">(</span><span class="n">add_monoid_hom.map_finsupp_sum</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span> <span class="n">r</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
        <span class="n">ext</span> <span class="n">m</span> <span class="n">s</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="o">(((</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">map_zero</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="228071024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228071024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228071024">(Feb 27 2021 at 17:22)</a>:</h4>
<p>PR <a href="https://github.com/leanprover-community/mathlib/issues/6457">#6457</a></p>



<a name="228071337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228071337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228071337">(Feb 27 2021 at 17:28)</a>:</h4>
<p>Thanks!</p>



<a name="228071592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228071592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228071592">(Feb 27 2021 at 17:32)</a>:</h4>
<p>No problem!</p>
<p>In the actual version, I begun the proof with a <code>classical</code>, since otherwise some of the finsets would complain.</p>
<p>I agree that using the definition of the submodule spanned as "the infimum of the submodules [...]" should be the standard approach, but sometimes I think that using linear combinations can be simpler/shorter.</p>



<a name="228072751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228072751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228072751">(Feb 27 2021 at 17:54)</a>:</h4>
<p>The other notable difference, is that I made implicit the assumptions <code>{m : M}</code> and <code>{s : set M}</code>, since they can be read off from the last assumption <code>(hm : m ∈ submodule.span R s)</code>.</p>
<p>(This change already appears in the shortened version above.)</p>



<a name="228073434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073434">(Feb 27 2021 at 18:07)</a>:</h4>
<p>Something strange happens with <code>M</code> when I try to apply Kevin's version.  This is what the checks say:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Kevin's formulation</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">submodule.span_as_sum</span>
<span class="n">submodule.span_as_sum</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">)}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">_inst_3</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">},</span>
    <span class="n">m</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="n">s</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">c.support</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">c.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="bp">⇑</span><span class="o">(</span><span class="bp">⇑</span><span class="o">((</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span><span class="o">)</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>

<span class="c1">-- original formulation</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">submodule.span_as_sum_mine</span>
<span class="n">submodule.span_as_sum_mine</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_3</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">},</span>
    <span class="n">m</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="n">s</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">c.support</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="k">in</span> <span class="n">c.support</span><span class="o">,</span> <span class="bp">⇑</span><span class="n">c</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
</code></pre></div>
<p>This actually means that I can apply the older version, but not the newer one.  Am I doing something wrong?</p>



<a name="228073532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073532">(Feb 27 2021 at 18:09)</a>:</h4>
<p>Try <code>refine</code> -- <code>apply</code> isn't always as smart as it could be. But it could be the problem with the smul_add_hom. I bet <code>convert</code> works.</p>



<a name="228073619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073619">(Feb 27 2021 at 18:10)</a>:</h4>
<p>actually, this is what I was doing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">csup</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">span_as_sum_mine</span> <span class="n">hm</span><span class="o">,</span>
</code></pre></div>



<a name="228073623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073623">(Feb 27 2021 at 18:10)</a>:</h4>
<p>I could try with explicit type ascription.</p>



<a name="228073683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073683">(Feb 27 2021 at 18:11)</a>:</h4>
<p>oh wait what -- you have universe issues, right?</p>



<a name="228073752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073752">(Feb 27 2021 at 18:12)</a>:</h4>
<p>Yes, some <code>max {...}</code> weirdness</p>



<a name="228073788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073788">(Feb 27 2021 at 18:13)</a>:</h4>
<p>That's the problem, Lean won't be able to unify the universes</p>



<a name="228073791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073791">(Feb 27 2021 at 18:13)</a>:</h4>
<p>Type ascription is not looking good either</p>



<a name="228073868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073868">(Feb 27 2021 at 18:14)</a>:</h4>
<p>I can't even get your version of my proof to compile -- can you post a MWE?</p>



<a name="228073887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073887">(Feb 27 2021 at 18:15)</a>:</h4>
<p>My version doesn't have the universe issues</p>



<a name="228073892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073892">(Feb 27 2021 at 18:15)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kn">open</span> <span class="n">submodule</span>

<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">finsupp</span>

<span class="kd">lemma</span> <span class="n">submodule.span_as_sum</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">submodule.span</span> <span class="n">R</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">c.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">c.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">span_induction</span> <span class="n">hm</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span> <span class="n">_</span> <span class="n">_</span><span class="bp">;</span> <span class="n">clear</span> <span class="n">hm</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">finsupp.single</span> <span class="n">x</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">mem_support_single</span><span class="o">]</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="n">hy.1</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">hd</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="n">set.subset.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">set.union_subset</span> <span class="n">hc</span> <span class="n">hd</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.coe_union</span><span class="o">,</span> <span class="n">finset.coe_subset</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">support_add</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">r</span> <span class="n">m</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">•</span> <span class="n">c</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hc</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mem_coe</span><span class="o">,</span> <span class="n">mem_support_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span> <span class="bp">⊢</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.coe_smul</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">right_ne_zero_of_mul</span> <span class="n">hx</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">sum_smul_index'</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">_</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">convert</span> <span class="o">(</span><span class="n">add_monoid_hom.map_finsupp_sum</span> <span class="o">(</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span> <span class="n">r</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
        <span class="n">ext</span> <span class="n">m</span> <span class="n">s</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="o">(((</span><span class="n">smul_add_hom</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">map_zero</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm">  Ideally, I would be able to prove this using the lemma above, but I cannot... -/</span>
<span class="kd">lemma</span> <span class="n">submodule.span_as_sum_mine</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">submodule.span</span> <span class="n">R</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">,</span> <span class="o">(</span><span class="n">c.support</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">c.support</span><span class="o">,</span> <span class="n">c</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- the element `m` is in the span of `s`, if it is in the span of a finite subset `T ⊆ s`</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">T</span><span class="o">,</span> <span class="n">Tv</span><span class="o">,</span> <span class="n">mT</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_span_finite_of_mem_span</span> <span class="n">hm</span><span class="o">,</span>
  <span class="c1">-- now that we know that our element `m` is in the span of `T ⊆ S`, we no longer need to carry</span>
  <span class="c1">-- around that it is also in the span of `S`</span>
  <span class="n">clear</span> <span class="n">hm</span><span class="o">,</span>
  <span class="c1">-- prepare for doing induction on</span>
  <span class="n">revert</span> <span class="n">m</span> <span class="n">s</span><span class="o">,</span>
  <span class="c1">-- induction on the finset `T`: the base case `T = ∅` is trivial.</span>
  <span class="n">refine</span> <span class="n">finset.induction_on</span> <span class="n">T</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">s</span> <span class="n">es</span> <span class="n">me</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">eq_comm</span><span class="o">]</span> <span class="n">using</span> <span class="n">me</span><span class="o">⟩)</span> <span class="n">_</span><span class="o">,</span>
  <span class="c1">-- clear unneded clutter (not sure why this did not go away on its own)</span>
  <span class="n">clear</span> <span class="n">T</span><span class="o">,</span>
  <span class="c1">-- induction step: we add an element `m1` to the finset `T`, we have an element `m`</span>
  <span class="c1">-- in the span of `T ∪ {m1}`</span>
  <span class="n">refine</span> <span class="bp">λ</span> <span class="n">m1</span> <span class="n">T</span> <span class="n">m1T</span> <span class="n">ih</span> <span class="n">m</span> <span class="n">s</span> <span class="n">ims</span> <span class="n">m1i</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span>
  <span class="c1">-- move sets/finsets around</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.coe_insert</span><span class="o">]</span> <span class="n">at</span> <span class="n">m1i</span><span class="o">,</span>
  <span class="c1">-- we isolate the coefficient `a` of `m1`</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">z</span><span class="o">,</span> <span class="n">hz</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">∈</span> <span class="n">span</span> <span class="n">R</span> <span class="bp">↑</span><span class="n">T</span><span class="o">),</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">m1</span> <span class="bp">+</span> <span class="n">z</span> <span class="o">:=</span>
    <span class="n">mem_span_insert.mp</span> <span class="n">m1i</span><span class="o">,</span>
  <span class="c1">-- apply the induction hypothesis to obtain the coefficients for the elements of `T`</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">c1</span><span class="o">,</span> <span class="n">c1ss</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">),</span> <span class="o">(</span><span class="n">c.support</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">T</span> <span class="bp">∧</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="k">in</span> <span class="n">c.support</span><span class="o">,</span> <span class="n">c</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span>
    <span class="n">ih</span> <span class="n">rfl.subset</span> <span class="n">hz</span><span class="o">,</span>
  <span class="c1">-- separate the cases in which the coefficient `a` of the "new" element `m1` vanishes...</span>
  <span class="n">by_cases</span> <span class="n">a0</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- in this case, the coefficients that we get by induction work straight away</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">c1</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">hg</span><span class="o">,</span> <span class="n">ims</span> <span class="o">(</span><span class="n">finset.mem_insert_of_mem</span> <span class="o">(</span><span class="n">c1ss</span> <span class="n">hg</span><span class="o">)),</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">a0</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">]</span> <span class="o">},</span>
  <span class="c1">-- or the new coefficient `a` is non-zero</span>
  <span class="c1">-- the new element `m1` is not in the support of the coefficients for `m` arising from the</span>
  <span class="c1">-- induction hypothesis</span>
  <span class="k">have</span> <span class="n">mc1</span> <span class="o">:</span> <span class="n">m1</span> <span class="bp">∉</span> <span class="n">c1.support</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">m1T</span> <span class="o">(</span><span class="n">finset.mem_coe.mp</span> <span class="o">(</span><span class="n">set.mem_of_mem_of_subset</span> <span class="n">h</span> <span class="n">c1ss</span><span class="o">)),</span>
  <span class="c1">-- by construction, the support of `c1` does not contain `m1`</span>
  <span class="k">have</span> <span class="n">dc1m</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">c1.support</span> <span class="o">(</span><span class="n">finsupp.single</span> <span class="n">m1</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.support_single_ne_zero</span> <span class="n">a0</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">finset.disjoint_singleton.mpr</span> <span class="n">mc1</span> <span class="o">},</span>
  <span class="c1">-- moreover, the involved coefficients are really the coefficients appearing in the support</span>
  <span class="c1">-- of `c1` and `{m1}`</span>
  <span class="k">have</span> <span class="n">cpa</span> <span class="o">:</span> <span class="o">(</span><span class="n">c1</span> <span class="bp">+</span> <span class="n">finsupp.single</span> <span class="n">m1</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="bp">=</span> <span class="n">c1.support</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">m1</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">finsupp.support_single_ne_zero</span> <span class="n">a0</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">finsupp.support_add</span> <span class="n">h</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="n">finset.mem_of_subset</span> <span class="o">(</span><span class="n">eq.subset</span> <span class="n">_</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finsupp.support_add_eq</span> <span class="n">dc1m</span> <span class="o">},</span>
  <span class="c1">-- of course, `m` is the sum of the coefficients coming from the induction and</span>
  <span class="c1">-- the new coefficient `a` for `m1`</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">c1</span> <span class="bp">+</span> <span class="n">finsupp.single</span> <span class="n">m1</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">hs</span><span class="o">,</span> <span class="n">ims</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="c1">-- make sure that the support is still contained in `T ∪ {m1}`</span>
  <span class="o">{</span> <span class="c1">-- we use `hs`, once we undo trivialities</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">cpa</span><span class="o">,</span> <span class="n">finset.union_comm</span><span class="o">]</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">set.mem_of_mem_of_subset</span> <span class="n">hs</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.insert_eq</span><span class="o">,</span> <span class="n">finset.coe_insert</span><span class="o">,</span> <span class="n">finset.coe_insert</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">set.insert_subset_insert</span> <span class="n">c1ss</span> <span class="o">},</span>
  <span class="c1">-- in this branch, we show that the element `m` really is the sum that we claim it is</span>
  <span class="o">{</span> <span class="c1">-- remove clutter from the proof</span>
    <span class="n">clear</span> <span class="n">m1i</span> <span class="n">m1T</span> <span class="n">hz</span> <span class="n">ih</span><span class="o">,</span>
    <span class="c1">-- a complicated way of writing `a • m1`, as a sum over the singleton `{m1}`</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="k">in</span> <span class="o">{</span><span class="n">m1</span><span class="o">},</span> <span class="o">(</span><span class="n">c1</span> <span class="bp">+</span> <span class="n">finsupp.single</span> <span class="n">m1</span> <span class="n">a</span><span class="o">)</span> <span class="n">x</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">m1</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset.sum_singleton</span><span class="o">,</span> <span class="n">finsupp.coe_add</span><span class="o">,</span> <span class="n">pi.add_apply</span><span class="o">,</span> <span class="n">add_smul</span><span class="o">,</span> <span class="n">finsupp.single_eq_same</span><span class="o">],</span>
      <span class="n">refine</span> <span class="n">add_left_eq_self.mpr</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.not_mem_support_iff.mp</span> <span class="n">mc1</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">]</span> <span class="o">},</span>
    <span class="c1">-- we start by matching up term, first one of the sums equals `a • m1`</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">cpa</span><span class="o">,</span> <span class="n">finset.sum_union</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rwa</span> <span class="n">finsupp.support_single_ne_zero</span> <span class="n">a0</span> <span class="n">at</span> <span class="n">dc1m</span><span class="o">),</span> <span class="n">add_comm</span><span class="o">,</span>
      <span class="n">this</span><span class="o">,</span> <span class="n">finsupp.coe_add</span><span class="o">],</span>
    <span class="c1">-- next, we split the other sum</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">pi.add_apply</span><span class="o">,</span> <span class="n">add_smul</span><span class="o">,</span> <span class="n">finset.sum_add_distrib</span><span class="o">],</span>
    <span class="c1">-- now we clear `a • m1` and one of the sums, since they are equal on both sides</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">add_right_inj</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">add_right_eq_self.mpr</span> <span class="n">_</span><span class="o">),</span>
    <span class="c1">-- we show that the remaining sum vanishes, by showing that all its terms vanish</span>
    <span class="n">refine</span> <span class="n">finset.sum_eq_zero</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">xc1</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="c1">-- it suffices to show that we are `smul`ling by `0`</span>
    <span class="n">convert</span> <span class="n">zero_smul</span> <span class="n">_</span> <span class="n">x</span><span class="o">,</span>
    <span class="c1">-- for this, it suffices to show that `x` is not equal to `m1`</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finsupp.not_mem_support_iff</span><span class="o">,</span> <span class="n">finsupp.support_single_ne_zero</span> <span class="n">a0</span><span class="o">,</span> <span class="n">finset.not_mem_singleton</span><span class="o">],</span>
    <span class="c1">-- since `x` is in the support of `c1`, it follows that `x ≠ m1`, the proof is by contradiction</span>
    <span class="n">rintros</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">mc1</span> <span class="n">xc1</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">submodule.span_as_sum</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">submodule.span_as_sum_mine</span>
</code></pre></div>



<a name="228073933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228073933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228073933">(Feb 27 2021 at 18:15)</a>:</h4>
<p>These are your proof first, then mine.  I changed your statement to the statement after the <code>change</code> in your original proof.</p>



<a name="228074017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228074017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228074017">(Feb 27 2021 at 18:17)</a>:</h4>
<p>In my VSCode, they compile.  I am on <code>toric</code> in lean liquid</p>



<a name="228074054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228074054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228074054">(Feb 27 2021 at 18:17)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">finsupp</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">lemma</span> <span class="n">submodule.span_as_sum</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="bp">...</span>
</code></pre></div>
<p>seems to fix the universe issues. No idea what's going on there.</p>



<a name="228074207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228074207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228074207">(Feb 27 2021 at 18:20)</a>:</h4>
<p>This is very strange.  Should I then change the PR as well?</p>



<a name="228074220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228074220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228074220">(Feb 27 2021 at 18:20)</a>:</h4>
<p>With universes on, the <code>M : Type*</code> version of mine compiles to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">submodule.span_as_sum.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">)}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">semiring.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">add_comm_group.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">)}</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">_inst_3</span> <span class="o">:</span> <span class="n">semimodule.</span><span class="o">{</span><span class="n">u_1</span> <span class="o">(</span><span class="n">max</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">)}</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">)}</span> <span class="n">M</span><span class="o">},</span>
    <span class="n">m</span> <span class="bp">∈</span> <span class="n">span.</span><span class="o">{</span><span class="n">u_1</span> <span class="o">(</span><span class="n">max</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">)}</span> <span class="n">R</span> <span class="n">s</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">),</span>
       <span class="bp">↑</span><span class="o">(</span><span class="n">c.support</span><span class="o">)</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">c.sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="bp">⇑</span><span class="o">(</span><span class="bp">⇑</span><span class="o">((</span><span class="n">smul_add_hom.</span><span class="o">{</span><span class="n">u_1</span> <span class="o">(</span><span class="n">max</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">)}</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">flip</span><span class="o">)</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
</code></pre></div>
<p>so it introduces three universes but never spots that <code>max u_2 u_3</code> is the only time <code>u_2</code> and <code>u_3</code> are used.</p>



<a name="228074339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228074339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228074339">(Feb 27 2021 at 18:23)</a>:</h4>
<p>Yes, it does compile, but I could not apply it.</p>
<p>In any case, I added the explicit universe in the PR as well and now I can apply it in my other file!</p>



<a name="228074342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228074342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228074342">(Feb 27 2021 at 18:23)</a>:</h4>
<p>Thanks!</p>



<a name="228074723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228074723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228074723">(Feb 27 2021 at 18:31)</a>:</h4>
<p>Oh lol, I didn't use <code>finsupp.coe_smul</code>because my mathlib was 2 days old and it was added yesterday :P (that's why your version of my proof didn't compile for me).</p>
<p>I asked about the universe issue in <a class="stream" data-stream-id="113488" href="/#narrow/stream/113488-general">#general</a></p>



<a name="228074936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228074936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228074936">(Feb 27 2021 at 18:34)</a>:</h4>
<p>The importance of a fresh copy of mathlib... Ahaha</p>
<p>I saw the universe issue question, thanks!</p>



<a name="228076493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228076493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228076493">(Feb 27 2021 at 19:04)</a>:</h4>
<p>It's nice to see lemmas I add being used immediately :)</p>



<a name="228280739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228280739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228280739">(Mar 01 2021 at 18:23)</a>:</h4>
<p>Turns out the proof of the lemma was:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">conv_lhs</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">set.image_id</span> <span class="n">s</span> <span class="o">},</span>
  <span class="n">simp_rw</span> <span class="bp">←</span><span class="n">exists_prop</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">finsupp.mem_span_iff_total</span> <span class="n">R</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.mem_span_iff_total">docs#finsupp.mem_span_iff_total</a></p>



<a name="228283824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/submodule.span%20as_sum/near/228283824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/submodule.2Espan.20as_sum.html#228283824">(Mar 01 2021 at 18:41)</a>:</h4>
<p>Yeah Alex pointed that out ages ago</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/partial.20functions.20and.20gluing.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html">partial functions and gluing</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="251825197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251825197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251825197">(Sep 03 2021 at 05:34)</a>:</h4>
<p>Hi all, I'm currently trying to do some basic point-set topology in Lean from the ground up -- partly to learn more about structures and typeclasses. I have looked a bit at topology in mathlib (only a little -- I kind of want to make my own mistakes, and I'm also not really fluent enough to read mathlib at length). I initially followed the first few section of Munkres <em>Topology</em> (open/closed sets, continuous functions).</p>
<p>I'm currently trying to formalize gluing, specifically gluing a fiber bundle given the data of a local trivialization.</p>
<p>The topology aspect is mostly all homeomorphisms. So the main challenge has really come from working with lots of subsets and/or subtypes and functions between them. I've read some discussions on here about it being generally preferable to use total functions with junk values. Would that be the right thing to do here? Or is there some way to make this easier?</p>
<p>For example, say <code>π : E → B</code> is a fiber bundle with fiber <code>F</code> and <code>U : set B</code> is a trivializing open set (i.e. I have the data of a bijection/homeomorphism <code>φ : U × F → π ⁻¹' U</code>). Then I find it surprisingly painful to show that any smaller subset <code>U' ⊆ U</code> is also trivializing. For example showing that <code>φ</code> restricted to <code>U' × F</code> maps to <code>π ⁻¹' U'</code> (and having to treat codomains similar to that one in two slightly different ways depending on whether they show up as a subtype of E or a subtype of <code>π ⁻¹' U</code>, i.e. a sub-subtype of E). </p>
<p>Here's my setup:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="n">E'</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">π</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">π'</span> <span class="o">:</span> <span class="n">E'</span> <span class="bp">→</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">φ</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">E'</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">fiber_map_subset</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">e</span> <span class="bp">∈</span> <span class="n">π</span> <span class="bp">⁻¹'</span> <span class="n">U</span> <span class="bp">↔</span> <span class="n">φ</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">π'</span> <span class="bp">⁻¹'</span> <span class="n">U</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">function.comp_app</span> <span class="n">π'</span> <span class="n">φ</span><span class="o">,</span> <span class="n">hφ</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">res_subset</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">π</span> <span class="bp">⁻¹'</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">π'</span> <span class="bp">⁻¹'</span> <span class="n">U</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">φ</span> <span class="n">e</span><span class="o">,</span> <span class="o">(</span><span class="n">fiber_map_subset</span> <span class="n">hφ</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">he</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">fiber_map_inj_iff_res_inj</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.injective</span> <span class="n">φ</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span><span class="o">),</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">res_subset</span> <span class="n">hφ</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">fiber_map_surj_iff_res_surj</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.surjective</span> <span class="n">φ</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span><span class="o">),</span> <span class="n">function.surjective</span> <span class="o">(</span><span class="n">res_subset</span> <span class="n">hφ</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">fiber_map_bij_iff_res_bij</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.bijective</span> <span class="n">φ</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span><span class="o">),</span> <span class="n">function.bijective</span> <span class="o">(</span><span class="n">res_subset</span> <span class="n">hφ</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>For those, filling in the <code>sorry</code>s takes me about 5 lines each. But then proving the analogous iff statements for continuity and inverse-continuity and homeomorphisms takes me 60-70 lines. I won't copy that all here, but the lemma statement is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- I have defined a topology as a set of open sets</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">TB</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">TE</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">TE'</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">E'</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">fiber_map_cts_iff_res_cts</span>
  <span class="o">(</span><span class="n">hπ_cts</span> <span class="o">:</span> <span class="n">cts</span> <span class="n">TE</span> <span class="n">TB</span> <span class="n">π</span><span class="o">)</span> <span class="o">(</span><span class="n">hπ'_cts</span> <span class="o">:</span> <span class="n">cts</span> <span class="n">TE'</span> <span class="n">TB</span> <span class="n">π'</span><span class="o">)</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">topology.cts</span> <span class="n">TE</span> <span class="n">TE'</span> <span class="n">φ</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="n">U</span> <span class="o">(</span><span class="n">hU</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">TB.opens</span><span class="o">),</span> <span class="n">cts</span> <span class="bp">↑</span><span class="n">TE</span> <span class="bp">↑</span><span class="n">TE'</span> <span class="o">(</span><span class="n">res_subset</span> <span class="n">hφ</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span>

<span class="c1">-- proof of the above is 15-20 lines and uses:</span>
<span class="kd">def</span> <span class="n">to_sub</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">A</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">x.val</span> <span class="bp">∈</span> <span class="n">U</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">from_sub</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U'</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span> <span class="o">(⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">U'</span><span class="o">}</span>
<span class="kd">lemma</span> <span class="n">to_sub_open_iff</span> <span class="o">(</span><span class="n">U'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">U'</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">TX</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">opens</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">TX.opens</span><span class="o">,</span> <span class="n">U'</span> <span class="bp">=</span> <span class="n">to_sub</span> <span class="n">A</span> <span class="n">U</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">from_sub_open_iff</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">TX.opens</span><span class="o">)</span> <span class="o">(</span><span class="n">U'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">U'</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">TX</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">opens</span> <span class="bp">↔</span> <span class="n">from_sub</span> <span class="n">A</span> <span class="n">U'</span> <span class="bp">∈</span> <span class="n">TX.opens</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>I'd be grateful for any comments or advice!</p>



<a name="251829014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251829014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251829014">(Sep 03 2021 at 06:34)</a>:</h4>
<p><span class="user-mention" data-user-id="391579">@Jake Levinson</span> These issues are painful. Do you have a specific <code>sorry</code> that you want advice on?<br>
One complication is that you seem to have built your own topology library, and I have no idea what exactly it looks like. So I have no idea whether those final two <code>sorry</code>s are supposed to be filled by <code>iff.rfl</code>, or that the definitions force you into a 20-line proof.</p>



<a name="251855059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251855059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251855059">(Sep 03 2021 at 10:07)</a>:</h4>
<p>Not sure if it will make things much easier, but I think it is better to work with open embeddings and not open subsets.</p>



<a name="251855268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251855268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251855268">(Sep 03 2021 at 10:08)</a>:</h4>
<p>For one thing, your mental picture of what is going on will be a lot closer to Lean's.</p>



<a name="251901999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251901999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251901999">(Sep 03 2021 at 15:53)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Hmm, thanks for the comments. Let me include a bit more of the code, though FWIW this gluing stuff is mostly independent of most earlier lemmas (which were on stuff like bases for a topology, interiors and closures, etc).</p>
<p>Here are two <code>sorry</code>s I would appreciate advice on.</p>
<ol>
<li>For the injectivity/bijectivity lemmas (which are purely about sets and functions, so no other lemmas necessary), I wonder if there is a way to get a one-line proof? For example I have:</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">fiber_map_subset'</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">π</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">↔</span> <span class="n">π'</span> <span class="o">(</span><span class="n">φ</span> <span class="n">e</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">U</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">function.comp_app</span> <span class="n">π'</span> <span class="n">φ</span><span class="o">,</span> <span class="n">hφ</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">fiber_map_surj_iff_res_surj</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.surjective</span> <span class="n">φ</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span><span class="o">),</span> <span class="n">function.surjective</span> <span class="o">(</span><span class="n">res_subset</span> <span class="n">hφ</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
    <span class="n">rintros</span> <span class="n">h</span> <span class="n">U</span> <span class="o">⟨</span><span class="n">e'</span><span class="o">,</span> <span class="n">he'</span><span class="o">⟩,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">e'</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">fiber_map_subset'</span> <span class="n">hφ</span><span class="o">,</span> <span class="n">he</span><span class="o">],</span> <span class="n">he</span><span class="o">⟩,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">specialize</span> <span class="n">h</span> <span class="n">set.univ</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">function.surjective</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>This is reasonably short, going directly from the definition of surjectivity in both directions of the <code>iff</code>. (My first attempt was longer until I finally wrote the auxiliary lemma <code>fiber_map_subset'</code>). Still a little longer than I had expected.</p>
<ol start="2">
<li>For <code>fiber_map_cts_iff_res_cts</code> (see below), I think my proof is pretty messy. Notably, I couldn't find an easy/clean way to deal with the distinction between functions <code>E → E</code> and <code>{e : E // true} → {e : E // true}</code> (this works OK in <code>fiber_map_surj_iff_res_surj</code> above via <code>simp</code> in the <code>iff.mpr</code> direction).</li>
</ol>
<p>Here is my code, including my definitions of topology, continuous function, subspace topology (this should all be a working example, if not quite an <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kn">section</span> <span class="n">topology</span>

<span class="kd">class</span> <span class="n">topology</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">opens</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span> <span class="c1">-- (should this instead be: is_open : set X → Prop ?)</span>
<span class="o">(</span><span class="n">empty_open</span> <span class="o">:</span> <span class="bp">∅</span> <span class="bp">∈</span> <span class="n">opens</span><span class="o">)</span>
<span class="o">(</span><span class="n">univ_open</span> <span class="o">:</span> <span class="n">set.univ</span> <span class="bp">∈</span> <span class="n">opens</span><span class="o">)</span>
<span class="o">(</span><span class="n">inter₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">opens</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">opens</span> <span class="bp">→</span> <span class="n">set.inter</span> <span class="n">U</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">opens</span><span class="o">)</span>
<span class="o">(</span><span class="n">union</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">sU</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)),</span> <span class="n">sU</span> <span class="bp">⊆</span> <span class="n">opens</span> <span class="bp">→</span> <span class="bp">⋃₀</span> <span class="n">sU</span> <span class="bp">∈</span> <span class="n">opens</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">TX</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">TY</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">cts</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">TY.opens</span><span class="o">,</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">TX.opens</span>

<span class="kd">instance</span> <span class="n">inverse_image_topology</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">⟨</span>
  <span class="o">{</span><span class="n">W</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">U</span> <span class="bp">∈</span> <span class="n">TY.opens</span><span class="o">),</span> <span class="n">W</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">U</span><span class="o">},</span>
  <span class="o">⟨</span><span class="bp">∅</span><span class="o">,</span> <span class="o">⟨</span><span class="n">topology.empty_open</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩,</span>
  <span class="o">⟨</span><span class="n">set.univ</span><span class="o">,</span> <span class="o">⟨</span><span class="n">topology.univ_open</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩,</span>
  <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- written on the side</span>
  <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- written on the side</span>
<span class="o">⟩</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">subspace_topology</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">A</span> <span class="o">:=</span>
  <span class="n">inverse_image_topology</span> <span class="n">TX</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a.val</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">topology_to_subspace_topology</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">topology</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">topology</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="bp">λ</span> <span class="n">TX</span><span class="o">,</span> <span class="n">subspace_topology</span> <span class="n">TX</span> <span class="n">A</span><span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">to_sub</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">A</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">x.val</span> <span class="bp">∈</span> <span class="n">U</span><span class="o">}</span>
<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">from_sub</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U'</span><span class="o">,</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span> <span class="o">(⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">U'</span><span class="o">}</span>

<span class="c1">-- Then I proved as many lemmas as I could think of about `to_sub` and `from_sub`. The only two I use below are:</span>

<span class="kd">lemma</span> <span class="n">to_sub_open_iff</span> <span class="o">(</span><span class="n">U'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">U'</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">TX</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">opens</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">TX.opens</span><span class="o">,</span> <span class="n">U'</span> <span class="bp">=</span> <span class="n">to_sub</span> <span class="n">A</span> <span class="n">U</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">from_sub_open_iff</span> <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">TX.opens</span><span class="o">)</span> <span class="o">(</span><span class="n">U'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">U'</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">TX</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">opens</span> <span class="bp">↔</span> <span class="n">from_sub</span> <span class="n">A</span> <span class="n">U'</span> <span class="bp">∈</span> <span class="n">TX.opens</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">topology</span>

<span class="c1">-- Finally, here is `fiber_map_cts_iff_res_cts`.</span>

<span class="kn">section</span> <span class="n">fiber_bundle</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="n">E'</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">π</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">π'</span> <span class="o">:</span> <span class="n">E'</span> <span class="bp">→</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">φ</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">E'</span><span class="o">}</span>
  <span class="o">(</span><span class="n">TB</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">TE</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">TE'</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">E'</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">fiber_map_subset</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">e</span> <span class="bp">∈</span> <span class="n">π</span> <span class="bp">⁻¹'</span> <span class="n">U</span> <span class="bp">↔</span> <span class="n">φ</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">π'</span> <span class="bp">⁻¹'</span> <span class="n">U</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">function.comp_app</span> <span class="n">π'</span> <span class="n">φ</span><span class="o">,</span> <span class="n">hφ</span><span class="o">]}</span>

<span class="kd">lemma</span> <span class="n">fiber_map_subset'</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">π</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">U</span> <span class="bp">↔</span> <span class="n">π'</span> <span class="o">(</span><span class="n">φ</span> <span class="n">e</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">U</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">function.comp_app</span> <span class="n">π'</span> <span class="n">φ</span><span class="o">,</span> <span class="n">hφ</span><span class="o">]</span>

<span class="kd">@[simp]</span>
<span class="kd">def</span> <span class="n">res_subset</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">π</span> <span class="bp">⁻¹'</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">π'</span> <span class="bp">⁻¹'</span> <span class="n">U</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">φ</span> <span class="n">e</span><span class="o">,</span> <span class="o">(</span><span class="n">fiber_map_subset</span> <span class="n">hφ</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">he</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">fiber_map_cts_iff_res_cts</span> <span class="o">(</span><span class="n">hπ_cts</span> <span class="o">:</span> <span class="n">cts</span> <span class="n">TE</span> <span class="n">TB</span> <span class="n">π</span><span class="o">)</span> <span class="o">(</span><span class="n">hπ'_cts</span> <span class="o">:</span> <span class="n">cts</span> <span class="n">TE'</span> <span class="n">TB</span> <span class="n">π'</span><span class="o">)</span> <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">π'</span> <span class="bp">∘</span> <span class="n">φ</span> <span class="bp">=</span> <span class="n">π</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">topology.cts</span> <span class="n">TE</span> <span class="n">TE'</span> <span class="n">φ</span> <span class="bp">↔</span>
  <span class="bp">∀</span> <span class="n">U</span> <span class="o">(</span><span class="n">hU</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">TB.opens</span><span class="o">),</span> <span class="n">cts</span> <span class="bp">↑</span><span class="n">TE</span> <span class="bp">↑</span><span class="n">TE'</span> <span class="o">(</span><span class="n">res_subset</span> <span class="n">hφ</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="c1">-- mp</span>
  <span class="n">intros</span> <span class="n">hφ_cts</span> <span class="n">U</span> <span class="n">hU</span> <span class="n">V</span> <span class="n">hV</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">V_E'</span> <span class="o">:=</span> <span class="n">from_sub</span> <span class="n">_</span> <span class="n">V</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hV_E'</span> <span class="o">:=</span> <span class="o">(</span><span class="n">from_sub_open_iff</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">hπ'_cts</span> <span class="n">U</span> <span class="n">hU</span><span class="o">)</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hV</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hφ_cts</span> <span class="n">V_E'</span> <span class="n">hV_E'</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">res_subset</span> <span class="n">hφ</span> <span class="n">U</span> <span class="bp">⁻¹'</span> <span class="n">V</span> <span class="bp">=</span> <span class="n">to_sub</span> <span class="n">_</span> <span class="o">(</span><span class="n">φ</span> <span class="bp">⁻¹'</span> <span class="n">V_E'</span><span class="o">),</span>
    <span class="n">ext</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩,</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">fiber_map_subset</span> <span class="n">hφ</span> <span class="n">at</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">he</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">h</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">h'</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">to_sub_open_iff</span><span class="o">],</span>
  <span class="n">use</span> <span class="o">(</span><span class="n">φ</span> <span class="bp">⁻¹'</span> <span class="n">V_E'</span><span class="o">),</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">hφ_cts</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="c1">-- mpr</span>
  <span class="n">intro</span> <span class="n">hφU_cts</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hφU_cts</span> <span class="n">set.univ</span> <span class="n">TB.univ_open</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">V</span> <span class="n">hV</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hφU_cts</span> <span class="o">(</span><span class="n">to_sub</span> <span class="n">set.univ</span> <span class="n">V</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">to_sub_open_iff</span> <span class="n">at</span> <span class="n">hφU_cts</span><span class="o">,</span> <span class="n">specialize</span> <span class="n">hφU_cts</span> <span class="o">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hV</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">rw</span> <span class="n">from_sub_open_iff</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">hπ_cts</span> <span class="n">_</span> <span class="n">TB.univ_open</span><span class="o">)</span> <span class="n">at</span> <span class="n">hφU_cts</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">hφU_cts</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">e</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">fiber_bundle</span>
</code></pre></div>
<p>I have no idea if the above is even slightly readable, heh... and I found it very difficult to write. I would highlight that the <code>mpr</code> direction is quite complicated even though I have the hypothesis <code>cts ↑TE ↑TE' (res_subset hφ set.univ)</code>,  i.e. the restriction of <code>φ</code> to <code>π ⁻¹' set.univ</code> is continuous.</p>



<a name="251902555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251902555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251902555">(Sep 03 2021 at 15:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/partial.20functions.20and.20gluing/near/251855059">said</a>:</p>
<blockquote>
<p>Not sure if it will make things much easier, but I think it is better to work with open embeddings and not open subsets.</p>
</blockquote>
<p>I considered doing this -- it definitely makes sense to me that there would be advantages to suppressing sets throughout and always replacing <code>U : set X</code> by <code>f : U \to X</code> and <code>hf : open_immersion f</code>.</p>
<p>I think my main hesitation was that I think I would then have to replace intersection of open sets by fiber product? I got the feeling that this approach would quickly lead me more towards formalizing category theory rather than topology, if that makes sense...</p>



<a name="251903280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251903280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251903280">(Sep 03 2021 at 16:02)</a>:</h4>
<p><span class="user-mention" data-user-id="391579">@Jake Levinson</span> I started following along with your exercise last night to see to get a better idea of what you might be running into.  I have exactly the same definition for <code>topology</code> (sets of sets seem fine to me).  Here's a notation trick:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">...</span>
<span class="o">(</span><span class="n">opens</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span>
<span class="bp">...</span>
</code></pre></div>
<p>The square brackets make it take <code>X</code> explicitly, so you can write things like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">union_mem</span> <span class="o">(</span><span class="n">U</span> <span class="n">U'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">U'</span> <span class="bp">∈</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">∪</span> <span class="n">U'</span> <span class="bp">∈</span> <span class="n">opens</span> <span class="n">X</span>
</code></pre></div>



<a name="251903650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251903650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251903650">(Sep 03 2021 at 16:04)</a>:</h4>
<p>For <code>inverse_image_topology</code>, you don't want that to be an instance, since it depends on <code>f</code> and can't be used.</p>
<p>If you want to be terse for the definition of the open sets, you can do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">inverse_image_topology</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">opens</span> <span class="o">:=</span> <span class="n">set.preimage</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span>
   <span class="bp">...</span> <span class="o">}</span>
</code></pre></div>



<a name="251903841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251903841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251903841">(Sep 03 2021 at 16:05)</a>:</h4>
<p>Once you have that, the subspace topology is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">topology.subspace</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">topology</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">inverse_image_topology</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>
</code></pre></div>
<p>(<code>coe</code> is the official way to apply <code>subtype.val</code>)</p>



<a name="251904700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251904700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251904700">(Sep 03 2021 at 16:10)</a>:</h4>
<p>For example, here's a short definition for <code>from_sub</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">from_sub</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">set.image</span> <span class="n">coe</span>
</code></pre></div>
<p>and <code>to_sub</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">to_sub</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">set.preimage</span> <span class="n">coe</span>
</code></pre></div>



<a name="251905155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251905155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251905155">(Sep 03 2021 at 16:13)</a>:</h4>
<p>(I'm not sure I've used it yet, but these are related to another characterization of continuity:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">cts.def</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">cts</span> <span class="n">f</span> <span class="bp">↔</span> <span class="n">set.preimage</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">opens</span> <span class="n">Y</span> <span class="bp">⊆</span> <span class="n">opens</span> <span class="n">X</span>
</code></pre></div>
<p>This is saying that <code>set.image (set.preimage f)</code> is the induced map on open sets.)</p>



<a name="251905537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251905537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251905537">(Sep 03 2021 at 16:16)</a>:</h4>
<p>I find it somewhat more opaque to use <code>set.image</code> and <code>set.preimage</code> than just writing the sets out, but it's not so bad if you remind yourself what their underlying definitions are.  The benefit is that you get to use whatever lemmas mathlib already has about these sets.</p>



<a name="251953663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251953663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251953663">(Sep 03 2021 at 23:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/partial.20functions.20and.20gluing/near/251903280">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="391579">Jake Levinson</span> I started following along with your exercise last night to see to get a better idea of what you might be running into.  I have exactly the same definition for <code>topology</code> (sets of sets seem fine to me).  Here's a notation trick:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">...</span>
<span class="o">(</span><span class="n">opens</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span>
<span class="bp">...</span>
</code></pre></div>
<p>The square brackets make it take <code>X</code> explicitly, so you can write things like</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">union_mem</span> <span class="o">(</span><span class="n">U</span> <span class="n">U'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">U'</span> <span class="bp">∈</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">∪</span> <span class="n">U'</span> <span class="bp">∈</span> <span class="n">opens</span> <span class="n">X</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Wow, this is fantastic!  With that I was able to remove the implicit arguments from nearly everywhere. Thanks! One thing I still have to do is write <code>U \in topology.opens X</code>, not <code>U \in opens X</code> as you have. I'm not sure if there's some way to avoid that?</p>
<p>The other changes you suggested are quite helpful and I went and implemented them all. If you're curious, the repository is here -- <a href="https://github.com/mguaypaq/lean-topology">https://github.com/mguaypaq/lean-topology</a>. The stuff I posted here is in <code>topology.lean</code> and <code>bundles.lean</code>.</p>
<p>That said, my proof of <code>fiber_map_cts_iff_res_cts</code> remains long and messy.</p>



<a name="251954667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251954667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251954667">(Sep 03 2021 at 23:27)</a>:</h4>
<p>To do <code>opens</code> by itself, either put the code in the <code>topology</code> namespace or do <code>open topology</code>.  This makes all the names inside <code>topology</code> available without qualification.</p>



<a name="251954863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251954863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251954863">(Sep 03 2021 at 23:30)</a>:</h4>
<p>The set-of-sets version of <a href="https://github.com/mguaypaq/lean-topology/blob/main/topology.lean#L16">this</a> is in <code>data.set.lattice</code>.  There's a predicate on finiteness in <code>data.set.finite</code> that you could use when you want to do just finite intersections (so if <code>s</code> is a set, <code>(h : s.finite)</code> would be how you indicate that you need a proof of finiteness)</p>



<a name="251954913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251954913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251954913">(Sep 03 2021 at 23:30)</a>:</h4>
<p>Oh, I misunderstood what you are doing</p>



<a name="251954943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251954943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251954943">(Sep 03 2021 at 23:31)</a>:</h4>
<p>It tends to be frowned upon overloading notation without using a typeclass, like <code>has_add</code> etc.)</p>



<a name="251955535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251955535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251955535">(Sep 03 2021 at 23:39)</a>:</h4>
<p>For example, this could be <code>open_of_inter_of_finset</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">sInter_mem</span> <span class="o">(</span><span class="n">sU</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">sU.finite</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">sU</span> <span class="bp">⊆</span> <span class="n">topology.opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">⋂₀</span> <span class="n">sU</span> <span class="bp">∈</span> <span class="n">topology.opens</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">set.finite.induction_on</span> <span class="n">hf</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- the h at the end effectively adds h as an additional induction hypothesis</span>
  <span class="c1">-- this would be clearer:</span>
  <span class="c1">--   revert h,</span>
  <span class="c1">--   refine set.finite.induction_on hf _ _,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">univ_mem</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">U</span> <span class="n">sU'</span> <span class="n">hU</span> <span class="n">hf</span> <span class="n">h</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.sInter_insert</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set.insert_subset</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">inter_mem</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hi.1</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hi.2</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="251955790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251955790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251955790">(Sep 03 2021 at 23:43)</a>:</h4>
<p>(This also saves you from needing to worry about decidable equality.)</p>



<a name="251957911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251957911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251957911">(Sep 04 2021 at 00:16)</a>:</h4>
<p>That's interesting, I did find the whole decidable-equality thing confusing. (I haven't actually used those finite-intersection lemmas elsewhere -- I just proved them early on, so they're at the top of the file.) I'll try to understand your solution.</p>
<p>Incidentally -- the <code>topology.lean</code> file is super long since I just kept adding to it as I went. I guess it's probably better to split it into several smaller files at some point. (For instance the sections on interiors and closures, on continuous functions, on bases, on product and subspace topologies, etc).</p>



<a name="251958186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partial%20functions%20and%20gluing/near/251958186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partial.20functions.20and.20gluing.html#251958186">(Sep 04 2021 at 00:21)</a>:</h4>
<p>I wonder if the <code>from_sub</code> and <code>to_sub</code> lemmas can now all be removed to work directly with properties of <code>set.image</code> and <code>set.preimage</code> and <code>coe</code>. I tried doing this a little bit. I was surprised by how annoying those <code>fiber_map</code> lemmas were to prove.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html">using patterns in eq compiler</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="214102506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214102506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214102506">(Oct 21 2020 at 19:30)</a>:</h4>
<p>What would be the right syntax to get something like the following to work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.vector2</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">list.length_cons_tail</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">l.length</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_left_inj</span><span class="o">,</span> <span class="n">list.length</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">vector.my_map_l</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">β</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">_</span>           <span class="n">_</span> <span class="o">:=</span> <span class="n">vector.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">⟨</span><span class="n">x</span> <span class="o">::</span> <span class="n">l</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="o">(</span><span class="n">vector.my_map_l</span> <span class="o">⟨</span><span class="n">l</span><span class="o">,</span> <span class="n">list.length_cons_tail</span> <span class="n">h</span><span class="o">⟩</span> <span class="n">f</span><span class="o">)</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">vector.cons</span>

<span class="c1">-- this does not work</span>
<span class="kd">def</span> <span class="n">vector.my_map_v</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">β</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">_</span>         <span class="n">_</span> <span class="o">:=</span> <span class="n">vector.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">v</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="o">(</span><span class="n">vector.my_map_v</span> <span class="n">v</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>



<a name="214106464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214106464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214106464">(Oct 21 2020 at 19:59)</a>:</h4>
<p>I had to give lean a hint that <code>n</code>is smaller than <code>n+1</code>, but here it is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.vector2</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">list.length_cons_tail</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">l.length</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_left_inj</span><span class="o">,</span> <span class="n">list.length</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">vector.my_map_l</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">β</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">_</span>           <span class="n">_</span> <span class="o">:=</span> <span class="n">vector.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">⟨</span><span class="n">x</span> <span class="o">::</span> <span class="n">l</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="o">(</span><span class="n">vector.my_map_l</span> <span class="o">⟨</span><span class="n">l</span><span class="o">,</span> <span class="n">list.length_cons_tail</span> <span class="n">h</span><span class="o">⟩</span> <span class="n">f</span><span class="o">)</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">vector.cons</span>

<span class="kd">def</span> <span class="n">vector.my_map_v</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">β</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">vector.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">vs</span> <span class="n">f</span> <span class="o">:=</span> <span class="k">have</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="k">from</span> <span class="n">lt_add_one</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">(</span><span class="n">f</span> <span class="n">vs.head</span><span class="o">)</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">vector.my_map_v</span> <span class="n">vs.tail</span> <span class="n">f</span>
</code></pre></div>



<a name="214106492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214106492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214106492">(Oct 21 2020 at 19:59)</a>:</h4>
<p>There's probably a better way.</p>



<a name="214106859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214106859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214106859">(Oct 21 2020 at 20:01)</a>:</h4>
<p>Thanks!</p>
<p>So I can just directly do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">vector.my_map_v</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">vector</span> <span class="n">β</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">vector.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">v</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">v.head</span> <span class="o">::</span><span class="bp">ᵥ</span> <span class="n">vector.my_map_v</span> <span class="n">v.tail</span> <span class="n">f</span>
</code></pre></div>



<a name="214107003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107003">(Oct 21 2020 at 20:02)</a>:</h4>
<p>Oh yeah that works. I don't know why lean was telling at me about well_founded_recursion.</p>



<a name="214107101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107101">(Oct 21 2020 at 20:03)</a>:</h4>
<p>Really, I'm defining the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">vector.enumerate_from</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vector</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">_</span> <span class="n">_</span>           <span class="o">:=</span> <span class="n">vector.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">m</span> <span class="n">v</span> <span class="o">:=</span> <span class="o">(⟨</span><span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">lt_add_iff_pos_right</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">nat.succ_pos'</span><span class="o">⟩,</span> <span class="n">v.head</span><span class="o">)</span> <span class="o">::</span><span class="bp">ᵥ</span>
                           <span class="o">(</span><span class="n">vector.map</span> <span class="o">(</span><span class="n">prod.map</span> <span class="n">fin.succ</span> <span class="n">id</span><span class="o">)</span> <span class="o">(</span><span class="n">vector.enumerate_from</span> <span class="n">m</span> <span class="n">v.tail</span><span class="o">))</span>
</code></pre></div>



<a name="214107251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107251">(Oct 21 2020 at 20:04)</a>:</h4>
<p>And it's not clear for me whether things of this nature should be expressed as variations of <code>vector.map_accumr</code> or <code>map_accuml</code> (which doesn't even exist yet), or do bespoke definitions each time</p>



<a name="214107345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107345">(Oct 21 2020 at 20:05)</a>:</h4>
<p>Unfortunately, while the <code>m + n</code> order makes this definition easier, it makes it that the following is a little nastier than desired:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">vector.enumerate</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">vector</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">vector.map</span> <span class="o">(</span><span class="n">prod.map</span> <span class="o">(</span><span class="n">fin.cast</span> <span class="o">(</span><span class="n">zero_add</span> <span class="n">n</span><span class="o">))</span> <span class="n">id</span><span class="o">)</span> <span class="bp">$</span> <span class="n">vector.enumerate_from</span> <span class="mi">0</span> <span class="n">v</span>
</code></pre></div>



<a name="214107428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107428">(Oct 21 2020 at 20:05)</a>:</h4>
<p>it's either rely on the defeq of <code>n + 0</code> in the <code>enumerate</code> defn, or in the <code>enumerate_from</code></p>



<a name="214107572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107572">(Oct 21 2020 at 20:06)</a>:</h4>
<p>inb4 Mario -- the problem with types like <code>vector α n</code> is that they're dependent types, which should be avoided at all costs in dependent type theory.</p>



<a name="214107574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107574">(Oct 21 2020 at 20:06)</a>:</h4>
<p>Sorry, what is enumerate from supposed to do?</p>



<a name="214107643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107643">(Oct 21 2020 at 20:07)</a>:</h4>
<p>i.e. "use lists if you possibly can"</p>



<a name="214107674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107674">(Oct 21 2020 at 20:07)</a>:</h4>
<p>Yeah, or define an inductive version of <code>vector</code>.</p>



<a name="214107869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107869">(Oct 21 2020 at 20:08)</a>:</h4>
<p>E.g. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">inductive</span> <span class="n">my_vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">my_vector</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">my_vector</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">my_vector</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="214107899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107899">(Oct 21 2020 at 20:09)</a>:</h4>
<p>I feel like something like that already exists somewhere in mathlib, no?</p>



<a name="214107926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107926">(Oct 21 2020 at 20:09)</a>:</h4>
<p>That's exactly <code>fin n</code></p>



<a name="214107996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214107996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214107996">(Oct 21 2020 at 20:10)</a>:</h4>
<p>I thought <code>fin n := {x : \N // x &lt; n}</code>.</p>



<a name="214108037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108037">(Oct 21 2020 at 20:10)</a>:</h4>
<p>not in my mathlib! fin is just a subtype</p>



<a name="214108098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108098">(Oct 21 2020 at 20:10)</a>:</h4>
<p>It's very close to <code>fin2 n</code> though...</p>



<a name="214108099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108099">(Oct 21 2020 at 20:10)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Adding an element at the beginning of an `n`-tuple, to get an `n+1`-tuple -/</span>
<span class="kd">def</span> <span class="n">cons</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">α</span> <span class="o">(</span><span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="bp">Π</span><span class="n">i</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">fin.cases</span> <span class="n">x</span> <span class="n">p</span> <span class="n">j</span>
</code></pre></div>



<a name="214108145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108145">(Oct 21 2020 at 20:10)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- An alternate definition of `fin n` defined as an inductive type</span>
<span class="sd">  instead of a subtype of `nat`. This is useful for its induction</span>
<span class="sd">  principle and different definitional equalities. -/</span>
<span class="kd">inductive</span> <span class="n">fin2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">fz</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">fin2</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">fs</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">fin2</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin2</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="214108201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108201">(Oct 21 2020 at 20:11)</a>:</h4>
<p>Oh right. <code>fin2</code> is the inductive version of <code>fin</code>.</p>



<a name="214108227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108227">(Oct 21 2020 at 20:11)</a>:</h4>
<p>Using lists is fine, until you have to provide a proof to <code>list.nth_le</code>, otherwise <code>list.nth</code> returns an <code>option a</code></p>



<a name="214108252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108252">(Oct 21 2020 at 20:11)</a>:</h4>
<p>So either you carry around the proof all the time, or invent it at the time of <code>list.nth_le</code></p>



<a name="214108368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108368">(Oct 21 2020 at 20:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">vector.nth</span> <span class="bp">$</span> <span class="n">vector.enumerate_from</span> <span class="mi">5</span> <span class="bp">$</span>
  <span class="o">(</span><span class="n">vector.of_fn</span> <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="n">some</span> <span class="mi">1</span><span class="o">,</span> <span class="n">some</span> <span class="mi">2</span><span class="o">,</span> <span class="n">some</span> <span class="mi">6</span><span class="o">,</span> <span class="n">none</span><span class="o">,</span> <span class="n">some</span> <span class="mi">10</span><span class="o">]))</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">(5, (some 1)), (6, (some 2)), (7, (some 6)), (8, none), (9, (some 10))</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="214108392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108392">(Oct 21 2020 at 20:12)</a>:</h4>
<p>using a small <code>has_repr (fin n)</code> that I wrote</p>



<a name="214108924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108924">(Oct 21 2020 at 20:16)</a>:</h4>
<p>I think it would be easier to define this for lists and prove separately that the list version of enumerate_from preserves the length, which would let you extend it to vectors.</p>



<a name="214108966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214108966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214108966">(Oct 21 2020 at 20:17)</a>:</h4>
<p>Of course, this requires knowing how vectors are defined, which might upset some people.</p>



<a name="214109250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214109250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214109250">(Oct 21 2020 at 20:19)</a>:</h4>
<p>Totally. I just spent ~300 lines defining <code>vector.filter</code>, and it was that long because I was trying to work with the underlying list as little as possible.</p>



<a name="214109367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214109367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214109367">(Oct 21 2020 at 20:20)</a>:</h4>
<p>Alternatively, it's possible to define a general induction principle for vectors, with a type similar to <code>list.rec</code> and use that as your recursor.</p>



<a name="214111997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214111997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214111997">(Oct 21 2020 at 20:41)</a>:</h4>
<p>What would be the type of <code>vector.filter</code>?</p>



<a name="214114984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214114984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214114984">(Oct 21 2020 at 21:07)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">vector.filter_count</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">v.to_list.filter</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span>

<span class="kd">def</span> <span class="n">vector.filter</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v.filter_count</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">m</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">v.to_list.filter</span> <span class="n">p</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>
</code></pre></div>



<a name="214115024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214115024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214115024">(Oct 21 2020 at 21:08)</a>:</h4>
<p>With a final culmination in</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">vector.filter_valid</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">v.filter_count</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">p</span> <span class="o">((</span><span class="n">v.filter</span> <span class="n">p</span> <span class="n">hm</span><span class="o">)</span><span class="bp">.</span><span class="n">nth</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">hm'</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">vector.filter_count_nil</span><span class="o">]</span> <span class="n">using</span> <span class="n">hm.symm</span> <span class="o">},</span>
    <span class="n">unify_equations</span> <span class="n">hm'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">fin_zero_elim</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">m</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">fin_zero_elim</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">vector.prop_distribute'</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">p</span> <span class="o">(</span><span class="n">v.filter</span> <span class="n">p</span> <span class="n">hm</span><span class="o">)</span><span class="bp">.</span><span class="n">head</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">refine</span> <span class="n">vector.filter_count_imp_head</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_refl</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span>
          <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">vector.filter_count_filter</span><span class="o">]</span> <span class="o">},</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">true_and</span><span class="o">],</span>
      <span class="n">apply</span> <span class="n">vector.filter_count_imp_tail</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">vector.filter_count_filter</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="214115105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214115105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214115105">(Oct 21 2020 at 21:08)</a>:</h4>
<p>Of course, it'd be much easier to prove the validity by accessing the underlying list, but where is the fun in that?</p>



<a name="214115132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214115132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214115132">(Oct 21 2020 at 21:08)</a>:</h4>
<p>Oh ok, I was just wondering how you were handling the length.</p>



<a name="214115423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214115423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214115423">(Oct 21 2020 at 21:10)</a>:</h4>
<p>Yeah, passing around a proof of it and using it. So in practical use, it looks like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">vector.nth</span> <span class="bp">$</span> <span class="n">vector.reduce_some</span> <span class="o">(</span><span class="n">vector.of_fn</span> <span class="bp">$</span> <span class="n">matrix.ravel</span>
      <span class="o">(</span><span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[(</span><span class="bp">♞</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">chess.colored_pieces</span><span class="o">)),</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♞</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="n">__</span><span class="o">],</span>
         <span class="bp">!</span><span class="o">[</span><span class="bp">♘</span><span class="o">,</span> <span class="n">__</span><span class="o">,</span> <span class="bp">♘</span><span class="o">]]))</span> <span class="n">rfl</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">♞, ♞, ♘, ♘</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="214115470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214115470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214115470">(Oct 21 2020 at 21:11)</a>:</h4>
<p>Where you can fill in the expected "function" of unknown functions, in that example.</p>



<a name="214115491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214115491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214115491">(Oct 21 2020 at 21:11)</a>:</h4>
<p>The proof term for the filtering is the magic <code>rfl</code></p>



<a name="214115524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/using%20patterns%20in%20eq%20compiler/near/214115524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/using.20patterns.20in.20eq.20compiler.html#214115524">(Oct 21 2020 at 21:11)</a>:</h4>
<p>and <code>__</code> is just <code>option.none</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
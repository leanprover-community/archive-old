---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Naming.20Conventions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html">Naming Conventions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="248244418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248244418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248244418">(Aug 03 2021 at 16:21)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">is_sym</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">A</span><span class="bp">ᵀ</span> <span class="bp">=</span> <span class="n">A</span>

<span class="kd">lemma</span> <span class="n">is_sym_apply</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A.is_sym</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span>
<span class="n">A</span><span class="bp">ᵀ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">matrix.is_sym</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">is_sym_ext</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">A</span><span class="bp">ᵀ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="n">A.is_sym</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">i</span> <span class="n">j</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">is_sym_iff</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">A.is_sym</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">A</span><span class="bp">ᵀ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">is_sym_apply</span><span class="o">,</span> <span class="n">is_sym_ext</span><span class="o">⟩</span>
</code></pre></div>
<p>Are the three lemma names I gave consistent with the name conventions?</p>



<a name="248244971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248244971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248244971">(Aug 03 2021 at 16:26)</a>:</h4>
<p>I wouldn't do <code>protected def</code>. I would call the first lemma <code>is_sym.apply</code>.</p>



<a name="248245031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248245031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248245031">(Aug 03 2021 at 16:27)</a>:</h4>
<p>or perhaps</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_sym_ext</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A.is_sym</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span>
<span class="n">A</span><span class="bp">ᵀ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">matrix.is_sym</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">is_sym_of</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">A</span><span class="bp">ᵀ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="n">A.is_sym</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">i</span> <span class="n">j</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">is_sym_iff</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">A.is_sym</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">A</span><span class="bp">ᵀ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">is_sym_ext</span><span class="o">,</span> <span class="n">is_sym_of</span><span class="o">⟩</span>
</code></pre></div>



<a name="248245188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248245188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248245188">(Aug 03 2021 at 16:28)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> I did that because I think <code>matrix.is_sym</code> is parallel with some other <code>.is_sym</code>s existing in mathlib. Some bridges can be then built.</p>



<a name="248245466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248245466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248245466">(Aug 03 2021 at 16:31)</a>:</h4>
<p>I only found <code>sym_sesq_form</code> and <code>sym_bilin_form</code> with <code>is_sym</code>. Neither is protected afaik. The nice part of not protected is that <code>open matrix</code> will let you just say <code>is_sym</code>.</p>



<a name="248245937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248245937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248245937">(Aug 03 2021 at 16:35)</a>:</h4>
<p>I am not sure whether there is any advantage of using the dot notation in this case.</p>



<a name="248246148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248246148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248246148">(Aug 03 2021 at 16:36)</a>:</h4>
<p>Dot notation lets you write <code>h.apply i j</code> to mean <code>Aᵀ i j = A i j</code> when you have <code>(h : A.is_sym) (i j : I)</code></p>



<a name="248246401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248246401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248246401">(Aug 03 2021 at 16:38)</a>:</h4>
<p>oh, that's nice.</p>



<a name="248246623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248246623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248246623">(Aug 03 2021 at 16:40)</a>:</h4>
<p>Which version of the lemma names is better do you think? <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> <span class="user-mention" data-user-id="310045">@Eric Wieser</span>  when changing both to <code>is_sym.</code></p>



<a name="248246888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248246888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248246888">(Aug 03 2021 at 16:43)</a>:</h4>
<p>I could call the last one as <code>is_sym.ext_iff</code>. Where would you use it?</p>



<a name="248246928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248246928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248246928">(Aug 03 2021 at 16:43)</a>:</h4>
<p>You can prove it just by <code>rw [is_sym, matrix.ext_iff]</code></p>



<a name="248247169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248247169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248247169">(Aug 03 2021 at 16:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Naming.20Conventions/near/248246888">said</a>:</p>
<blockquote>
<p>I could call the last one as <code>is_sym.ext_iff</code>. Where would you use it?</p>
</blockquote>
<p>I think that is useful in many further theorems.</p>



<a name="248247358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248247358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248247358">(Aug 03 2021 at 16:47)</a>:</h4>
<p>Sure, but since you know that <code>A^T = A</code> you could just rewrite that, you don't need to require it to be fully applied.</p>



<a name="248247597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248247597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248247597">(Aug 03 2021 at 16:49)</a>:</h4>
<p>Yes. The three lemmas are very simple APIs anyway. I was just a little bit concerned about which names are better.</p>



<a name="248248041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248248041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248248041">(Aug 03 2021 at 16:52)</a>:</h4>
<p>Modified according to your suggestion!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_sym</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">A</span><span class="bp">ᵀ</span> <span class="bp">=</span> <span class="n">A</span>

<span class="kd">lemma</span> <span class="n">is_sym.ext_iff</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">A.is_sym</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">A</span><span class="bp">ᵀ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">is_sym</span><span class="o">,</span> <span class="n">matrix.ext_iff</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">is_sym.apply</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A.is_sym</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span>
<span class="n">A</span><span class="bp">ᵀ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">is_sym.ext_iff.1</span> <span class="n">h</span> <span class="n">i</span> <span class="n">j</span>

<span class="kd">lemma</span> <span class="n">is_sym.ext</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">I</span> <span class="n">I</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">A</span><span class="bp">ᵀ</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="n">A.is_sym</span> <span class="o">:=</span> <span class="n">is_sym.ext_iff.2</span>
</code></pre></div>



<a name="248248554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248248554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248248554">(Aug 03 2021 at 16:56)</a>:</h4>
<p>It will be useful to prove </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">cir</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">v</span> <span class="o">(</span><span class="n">i</span> <span class="bp">-</span> <span class="n">j</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">cir_is_sym_ext_iff</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">cir</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">is_sym</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">v</span> <span class="o">(</span><span class="n">j</span> <span class="bp">-</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span> <span class="o">(</span><span class="n">i</span> <span class="bp">-</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">is_sym.ext_iff</span><span class="o">,</span> <span class="n">cir</span><span class="o">]</span>
</code></pre></div>
<p>for example.</p>



<a name="248248679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248248679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248248679">(Aug 03 2021 at 16:57)</a>:</h4>
<p>Why would you want to prove that and not <code>(cir v).is_sym ↔ ∀ i, v i = v (-i)</code>?</p>



<a name="248248804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248248804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248248804">(Aug 03 2021 at 16:58)</a>:</h4>
<p>I'm not really sure any of these lemmas are worth having</p>



<a name="248248860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248248860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248248860">(Aug 03 2021 at 16:59)</a>:</h4>
<p>You can make them, and then when you use them in a more complex lemma, we can see if there are good golfing strategies that retain expressability/comprehensability</p>



<a name="248248891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248248891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248248891">(Aug 03 2021 at 16:59)</a>:</h4>
<p>The only lemma I'd want is <code>is_sym.eq (h : A.is_sym) : Aᵀ = A := h</code> for dot notation.</p>



<a name="248249184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248249184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248249184">(Aug 03 2021 at 17:01)</a>:</h4>
<p>I was not careful enough, it should be <code>(cir v).is_sym ↔ ∀ i, v (-i) = v i </code>.</p>



<a name="248249301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248249301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248249301">(Aug 03 2021 at 17:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Naming.20Conventions/near/248248891">said</a>:</p>
<blockquote>
<p>The only lemma I'd want is <code>is_sym.eq (h : A.is_sym) : Aᵀ = A := h</code> for dot notation.</p>
</blockquote>
<p>Why is this useful? Why don't we just use <code>unfold</code> or <code>simp</code> or etc?</p>



<a name="248249354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248249354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248249354">(Aug 03 2021 at 17:02)</a>:</h4>
<p>Because then you can do <code>rw [h.eq]</code></p>



<a name="248249364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248249364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248249364">(Aug 03 2021 at 17:03)</a>:</h4>
<p>see <a href="https://leanprover-community.github.io/mathlib_docs/find/commute.eq">docs#commute.eq</a> which is the same idea</p>



<a name="248249563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Naming%20Conventions/near/248249563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Zhang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Naming.20Conventions.html#248249563">(Aug 03 2021 at 17:04)</a>:</h4>
<p>OK. I see the point.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html">Sending `perm $ option α` to `perm α`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="221446194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221446194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221446194">(Jan 03 2021 at 11:13)</a>:</h4>
<p>I'm struggling a little with this definition, as I don'thave much experience with the API for <code>option</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module</span>
<span class="kn">import</span> <span class="n">data.equiv.fin</span>
<span class="kn">import</span> <span class="n">control.equiv_functor</span>
<span class="kn">import</span> <span class="n">group_theory.perm.basic</span>

<span class="kn">open</span> <span class="n">equiv</span>

<span class="kn">section</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">perm</span> <span class="bp">$</span> <span class="n">option</span> <span class="n">α</span> <span class="o">)</span>

<span class="kd">def</span> <span class="n">un_option_aux</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x'</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">),</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">_</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">some</span> <span class="n">y</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">none</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">option.get</span> <span class="bp">$</span> <span class="k">show</span> <span class="o">(</span><span class="n">σ</span> <span class="n">none</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span><span class="o">,</span> <span class="k">from</span>
  <span class="gr">sorry</span> <span class="c1">-- hand-wave: we know that none does not map from none, and σ is injective</span>
<span class="kd">end</span>

<span class="sd">/-- take a permutation `σ : perm (option α)`, and produce a permutation `σ'` of `α` where</span>
<span class="sd">`some (σ' x) = if σ (some x) is none then σ none else σ (some x)` or `some (σ' x) = σ none`  -/</span>
<span class="kd">def</span> <span class="n">un_option</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">un_option_aux</span> <span class="n">σ</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">un_option_aux</span> <span class="n">σ</span><span class="bp">⁻¹</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="gr">sorry</span><span class="o">,</span>  <span class="c1">-- awful _match expressions</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">end</span>
</code></pre></div>



<a name="221446388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221446388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221446388">(Jan 03 2021 at 11:19)</a>:</h4>
<p>How do you know that <code>\si</code> fixes <code>none</code>??</p>



<a name="221446450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221446450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221446450">(Jan 03 2021 at 11:20)</a>:</h4>
<p>Either it does fix none, in which case the mapping is obvious, or it doesn't fix none, in which case <code>σ (some x).is_none</code> implies <code>(σ none).is_some</code> - that's what I mean by the "or" in my docstring</p>



<a name="221446692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221446692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221446692">(Jan 03 2021 at 11:26)</a>:</h4>
<p>Perhaps a clearer statement avoiding <code>match</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">un_option_aux'</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">is_some</span>
  <span class="k">then</span> <span class="n">option.get</span> <span class="n">h</span>
  <span class="k">else</span> <span class="n">option.get</span> <span class="bp">$</span> <span class="k">show</span> <span class="o">(</span><span class="n">σ</span> <span class="n">none</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span><span class="o">,</span> <span class="k">from</span>
  <span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">option.is_some_iff_exists</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">option.not_is_some_iff_eq_none</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="221447046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447046">(Jan 03 2021 at 11:36)</a>:</h4>
<p>I have this so far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">option.pbind_with</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">none</span>     <span class="n">g</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">g</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">un_option_aux</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">pbind_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">σ</span> <span class="n">none</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span>
</code></pre></div>



<a name="221447056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447056">(Jan 03 2021 at 11:36)</a>:</h4>
<p>The hypotheses aren't needed, I just had this <code>pbind_with</code> lying around</p>



<a name="221447072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447072">(Jan 03 2021 at 11:36)</a>:</h4>
<p>That looks a lot tidier thatn what I have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">un_option_aux'</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">is_some</span>
  <span class="k">then</span> <span class="n">option.get</span> <span class="n">h</span>
  <span class="k">else</span> <span class="n">option.get</span> <span class="bp">$</span> <span class="k">show</span> <span class="o">(</span><span class="n">σ</span> <span class="n">none</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span><span class="o">,</span> <span class="k">from</span>
  <span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">option.not_is_some_iff_eq_none</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">option.ne_none_iff_is_some</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">hn</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">σ.injective</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="221447224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447224">(Jan 03 2021 at 11:41)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">option.pbind_with</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">none</span>     <span class="n">g</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">g</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">option.pbind_with_eq_some_of_const_some</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">option.pbind_with</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">y</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span>

<span class="kd">def</span> <span class="n">un_option_aux</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">pbind_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">σ</span> <span class="n">none</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">un_option_aux_eq_some</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">un_option_aux</span> <span class="n">σ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">un_option_aux</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221447234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447234">(Jan 03 2021 at 11:41)</a>:</h4>
<p>That's not going to be constructive though</p>



<a name="221447277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447277">(Jan 03 2021 at 11:42)</a>:</h4>
<p>Oh, maybe it is since you can pass that to <code>option.get</code></p>



<a name="221447285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447285">(Jan 03 2021 at 11:43)</a>:</h4>
<p>exactly</p>



<a name="221447294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447294">(Jan 03 2021 at 11:43)</a>:</h4>
<p>I'm just giving you a lemma that proves that you always get something <code>some</code> out of <code>un_option_aux</code></p>



<a name="221447337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447337">(Jan 03 2021 at 11:44)</a>:</h4>
<p>My definition above seems to work, but proving <code>left_inv</code> is awful</p>



<a name="221447482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447482">(Jan 03 2021 at 11:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">option.pbind_with</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">none</span>     <span class="n">g</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">g</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">option.pbind_with_eq_some_of_const_some</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">option.pbind_with</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">y</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span>

<span class="kd">def</span> <span class="n">un_option_aux</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">pbind_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">σ</span> <span class="n">none</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">un_option_aux_eq_some</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">un_option_aux</span> <span class="n">σ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span> <span class="n">z</span><span class="bp">;</span>
  <span class="n">cases</span> <span class="n">hs'</span> <span class="o">:</span> <span class="n">σ</span> <span class="n">none</span> <span class="k">with</span> <span class="n">w</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">hs'</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">hs</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">un_option_aux</span><span class="o">,</span> <span class="n">hs'</span><span class="o">]</span> <span class="n">using</span> <span class="n">or.inr</span> <span class="n">hs</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">un_option_aux</span><span class="o">,</span> <span class="n">hs'</span><span class="o">]</span> <span class="n">using</span> <span class="n">hs</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">un_option_aux</span><span class="o">,</span> <span class="n">hs'</span><span class="o">]</span> <span class="n">using</span> <span class="n">or.inl</span> <span class="n">hs</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221447936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221447936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221447936">(Jan 03 2021 at 12:03)</a>:</h4>
<p>Alright, I have a proof of the equiv now too:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module</span>
<span class="kn">import</span> <span class="n">data.equiv.fin</span>
<span class="kn">import</span> <span class="n">control.equiv_functor</span>
<span class="kn">import</span> <span class="n">group_theory.perm.basic</span>

<span class="kn">open</span> <span class="n">equiv</span>

<span class="kn">section</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">perm</span> <span class="bp">$</span> <span class="n">option</span> <span class="n">α</span> <span class="o">)</span>

<span class="kd">def</span> <span class="n">un_option_aux</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">is_some</span>
  <span class="k">then</span> <span class="n">option.get</span> <span class="n">h</span>
  <span class="k">else</span> <span class="n">option.get</span> <span class="bp">$</span> <span class="k">show</span> <span class="o">(</span><span class="n">σ</span> <span class="n">none</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span><span class="o">,</span> <span class="k">from</span>
  <span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">option.not_is_some_iff_eq_none</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">option.ne_none_iff_is_some</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">hn</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">σ.injective</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">un_option_aux_inv</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">un_option_aux</span> <span class="n">σ</span><span class="bp">⁻¹</span> <span class="o">(</span><span class="n">un_option_aux</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">un_option_aux</span><span class="o">],</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">is_some</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">not_forall</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">nx</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nx</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">subst</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">option.not_is_some_iff_eq_none</span><span class="o">,</span> <span class="bp">←</span><span class="n">perm.eq_inv_iff_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">h</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">option.not_is_some_iff_eq_none</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">↥</span><span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">is_some</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">option.ne_none_iff_is_some</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">hn</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hx</span> <span class="o">(</span><span class="n">option.some_injective</span> <span class="n">_</span> <span class="o">(</span><span class="n">σ.injective</span> <span class="n">h</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">end</span>
</code></pre></div>
<p>Now just a case of golfing it (and deciding whether a case-matching approach makes more sense than <code>if</code></p>



<a name="221448431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221448431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221448431">(Jan 03 2021 at 12:19)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">equiv</span>

<span class="kn">section</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">perm</span> <span class="bp">$</span> <span class="n">option</span> <span class="n">α</span> <span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">option.pbind_with</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">none</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">none</span>     <span class="n">g</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">g</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">option.pbind_with_eq_some_of_const_some</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">option.pbind_with</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">y</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span>

<span class="kd">def</span> <span class="n">un_option_aux</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">pbind_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">σ</span> <span class="n">none</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">un_option_aux_eq_some</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">un_option_aux</span> <span class="n">σ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">σ</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span> <span class="n">z</span><span class="bp">;</span>
  <span class="n">cases</span> <span class="n">hs'</span> <span class="o">:</span> <span class="n">σ</span> <span class="n">none</span> <span class="k">with</span> <span class="n">w</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">hs'</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">hs</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">un_option_aux</span><span class="o">,</span> <span class="n">hs'</span><span class="o">]</span> <span class="n">using</span> <span class="n">or.inr</span> <span class="n">hs</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">un_option_aux</span><span class="o">,</span> <span class="n">hs'</span><span class="o">]</span> <span class="n">using</span> <span class="n">hs</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="o">[</span><span class="n">un_option_aux</span><span class="o">,</span> <span class="n">hs'</span><span class="o">]</span> <span class="n">using</span> <span class="n">or.inl</span> <span class="n">hs</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">un_option_aux_is_some</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">un_option_aux</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">is_some</span> <span class="o">:=</span>
<span class="n">option.is_some_iff_exists.mpr</span> <span class="o">(</span><span class="n">un_option_aux_eq_some</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">un_option'</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">option.get</span> <span class="o">(</span><span class="n">un_option_aux_is_some</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">un_option'_iff</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">un_option'</span> <span class="n">σ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">un_option_aux</span> <span class="n">σ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">un_option'</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">un_option'</span><span class="o">,</span> <span class="bp">←</span><span class="n">option.some_inj</span><span class="o">,</span> <span class="n">option.some_get</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">un_option</span> <span class="o">:</span> <span class="n">perm</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">un_option'</span> <span class="n">σ</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">un_option'</span> <span class="n">σ.symm</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span> <span class="n">hz</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">un_option_aux_eq_some</span> <span class="n">σ</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[(</span><span class="n">un_option'_iff</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hz</span><span class="o">,</span> <span class="n">un_option'_iff</span><span class="o">,</span> <span class="n">un_option_aux</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">un_option_aux</span><span class="o">]</span> <span class="n">at</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hz</span> <span class="k">with</span> <span class="n">hz</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hz</span><span class="o">,</span> <span class="n">hz'</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">hz</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">hz</span><span class="o">,</span> <span class="bp">←</span><span class="n">hz'</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span> <span class="n">hz</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">un_option_aux_eq_some</span> <span class="n">σ.symm</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[(</span><span class="n">un_option'_iff</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hz</span><span class="o">,</span> <span class="n">un_option'_iff</span><span class="o">,</span> <span class="n">un_option_aux</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">un_option_aux</span><span class="o">]</span> <span class="n">at</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hz</span> <span class="k">with</span> <span class="n">hz</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">hz</span><span class="o">,</span> <span class="n">hz'</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">hz</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span><span class="n">hz</span><span class="o">,</span> <span class="bp">←</span><span class="n">hz'</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">}</span>
</code></pre></div>



<a name="221448485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221448485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221448485">(Jan 03 2021 at 12:20)</a>:</h4>
<p>some non-terminal simps, but they can prolly get golfed easily</p>



<a name="221448488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221448488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221448488">(Jan 03 2021 at 12:20)</a>:</h4>
<p>My strategy here is to get away as soon as possible from juggling <code>is_some</code> predicates</p>



<a name="221448860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221448860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221448860">(Jan 03 2021 at 12:32)</a>:</h4>
<p>Yeah, the pile of different ways to express <code>is_some</code> makes this very painful</p>



<a name="221448864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221448864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221448864">(Jan 03 2021 at 12:32)</a>:</h4>
<p>Is there any precedent for the <code>pbind_with</code> name?</p>



<a name="221448940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221448940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221448940">(Jan 03 2021 at 12:34)</a>:</h4>
<p>I have a <code>pbind</code> defined in <a href="https://github.com/leanprover-community/mathlib/issues/5442">#5442</a>, I didn't PR the more general <code>pbind_with</code></p>



<a name="221448969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221448969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221448969">(Jan 03 2021 at 12:35)</a>:</h4>
<p>There's a general issue of whether all functors/monads should have auto-generated <code>pmap</code> for their <code>map</code> and <code>pbind</code> for their <code>bind</code>. That's why I've held off with the <code>pbind_with</code>. But your case isn't the first time I've come across having to deal with "meaningful" <code>none</code>s, I've had the same.</p>



<a name="221449505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221449505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221449505">(Jan 03 2021 at 12:49)</a>:</h4>
<p>Edited my version above, was able to get rid of most of the is_some mess</p>



<a name="221454326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221454326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221454326">(Jan 03 2021 at 14:55)</a>:</h4>
<p>Cleaned up in <a href="https://github.com/leanprover-community/mathlib/issues/5593">#5593</a>. I'll leave that WIP until I get the correspondance to <code>fin n.succ</code> in there</p>



<a name="221476280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221476280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221476280">(Jan 03 2021 at 23:11)</a>:</h4>
<p>This is a notoriously tricky proof. I'm surprised we don't have it in mathlib yet (I expected we would have the injectivity of <code>(λ x, x + 1 : cardinal → cardinal)</code>, which would use/give <code>remove_none</code>)</p>



<a name="221476629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221476629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221476629">(Jan 03 2021 at 23:18)</a>:</h4>
<p>I take it then that you also couldn't find this in mathlib? Is <code>equiv.remove_none</code> a reasonable name in your opinion?</p>



<a name="221476747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221476747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221476747">(Jan 03 2021 at 23:21)</a>:</h4>
<p>I guess <code>elim</code> / <code>skip</code> / <code>ignore</code> / <code>tie</code> / <code>coalesce</code> might all be alternatives for <code>remove</code> in the name</p>



<a name="221477219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221477219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221477219">(Jan 03 2021 at 23:33)</a>:</h4>
<p>I'm quite sure it's not in mathlib, indeed. <br>
I don't think there is a "good" name, so I think this one is fine. Other possibilities are <code>equiv.cancel_none</code> or <code>equiv.option_inj[ective]</code> or something.</p>
<p>How hard would it be to go from your formulation to <code>α ≃ β → { x : α // x ≠ x₀ } ≃ { y : β // y ≠ y₀ }</code> (assuming something like <code>decidable_eq</code> or <code>decidable_pred (= x₀)</code> if you want to do it constructively).<br>
I don't know if you will also want that version at some point (it might be easier to go from the version I suggest to the version you have for option, using something like <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.option_is_some_equiv">docs#equiv.option_is_some_equiv</a>).</p>



<a name="221477280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221477280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221477280">(Jan 03 2021 at 23:34)</a>:</h4>
<p>If we make a file <code>equiv/option</code>, should we move the appropriate results from <code>equiv/basic</code> into that file?</p>



<a name="221492506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221492506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221492506">(Jan 04 2021 at 06:17)</a>:</h4>
<p>We can, do you want to do this in this PR or separate?</p>



<a name="221492554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Sending%20%60perm%20%24%20option%20%CE%B1%60%20to%20%60perm%20%CE%B1%60/near/221492554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Sending.20.60perm.20.24.20option.20.CE.B1.60.20to.20.60perm.20.CE.B1.60.html#221492554">(Jan 04 2021 at 06:18)</a>:</h4>
<p>Relatedly, should the simp-normal form for <code>equiv.refl α : perm α</code> be <code>equiv.refl α</code> or <code>1</code>?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html">Working on Frobenius elements</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="291021688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291021688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291021688">(Jul 27 2022 at 11:40)</a>:</h4>
<p>Hi, I am a PhD candidate at Radboud and currently planning to formalise Frobenius elements. Is there anyone else working on this already? Thank you.</p>



<a name="291021985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291021985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291021985">(Jul 27 2022 at 11:44)</a>:</h4>
<p>Frobenius elements of Galois groups, you mean?</p>



<a name="291022001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291022001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291022001">(Jul 27 2022 at 11:44)</a>:</h4>
<p>For finite or infinite extensions?</p>



<a name="291022014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291022014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291022014">(Jul 27 2022 at 11:44)</a>:</h4>
<p>Also: welcome!</p>



<a name="291022179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291022179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291022179">(Jul 27 2022 at 11:46)</a>:</h4>
<p>Thank you for the welcome.</p>
<p>Yes, for finite extensions.</p>



<a name="291022230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291022230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291022230">(Jul 27 2022 at 11:47)</a>:</h4>
<p>I guess we would need to be able to talk about ramification as well, which we currently cannot do!</p>



<a name="291024698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291024698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291024698">(Jul 27 2022 at 12:12)</a>:</h4>
<p>Not for Frobenius elements -- this would be precisely avoiding the ramified case! But of course in general we want to one day be able to talk about decomposition and inertia groups, which we currently cannot do.</p>



<a name="291025025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291025025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291025025">(Jul 27 2022 at 12:15)</a>:</h4>
<p>Well, to be able to talk about the unramified case, we need to be able to talk about the ramified case as well ;)<br>
Anyway, what I really meant is that we need inertia/decomposition groups.</p>



<a name="291025186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291025186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291025186">(Jul 27 2022 at 12:17)</a>:</h4>
<p><span class="user-mention" data-user-id="454183">@Michail Karatarakis</span> I learnt about decomposition and inertia groups from Marcus' book "Number fields".</p>



<a name="291025547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291025547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291025547">(Jul 27 2022 at 12:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> and <span class="user-mention" data-user-id="243562">@Adam Topaz</span> Great, thank you.</p>



<a name="291154624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291154624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291154624">(Jul 28 2022 at 08:32)</a>:</h4>
<p>Welcome <span class="user-mention" data-user-id="454183">@Michail Karatarakis</span> ! Concerning Inertia and Ramification, consider that we have something in <a href="https://leanprover-community.github.io/mathlib_docs/find/ideal.ramification_idx">docs#ideal.ramification_idx</a>   but it is still a bit incomplete. Having a look there might help, though.</p>



<a name="291170295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291170295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291170295">(Jul 28 2022 at 11:41)</a>:</h4>
<p><span class="user-mention" data-user-id="300245">@Filippo A. E. Nuccio</span>  It definitely helps - thank you.</p>



<a name="291231081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291231081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291231081">(Jul 28 2022 at 18:12)</a>:</h4>
<p><span class="user-mention" data-user-id="454183">@Michail Karatarakis</span> although the applications to FLT are all in the number field case, for decomposition and inertia groups one should work in more generality, although what I'm not sure about is what generality one can get away with. The maximally general (and possibly too general) situation is this: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a commutative ring with field of fractions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> is a field extension of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> is the integral closure of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> is an ideal of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>. The <em>decomposition group</em> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> with respect to the data <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R,K,L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span></span></span></span> is the subgroup of <code>G := L \equiv\_a[K] L</code> (the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>-algebra isomorphisms from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>) which is the stabiliser of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> acts on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> and the ideals of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>). The group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">D_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> acts on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> and hence on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">S/P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>, and the <em>inertia subgroup</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">I_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">D_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">D_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> which fix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">S/P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> pointwise. In this generality the definition is probably useless, but everything seems to work.</p>
<p>Actually a variant would be the following: if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> is a valuation on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">D_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the subgroup of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> which fixes the valuation (i.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>g</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v(gx)=v(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">gx</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>) and if furthermore <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> is nonarchimedean (are all valuations nonarchimedean in mathlib??) then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">I_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the subgroup of elements <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> with the property that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">v(x)\leq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>g</mi><mi>x</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">v(x-gx)&lt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">gx</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>. I guess you could even formalise both and prove that they're "the same" in situations of interest (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> the discrete valuation coming from a maximal ideal of a Dedekind domain).</p>
<p>In practice number theorists only care about special cases of this definition, but it seems to me that the definitions can be made in huge generality.</p>



<a name="291259045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291259045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291259045">(Jul 28 2022 at 22:11)</a>:</h4>
<p>The most comprehensive treatment I know of regarding decomposition theory for (Krull) valuations is in Zariski-Samuel's book on commutative algebra.</p>



<a name="291259151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291259151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291259151">(Jul 28 2022 at 22:12)</a>:</h4>
<p>Decomposition theory certainly works (and is very important) for arbitrary valuations, not just discrete ones.</p>



<a name="291261765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291261765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291261765">(Jul 28 2022 at 22:39)</a>:</h4>
<p>Arguably we should even make sure that inertia/decomposition groups are defined in large enough generality that would allow us to talk about inertia/decomposition in etale fundamental groups</p>



<a name="291267002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291267002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291267002">(Jul 28 2022 at 23:39)</a>:</h4>
<p>Do you have to do it for rings first and then extend to schemes? If so then Michail doesn't have to worry about schemes (his aim here will be to be able to talk about Frobenius elements in Galois extensions of number fields)</p>



<a name="291348954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291348954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291348954">(Jul 29 2022 at 16:31)</a>:</h4>
<p>I think that defining ramification and inertia for arbitrary valuations would be the best option also for bare-hands algebraic number theory, because I think it will simplify the local-to-global (and viceversa) process. Of course, only rank-1 will be needed, but the language will be the most appropriate, no?</p>



<a name="291717390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291717390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul Lezeau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291717390">(Aug 02 2022 at 14:31)</a>:</h4>
<p><span class="user-mention" data-user-id="454183">@Michail Karatarakis</span> A while back I'd started working on the definition of the decomposition group, here's some of the code I wrote if you haven't written the definition yet <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="bp">Γ₀</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>
  <span class="o">[</span><span class="n">linear_ordered_comm_group_with_zero</span> <span class="bp">Γ₀</span><span class="o">]</span> <span class="o">{</span><span class="n">w</span> <span class="o">:</span> <span class="n">valuation</span> <span class="n">L</span> <span class="bp">Γ₀</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">alg_equiv.mul_eq_trans</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b.trans</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">alg_equiv.inv_eq_symm</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="n">a.symm</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">decomposition_group</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span> <span class="bp">|</span> <span class="n">w</span> <span class="bp">∘</span> <span class="n">σ</span> <span class="bp">=</span> <span class="n">w</span><span class="o">},</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_equiv.mul_eq_trans</span><span class="o">,</span>
    <span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">alg_equiv.coe_trans</span><span class="o">],</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">function.comp.assoc</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ext</span> <span class="n">x</span> <span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_equiv.one_apply</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">],</span>
  <span class="n">inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">z</span><span class="o">,</span> <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span> <span class="n">conv_lhs</span> <span class="o">{</span><span class="n">rw</span> <span class="bp">←</span> <span class="n">hx</span><span class="o">},</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_equiv.inv_eq_symm</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">alg_equiv.apply_symm_apply</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="291720559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291720559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291720559">(Aug 02 2022 at 14:55)</a>:</h4>
<p><span class="user-mention" data-user-id="376152">@Paul Lezeau</span>  Great! Thanks a lot for sharing <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="291754950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/291754950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#291754950">(Aug 02 2022 at 19:10)</a>:</h4>
<p>Note that it's probably better to take the stabilizer of the <em>equivalence class</em> of the valuation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> as opposed to the function underlying <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>. We have a fairly good theory of <a href="https://leanprover-community.github.io/mathlib_docs/find/valuation_subring">docs#valuation_subring</a> that could be used.</p>



<a name="292423299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/292423299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#292423299">(Aug 08 2022 at 16:12)</a>:</h4>
<p>Hi, I've been looking at how to define the equivalence class of w. What's the general way of implementing equivalence classes/relations? We have that two valuations are equivalent iff they have the same valuation ring ( lemma <code>is_equiv_iff_valuation_subring</code>). Do I have to define the set of all equivalence classes as a setoid with such an equivalence relation on it, and then define the equivalence class <code>[[w]]</code> as an element of this set ? Is there a similar implementation, or an example in the library I can look at?</p>



<a name="292425699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/292425699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#292425699">(Aug 08 2022 at 16:31)</a>:</h4>
<p>Why not just use the valuation subring directly?</p>



<a name="292425899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/292425899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#292425899">(Aug 08 2022 at 16:32)</a>:</h4>
<p>There is an issue with equivalence of valuations coming from universes, because a valuation involves not just a ring, but also a totally ordered abelian group, which a priori might have a different universe level. So one has to be somewhat careful in defining the equivalence relation on valuations and ensure that the universe parameters of the ring and the value group are the same.</p>



<a name="292426417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/292426417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#292426417">(Aug 08 2022 at 16:37)</a>:</h4>
<p>If you want to get a valuation out of a valuation subring, we do have <a href="https://leanprover-community.github.io/mathlib_docs/find/valuation_subring.valuation">docs#valuation_subring.valuation</a></p>



<a name="292428332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/292428332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#292428332">(Aug 08 2022 at 16:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/292425699">said</a>:</p>
<blockquote>
<p>Why not just use the valuation subring directly?</p>
</blockquote>
<p>Could you please clarify this further?  So, if suppose we have the set of equivalence classes of valuations of a ring, then for every valuation <code>w</code> in this set, we consider the valuation subring $A_w$ associated to <code>w</code>? Thank you</p>



<a name="292428783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/292428783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#292428783">(Aug 08 2022 at 16:55)</a>:</h4>
<p>Oh, all I'm saying is that the collection of valuations up to equivalence is "the same" (whatever that means) as the collection of valuation subrings of the given field. So instead of working with an equivalence class of valuations you can just work with a valuation subring</p>



<a name="292428944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/292428944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#292428944">(Aug 08 2022 at 16:56)</a>:</h4>
<p>Then if you want to talk about, say, the decomposition group of a valuation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>, you could just define that as the decomposition group of the valuation ring associated to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>.</p>



<a name="293157537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293157537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293157537">(Aug 12 2022 at 17:23)</a>:</h4>
<p>Hi,  I've changed the previous definition for the decomposition group by taking the valuation out of a valuation subring.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="bp">Γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">][</span><span class="n">A</span><span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">]</span>
<span class="o">[</span><span class="n">linear_ordered_comm_group_with_zero</span> <span class="bp">Γ</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">alg_equiv.mul_eq_trans</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b.trans</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">alg_equiv.inv_eq_symm</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="n">a.symm</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">decomp_group</span><span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span> <span class="bp">|</span> <span class="n">A.valuation</span> <span class="bp">∘</span> <span class="n">σ</span> <span class="bp">=</span> <span class="n">A.valuation</span> <span class="o">},</span>
<span class="n">mul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_equiv.mul_eq_trans</span><span class="o">,</span> <span class="n">alg_equiv.coe_trans</span><span class="o">],</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">function.comp.assoc</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">]},</span>
<span class="n">one_mem'</span><span class="o">:=</span> <span class="kd">by</span> <span class="n">ext</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
<span class="n">inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">conv_lhs</span> <span class="o">{</span><span class="n">rw</span> <span class="bp">←</span> <span class="n">hx</span><span class="o">},</span> <span class="n">simp</span> <span class="o">},}</span>
</code></pre></div>
<p>Is this what you meant by any chance?</p>



<a name="293164456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293164456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293164456">(Aug 12 2022 at 18:00)</a>:</h4>
<p>No, not quite. What I meant was to define an action of the Galojs group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi><mi>l</mi><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">∣</mi><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Gal(L|K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>  on the type of valuation subrings of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>, and define the decomposition group as a stabilizer of this action. Presumably we can already talk about stabilizers with what's currently in mathlib.</p>



<a name="293164776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293164776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293164776">(Aug 12 2022 at 18:02)</a>:</h4>
<p>This looks good to me! You don't need Gamma, it seems to play no role (you do need an L though, and some imports; this thread would be easier to follow if someone posts some code with full imports e.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">field_theory.abel_ruffini</span>
<span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">][</span><span class="n">A</span><span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">alg_equiv.mul_eq_trans</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b.trans</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">alg_equiv.inv_eq_symm</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="n">a.symm</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">decomp_group</span><span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span> <span class="bp">|</span> <span class="n">A.valuation</span> <span class="bp">∘</span> <span class="n">σ</span> <span class="bp">=</span> <span class="n">A.valuation</span> <span class="o">},</span>
<span class="n">mul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">alg_equiv.mul_eq_trans</span><span class="o">,</span> <span class="n">alg_equiv.coe_trans</span><span class="o">],</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">function.comp.assoc</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">]},</span>
<span class="n">one_mem'</span><span class="o">:=</span> <span class="kd">by</span> <span class="n">ext</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
<span class="n">inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">rw</span> <span class="n">set.mem_set_of_eq</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">conv_lhs</span> <span class="o">{</span><span class="n">rw</span> <span class="bp">←</span> <span class="n">hx</span><span class="o">},</span> <span class="n">simp</span> <span class="o">},}</span>
</code></pre></div>
<p>seems to work). </p>
<p>It seems to me that this decomposition group contains a whole host of subgroups. Given any element i of the valuation group which is &lt;= 1, you can look at the subgroup of this decomposition group consisting of the g such that v(gx-x)&lt;i for all x in the valuation ring, or maybe v&lt;=i. Look up definitions of higher ramification groups (with the "lower numbering"), probably there is no reason not to define all of them at this point!</p>



<a name="293169301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293169301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293169301">(Aug 12 2022 at 18:28)</a>:</h4>
<p>OK, so for the definition of the decomposition group as the stabiliser of the group action on the set of valuation subrings, could you point to me any references or similar constructions in the library?</p>



<a name="293171541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293171541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293171541">(Aug 12 2022 at 18:42)</a>:</h4>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action.stabilizer">docs#mul_action.stabilizer</a> but you'll need an action of <code>L ≃ₐ[K] L</code> on <code>valuation_subring L</code>, which you might have to make manually. I guess more generally the way to do it would be this: if L -&gt; M is a map of fields then you can pull back a valuation subring of M and get a valuation subring of L (I don't know if we have this). The pullback of the pullback is the pullback and the pullback via the identity map is the identity, and from these facts you can deduce that the pullback along an isomorphism is a bijection. I don't know if we have this stuff but it shouldn't be too hard.</p>



<a name="293266293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293266293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293266293">(Aug 13 2022 at 11:54)</a>:</h4>
<p>Could we use <a href="https://leanprover-community.github.io/mathlib_docs/category_theory/limits/shapes/comm_sq.html#category_theory.is_pullback">docs#category_theory.limits.shapes.comm_sq</a> for the pullback in this case?</p>



<a name="293270433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293270433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293270433">(Aug 13 2022 at 12:29)</a>:</h4>
<p>I think you''re confused about Kevin's use of the word "pullback". He just means to take the preimage, which would go under the name "comap" in mathlib, i.e. something like this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mem_or_inv_mem'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="293695562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293695562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293695562">(Aug 16 2022 at 11:15)</a>:</h4>
<p>Hi, so the definition above asks to prove that  <code>⊢ e k ∈ A ∨ e k⁻¹ ∈ A</code>. However, shouldn't it be <code>⊢ e k ∈ A ∨ (e k)⁻¹ ∈ A</code> from the definition of the valution subring? I am not clear about whether this a matter of notation or I am missing something. This is an example of what it's been going on : </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">valuation_subring.comap</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">mem_or_inv_mem'</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">rintro</span> <span class="n">k</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="n">k</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">e</span> <span class="n">k</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">valuation_subring.mem_or_inv_mem</span> <span class="n">A</span> <span class="o">(</span><span class="n">e</span> <span class="n">k</span><span class="o">),</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h</span> <span class="n">hinv</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="n">right</span><span class="o">,</span>
<span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="293701158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293701158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293701158">(Aug 16 2022 at 11:58)</a>:</h4>
<p><code>exact hinv,</code> works for me for that sorry. What's your question?</p>



<a name="293701500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293701500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293701500">(Aug 16 2022 at 12:00)</a>:</h4>
<p>That's interesting - it doesn't seem to work for me: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">⇑</span><span class="n">e</span> <span class="n">k</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">∈</span> <span class="n">A</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">⇑</span><span class="n">e</span> <span class="n">k</span><span class="bp">⁻¹</span> <span class="bp">∈</span> <span class="n">A</span>
</code></pre></div>



<a name="293701569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293701569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293701569">(Aug 16 2022 at 12:01)</a>:</h4>
<p>The non-terminal <code>simp</code> is doing a different thing on your box to mine.</p>



<a name="293701647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293701647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293701647">(Aug 16 2022 at 12:01)</a>:</h4>
<p>Nonterminal <code>simp</code>s are a bad idea. You ran <code>simp</code> but it didn't close the goal. Thus what happened is a function of what simp lemmas are on the system at a given time.</p>



<a name="293701798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293701798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293701798">(Aug 16 2022 at 12:02)</a>:</h4>
<p>OK, so how do I fix this?</p>



<a name="293701805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293701805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293701805">(Aug 16 2022 at 12:02)</a>:</h4>
<p>For the version of mathlib I was using, <code>simp</code> found <code>map_inv₀</code>. But you should remove the non-terminal <code>simp</code> anyway. Replace it with <code>squeeze_simp</code> and then the corresponding rewrite.</p>



<a name="293701889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293701889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293701889">(Aug 16 2022 at 12:03)</a>:</h4>
<p>and then post your question again and I'll be much more likely to be in the same position as you.</p>



<a name="293702077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293702077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293702077">(Aug 16 2022 at 12:04)</a>:</h4>
<p>On <code>master</code> <code>exact hinv</code> works for the sorry.</p>



<a name="293702135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293702135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293702135">(Aug 16 2022 at 12:04)</a>:</h4>
<p>Where are you working? If on a branch of mathlib you could try merging master. If on a separate project you could try bumping mathlib.</p>



<a name="293702304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293702304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293702304">(Aug 16 2022 at 12:05)</a>:</h4>
<p>So, now I am getting the same error as before whilst rewriting to : </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">valuation_subring.comap</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">mem_or_inv_mem'</span> <span class="o">:=</span>

<span class="kd">begin</span>
<span class="n">rintro</span> <span class="n">k</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subring.mem_carrier</span><span class="o">,</span> <span class="n">subring.mem_comap</span><span class="o">,</span> <span class="n">valuation_subring.mem_to_subring</span><span class="o">],</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="n">k</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">e</span> <span class="n">k</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">valuation_subring.mem_or_inv_mem</span> <span class="n">A</span> <span class="o">(</span><span class="n">e</span> <span class="n">k</span><span class="o">),</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h</span> <span class="n">hinv</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="n">right</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hinv</span><span class="o">,</span>
<span class="kd">end</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="293702734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293702734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293702734">(Aug 16 2022 at 12:08)</a>:</h4>
<p>I have been having some path related issues  with the imports. The only project that seemed to work at that time was the tutorials project :) I 'll try reinstalling everything.</p>



<a name="293703065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293703065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293703065">(Aug 16 2022 at 12:10)</a>:</h4>
<p>So now your code has no non-terminal <code>simp</code>s and it rightly doesn't work, because <code>(⇑e k)⁻¹</code> and <code>⇑e k⁻¹</code> are not definitionally equal.</p>



<a name="293703094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293703094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293703094">(Aug 16 2022 at 12:10)</a>:</h4>
<p>So what is left of your question now?</p>



<a name="293703137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293703137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293703137">(Aug 16 2022 at 12:11)</a>:</h4>
<p>One is <code>inv (e k)</code>, the other is <code>e (inv k)</code>.</p>



<a name="293703258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293703258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293703258">(Aug 16 2022 at 12:11)</a>:</h4>
<p>Alright, so now the definition works with <code>map_inv₀</code> ?</p>



<a name="293703407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293703407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293703407">(Aug 16 2022 at 12:12)</a>:</h4>
<p>Yeah, that's the last piece of the puzzle.</p>



<a name="293703953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293703953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293703953">(Aug 16 2022 at 12:17)</a>:</h4>
<p>I don't know why my <code>simp</code> found it and not yours.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">squeeze_simp</span><span class="o">,</span>
<span class="c1">-- Try this: simp only [subring.mem_carrier, subring.mem_comap, valuation_subring.mem_to_subring, map_inv₀]</span>
</code></pre></div>



<a name="293704599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293704599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293704599">(Aug 16 2022 at 12:21)</a>:</h4>
<p>because it just got changed: <a href="https://github.com/leanprover-community/mathlib/pull/15985">#15985</a></p>



<a name="293704639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293704639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293704639">(Aug 16 2022 at 12:21)</a>:</h4>
<p>You probably want to merge master.</p>



<a name="293704709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293704709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293704709">(Aug 16 2022 at 12:22)</a>:</h4>
<p>or bump mathlib, depending on where this code is</p>



<a name="293704800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293704800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293704800">(Aug 16 2022 at 12:23)</a>:</h4>
<p>Yes, thanks. I created a new project and it's fixed now.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">mem_or_inv_mem'</span> <span class="o">:=</span>

<span class="kd">begin</span>
<span class="n">rintro</span> <span class="n">k</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subring.mem_carrier</span><span class="o">,</span> <span class="n">subring.mem_comap</span><span class="o">,</span> <span class="n">valuation_subring.mem_to_subring</span><span class="o">,</span> <span class="n">map_inv₀</span><span class="o">],</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="n">k</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">e</span> <span class="n">k</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">valuation_subring.mem_or_inv_mem</span> <span class="n">A</span> <span class="o">(</span><span class="n">e</span> <span class="n">k</span><span class="o">),</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h</span> <span class="n">hinv</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="n">right</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hinv</span><span class="o">,</span>
<span class="kd">end</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="293704898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293704898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293704898">(Aug 16 2022 at 12:24)</a>:</h4>
<p>Do not recreate projects <span aria-label="scream" class="emoji emoji-1f631" role="img" title="scream">:scream:</span></p>



<a name="293704959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293704959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293704959">(Aug 16 2022 at 12:24)</a>:</h4>
<p>Do <code>leanproject up</code></p>



<a name="293707974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293707974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293707974">(Aug 16 2022 at 12:45)</a>:</h4>
<p>Regarding the action of the Galois group on <code>valuation_subring ring K</code>, do I have to define it as a new class?</p>



<a name="293722490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293722490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293722490">(Aug 16 2022 at 13:53)</a>:</h4>
<p>We should first golf a little bit...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mem_or_inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">valuation_subring.mem_or_inv_mem</span><span class="o">],</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="293722820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293722820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293722820">(Aug 16 2022 at 13:55)</a>:</h4>
<p>The action of the Galois group would be an <em>instance</em> of the class <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action">docs#mul_action</a></p>



<a name="293732896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293732896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293732896">(Aug 16 2022 at 14:49)</a>:</h4>
<p>BTW: Note that this is a right action</p>



<a name="293759169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293759169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293759169">(Aug 16 2022 at 16:49)</a>:</h4>
<p>Right, so how do I define this action as a right action involving the comap?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.defs</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">}</span> <span class="o">{</span><span class="n">M</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>
<span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">pullback_action</span><span class="o">:</span>  <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span>  <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">one_smul</span><span class="o">:=</span> <span class="bp">λ</span><span class="n">σ</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,</span>
 <span class="n">mul_smul</span><span class="o">:=</span> <span class="bp">λ</span><span class="n">σ₁</span><span class="o">,</span> <span class="bp">λ</span><span class="n">σ₂</span><span class="o">,</span> <span class="bp">λ</span><span class="n">m</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span> <span class="o">}</span>
</code></pre></div>



<a name="293762570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293762570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293762570">(Aug 16 2022 at 17:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293171541">said</a>:</p>
<blockquote>
<p>The pullback of the pullback is the pullback and the pullback via the identity map is the identity, and from these facts you can deduce that the pullback along an isomorphism is a bijection.</p>
</blockquote>
<p>I am not clear about how to customise this instance to involve these facts above. Would a right action suffice?</p>



<a name="293794108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293794108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293794108">(Aug 16 2022 at 20:23)</a>:</h4>
<p><a href="/user_uploads/3121/Kr48h6KreTLRvIRiRNHptYj4/type.png">type.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/Kr48h6KreTLRvIRiRNHptYj4/type.png" title="type.png"><img src="/user_uploads/3121/Kr48h6KreTLRvIRiRNHptYj4/type.png"></a></div><p>After the line <code>refine {to_fun := _, map_one' := _, map_mul' := _},</code>, one of your goals is a Type not a Prop. This is bad. You closed the goal with <code>tauto</code>, and what this did was generated a completely random endomorphism because tauto is not expecting to run on types. Judging by the other goals it looks like <code>tauto</code> chose the identity function, so right now what you seem to have is an action of the pulled back valuation (considered as a monoid), on the K-automorphisms of L, considered as a set (or more precisely a type), and the definition of the action is that everything acts trivially.</p>



<a name="293794282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293794282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293794282">(Aug 16 2022 at 20:24)</a>:</h4>
<p>You want to give an action of the automorphisms on the valuation subrings.</p>



<a name="293794709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293794709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293794709">(Aug 16 2022 at 20:27)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="n">e</span><span class="o">,</span> <span class="c1">-- you cannot use tactic mode for this, it's data</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="gr">sorry</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="gr">sorry</span> <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="293794945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293794945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293794945">(Aug 16 2022 at 20:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="454183">Michail Karatarakis</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293762570">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293171541">said</a>:</p>
<blockquote>
<p>The pullback of the pullback is the pullback and the pullback via the identity map is the identity, and from these facts you can deduce that the pullback along an isomorphism is a bijection.</p>
</blockquote>
<p>I am not clear about how to customise this instance to involve these facts above or if, they are implied. Would such a right action suffice?</p>
</blockquote>
<p>The facts I flagged are precisely what you have to prove to create the <code>mul_action</code>.</p>



<a name="293795864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293795864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293795864">(Aug 16 2022 at 20:34)</a>:</h4>
<p>You have defined <code>valuation_subring.comap</code>. Every definition comes with a cost. You might well find it tricky to fill in those two <code>sorry</code>s. Give them a go! But here's an interesting experiment (which you can try after): you can see that <code>valuation_subring.comap</code> is one proof and then everything else is <code>subring.comap</code>. You can jump to the definition of <code>subring.comap</code> in VS Code and observe that just after that definition is made, three theorems are proved:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_comap</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">subring</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">s.comap</span> <span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">mem_comap</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">subring</span> <span class="n">S</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">S</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s.comap</span> <span class="n">f</span> <span class="bp">↔</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">lemma</span> <span class="n">comap_comap</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">subring</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→+*</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.comap</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">comap</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">s.comap</span> <span class="o">(</span><span class="n">g.comp</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>
<p>Two of those lemmas are tagged <code>@[simp]</code> and if you don't prove the analogous lemmas for <code>valuation_subring.comap</code> then the simplifier won't know even the most basic stuff about <code>valuation_subring.comap</code>. You want to train the simplifier to prove simple equalities (like your two sorries) and iffs for you. So see if you can prove the analogues of those statements, and then you might find that the two sorries needed to make the <code>mul_action</code> are much easier.</p>



<a name="293796246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293796246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293796246">(Aug 16 2022 at 20:37)</a>:</h4>
<p>Here's the lemmas proved just after <code>subgroup.comap</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp, to_additive]</span>
<span class="kd">lemma</span> <span class="n">coe_comap</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">K.comap</span> <span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">K</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp, to_additive]</span>
<span class="kd">lemma</span> <span class="n">mem_comap</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">K.comap</span> <span class="n">f</span> <span class="bp">↔</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">K</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">comap_mono</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">K</span> <span class="n">K'</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">≤</span> <span class="n">K'</span> <span class="bp">→</span> <span class="n">comap</span> <span class="n">f</span> <span class="n">K</span> <span class="bp">≤</span> <span class="n">comap</span> <span class="n">f</span> <span class="n">K'</span> <span class="o">:=</span>
<span class="n">preimage_mono</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">comap_comap</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→*</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">K.comap</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">comap</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">K.comap</span> <span class="o">(</span><span class="n">g.comp</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>
<p>and here's what's proved after <code>submonoid.comap</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp, to_additive]</span>
<span class="kd">lemma</span> <span class="n">coe_comap</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">S.comap</span> <span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp, to_additive]</span>
<span class="kd">lemma</span> <span class="n">mem_comap</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S.comap</span> <span class="n">f</span> <span class="bp">↔</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
<span class="kn">omit</span> <span class="n">mc</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">comap_comap</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→*</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">S.comap</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">comap</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">S.comap</span> <span class="o">(</span><span class="n">g.comp</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">@[simp, to_additive]</span>
<span class="kd">lemma</span> <span class="n">comap_id</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">S.comap</span> <span class="o">(</span><span class="n">monoid_hom.id</span> <span class="n">P</span><span class="o">)</span> <span class="bp">=</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">ext</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span>
</code></pre></div>
<p>So those are some good suggestions for what kind of API you should make for <code>valuation_subring.comap</code>.</p>



<a name="293796504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293796504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293796504">(Aug 16 2022 at 20:39)</a>:</h4>
<p>Wooah, the bare type comap (called <code>preimage</code>, it's a special case like an irregular verb) has all this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">preimage</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">⁻¹'</span> <span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="n">preimage</span>

<span class="kn">section</span> <span class="n">preimage</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">preimage_empty</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="bp">∅</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">mem_preimage</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">lemma</span> <span class="n">preimage_congr</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">⁻¹'</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">congr'</span> <span class="k">with</span> <span class="n">x</span><span class="o">,</span> <span class="n">apply_assumption</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">preimage_mono</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">h</span> <span class="n">hx</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">preimage_univ</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">univ</span> <span class="bp">=</span> <span class="n">univ</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">subset_preimage_univ</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">univ</span> <span class="o">:=</span> <span class="n">subset_univ</span> <span class="n">_</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">preimage_inter</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span> <span class="bp">∩</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">preimage_union</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span> <span class="bp">∪</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">preimage_compl</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span><span class="bp">ᶜ</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">)</span><span class="bp">ᶜ</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">preimage_diff</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="o">(</span><span class="n">s</span> <span class="bp">\</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span> <span class="bp">\</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="o">[</span><span class="n">loads</span> <span class="n">more</span> <span class="n">omitted</span><span class="o">]</span>
</code></pre></div>



<a name="293797679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293797679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293797679">(Aug 16 2022 at 20:46)</a>:</h4>
<p>You could check that <code>valuation_subring.comap</code> plays well with the lattice structure on valuation subrings. Looking through the mathlib file where <code>valuation_subring</code> is defined, it appears to have <code>instance : semilattice_sup (valuation_subring K) := ...</code> which means that the valuation subrings of a field have some kind of lattice structure (infs or sups, like unions and intersections, maybe finite or infinite) and you could see if your construction preserved these things. That's what <code>preimage_inter</code> is doing above, for example (but using nonstandard <code>∩</code> instead of standard <code>⊓</code>, called <code>inf</code>)</p>



<a name="293798141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293798141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293798141">(Aug 16 2022 at 20:49)</a>:</h4>
<p>Finally, it's really important that you move <code>[algebra K L]</code> below the definition of <code>valuation_subring.comap</code>. I've just noticed that <code>comap</code> is picking it up, and we definitely don't need it at this point.</p>



<a name="293799095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293799095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293799095">(Aug 16 2022 at 20:55)</a>:</h4>
<p>Great, thank you very much.</p>



<a name="293799110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293799110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293799110">(Aug 16 2022 at 20:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293732896">said</a>:</p>
<blockquote>
<p>BTW: Note that this is a right action</p>
</blockquote>
<p>Oh yeah! <span class="user-mention" data-user-id="243562">@Adam Topaz</span> how do we do right actions in Lean? I think the code I've posted for the mul_action is not right.</p>



<a name="293799683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293799683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293799683">(Aug 16 2022 at 20:59)</a>:</h4>
<p><code>smul := λ e A, A.comap e.symm,</code> would work but is this the idiomatic way?</p>



<a name="293800132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293800132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293800132">(Aug 16 2022 at 21:02)</a>:</h4>
<p>One option is to use <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_opposite">docs#mul_opposite</a> but <span class="user-mention" data-user-id="310045">@Eric Wieser</span> will probably tell us the best way to do this</p>



<a name="293801951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293801951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293801951">(Aug 16 2022 at 21:14)</a>:</h4>
<p>With my way, to get <code>simp</code> to do the job you need</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">alg_equiv.one_symm</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">alg_equiv.mul_symm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">b.symm</span> <span class="bp">*</span> <span class="n">a.symm</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>Using </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">unop</span> <span class="n">e</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
</code></pre></div>
<p>I only have to make the basic API for <code>valuation_subring.comap</code> and I can get <code>ext, simp</code> to do everything.</p>



<a name="293802109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293802109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293802109">(Aug 16 2022 at 21:15)</a>:</h4>
<p><span class="user-mention" data-user-id="454183">@Michail Karatarakis</span> I hadn't noticed it was a right action. Probably the <code>ᵐᵒᵖ</code> approach is best.</p>



<a name="293803054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293803054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293803054">(Aug 16 2022 at 21:22)</a>:</h4>
<p>OK so, this is the definition we need for the right action?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">unop</span> <span class="n">e</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="gr">sorry</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="gr">sorry</span> <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="293803274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293803274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293803274">(Aug 16 2022 at 21:24)</a>:</h4>
<p>A good stress test for your definition is trying to show <code>smul_comm_class (L ≃ₐ[K] L) (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code>.</p>



<a name="293805596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293805596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293805596">(Aug 16 2022 at 21:43)</a>:</h4>
<p>Mathlib only has right <em>multiplication</em> actions, not actions on the codomain</p>



<a name="293806055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293806055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293806055">(Aug 16 2022 at 21:47)</a>:</h4>
<p>But certainly you can use <code>mul_opposite</code> to define this comap action; you're just at risk of hitting instance diamonds</p>



<a name="293806230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293806230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293806230">(Aug 16 2022 at 21:48)</a>:</h4>
<p><del>Is <a href="https://leanprover-community.github.io/mathlib_docs/find/valuation_subring">docs#valuation_subring</a> of the type I'd expect?</del> (edit: no) If so, then I think there's already an action via <code>map</code>, <a href="https://leanprover-community.github.io/mathlib_docs/find/subring.pointwise_mul_action">docs#subring.pointwise_mul_action</a></p>



<a name="293809597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293809597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293809597">(Aug 16 2022 at 22:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293803274">said</a>:</p>
<blockquote>
<p>A good stress test for your definition is trying to show <code>smul_comm_class (L ≃ₐ[K] L) (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code>.</p>
</blockquote>
<p>I can't make sense of this. What is the left action?</p>



<a name="293809876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293809876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293809876">(Aug 16 2022 at 22:16)</a>:</h4>
<p>The one via map</p>



<a name="293809899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293809899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293809899">(Aug 16 2022 at 22:17)</a>:</h4>
<p>That I link above for subring, but that we don't have yet for <code>valuation_subring</code></p>



<a name="293810671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293810671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293810671">(Aug 16 2022 at 22:24)</a>:</h4>
<p>I don't think there's <code>map</code> for <code>valuation_subring</code>. The image of a valuation subring under a ring homomorphism might not be a valuation subring.</p>



<a name="293810700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293810700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293810700">(Aug 16 2022 at 22:24)</a>:</h4>
<p>Oh -- I see -- for <code>equiv</code>s there is a <code>map</code>!</p>



<a name="293810759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293810759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293810759">(Aug 16 2022 at 22:25)</a>:</h4>
<p>I would guess it generalizes to any group action, not just equivs</p>



<a name="293810907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293810907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293810907">(Aug 16 2022 at 22:26)</a>:</h4>
<p>I'm confused. If you have a right action of a group on a thing, how are you getting a left action of the same group?</p>



<a name="293810926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293810926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293810926">(Aug 16 2022 at 22:26)</a>:</h4>
<p>Just use the right action of the inverse?</p>



<a name="293811037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293811037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293811037">(Aug 16 2022 at 22:28)</a>:</h4>
<p>I don't think these actions commute in general. I'm lost.</p>



<a name="293811104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293811104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293811104">(Aug 16 2022 at 22:28)</a>:</h4>
<p>I can't make any sense of Yael's stress test.</p>



<a name="293811173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293811173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293811173">(Aug 16 2022 at 22:29)</a>:</h4>
<p>I'll PR what I'm thinking of</p>



<a name="293811484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293811484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293811484">(Aug 16 2022 at 22:31)</a>:</h4>
<p>I can't see any <code>map</code> other than <code>A.map e = A.comap e.symm</code> and these actions won't commute if the group isn't abelian.</p>



<a name="293812738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293812738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293812738">(Aug 16 2022 at 22:45)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/16080">#16080</a></p>



<a name="293812786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293812786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293812786">(Aug 16 2022 at 22:45)</a>:</h4>
<p>Oh sorry, your point was that the actions might not commute, not that you can't think of what the left action is (which that PR provides)</p>



<a name="293813542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293813542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293813542">(Aug 16 2022 at 22:53)</a>:</h4>
<p>I also now agree that <span class="user-mention" data-user-id="387244">@Yaël Dillies</span>' stress test doesn't seem to make sense.</p>



<a name="293847590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293847590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293847590">(Aug 17 2022 at 07:25)</a>:</h4>
<p>Shouldn't my stress test boil down to associativity of composition?</p>



<a name="293849389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293849389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293849389">(Aug 17 2022 at 07:42)</a>:</h4>
<p>What are you composing?</p>



<a name="293851458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293851458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293851458">(Aug 17 2022 at 08:00)</a>:</h4>
<p>I guess I was seeing <code>valuation_subring</code> as an <code>alg_equiv</code> <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="293858645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293858645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293858645">(Aug 17 2022 at 08:58)</a>:</h4>
<p>I think the true version of the statement is that "two actions on (valuation) subrings commute if they commute on the elements". Currently we are missing those instances for pointwise actions on subobjects</p>



<a name="293873579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293873579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293873579">(Aug 17 2022 at 10:52)</a>:</h4>
<p>~Shall I just work on the API for the comap for now then, until the definition of the action can be stated or look at the PR first? I am bit confused.</p>



<a name="293878234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293878234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293878234">(Aug 17 2022 at 11:26)</a>:</h4>
<p>I am about to go on holiday for a week so will be limited help during this time, but my honest opinion is that it would be good for you to fill in the sorries for the <code>mop</code> left action but in practice if you use it you'll just get a load of subgroups of the opposite group which will be really annoying, so I would just define the decomposition and inertia subgroups manually.</p>



<a name="293902540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293902540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293902540">(Aug 17 2022 at 14:01)</a>:</h4>
<p>OK, just to conclude - here are the definitions we have so far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mem_or_inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">valuation_subring.mem_or_inv_mem</span><span class="o">],</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">e.unop</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="gr">sorry</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="gr">sorry</span> <span class="kd">end</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">decomposition_group</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">[</span><span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span>
<span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span>  <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Is the definition of the decomposition group above what you meant?</p>



<a name="293904846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293904846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293904846">(Aug 17 2022 at 14:14)</a>:</h4>
<p>Concerning the inertia group, do we define it as we 've discussed before ?:</p>
<p>1) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">R_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the valuation ring  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo>∈</mo><mi>L</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ a ∈ L | v(a) \leq 1 \} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span> ( prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">R_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a subring of  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> ).</p>
<p>2) Define the maximal ideal of  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>v</mi></msub><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo>∈</mo><mi>K</mi><mo>∣</mo><mi>v</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">m_v=\{ a ∈ K \mid v(a) &lt; 1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>  ( prove that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">m_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a subring of  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>).</p>
<p>3) Define the inertia group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">I_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as the quotient <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>v</mi></msub><mi mathvariant="normal">/</mi><msub><mi>m</mi><mi>v</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">R_v/m_v.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></p>
<p>Is this the best way we can define it?</p>



<a name="293907669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293907669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293907669">(Aug 17 2022 at 14:27)</a>:</h4>
<p>A few points</p>
<ol>
<li>As Kevin mentioned, it could get annoying to work with the decomposition group if defined as a stabilizer, because this is a right action, and you use <code>mop</code>, meaning that the stabilizer is a subgroup of the mul-opposite of the Galois group instead of the Galois group itself. It's possible to translate to the Galois group with this approach, but it would be easier to define it as a subgroup of the Galois group directly.</li>
<li>
<p>Your second declaration doesn't make sense. You're trying to define the decomposition group as a stabilizer, not obtain some element of the stabilizer. When you write <code>def decomposition_group (A : valuation_subring L) [mul_action (L ≃ₐ[K] L)ᵐᵒᵖ A] :
mul_action.stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ A  := sorry</code>, that means you're trying to obtain some element (aka "term") of the stabilizer.</p>
</li>
<li>
<p>The inertia group is not <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mi mathvariant="fraktur">m</mi></mrow><annotation encoding="application/x-tex">R/\mathfrak{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathfrak">m</span></span></span></span>. That's the residue field. you need to show that elements of the decomposition group preserve the maximal ideal and define the inertia group as those elements in the decomposition group which act trivially on the residue field.</p>
</li>
</ol>



<a name="293907967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293907967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293907967">(Aug 17 2022 at 14:29)</a>:</h4>
<p>We have a fairly robust API for valuation subrings in mathlib thanks to the work of <span class="user-mention" data-user-id="488744">@Jack McKoen</span> . There is no need to define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">R_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and/or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="fraktur">m</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">\mathfrak{m}_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6253em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathfrak">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Rather, it would be better to use (and extend) the existing API from mathlib.</p>



<a name="293910292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293910292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293910292">(Aug 17 2022 at 14:40)</a>:</h4>
<ol>
<li>
<p>&amp; 2. OK, thank you for the clarification.</p>
</li>
<li>
<p>Oh, yes, you are right. I meant I should define the residue field first and then proceed - defining the inertia group would have been a fourth goal. Thus, do I define it as a subgroup of the decomposition group in this case?</p>
</li>
</ol>



<a name="293910998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293910998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293910998">(Aug 17 2022 at 14:43)</a>:</h4>
<p>Re 2: I would define the inertia group as a subgroup of the Galois group and prove that it's contained in the decomposition group, using the lattice structure on the type of subgroups of a group.</p>



<a name="293911162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293911162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293911162">(Aug 17 2022 at 14:44)</a>:</h4>
<p>Also, mathlib knows that valuation rings are local, so there is no need to define the residue field as you can use the API for local rings.</p>



<a name="293912655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293912655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293912655">(Aug 17 2022 at 14:50)</a>:</h4>
<p>OK, clear.  I forgot to ask - the stabiliser subgroup is not in mathlib? (that's what confused me when I looked at <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action.stabilizer">docs#mul_action.stabilizer</a>).</p>



<a name="293913104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293913104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293913104">(Aug 17 2022 at 14:52)</a>:</h4>
<p>What do you mean? <code>mul_action.stabilizer</code> is precisely the stabiliser subgroup.</p>



<a name="293916305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293916305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293916305">(Aug 17 2022 at 15:08)</a>:</h4>
<p>Yeah, I was trying to understand Adam's point about the difference between obtaining a term of the stabiliser, and, the stabiliser. I thought that definition results in a subgroup and not a term. Of course my definition still doesn't make sense as it's been pointed out.</p>



<a name="293920255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293920255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293920255">(Aug 17 2022 at 15:31)</a>:</h4>
<p>Your mistake is like writing <code>def foo : 37 := sorry</code> instead of <code>def foo : nat := 37</code></p>



<a name="293940798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293940798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293940798">(Aug 17 2022 at 17:18)</a>:</h4>
<p>The problem is that it's a right action so the stabiliser stuff doesn't work because that's set up for left actions</p>



<a name="293944107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/293944107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#293944107">(Aug 17 2022 at 17:36)</a>:</h4>
<p>Right, I 'll try filling up the <code> sorry </code>s of the action regardless for practice. However, is there a set theoretic notation for the definition of the decomposition group that involves this action? Does the right action just play the rule of the composition <code>∘</code> as in the previous attempts ?</p>



<a name="294637754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294637754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294637754">(Aug 22 2022 at 09:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , could this be an alternative definition for the inertia group? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">][</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">A</span><span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">inertia</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">):=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span>  <span class="bp">|</span>  <span class="n">A.valuation</span> <span class="o">(</span><span class="n">σ</span> <span class="n">x</span> <span class="bp">-</span> <span class="n">x</span><span class="o">)</span> <span class="bp">&lt;</span><span class="mi">1</span> <span class="o">},</span>
  <span class="n">mul_mem'</span><span class="o">:=</span><span class="gr">sorry</span><span class="o">,</span>
  <span class="n">one_mem'</span><span class="o">:=</span><span class="gr">sorry</span><span class="o">,</span>
  <span class="n">inv_mem'</span><span class="o">:=</span><span class="gr">sorry</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>



<a name="294640721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294640721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294640721">(Aug 22 2022 at 09:52)</a>:</h4>
<p>That's not the inertia subgroup because that function takes an input x and then returns a subgroup which depends on x. You probably want a "for all x" somewhere instead. I'm still in a field with no access to lean but I guess the forall goes after <code>|</code> in the carrier field</p>



<a name="294644889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294644889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294644889">(Aug 22 2022 at 10:20)</a>:</h4>
<p>I don't think <code>A : valuation_subring L</code> should be in <code>[typeclass brackets]</code>. I guess <code>(regular explicit)</code> is how it's intended to be used.</p>



<a name="294645323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294645323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294645323">(Aug 22 2022 at 10:23)</a>:</h4>
<p><del><code>{A : valuation_subring L}</code> is the correct thing here, actually, because of the<code>(x : A)</code>.</del> That's not the case anymore if you fix the definition as Kevin says.</p>



<a name="294645906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294645906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294645906">(Aug 22 2022 at 10:27)</a>:</h4>
<p>Right, so it should be something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">][</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">inertia</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">):</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">):=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span>  <span class="bp">|</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">A.valuation</span> <span class="o">(</span><span class="n">σ</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="o">},</span>
  <span class="n">mul_mem'</span><span class="o">:=</span><span class="gr">sorry</span><span class="o">,</span>
  <span class="n">one_mem'</span><span class="o">:=</span><span class="gr">sorry</span><span class="o">,</span>
  <span class="n">inv_mem'</span><span class="o">:=</span><span class="gr">sorry</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>



<a name="294657569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294657569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294657569">(Aug 22 2022 at 11:44)</a>:</h4>
<p>1) Could an alternative definition for the inertia group be the following : " the elements of the Galois group (of the decomposition group)​ which fix the residue field pointwise" instead of saying "the elements that act trivially on the residue field" ? In this case, do the pointwise actions from  <a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/valuation/valuation_subring.html#pointwise-actions">docs#valuation_subring</a> need to be modified for this goal?</p>
<p>2) Furthermore, understanding how actions are implemented would help me define the decomposition group too. Right now I am not clear about how to define it as a stabiliser from scratch. For example <code> mul_action.stabiliser </code> ( as it's been pointed out ) only works for left actions. It also seems that the definition is also based on other things that need to be defined from scratch for right actions too. So far, I can't see clearly where I have to start for that and how deep it gets- what we have, is this instance</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">e.unop</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="gr">sorry</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="gr">sorry</span> <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p>If I wish to define the decomposition group as </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">decomposition_group</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span>  <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>how could I involve this instance in the carrier?</p>



<a name="294664541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294664541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294664541">(Aug 22 2022 at 12:27)</a>:</h4>
<p>Just define the stabiliser by hand as the elements of the group which fix something. As for fixing the residue field, sure you could define it like this. Did you define an action of the decomposition group on the residue field? That's an obvious prerequisite for this approach</p>



<a name="294685209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294685209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294685209">(Aug 22 2022 at 14:15)</a>:</h4>
<p>"Just define the stabiliser by hand as the elements of the group which fix something" If I have a generic subgroup such as </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span>  <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span> <span class="o">]</span> <span class="o">[</span> <span class="n">group</span> <span class="n">β</span> <span class="o">]</span>

<span class="kd">def</span> <span class="n">stabilizer</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">α</span>  <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>   <span class="bp">|</span>  <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">b</span> <span class="bp">•</span> <span class="n">a</span>  <span class="bp">=</span> <span class="n">b</span> <span class="o">},</span>
 <span class="n">mul_mem'</span><span class="o">:=</span><span class="gr">sorry</span><span class="o">,</span>
 <span class="n">one_mem'</span><span class="o">:=</span><span class="gr">sorry</span><span class="o">,</span>
 <span class="n">inv_mem'</span><span class="o">:=</span><span class="gr">sorry</span>
  <span class="o">}</span>
</code></pre></div>
<p>How do I to involve the <code> mul_action </code> instance from above  - i. e. how do I equip this subgroup where <code> • </code> is that right action specifically?</p>



<a name="294787679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294787679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294787679">(Aug 23 2022 at 00:31)</a>:</h4>
<p>That example seems to be missing <code>mul_action α β</code></p>



<a name="294787708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294787708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294787708">(Aug 23 2022 at 00:31)</a>:</h4>
<p>But the answer is "choose α and β and lean will find the appropriate instance"</p>



<a name="294787811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294787811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294787811">(Aug 23 2022 at 00:33)</a>:</h4>
<p>You should be able to use <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code></p>



<a name="294787870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/294787870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#294787870">(Aug 23 2022 at 00:34)</a>:</h4>
<p>(also note that the <code>map</code> action is now merged, <a href="https://leanprover-community.github.io/mathlib_docs/find/valuation_subring.pointwise_mul_action">docs#valuation_subring.pointwise_mul_action</a>)</p>



<a name="295295322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295295322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295295322">(Aug 25 2022 at 19:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/294787811">said</a>:</p>
<blockquote>
<p>You should be able to use <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code></p>
</blockquote>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span>  Yes sure, but what it's been pointed out is that this stabilizer is set up for left actions and we need a right action. Thus, it's better if I can define a stabilizer subgroup for an arbitrary <code> mul_action </code>. That's what I am not clear about, hence that example above. Any ideas of how I could implement a stabilizer subgroup for an arbitrary action?</p>



<a name="295295940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295295940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295295940">(Aug 25 2022 at 19:23)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action.stabilizer">docs#mul_action.stabilizer</a> <em>is already</em> defined for an arbitrary <code>mul_action</code> (over a group), so I don't understand your question</p>



<a name="295296540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295296540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295296540">(Aug 25 2022 at 19:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/293940798">said</a>:</p>
<blockquote>
<p>The problem is that it's a right action so the stabiliser stuff doesn't work because that's set up for left actions</p>
</blockquote>
<p>Right, I am referring to what <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  and Adam pointed out.</p>



<a name="295298241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295298241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295298241">(Aug 25 2022 at 19:37)</a>:</h4>
<p>We don't want a subgroup of <code>G^mop</code>, we want a subgroup of G.</p>
<p>Do you know what -- maybe we don't want the decomposition subgroup to be a subgroup? Maybe we just use the left action of mop but define <code>D v</code> to be the subtype rather than the subgroup? What do you think <span class="user-mention" data-user-id="243562">@Adam Topaz</span> ? If <code>v</code> is a valuation not on the top field but on the bottom field, how are we going to define <code>D v</code>? I have always thought of it as a subgroup of the global Galois group but I'm wondering whether the object is sufficiently important to deserve its own <code>decomposition_group v : Type</code> rather than <code>decomposition_subgroup v : subgroup (L K-alg_iso L)</code>. </p>
<p><span class="user-mention" data-user-id="454183">@Michail Karatarakis</span> there is a ton of stuff you could do here. Let's just have a one-on-one meeting at some point. I am on holiday right now unfortunately, but I will be back on Monday evening. I'll contact you offline and give you some concrete problems to think about. Right now, as sometimes happens, there seems to be several possibilities for the formalised definition of a decomposition group.</p>



<a name="295298445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295298445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295298445">(Aug 25 2022 at 19:38)</a>:</h4>
<p>Then you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.unopposite">docs#subgroup.unopposite</a>.</p>



<a name="295298505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295298505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295298505">(Aug 25 2022 at 19:38)</a>:</h4>
<p>Damn, it doesn't exist <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span> but <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite">docs#subgroup.opposite</a> does, so it really should be there!</p>



<a name="295298559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295298559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295298559">(Aug 25 2022 at 19:39)</a>:</h4>
<p>I guess you're meant to use <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite_equiv">docs#subgroup.opposite_equiv</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">decomposition_subgroup</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite_equiv.symm</span> <span class="bp">$</span> <span class="n">stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span>
</code></pre></div>



<a name="295302577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295302577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295302577">(Aug 25 2022 at 20:06)</a>:</h4>
<p>Well, there is no decomposition group if you only have a valuation of the base-field -- you need to choose a prolongation.<br>
It's a theorem that the decomposition groups of two prolongations (which are conjugate) are conjugate in the group-theoretic sense, but that's a theorem. So you could define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">D_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as a conjugacy class when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> is a valuation of the base.</p>



<a name="295303296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295303296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295303296">(Aug 25 2022 at 20:11)</a>:</h4>
<p>I do think it should be defined as a sungroup because the behavior of this subgroup in the lattice of subgroups of the Galois groups reflects the decomposition behavior of the valuation on the base (and if you also include the inertia, you can relate ramification to this lattice structure as well)</p>



<a name="295306818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295306818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295306818">(Aug 25 2022 at 20:36)</a>:</h4>
<p>Oh yes of course I'm a fool, it's only a conjugacy class of subgroups, I don't know what I was thinking.</p>



<a name="295308047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295308047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295308047">(Aug 25 2022 at 20:46)</a>:</h4>
<p>It is confusing because we like to identify "the decomposition group of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>" in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi><msub><mi>l</mi><mi mathvariant="double-struck">Q</mi></msub></mrow><annotation encoding="application/x-tex">Gal_\mathbb{Q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9611em;vertical-align:-0.2667em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3322em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbb mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2667em;"><span></span></span></span></span></span></span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi><msub><mi>l</mi><msub><mi mathvariant="double-struck">Q</mi><mi>p</mi></msub></msub></mrow><annotation encoding="application/x-tex">Gal_{\mathbb{Q}_p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0418em;vertical-align:-0.3473em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3322em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbb mtight">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3473em;"><span></span></span></span></span></span></span></span></span></span> all the time ;)</p>



<a name="295309475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295309475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295309475">(Aug 25 2022 at 20:57)</a>:</h4>
<p>OK so from now on I will try to be coherent. In the example you highlight above the following phenomena occur: We have an extension L of K (Galois, in this case), a valuation v on K, (uncountably) many extensions of this valuation to L, and for any two such extensions w1 and w2, there's a K-isomorphism from L to L sending w1 to w2. Furthermore if we choose an arbitrary w in L extending v on K, then the canonical map from D_w to the K_v-isomorphisms of L_w is an isomorphism. In what generality is all that true?</p>



<a name="295310008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295310008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295310008">(Aug 25 2022 at 21:01)</a>:</h4>
<p>If you replace completion with Henselization, then this is true for arbitrary valuations. For completions, I don't know of the top of my head.</p>



<a name="295310062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295310062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295310062">(Aug 25 2022 at 21:01)</a>:</h4>
<p>Do we have this in mathlib?</p>



<a name="295310110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295310110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295310110">(Aug 25 2022 at 21:02)</a>:</h4>
<p>I don't think so.</p>



<a name="295310398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295310398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295310398">(Aug 25 2022 at 21:04)</a>:</h4>
<p>Would it be worth Michail working on this, if his ultimate goal is to start talking about things like local conditions on deformations of global Galois representations? Is it the sort of thing which one actually needs in practice, or would be helpful to have? Is it _hard_? What's a reference?</p>



<a name="295310474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295310474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295310474">(Aug 25 2022 at 21:04)</a>:</h4>
<p>I hadn't quite realised that things could be done in such generality.</p>



<a name="295310692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295310692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295310692">(Aug 25 2022 at 21:05)</a>:</h4>
<p>Here is the page from the stacks project <a href="https://stacks.math.columbia.edu/tag/0BSK">https://stacks.math.columbia.edu/tag/0BSK</a></p>



<a name="295310788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295310788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295310788">(Aug 25 2022 at 21:06)</a>:</h4>
<p>What sorts of local conditions are you referring to?</p>



<a name="295310881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295310881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295310881">(Aug 25 2022 at 21:07)</a>:</h4>
<p>deformations of representations of global Galois groups which are finite flat at p, or unramified at q, or something like that. FLT stuff. Michail is a student of Freek who's formalising the statements of some of the theorems of Wiles and Taylor-Wiles.</p>



<a name="295311339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295311339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295311339">(Aug 25 2022 at 21:11)</a>:</h4>
<p>I think most things (e.g. unramified) can be phrased (and usually are phrased) entirely in terms of the structure of the decomposition group. Once you get to more analytic conditions, like being de Rham at p, that's when the identification with the Galois group of the completion seems to be required</p>



<a name="295311534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295311534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295311534">(Aug 25 2022 at 21:13)</a>:</h4>
<p>A 2-dimensional representation being locally an extension of one-dimensional representations is perhaps a nice example. No completions needed there I guess.</p>



<a name="295311788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295311788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295311788">(Aug 25 2022 at 21:15)</a>:</h4>
<p>I'm teaching a graduate NT course next term. It would be great if I can show off decomposition theory in mathlib by then ;)</p>



<a name="295313111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295313111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295313111">(Aug 25 2022 at 21:26)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> what do you think of the following fix for the left/right thing: we can pull back valuations along arbitrary field maps, but we can push them forward along equivs. This would give us a left action, right?</p>



<a name="295313353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295313353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295313353">(Aug 25 2022 at 21:28)</a>:</h4>
<p>Hmmmm I think that would be confusing. For example, is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><msub><mi>D</mi><mi>v</mi></msub><msup><mi>σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msub><mi>D</mi><msup><mi>v</mi><mi>σ</mi></msup></msub></mrow><annotation encoding="application/x-tex">\sigma D_v \sigma^{-1} = D_{v^\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9641em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2655em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> or <span class="tex-error">$$D_{v^{\sigma^{-1}}$$</span>? (I never remember and always have to write out the formula when I need to figure this out, but it's written down in books always using the right action, I suppose)</p>



<a name="295313671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295313671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295313671">(Aug 25 2022 at 21:31)</a>:</h4>
<p>I'm a bit surprised that right actions are such a problem, given that we now have things like two-sided ideals.</p>



<a name="295313817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295313817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295313817">(Aug 25 2022 at 21:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295313671">said</a>:</p>
<blockquote>
<p>I'm a bit surprised that right actions are such a problem, given that we now have things like two-sided ideals.</p>
</blockquote>
<p>maybe I just made that up?</p>



<a name="295313875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295313875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295313875">(Aug 25 2022 at 21:33)</a>:</h4>
<p>Do we want the decomposition subgroup to be a subgroup of G or of G^mop?</p>



<a name="295313913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295313913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295313913">(Aug 25 2022 at 21:33)</a>:</h4>
<p>of G!</p>



<a name="295313924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295313924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295313924">(Aug 25 2022 at 21:33)</a>:</h4>
<p>I guess we could pull it back along the isomorphism (do you know the name for the group iso G -&gt; G^mop?) (op(g^{-1}) or whatever)</p>



<a name="295314042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295314042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295314042">(Aug 25 2022 at 21:34)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/mul_equiv.inv'">docs#mul_equiv.inv'</a></p>



<a name="295314122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295314122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295314122">(Aug 25 2022 at 21:35)</a>:</h4>
<p>oh is this the point of division monoids??</p>



<a name="295314280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295314280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295314280">(Aug 25 2022 at 21:36)</a>:</h4>
<p>That was my first encounter with <code>division_monoid</code> <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="295314528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295314528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295314528">(Aug 25 2022 at 21:38)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> that's pretty cool :-)</p>



<a name="295323603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295323603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295323603">(Aug 25 2022 at 23:01)</a>:</h4>
<p>We have subbimodules, implemented via tensor product: <a href="https://github.com/leanprover-community/mathlib/commit/58cef51f7a819e7227224461e392dee423302f2d">https://github.com/leanprover-community/mathlib/commit/58cef51f7a819e7227224461e392dee423302f2d</a><br>
Two-sided ideals would involve mop (<a href="#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/293167433">sketch here</a>)</p>



<a name="295345543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295345543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295345543">(Aug 26 2022 at 02:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295314122">said</a>:</p>
<blockquote>
<p>oh is this the point of division monoids??</p>
</blockquote>
<p>One of them!</p>



<a name="295345650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295345650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295345650">(Aug 26 2022 at 02:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295313924">said</a>:</p>
<blockquote>
<p>I guess we could pull it back along the isomorphism (do you know the name for the group iso G -&gt; G^mop?) (op(g^{-1}) or whatever)</p>
</blockquote>
<p>Did you read <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295298559">my snippet above</a>? This is exactly what it does:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">decomposition_subgroup</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite_equiv.symm</span> <span class="bp">$</span> <span class="n">stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span>
</code></pre></div>



<a name="295345758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295345758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295345758">(Aug 26 2022 at 02:26)</a>:</h4>
<blockquote>
<p>This is exactly what it does:</p>
</blockquote>
<p>I think they differ by ⁻¹</p>



<a name="295348956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295348956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295348956">(Aug 26 2022 at 03:23)</a>:</h4>
<p>Hmm... You're right. Why does that matter?</p>



<a name="295349590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295349590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295349590">(Aug 26 2022 at 03:36)</a>:</h4>
<p>I think what they have in mind originally/mathematics-wise is your version, actually.</p>



<a name="295592902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295592902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295592902">(Aug 27 2022 at 12:48)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> is there a general theory of higher ramification groups in this setting, indexed e.g. by elements of the value group in the range (0,1] or something?</p>



<a name="295592980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295592980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295592980">(Aug 27 2022 at 12:48)</a>:</h4>
<p>Do you understand all that phi and psi conversion to upper numbering in the DVR setting, on a conceptual level?</p>



<a name="295593467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295593467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295593467">(Aug 27 2022 at 12:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295298559">said</a>:</p>
<blockquote>
<p>I guess you're meant to use <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite_equiv">docs#subgroup.opposite_equiv</a>:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">decomposition_subgroup</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite_equiv.symm</span> <span class="bp">$</span> <span class="n">stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>  Could you please explain what your code does, and include the imports?</p>



<a name="295594307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295594307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295594307">(Aug 27 2022 at 13:00)</a>:</h4>
<p>The imports should be the same as yours.</p>



<a name="295594519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295594519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295594519">(Aug 27 2022 at 13:02)</a>:</h4>
<p>So <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L) : subgroup (L ≃ₐ[K] L)ᵐᵒᵖ</code>. But mathematically <code>(L ≃ₐ[K] L)ᵐᵒᵖ</code> is just <code>L ≃ₐ[K] L</code> again, so take the image of <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code> under the mathematically irrelevant map <code>(L ≃ₐ[K] L)ᵐᵒᵖ → L ≃ₐ[K] L</code>.</p>



<a name="295595006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295595006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295595006">(Aug 27 2022 at 13:06)</a>:</h4>
<p>It doesn't seem to compile. What's the issue here? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.opposite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">decomposition_subgroup</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite_equiv.symm</span> <span class="bp">$</span> <span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span>
</code></pre></div>



<a name="295595075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295595075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295595075">(Aug 27 2022 at 13:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/295594519">said</a>:</p>
<blockquote>
<p>So <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L) : subgroup (L ≃ₐ[K] L)ᵐᵒᵖ</code>. But mathematically <code>(L ≃ₐ[K] L)ᵐᵒᵖ</code> is just <code>L ≃ₐ[K] L</code> again, so take the image of <code>stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code> under the mathematically irrelevant map <code>(L ≃ₐ[K] L)ᵐᵒᵖ → L ≃ₐ[K] L</code>.</p>
</blockquote>
<p>OK, thanks.</p>



<a name="295595307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295595307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295595307">(Aug 27 2022 at 13:09)</a>:</h4>
<p>Sorry, I wasn't done explaining!</p>



<a name="295595468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295595468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295595468">(Aug 27 2022 at 13:10)</a>:</h4>
<p>However <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite_equiv">docs#subgroup.opposite_equiv</a> is not what I thought it was, so here's <a href="https://github.com/leanprover-community/mathlib/pull/16271">#16271</a> to define that "mathematically irrelevant map". If you use the code from that PR, then the definition becomes</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">decomposition_subgroup</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite.symm</span> <span class="bp">$</span> <span class="n">stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span>
</code></pre></div>



<a name="295599215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295599215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295599215">(Aug 27 2022 at 13:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> there is some work on this but as far as I know there is no established theory. </p>
<p>The one thing that comes to mind is work of Abrashkin on higher ramification in higher dimensional local fields -- he even constructs analogues of the field of norms!</p>



<a name="295599349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295599349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295599349">(Aug 27 2022 at 13:44)</a>:</h4>
<p>The wild ramification group can always be defined for any valuation (it's the unique p-Sylow subgroup of the inertia group, where p is the residue characteristic)</p>



<a name="295599437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295599437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295599437">(Aug 27 2022 at 13:44)</a>:</h4>
<p>And the theorem that the residue Galois group acts cyclotomically on the tame inertia still holds in general</p>



<a name="295599573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295599573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295599573">(Aug 27 2022 at 13:46)</a>:</h4>
<p>but then wild inertia has some funny filtration on it indexed by the value group (which I just discovered isn't a group! <a href="https://github.com/leanprover-community/mathlib/pull/16272">#16272</a> that confused me for a bit).</p>



<a name="295599643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295599643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295599643">(Aug 27 2022 at 13:46)</a>:</h4>
<p>I think Huber uses the phrase differently to mathlib :-(</p>



<a name="295600787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295600787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295600787">(Aug 27 2022 at 13:58)</a>:</h4>
<p>I think even defining the filtration is subtle. There is no obvious choice. Do you take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mi>x</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\sigma x - x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> to have valuation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\le a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>, or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">&lt; a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>? Maybe you want to say that it acts trivially on the valuation ring modulo some power of the maximal ideal?</p>



<a name="295600990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295600990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295600990">(Aug 27 2022 at 13:59)</a>:</h4>
<p>Each element x of the value group on the right side of 1 (I'm assuming &lt;= 1) gives you two ideals of the valuation ring,  J_{&lt;=x} and J_x, and you can define I_{&lt;=x} and I_{&lt;x} to be the things fixing R / this ideal.</p>



<a name="295601127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295601127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295601127">(Aug 27 2022 at 14:00)</a>:</h4>
<p>Yeah sure but not every ideal is of this form</p>



<a name="295601166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295601166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295601166">(Aug 27 2022 at 14:01)</a>:</h4>
<p>Maybe one should index them by the ideals</p>



<a name="295601170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295601170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295601170">(Aug 27 2022 at 14:01)</a>:</h4>
<p>Oh I see, you're saying that using ideals is even more general.</p>



<a name="295601326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295601326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295601326">(Aug 27 2022 at 14:02)</a>:</h4>
<p>And then there's a map from nat into the ideals sending n to max^n and there's your higher ramification groups.</p>



<a name="295601734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295601734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295601734">(Aug 27 2022 at 14:05)</a>:</h4>
<p>Now what about the upper numbering?</p>



<a name="295602358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295602358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295602358">(Aug 27 2022 at 14:10)</a>:</h4>
<p>For me that's defined for finite extensions only, from the lower numbering, via this combinatorial voodoo, and then this miracle theorem that it's well-behaved under quotients (unlike the lower numbering, which is only well-behaved under subs), and then you can define it for arbitrary Galois extensions. OK completely dumb question: what's the relationship between the upper numbering higher ramification groups (indexed by Q) in the absolute Galois group of a p-adic field e.g. Q_p, and the filtration on inertia which we have, indexed by the ideals of Z_p-bar?</p>



<a name="295603372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/295603372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#295603372">(Aug 27 2022 at 14:19)</a>:</h4>
<p>Kevin, these are the right questions, but I've exhausted what I can do on my phone while also making breakfast. I'll have to come back to this later ;)</p>



<a name="296333024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296333024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296333024">(Aug 31 2022 at 14:12)</a>:</h4>
<p>Hi, I have defined the decomposition subgroup as the pullback along the map <code>( L ≃ₐ[K] L) →* ( L ≃ₐ[K] L)ᵐᵒᵖ</code>(which should be an isomorphism..)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.opposite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mem_or_inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">valuation_subring.mem_or_inv_mem</span><span class="o">],</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">e.unop</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="n">rintro</span> <span class="n">b</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">rintro</span> <span class="n">k</span><span class="o">,</span> <span class="n">exact</span> <span class="n">k</span><span class="o">,</span> <span class="n">rintro</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,}</span>

<span class="kn">open</span> <span class="n">mul_opposite</span>

<span class="kd">def</span> <span class="n">decomposition_group.comap</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="o">(</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→*</span> <span class="o">(</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">):</span>
<span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
 <span class="bp">..</span> <span class="o">((</span><span class="n">mul_action.stabilizer</span>  <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span>  <span class="o">)</span><span class="bp">.</span><span class="n">comap</span> <span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p>Does this work? This function might need to take a valuation on L as input. Any tricks for that?</p>



<a name="296334714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296334714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296334714">(Aug 31 2022 at 14:19)</a>:</h4>
<p>The pullback that you should use is <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite">docs#subgroup.opposite</a> (once <a href="https://github.com/leanprover-community/mathlib/pull/16271">#16271</a> is in).</p>



<a name="296579861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296579861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296579861">(Sep 01 2022 at 12:56)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>  Using  <a href="https://github.com/leanprover-community/mathlib/pull/16271">#16271</a> we get what you wrote before (unless you have something else in mind) :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">decomposition_subgroup</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite.symm</span> <span class="o">(</span> <span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span><span class="o">)</span>
</code></pre></div>
<p>It's using the map <code> (L ≃ₐ[K] L)ᵐᵒᵖ → L ≃ₐ[K] L </code>, whereas I am using  <code>  (L ≃ₐ[K] L)  →*  (L ≃ₐ[K] L)ᵐᵒᵖ  </code></p>
<p>Don't we need to have a valuation on L as input ? I am not clear about what's wrong with these two definitions.</p>



<a name="296580094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296580094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296580094">(Sep 01 2022 at 12:57)</a>:</h4>
<p>Additionally, is there a correct way to promote the decomposition subgroup to a group?</p>



<a name="296589509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296589509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296589509">(Sep 01 2022 at 13:47)</a>:</h4>
<p>The input is <code>A</code>. These definitions look fine to me. You can golf your proof of <code>one_smul</code>: the <code>simp</code> doesn't do anything so you can just remove it (and it is not good style anyway because it's not a terminal <code>simp</code>) and when you see <code>rintro X, exact X</code> you should be thinking "that's the identity map"; indeed instead of <code>split, ...</code> you can just finish the proof with <code>refl</code> because by this point your goal is of the form X &lt;-&gt; Y with X and Y definitionally equal.</p>
<p>The way to promote the subgroup to a group is just to start talking about it as if it were a type; when Lean is expecting a type and you provide it with a term it will look in the typeclass system to see if there are any coercions around which promote the term to a type, and it will find one and apply it; you know it's happened because you'll see one of those funny <code>↥</code> arrows, which in this case will indication an application of the function <code>set_like.has_coe_to_sort</code>.</p>



<a name="296609842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296609842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296609842">(Sep 01 2022 at 15:25)</a>:</h4>
<p>OK, thank you. I golfed the proof above.</p>



<a name="296610084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296610084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296610084">(Sep 01 2022 at 15:26)</a>:</h4>
<p>You mean that this coercion will happen automatically if I treat the decomposition subgroup as a group?</p>



<a name="296619516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296619516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296619516">(Sep 01 2022 at 15:36)</a>:</h4>
<p>OK, then perhaps I could experiment by defining the inertia group ( subgroup for the Galois group, and, as the pointwise stabilizer of the decomposition group acting on the residue field ? ) There is <a href="https://leanprover-community.github.io/mathlib_docs/ring_theory/valuation/valuation_subring.html#valuation_subring.pointwise_mul_action">docs#valuation_subring.pointwise_mul_action</a>. Is this the action that we need?</p>



<a name="296659938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296659938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296659938">(Sep 01 2022 at 17:06)</a>:</h4>
<p>Using this definition,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">decomposition_group</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite.symm</span> <span class="o">(</span> <span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span><span class="o">)</span>
</code></pre></div>
<p>the definition: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">D</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">D</span><span class="o">:</span> <span class="n">decomposition_group</span><span class="o">)</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">D</span> <span class="o">(</span><span class="n">local_ring.residue_field</span> <span class="n">L</span><span class="o">):=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>yields a (deterministic) timeout error  (if I try to remove the <code>sorry</code>)- Could someone explain what's this error about ? </p>
<p>Furthermore, why doesn't this definition </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">D</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">D</span><span class="o">:</span> <span class="n">decomposition_group</span><span class="o">)</span> <span class="o">:</span>
<span class="n">pointwise_mul_action</span> <span class="n">D</span> <span class="o">(</span><span class="n">local_ring.residue_field</span> <span class="n">L</span><span class="o">):=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>work? I am not clear about the syntax here; doesn't <code>pointwise_mul_action</code> behave like <code>mul_action</code>?</p>



<a name="296660713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296660713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296660713">(Sep 01 2022 at 17:10)</a>:</h4>
<p>Can you provide a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> ?</p>



<a name="296661573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296661573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296661573">(Sep 01 2022 at 17:15)</a>:</h4>
<p>Right, </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.opposite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">A</span> <span class="o">:</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mem_or_inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">valuation_subring.mem_or_inv_mem</span><span class="o">],</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">e.unop</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">refl</span><span class="o">},</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,}</span>

<span class="kd">def</span> <span class="n">decomposition_group</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite.symm</span> <span class="o">(</span> <span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span><span class="o">)</span>


<span class="c1">--The following gives the timeout error</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">D</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">D</span><span class="o">:</span> <span class="n">decomposition_group</span><span class="o">)</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">D</span> <span class="o">(</span><span class="n">local_ring.residue_field</span> <span class="n">L</span><span class="o">):=</span> <span class="gr">sorry</span>

<span class="c1">--The following doesn't compile</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">D</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">D</span><span class="o">:</span> <span class="n">decomposition_group</span><span class="o">)</span> <span class="o">:</span>
<span class="n">pointwise_mul_action</span> <span class="n">D</span> <span class="o">(</span><span class="n">local_ring.residue_field</span> <span class="n">L</span><span class="o">):=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="296662897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296662897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296662897">(Sep 01 2022 at 17:23)</a>:</h4>
<p>The line </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">D</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">D</span><span class="o">:</span> <span class="n">decomposition_group</span><span class="o">)</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">D</span> <span class="o">(</span><span class="n">local_ring.residue_field</span> <span class="n">L</span><span class="o">):=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>is not what you want.</p>



<a name="296662945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296662945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296662945">(Sep 01 2022 at 17:23)</a>:</h4>
<p>It seems you're still confused about types vs terms.</p>



<a name="296663155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296663155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296663155">(Sep 01 2022 at 17:24)</a>:</h4>
<p>What this line is saying, in words, is this: Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> be a type, and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> be an element of <code>decomposition_group</code> (which is a function, so that doesn't make sense). Then there is a multiplicative action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> (but which one? there are two D's introduced) on the residue field of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>.</p>



<a name="296663318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296663318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296663318">(Sep 01 2022 at 17:25)</a>:</h4>
<p>Besides those issues, there is also no valuation mentioned whatsoever -- you're taking the residue field of the field <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>, which is a local ring since it has a unique maximal ideal (the trivial ideal). The residue field in this case is isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> itself.</p>



<a name="296663683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296663683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296663683">(Sep 01 2022 at 17:27)</a>:</h4>
<p>There is also an issue that your valuation ring variable is in square brackets. Those brackets are reserved for typeclass parameters whereas <code>valuation_subring L</code> is the type of (bundled) valuation subrings of the field L.</p>



<a name="296664355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296664355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296664355">(Sep 01 2022 at 17:30)</a>:</h4>
<p>I don't know what this <code>pointwise_mul_action</code> is supposed to accomplish, but in any case, here is some code to get you started:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.opposite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mem_or_inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">valuation_subring.mem_or_inv_mem</span><span class="o">],</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">e.unop</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">refl</span><span class="o">},</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,}</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">K</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">valuation_subring.decomposition_group</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite.symm</span> <span class="o">(</span> <span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">K</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">):</span>
  <span class="n">mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">local_ring.residue_field</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="296664455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296664455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296664455">(Sep 01 2022 at 17:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/296662897">said</a>:</p>
<blockquote>
<p>The line </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">D</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">D</span><span class="o">:</span> <span class="n">decomposition_group</span><span class="o">)</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">D</span> <span class="o">(</span><span class="n">local_ring.residue_field</span> <span class="n">L</span><span class="o">):=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>is not what you want.</p>
</blockquote>
<p>Sure, I just haven't encountered that timeout error before and I was wondering what it's about.</p>



<a name="296672489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296672489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296672489">(Sep 01 2022 at 18:11)</a>:</h4>
<p>If Lean is expecting X and you give it Y, then it might put some effort into figuring out how Y's can be interpreted as X's. If you give it junk and Y can't be coerced into X then Lean might spend forever trying to do something impossible.</p>



<a name="296794654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296794654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296794654">(Sep 02 2022 at 11:00)</a>:</h4>
<p>Hi, I have this MWE so far </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.opposite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mem_or_inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">valuation_subring.mem_or_inv_mem</span><span class="o">],</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">e.unop</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span><span class="n">ext1</span><span class="o">,</span> <span class="n">refl</span><span class="o">},</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,}</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">K</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">valuation_subring.decomposition_group</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite.symm</span> <span class="o">(</span> <span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">K</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">):</span>
<span class="n">mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">local_ring.residue_field</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span><span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">k</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">one_smul</span><span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">mul_smul</span><span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,}</span>

<span class="kd">def</span> <span class="n">valuation_subring.inertia_group</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span>
   <span class="c1">-- ..((mul_action.stabilizer (A.decomposition_group K) (local_ring.residue_field A) ) )</span>
  <span class="o">}</span>
</code></pre></div>
<p>The goal is to complete the definition of the inertia group as the stabilizer of the action of the decomposition group on the residue field.</p>
<p>Is this the correct way to define it ? -  I am confused about how to complete this carrier. Removing the comment indicates that the carrier has type <code>set ↥(valuation_subring.decomposition_group K A)</code> but is expected to have type  <code>set (L ≃ₐ[K] L)</code> What could be the right syntax, or, what could I use from the library to complete this coercion?</p>



<a name="296798606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296798606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296798606">(Sep 02 2022 at 11:26)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action.stabilizer">docs#mul_action.stabilizer</a> is the stabilizer of a single point of a group acting on a Type, so you would really want the intersection of all the stabilizers of all points I guess, I don't know if we have this definition as a thing already in mathlib</p>



<a name="296799749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296799749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296799749">(Sep 02 2022 at 11:33)</a>:</h4>
<p>Probably you could use the kernel of <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action.to_perm_hom">docs#mul_action.to_perm_hom</a> for this</p>



<a name="296800331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296800331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296800331">(Sep 02 2022 at 11:37)</a>:</h4>
<p>You defined the action on the residue field to be trivial. That's not the correct action.</p>



<a name="296800798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296800798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296800798">(Sep 02 2022 at 11:40)</a>:</h4>
<p>And the whole point of doing it this way around is that the subgroup you'll get is a subgroup of the decomposition group, not of the full Galois group.</p>



<a name="296801014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296801014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296801014">(Sep 02 2022 at 11:41)</a>:</h4>
<p>I think thats the type error above, even Lean wants to define a subgroup of the decomposition group! I couldn't work out how to get a subgroup of a subgroup into a subgroup the original group though, do we have that somewhere?</p>



<a name="296801085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296801085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296801085">(Sep 02 2022 at 11:41)</a>:</h4>
<p>Just push it forward along the homomorphism with <code>map</code>.</p>



<a name="296801326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296801326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296801326">(Sep 02 2022 at 11:43)</a>:</h4>
<p>Yeah idk why I was just expecting a name for that, but that makes total sense.</p>



<a name="296801499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296801499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296801499">(Sep 02 2022 at 11:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/296801014">said</a>:</p>
<blockquote>
<p>I think thats the type error above, even Lean wants to define a subgroup of the decomposition group! I couldn't work out how to get a subgroup of a subgroup into a subgroup the original group though, do we have that somewhere?</p>
</blockquote>
<p>Yeah, that's what I got stuck on. The plan was to define the inertia as a subgroup of the Galois group and then to prove perhaps a theorem that says that it's a subgroup of the decomposition group. I thought there would be a coercion somewhere in that definition.</p>



<a name="296802306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296802306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296802306">(Sep 02 2022 at 11:49)</a>:</h4>
<p>So what could I do to fix it?</p>



<a name="296803002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296803002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296803002">(Sep 02 2022 at 11:53)</a>:</h4>
<p>What confused me was that, that theorem was being "asked for" in the definition.</p>



<a name="296827760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296827760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296827760">(Sep 02 2022 at 14:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/296800331">said</a>:</p>
<blockquote>
<p>You defined the action on the residue field to be trivial. That's not the correct action.</p>
</blockquote>
<p>Right, what action do we need for this? All I know is that the decomposition group acts pointwise on the residue field.</p>



<a name="296862869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296862869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296862869">(Sep 02 2022 at 17:17)</a>:</h4>
<p>You need to define a <code>sub_mul_action (A.decomposition_group K) L</code> with <code>carrier := A</code> (I'm not sure if the <code>mul_action</code> is already inferred by instance search). Then you sort of want to use <a href="https://leanprover-community.github.io/mathlib_docs/find/add_action.quotient_action">docs#add_action.quotient_action</a> with <code>H := local_ring.maximal_ideal A</code>, but we have a <code>mul_action</code> not <code>add_action</code>; the best way out of this is to consider the action on <code>multiplicative L</code>, I think. Another thing to beware of is that you should only be able to define a (left) mul_action of the mul_opposite <code>(A.decomposition_group K)ᵐᵒᵖ</code>.</p>



<a name="296864341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296864341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296864341">(Sep 02 2022 at 17:26)</a>:</h4>
<p>Thanks for the clarification. But how can I combine this with what <span class="user-mention" data-user-id="243562">@Adam Topaz</span> already defined below ? - This is a different action.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">):</span>
<span class="n">mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">local_ring.residue_field</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="296866218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296866218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296866218">(Sep 02 2022 at 17:37)</a>:</h4>
<p>Right, you first need to define an action of the decomposition group by ring isomorphisms on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> itself, then use the fact that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is local to descend this action to an action on the residue field.</p>



<a name="296868940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296868940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296868940">(Sep 02 2022 at 17:53)</a>:</h4>
<p>Yeah I was just pointing out some intermediate defs you need to get to the end goal, and that the end goal should involve the mul_opposite of (A.decomposition_group K).</p>



<a name="296869374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296869374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296869374">(Sep 02 2022 at 17:56)</a>:</h4>
<p>Well, the decomposition group should be a subgroup of the Galois group, so it should just be a regular left action on <code>A</code>.</p>



<a name="296869485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296869485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296869485">(Sep 02 2022 at 17:57)</a>:</h4>
<p>Michail already converted from the stabilizer (which is a subgroup of the opposite group) to a subgroup of the Galois group using <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite">docs#subgroup.opposite</a></p>



<a name="296869944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296869944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296869944">(Sep 02 2022 at 18:00)</a>:</h4>
<p>Note that we do have <a href="https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action">docs#distrib_mul_action</a> which includes compatibility with addition. But the action on the ring is really by ring automorphisms, and as far as I know we don't have a way to speak nicely about actions by ring automorphisms.</p>



<a name="296873772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296873772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296873772">(Sep 02 2022 at 18:22)</a>:</h4>
<p>Notice that if you use <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_action.quotient_action">docs#mul_action.quotient_action</a> with H := <a href="https://leanprover-community.github.io/mathlib_docs/find/add_subgroup.to_subgroup">docs#add_subgroup.to_subgroup</a> (local_ring.maximal_ideal A), then <code>inv_mul_mem</code> boils down to <code>a' - a ∈ H → b • a' - b • a ∈ H</code>, so you just need distrib_mul_action + a little bit.</p>



<a name="296877642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296877642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296877642">(Sep 02 2022 at 18:48)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.opposite">docs#subgroup.opposite</a> doesn't turn an action by mul_opposite (i.e. a right action) to an action by the original group (i.e. a left action) because it's simply the identity; <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_equiv.inv'">docs#mul_equiv.inv'</a> could do that because it inserts an inverse. So <code>mul_action.stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ A</code> inherits the mul_action from (L ≃ₐ[K] L)ᵐᵒᵖ (probably by typeclass inference), but when you convert it to a subgroup of <code>(L ≃ₐ[K] L)</code> using subgroup.opposite.symm, it no longer has a mul_action. So I think it's better to consider the action of <code>mul_action.stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ A</code> and get an the inertia subgroup as a subgroup of it instead of <code>A.decomposition_group K</code>, and only convert it to a subgroup of <code>(L ≃ₐ[K] L)</code> in the end if you really want to do that.</p>



<a name="296881586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296881586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296881586">(Sep 02 2022 at 19:16)</a>:</h4>
<p>But there is no mul action of <code>mul_action.stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ A</code>. It's a stabilizer! The action is trivial (on A as a <em>set</em>).</p>



<a name="296881629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296881629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296881629">(Sep 02 2022 at 19:16)</a>:</h4>
<p>Since it stabilizes A as a set, the mul action induced by that of the Galois group on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> restricts to an action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>



<a name="296881771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296881771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296881771">(Sep 02 2022 at 19:17)</a>:</h4>
<p>What we DO have is a mul_action of a subgroup of the Galois group of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">∣</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">L|K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>. That should be called <a href="https://leanprover-community.github.io/mathlib_docs/find/subgroup.mul_action">docs#subgroup.mul_action</a> maybe?</p>



<a name="296881957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296881957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296881957">(Sep 02 2022 at 19:18)</a>:</h4>
<p>What Michail now needs to prove is that this mul_action of the decomposition group, when acting on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>, restricts to an action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>



<a name="296882258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296882258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296882258">(Sep 02 2022 at 19:21)</a>:</h4>
<p>Here's a bit more code... once those sorries are done, it would be a good exercise to obtain the action on the residue field by showing that the action on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> preserves the maximal ideal.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.opposite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mem_or_inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">valuation_subring.mem_or_inv_mem</span><span class="o">],</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">e.unop</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">refl</span><span class="o">},</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,}</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">K</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">valuation_subring.decomposition_group</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite.symm</span> <span class="o">(</span><span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span>
<span class="n">infer_instance</span>

<span class="kd">def</span> <span class="n">valuation_subring.sub_mul_action</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sub_mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">smul_mem'</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">decomposition_group.mul_action</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">distrib_mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul_add</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">sub_mul_action.mul_action</span> <span class="o">(</span><span class="n">A.sub_mul_action</span> <span class="n">K</span><span class="o">))</span> <span class="o">}</span>
</code></pre></div>



<a name="296893463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296893463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296893463">(Sep 02 2022 at 20:50)</a>:</h4>
<p>Oh yeah I was confused. I agree that you should be able to do <code>sub_mul_action (A.decomposition_group K) L</code> with carrier <code>A</code>. The reason is that the action on valuation subrings is via comap, which implicitly introduces an inverse relative to the action on elements: with the definition of <code>mul_action (L ≃ₐ[K] L)ᵐᵒᵖ (valuation_subring L)</code> it holds that <code>a ∈ A → e⁻¹ • a ∈ e • A</code>, i.e. to make the two actions compatible you need an inverse. Without using inverse, this can be written <code>e • a ∈ A → a ∈ e • A</code>, i.e. the two actions are not compatible but "adjoint".</p>



<a name="296946488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296946488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296946488">(Sep 03 2022 at 06:22)</a>:</h4>
<p>Isn't <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_semiring_action">docs#mul_semiring_action</a> the tool to talk about actions by ring automorphisms, <span class="user-mention" data-user-id="243562">@Adam Topaz</span>?</p>



<a name="296946558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296946558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296946558">(Sep 03 2022 at 06:23)</a>:</h4>
<p>I think we're missing the instance for ring automorphisms because we're also missing the monoid structure (by composition) of ring automorphisms</p>



<a name="296946609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296946609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296946609">(Sep 03 2022 at 06:24)</a>:</h4>
<p>But we have the version for <code>alg_equiv</code></p>



<a name="296946869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/296946869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#296946869">(Sep 03 2022 at 06:28)</a>:</h4>
<p>Also, can't you just define the decomposition group in terms of the existing <a href="https://leanprover-community.github.io/mathlib_docs/find/valuation_subring.pointwise_mul_action">docs#valuation_subring.pointwise_mul_action</a> instead of making a new mul_action instance (defined via map instead of comap)? After all, <code>comap</code>ing by <code>e</code> is just mapping by <code>e⁻¹</code>?</p>



<a name="297052422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/297052422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#297052422">(Sep 04 2022 at 02:42)</a>:</h4>
<p>Ah! Great! I didn't know this pointwise mul action existed!</p>



<a name="297052690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/297052690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#297052690">(Sep 04 2022 at 02:48)</a>:</h4>
<p>BTW the docstring for <a href="https://leanprover-community.github.io/mathlib_docs/find/subring.pointwise_mul_action">docs#subring.pointwise_mul_action</a> sounds wrong to me (similarly for the valuation one).</p>



<a name="297052706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/297052706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#297052706">(Sep 04 2022 at 02:49)</a>:</h4>
<p>It's not the action on <em>a</em> subring, but rather the action on the type of all subrings.</p>



<a name="297062933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/297062933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#297062933">(Sep 04 2022 at 06:02)</a>:</h4>
<p>I guess we should add the following class/instances?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.group_action.quotient</span>
<span class="kn">import</span> <span class="n">ring_theory.ideal.quotient</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">mul_action.add_quotient_action</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">β</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">neg_add_mem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="bp">-</span><span class="n">a</span> <span class="bp">+</span> <span class="n">a'</span> <span class="bp">∈</span> <span class="n">H</span> <span class="bp">→</span> <span class="bp">-</span><span class="o">(</span><span class="n">b</span> <span class="bp">•</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">•</span> <span class="n">a'</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">H</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"> `inv_mul_mem` in docs#add_action.quotient_action should also be called `neg_add_mem`. -/</span>

<span class="kd">instance</span> <span class="n">mul_action.add_quotient</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">β</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">[</span><span class="n">mul_action.add_quotient_action</span> <span class="n">β</span> <span class="n">H</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">β</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⧸</span> <span class="n">H</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c">/-</span><span class="cm"> The above are analogous to docs#mul_action.quotient_action, docs#mul_action.quotient -/</span>

<span class="kd">instance</span> <span class="n">distrib_mul_action.add_quotient</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">β</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">[</span><span class="n">mul_action.add_quotient_action</span> <span class="n">β</span> <span class="n">H</span><span class="o">]</span> <span class="o">[</span><span class="n">H.normal</span><span class="o">]</span> <span class="o">:</span> <span class="n">distrib_mul_action</span> <span class="n">β</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⧸</span> <span class="n">H</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">instance</span> <span class="n">mul_distrib_mul_action.add_quotient</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_distrib_mul_action</span> <span class="n">β</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">[</span><span class="n">mul_action.add_quotient_action</span> <span class="n">β</span> <span class="n">I.to_add_subgroup</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_distrib_mul_action</span> <span class="n">β</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⧸</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">instance</span> <span class="n">mul_semiring_action.add_quotient</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_semiring_action</span> <span class="n">β</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">[</span><span class="n">mul_action.add_quotient_action</span> <span class="n">β</span> <span class="n">I.to_add_subgroup</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_semiring_action</span> <span class="n">β</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⧸</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="297066036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/297066036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#297066036">(Sep 04 2022 at 07:04)</a>:</h4>
<p>And we probably also want the following, but the current algebra hierarchy doesn't yet allow us to state them properly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">submodule.distrib_mul_action</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">distrib_mul_action</span> <span class="n">β</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">distrib_mul_action</span> <span class="n">β</span> <span class="n">p</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="c">/-</span><span class="cm"> Analogous to docs#sub_mul_action.mul_action.</span>
<span class="cm">  We want p to be both a sub_mul_action and a submonoid, i.e. a submodule, but the current</span>
<span class="cm">  typeclass requirement for submodule is too strong. Relax it? -/</span>

<span class="kd">instance</span> <span class="n">submonoid'.mul_distrib_mul_action</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_distrib_mul_action</span> <span class="n">β</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">α</span> <span class="c">/-</span><span class="cm"> + smul_mem -/</span><span class="o">)</span> <span class="o">:</span> <span class="n">mul_distrib_mul_action</span> <span class="n">β</span> <span class="n">p</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">instance</span> <span class="n">subsemiring'.mul_semiring_action</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_semiring_action</span> <span class="n">β</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">subsemiring</span> <span class="n">α</span> <span class="c">/-</span><span class="cm"> + smul_mem -/</span><span class="o">)</span> <span class="o">:</span> <span class="n">mul_semiring_action</span> <span class="n">β</span> <span class="n">p</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="297067912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/297067912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#297067912">(Sep 04 2022 at 07:33)</a>:</h4>
<p>I already tried relaxing the typeclass requirements for <code>submodule</code> sometime last year, but ran into timeouts</p>



<a name="298163091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298163091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298163091">(Sep 10 2022 at 17:39)</a>:</h4>
<p>Hi, I have the following MWE :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.opposite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mem_or_inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">valuation_subring.mem_or_inv_mem</span><span class="o">],</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">e.unop</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">refl</span><span class="o">},</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,}</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">K</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">valuation_subring.decomposition_group</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite.symm</span> <span class="o">(</span><span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="kd">def</span> <span class="n">valuation_subring.sub_mul_action</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sub_mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">smul_mem'</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rintros</span> <span class="n">d</span> <span class="n">l</span> <span class="n">h</span><span class="o">,</span>
  <span class="gr">sorry</span>
  <span class="kd">end</span>
   <span class="o">}</span>
</code></pre></div>
<p>It looks simple enough but I keep missing something. Is there anything in the library I could use, or any specific lemmata I shall define first?</p>
<p>However, concerning the previous conversation: </p>
<p>~Do we need to define the decomposition group in terms of that pointwise mul action instead?</p>



<a name="298163853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298163853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298163853">(Sep 10 2022 at 17:49)</a>:</h4>
<p>So your <code>d</code> has type <code>↥(valuation_subring.decomposition_group K A)</code>, which means "subgroup (a term), promoted to a group (a type)". If you could get your hands on what was _actually_ going on, i.e. an element of the full Galois group <code>L ≃ₐ[K] L</code> and a proof that it's in the subgroup (and in particular if you could get rid of the <code>↥</code> coercion) then probably you could make more progress. The way to do this is literally to take <code>d</code> apart. To give a term of type <code>↥(valuation_subring.decomposition_group K A)</code> <em>is</em> to give a pair consisting of an element of <code>L ≃ₐ[K] L</code> and a proof that it's in the subgroup. So you could continue with <code>cases d with g hg</code> for example. Or you could just do everything in one go with <code>rintros ⟨g, hg⟩ l h,</code>.</p>



<a name="298163925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298163925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298163925">(Sep 10 2022 at 17:50)</a>:</h4>
<blockquote>
<p>Do we need to define the decomposition group in terms of that pointwise mul action instead?</p>
</blockquote>
<p>You don't _need_ to do anything. I don't quite understand the question.</p>



<a name="298165511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298165511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298165511">(Sep 10 2022 at 18:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/298163925">said</a>:</p>
<blockquote>
<blockquote>
<p>Do we need to define the decomposition group in terms of that pointwise mul action instead?</p>
</blockquote>
<p>You don't _need_ to do anything. I don't quite understand the question.</p>
</blockquote>
<p>Right, I am referring to : <a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/296946869">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/296946869</a></p>



<a name="298167783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298167783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michail Karatarakis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298167783">(Sep 10 2022 at 18:35)</a>:</h4>
<p>Thank you for the hint - Using <code>cases</code> with <code>simp </code> does remove the coercions, and I end up with the following: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.opposite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">valuation_subring.comap</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span>  <span class="o">:</span> <span class="n">K</span> <span class="bp">→+*</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">valuation_subring</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mem_or_inv_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">valuation_subring.mem_or_inv_mem</span><span class="o">],</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">A.to_subring.comap</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="o">(</span><span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">A</span><span class="o">,</span> <span class="n">A.comap</span> <span class="o">(</span><span class="n">e.unop</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">refl</span><span class="o">},</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,}</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">K</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">valuation_subring.decomposition_group</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite.symm</span> <span class="o">(</span><span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="kd">def</span> <span class="n">valuation_subring.sub_mul_action</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sub_mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">smul_mem'</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩</span> <span class="n">l</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p>which I find a bit confusing: I am looking for a proof involving an action of a tuple <code> ⟨g, hg⟩ • l ∈ A </code> instead, where <code>g : L ≃ₐ[K] L</code> and <code> hg : g ∈ valuation_subring.decomposition_group K A </code>. Is there anything more I could do from here?<br>
Furthermore, <code>library_search</code> curiously gives several errors concerning the types instead of the usual timeout or indicating that it hasn't found something.</p>



<a name="298176021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298176021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298176021">(Sep 10 2022 at 20:28)</a>:</h4>
<p>Are you claiming that <code>simp at *</code> closes the goal? It doesn't for me. If I do this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩</span> <span class="n">l</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span>
</code></pre></div>
<p>(this works because <code>⟨g, hg⟩ • l ∈ A</code> is definitionally equal to <code>g • l ∈ A</code>) then we have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">hg</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">∈</span> <span class="n">valuation_subring.decomposition_group</span> <span class="n">K</span> <span class="n">A</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">A</span>
<span class="bp">⊢</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">A</span>
</code></pre></div>
<p>Mathematically this is trivial: it says "if g is in the subgroup which stabilises A, then it sends something in A to something in A". Well, if something is mathematically trivial like this but is causing problems in Lean then it should probably be a lemma! Indeed if I look at your code then I see a red flag: every definition in Lean comes with a cost, and the cost is that you need to make an API for that definition (i.e. a list of basic theorems about that definition). You define <code>valuation_subring.decomposition_group</code> and prove 0 theorems about it and then go on to make another definition, and now you're in the middle of a proof about this second definition but you find that you need a fact about the first definition. The thing to think now is not "how do I continue in this proof in the second definition", it's "let's go back and make the API for the first definition". It's important to make this API because all of this left action / right action nonsense means that it's not really as easy as one would like to close the goal from here (assuming that your code didn't clear it -- it didn't for me).</p>



<a name="298183534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298183534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298183534">(Sep 10 2022 at 22:31)</a>:</h4>
<p>Arguably there is no point in having <code>valuation_subring.decomposition_group</code> at all, as it is a longer spelling and has less API than the equal <code>mul_action.stabilizer (L ≃ₐ[K] L) A</code></p>



<a name="298183618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298183618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298183618">(Sep 10 2022 at 22:33)</a>:</h4>
<p>Here's a proof of the above without any real definitions, which also follows my earlier suggestion to throw out all the <code>mul_opposite</code> stuff that isn't necessary</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.valuation.valuation_subring</span>
<span class="kn">import</span> <span class="n">group_theory.group_action.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">K</span><span class="o">)</span>

<span class="n">open_locale</span> <span class="n">pointwise</span>

<span class="kd">abbreviation</span> <span class="n">valuation_subring.decomposition_group</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="n">A</span>

<span class="kd">def</span> <span class="n">valuation_subring.sub_mul_action</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sub_mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">smul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">l</span> <span class="n">h</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">convert</span> <span class="n">set.smul_mem_smul_set</span> <span class="n">h</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">congr_arg</span> <span class="n">coe</span> <span class="n">g.prop.symm</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="298184386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298184386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298184386">(Sep 10 2022 at 22:44)</a>:</h4>
<p>It also generalizes to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">valuation_subring.sub_mul_action</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">[</span><span class="n">mul_semiring_action</span> <span class="n">G</span> <span class="n">L</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">sub_mul_action</span> <span class="o">(</span><span class="n">mul_action.stabilizer</span> <span class="n">G</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">smul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">l</span> <span class="n">h</span><span class="o">,</span> <span class="n">set.mem_of_mem_of_subset</span> <span class="o">(</span><span class="n">set.smul_mem_smul_set</span> <span class="n">h</span><span class="o">)</span> <span class="n">g.prop.le</span> <span class="o">}</span>
</code></pre></div>



<a name="298184591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298184591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298184591">(Sep 10 2022 at 22:48)</a>:</h4>
<p>Or even more generally</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Any set is stable under its stabilizer. -/</span>
<span class="kd">def</span> <span class="n">set.to_stabilizer_sub_mul_action</span> <span class="o">{</span><span class="n">G</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">sub_mul_action</span> <span class="o">(</span><span class="n">mul_action.stabilizer</span> <span class="n">G</span> <span class="n">A</span><span class="o">)</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">smul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">l</span> <span class="n">h</span><span class="o">,</span> <span class="n">set.mem_of_mem_of_subset</span> <span class="o">(</span><span class="n">set.smul_mem_smul_set</span> <span class="n">h</span><span class="o">)</span> <span class="n">g.prop.le</span> <span class="o">}</span>
</code></pre></div>



<a name="298185654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298185654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298185654">(Sep 10 2022 at 23:07)</a>:</h4>
<p>I think that <code>decomposition_group</code> needs a definition of some kind because it's a fundamental object in number theory. Here is my proposed development:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">valuation_subring</span>

<span class="kd">def</span> <span class="n">decomposition_group</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">subgroup.opposite.symm</span> <span class="o">(</span><span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">mem_decomposition_group'</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">∈</span> <span class="n">A.decomposition_group</span> <span class="n">K</span> <span class="bp">↔</span>
    <span class="n">mul_opposite.op</span> <span class="n">g</span> <span class="bp">∈</span> <span class="n">mul_action.stabilizer</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">)</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">mem_decomposition_group</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="o">(</span><span class="n">L</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">K</span><span class="o">]</span> <span class="n">L</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">g</span> <span class="bp">∈</span> <span class="n">A.decomposition_group</span> <span class="n">K</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">L</span><span class="o">,</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">sub_mul_action</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">valuation_subring</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sub_mul_action</span> <span class="o">(</span><span class="n">A.decomposition_group</span> <span class="n">K</span><span class="o">)</span> <span class="n">L</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">smul_mem'</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩</span> <span class="n">l</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">valuation_subring</span>
</code></pre></div>
<p>Eric: Michail is my new PhD student and he's learning Lean right now. Don't give too many spoilers! He's supposed to be learning Lean this way! Michail: perhaps we should stop having these conversations in public, although I think Eric's idea of an <code>abbreviation</code> is probably better than mine.</p>



<a name="298185763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298185763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298185763">(Sep 10 2022 at 23:09)</a>:</h4>
<p>Ah, if the goal is to learn lean, it might be a useful exercise to prove that <code>mul_action.stabilizer (L ≃ₐ[K] L) A</code> is equal to the more complicated <code>subgroup.opposite.symm (mul_action.stabilizer (L ≃ₐ[K] L)ᵐᵒᵖ A)</code>, so that dropping the latter in favor of the former feels justified!</p>



<a name="298185819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298185819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298185819">(Sep 10 2022 at 23:10)</a>:</h4>
<p>One thing I see in Eric's code is that we now have a left action of G on the valuation subrings?</p>



<a name="298185841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Working%20on%20Frobenius%20elements/near/298185841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements.html#298185841">(Sep 10 2022 at 23:10)</a>:</h4>
<p>Yes, that's mentioned higher up in this thread (<a href="#narrow/stream/113489-new-members/topic/Working.20on.20Frobenius.20elements/near/294787870">here</a>)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
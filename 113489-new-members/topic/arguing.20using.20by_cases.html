---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/arguing.20using.20by_cases.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html">arguing using by_cases</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="197857271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197857271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aniruddh Agarwal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197857271">(May 17 2020 at 16:35)</a>:</h4>
<p>The setup is:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_zero_divisor</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="n">def</span> <span class="n">is_nilpotent</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span>

<span class="kn">theorem</span> <span class="n">nonzero_nilpotent_is_zerodivisor</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">is_nilpotent</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">ha&#39;</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_zero_divisor</span> <span class="n">a</span>
  <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">zero_is_zero_divisor_in_nonzero_ring</span> <span class="o">[</span><span class="n">nonzero_comm_ring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">:</span> <span class="n">is_zero_divisor</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="mi">1</span> <span class="bp">⟨</span><span class="n">one_ne_zero</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">⟩</span>
</code></pre></div>


<p>I'm trying to prove</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">nonzero_ring_nilpotent_is_zerodivisor</span> <span class="o">[</span><span class="n">nonzero_comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">is_nilpotent</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">is_zero_divisor</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">by_cases</span> <span class="o">(</span><span class="k">assume</span> <span class="n">h1</span>  <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">zero_is_zero_divisor_in_nonzero_ring</span><span class="o">)</span>
                   <span class="o">(</span><span class="k">assume</span> <span class="n">hnz</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nonzero_nilpotent_is_zerodivisor</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">hnz</span><span class="o">)</span>
</code></pre></div>


<p>but lean is complaining:</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">classical</span><span class="bp">.</span><span class="n">by_cases</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span> <span class="n">zero_is_zero_divisor_in_nonzero_ring</span><span class="o">)</span>
<span class="n">term</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span> <span class="n">zero_is_zero_divisor_in_nonzero_ring</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span> <span class="n">is_zero_divisor</span> <span class="mi">0</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">is_zero_divisor</span> <span class="n">a</span>
</code></pre></div>


<p>My guess is that lean isn't able to prove that <code>is_zero_divisor 0</code> is the same as <code>is_zero_divisor a</code> in the first case. How can I fix this?</p>



<a name="197858589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197858589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197858589">(May 17 2020 at 17:06)</a>:</h4>
<p>Can you post a <a href="https://github.com/leanprover-community/mathlib/wiki/Minimum-Working-Example-&#40;MWE&#41;">#mwe</a> ?</p>



<a name="197859325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aniruddh Agarwal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859325">(May 17 2020 at 17:20)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">associated</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="c">/-</span><span class="cm"> An element a of a ring α is a zero divisor if there exists a b ∈ α</span>
<span class="cm">   such that b ≠ 0 and ab = 0. -/</span>
<span class="n">def</span> <span class="n">is_zero_divisor</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span>

<span class="c">/-</span><span class="cm"> An element a of a ring α is nilpotent if there exists a n ∈ ℕ such</span>
<span class="cm">   that n ≠ 0 and a^n = 0 -/</span>
<span class="n">def</span> <span class="n">is_nilpotent</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span>

<span class="kn">theorem</span> <span class="n">nonzero_nilpotent_is_zerodivisor</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">is_nilpotent</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">ha&#39;</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_zero_divisor</span> <span class="n">a</span>
  <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">zero_is_zero_divisor_in_nonzero_ring</span> <span class="o">[</span><span class="n">nonzero_comm_ring</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">:</span> <span class="n">is_zero_divisor</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="mi">1</span> <span class="bp">⟨</span><span class="n">one_ne_zero</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">⟩</span>

<span class="c">/-</span><span class="cm"> All nilpotents are zero divisors in a nonzero ring. -/</span>
<span class="kn">theorem</span> <span class="n">nonzero_ring_nilpotent_is_zerodivisor</span> <span class="o">[</span><span class="n">nonzero_comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">is_nilpotent</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">is_zero_divisor</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">by_cases</span> <span class="o">(</span><span class="k">assume</span> <span class="n">hz</span>  <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">zero_is_zero_divisor_in_nonzero_ring</span><span class="o">)</span>
                   <span class="o">(</span><span class="k">assume</span> <span class="n">hnz</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nonzero_nilpotent_is_zerodivisor</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">hnz</span><span class="o">)</span>
</code></pre></div>



<a name="197859431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859431">(May 17 2020 at 17:22)</a>:</h4>
<p><code>is_zero_divisor 0</code> isn't the same as <code>is_zero_divisor a</code>, even if you have some hypothesis saying <code>a = 0</code>; you need to rewrite that hypothesis before the terms become equal.</p>



<a name="197859446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aniruddh Agarwal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859446">(May 17 2020 at 17:22)</a>:</h4>
<p>Yeah, I'm just failing to see how to do that</p>



<a name="197859521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859521">(May 17 2020 at 17:24)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">nonzero_ring_nilpotent_is_zerodivisor</span> <span class="o">[</span><span class="n">nonzero_comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">is_nilpotent</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">is_zero_divisor</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">zero_is_zero_divisor_in_nonzero_ring</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">nonzero_nilpotent_is_zerodivisor</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">h</span><span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="197859537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aniruddh Agarwal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859537">(May 17 2020 at 17:25)</a>:</h4>
<p>Ah, I was trying to avoid entering tactic mode</p>



<a name="197859547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859547">(May 17 2020 at 17:25)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm"> All nilpotents are zero divisors in a nonzero ring. -/</span>
<span class="kn">theorem</span> <span class="n">nonzero_ring_nilpotent_is_zerodivisor</span> <span class="o">[</span><span class="n">nonzero_comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">is_nilpotent</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">is_zero_divisor</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">by_cases</span> <span class="o">(</span><span class="k">assume</span> <span class="n">hz</span>  <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hz</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">zero_is_zero_divisor_in_nonzero_ring</span><span class="o">)</span>
                   <span class="o">(</span><span class="k">assume</span> <span class="n">hnz</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nonzero_nilpotent_is_zerodivisor</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">hnz</span><span class="o">)</span>
</code></pre></div>



<a name="197859554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859554">(May 17 2020 at 17:25)</a>:</h4>
<p>The stupid triangle is a term mode version of rewrite.</p>



<a name="197859555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aniruddh Agarwal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859555">(May 17 2020 at 17:25)</a>:</h4>
<p>Thank you!</p>



<a name="197859560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859560">(May 17 2020 at 17:25)</a>:</h4>
<p>But believe you me, it's nowhere near as powerful.</p>



<a name="197859613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859613">(May 17 2020 at 17:26)</a>:</h4>
<p>Oh -- I had to <code>open_locale classical</code> to get the tactic proof working by the way</p>



<a name="197859630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859630">(May 17 2020 at 17:26)</a>:</h4>
<p>Did you know that substitution is just induction on <code>=</code>?</p>



<a name="197859641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aniruddh Agarwal <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859641">(May 17 2020 at 17:26)</a>:</h4>
<p>What?</p>



<a name="197859645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859645">(May 17 2020 at 17:27)</a>:</h4>
<p><code>=</code> isn't some inbuilt thing in Lean, it's just notation for some inductive type <code>eq</code></p>



<a name="197859715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859715">(May 17 2020 at 17:28)</a>:</h4>
<p><code>eq x y</code> has one constructor: <code>eq.refl a</code> has type <code>eq a a</code> and that's it.</p>



<a name="197859739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859739">(May 17 2020 at 17:29)</a>:</h4>
<p>And when you build the inductive type, Lean adds to its environment the new type, its constructor(s) and its eliminator (i.e. its recursor).</p>



<a name="197859745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859745">(May 17 2020 at 17:29)</a>:</h4>
<p>When you build the naturals using the standard functional definition (Peano's axioms), the recursor Lean generates is the standard principle of mathematical recursion.</p>



<a name="197859795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859795">(May 17 2020 at 17:30)</a>:</h4>
<p>When you make the <code>eq</code> inductive type, the recursor it generates is this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">eq</span><span class="bp">.</span><span class="n">rec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u_3</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">u_2</span><span class="o">},</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a_1</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a_1</span>
</code></pre></div>



<a name="197859806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859806">(May 17 2020 at 17:30)</a>:</h4>
<p>i.e. if you have a term of type <code>C a</code>, then for all <code>b</code> and for all proofs of <code>a = b</code>, you can get a term of type <code>C b</code></p>



<a name="197859816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859816">(May 17 2020 at 17:31)</a>:</h4>
<p>In other words, <code>a = b -&gt; (C a -&gt; C b)</code></p>



<a name="197859824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859824">(May 17 2020 at 17:31)</a>:</h4>
<p>which is <code>rw</code></p>



<a name="197859912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859912">(May 17 2020 at 17:33)</a>:</h4>
<p>The stupid triangle (<code>\t</code>) is just notation for <code>eq.subst</code> (you can check this with <code>#print notation ▸</code>) and <code>eq.subst</code> is the Prop version of <code>eq.rec</code>: if <code>a = b</code> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>P</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(a)\implies P(b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>



<a name="197859937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859937">(May 17 2020 at 17:33)</a>:</h4>
<p>Did you know that "<code>false</code> implies <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>" is just induction on <code>false</code>? ;-)</p>



<a name="197859991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197859991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197859991">(May 17 2020 at 17:34)</a>:</h4>
<p>To give a map from <code>false</code> to anything, you just have to say where all its constructors go, but <code>false</code> has no constructors at all <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="197860211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197860211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197860211">(May 17 2020 at 17:39)</a>:</h4>
<p>I sometimes use this when I can't convince rw to do what I want : if I have the hypothesis <code>h : a = b</code> and <code>rw</code> refuses to work for some reason I've done <code>cases h</code> which does!</p>



<a name="197860361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197860361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197860361">(May 17 2020 at 17:42)</a>:</h4>
<p>I often use <code>cases</code> on an equality to mean "sub in everywhere".</p>



<a name="197860590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197860590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197860590">(May 17 2020 at 17:47)</a>:</h4>
<p><span class="user-mention" data-user-id="294709">@Aniruddh Agarwal</span> you don't need <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n\not=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> in your definition of <code>is_nilpotent</code>.</p>



<a name="197860597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197860597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197860597">(May 17 2020 at 17:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/arguing.20using.20by_cases/near/197860361">said</a>:</p>
<blockquote>
<p>I often use <code>cases</code> on an equality to mean "sub in everywhere".</p>
</blockquote>
<p>Isn't the <code>subst</code> tactic meant to do this? Is there a reason to use one or the other?</p>



<a name="197860883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197860883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197860883">(May 17 2020 at 17:53)</a>:</h4>
<p>Prefer the <code>subst</code> tactic when it applies (or <code>rfl</code> in an <code>rcases</code>/<code>obtain</code> pattern, which calls <code>subst</code>). It only works if one side of the equality is a variable, though, while <code>cases</code> can see through multiple layers of constructors. For example if <code>h : (a, b) = (c, d)</code> then <code>cases h</code> will replace <code>c</code> by <code>a</code> and <code>d</code> by <code>b</code> in the goal, while <code>subst h</code> will fail.</p>
<p>But <code>cases</code> will also often make a mess when trying to reduce things to a normal form, so the result of the substitution may not be optimal, for example if <code>h : foo a = b</code> then <code>cases</code> might unfold <code>foo a</code> before substitution, causing big expressions all through your goal. In these cases, you can use <code>injection</code> and <code>subst</code> to get a bit more control over unfolding.</p>



<a name="197860959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/arguing%20using%20by_cases/near/197860959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/arguing.20using.20by_cases.html#197860959">(May 17 2020 at 17:54)</a>:</h4>
<p>In an <code>rcases</code> pattern, <code>rfl</code> means <code>subst</code> and <code>&lt;&gt;</code> means <code>cases</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
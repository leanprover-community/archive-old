---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html">formalizing definitions for real analysis</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204963923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204963923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204963923">(Jul 24 2020 at 20:39)</a>:</h4>
<p>I was wondering if someone might be able to suggest the best way to formalize the following, especially the definition of a partition.</p>
<p>1.1 Definition: A partition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> of a closed interval <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> is a finite sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_{0}, x_{1}, \ldots, x_{n})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mo>…</mo><mo>&lt;</mo><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a = x_{0} &lt; x_{1} &lt; \ldots &lt; x_{n} = b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>. The norm of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>, denoted <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">∣</mo><mrow><mo fence="true">∣</mo><mi>P</mi><mo fence="true">∣</mo></mrow><mo fence="true">∣</mo></mrow><annotation encoding="application/x-tex">\left|\left|P\right|\right|</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span>, is defined by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mrow><mo fence="true">∣</mo><mi>P</mi><mo fence="true">∣</mo></mrow><mo fence="true">∣</mo></mrow><mo>=</mo><msub><mo><mi>max</mi><mo>⁡</mo></mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\left|\left|P\right|\right| = \max_{1 \leq i \leq n} (x_{i} - x_{i-1})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>1.2 Definition: Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P = (x_{0}, \ldots, x_{n})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> be a partition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>, and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> be defined on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>. For each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, \ldots, n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span>, let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>∗</mo></mrow><annotation encoding="application/x-tex">x_{i}*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∗</span></span></span></span> be an arbitrary point in the interval <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x_{i-1}, x_{i}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>. Then any sum of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(f, P) = \sum_{i=1}^{n} f(x_{i}*)(x_{i} - x_{i-1})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∗</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is called a Riemann sum of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> relative to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>.</p>
<p>1.3 Definition: A function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is Riemann integrable on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> if there is a real number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> such that for any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\epsilon &gt; 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, there exists a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta &gt; 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> such that for any partition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> satisfying <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mrow><mo fence="true">∣</mo><mi>P</mi><mo fence="true">∣</mo></mrow><mo fence="true">∣</mo></mrow><mo>&lt;</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">\left|\left|P\right|\right| &lt; \delta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span>, and for any Riemann sum <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(f, P)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> relative to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>, we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mi>R</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">)</mo><mo>−</mo><mi>R</mi><mo fence="true">∣</mo></mrow><mo>&lt;</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\left|R(f,P) - R\right| &lt; \epsilon</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>.</p>
<p>1.4 Definition: A function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>, defined on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>, is a step function if there is a partition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P = (x_{0}, x_{1}, \ldots, x_{n})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is constant on each open subinterval <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_{i-1}, x_{i})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, \ldots, n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span>.</p>



<a name="204964033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204964033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204964033">(Jul 24 2020 at 20:40)</a>:</h4>
<p>just don't use backticks</p>



<a name="204964053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204964053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204964053">(Jul 24 2020 at 20:40)</a>:</h4>
<p>and use double-dollar-signs, i.e. <code>$$\LaTeX$$</code> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord"><span class="mord textrm mtight sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span></p>



<a name="204964275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204964275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204964275">(Jul 24 2020 at 20:42)</a>:</h4>
<p>Thank you.</p>



<a name="204965063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965063">(Jul 24 2020 at 20:49)</a>:</h4>
<p>What theorems do you want to prove and how do the proofs go?</p>



<a name="204965331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965331">(Jul 24 2020 at 20:51)</a>:</h4>
<p>I would probably be inclined to go for a fairly literal translation (and, in particular, not invent a custom inductive type for a partition) in order to avoid reinventing lots of finset sum stuff.</p>



<a name="204965492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965492">(Jul 24 2020 at 20:52)</a>:</h4>
<p>I'm going through the exercises in the first chapter of "An Introduction to Lebesgue Integration and Fourier Series" by Howard J. Wilcox and David L. Myers. I'm attaching what I have done in latex. <a href="/user_uploads/3121/eC42X4k1t9MAH3_5jZn_Kh3m/myers.dvi">myers.dvi</a></p>



<a name="204965627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965627">(Jul 24 2020 at 20:53)</a>:</h4>
<p>(do you know that mathlib has lebesgue integration?)</p>



<a name="204965775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965775">(Jul 24 2020 at 20:55)</a>:</h4>
<p>I saw that directory, but I didn't understand it.</p>



<a name="204965870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965870">(Jul 24 2020 at 20:55)</a>:</h4>
<p>yury gave some tutorials about this part of the library at lftcm2020</p>



<a name="204965936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204965936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204965936">(Jul 24 2020 at 20:56)</a>:</h4>
<p>there are exercises you can get with <code>leanproject get lftcm2020</code> and a <a href="https://www.youtube.com/watch?v=p8Etfv1_VqQ">video lecture</a></p>
<div class="youtube-video message_inline_image"><a data-id="p8Etfv1_VqQ" href="https://www.youtube.com/watch?v=p8Etfv1_VqQ"><img src="https://i.ytimg.com/vi/p8Etfv1_VqQ/default.jpg"></a></div>



<a name="204966046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204966046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204966046">(Jul 24 2020 at 20:57)</a>:</h4>
<p>the rest of the talks are on the same youtube channel :)</p>



<a name="204966084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204966084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204966084">(Jul 24 2020 at 20:57)</a>:</h4>
<p>Cool. I'll take a look.</p>



<a name="204967671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204967671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204967671">(Jul 24 2020 at 21:14)</a>:</h4>
<p>The ultimate aim of the work described here would be to formally define an integral which is strictly weaker than an integral we have already. However, if you write the proofs in tactic mode with comments then it would be an excellent pedagogical resource.</p>



<a name="204967913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204967913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204967913">(Jul 24 2020 at 21:17)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> if you're thinking of developing the theory with pedagogy in mind then you might want to make new notation for a partition. Reid's point is a partition is just a finset containing a and b, and that the moment things get tough you are going to be unfolding the definition of a partition because all the lemmas about finsets which you'll need won't be rewritable until we can see the finset.</p>



<a name="204968289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968289">(Jul 24 2020 at 21:20)</a>:</h4>
<p>Yes, it is for pedagogy. Sorry, I'm not sure if you are saying if I should or should not define it as a finset in lean.</p>



<a name="204968308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968308">(Jul 24 2020 at 21:21)</a>:</h4>
<p>If you're trying to write golfy term mode proofs for mathlib, this (making a new definition) will become tedious. But if you're happy to write tactic mode proofs then this will not be a bother at all. Taking Reid's argument to its natural conclusion, the lean idiomatic way would be to think of a partition as a nonempty finset of reals and you then define a and b to be the min and max. No new definition needed. The computer scientists would argue that the definition in your maths book is lousy because it's inconvenient to use in term mode. They say the fewer definitions the better. But I'm coming to the conclusion that there's some merit in ignoring the computer scientists and developing things the normal maths way. I just did three live streams about topological spaces and compact sets etc and I never once used a filter, I did it all the way I was taught. It's not going in mathlib but it's instructive for mathematicians</p>



<a name="204968641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968641">(Jul 24 2020 at 21:24)</a>:</h4>
<p>What are "golfy term mode proofs"?</p>



<a name="204968686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968686">(Jul 24 2020 at 21:25)</a>:</h4>
<p>Does that just mean really compact proofs or something more?</p>



<a name="204968775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968775">(Jul 24 2020 at 21:26)</a>:</h4>
<p>I really meant something like <code>(n : nat) (x : fin (n+1) -&gt; real) (h0 : x 0 = a) ...</code></p>



<a name="204968806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968806">(Jul 24 2020 at 21:27)</a>:</h4>
<p>I would suggest trying to formulate and prove a theorem about telescoping sums which amounts to the calculation of a Riemann sum for a constant function</p>



<a name="204968910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968910">(Jul 24 2020 at 21:28)</a>:</h4>
<p>Is that code a suggestion for the definition of a partition?</p>



<a name="204968991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204968991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204968991">(Jul 24 2020 at 21:29)</a>:</h4>
<p>Yes</p>



<a name="204969090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204969090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204969090">(Jul 24 2020 at 21:30)</a>:</h4>
<p>I see.</p>



<a name="204970361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204970361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204970361">(Jul 24 2020 at 21:48)</a>:</h4>
<p>Why this rather than a finite set of reals? I haven't worked with fin before.</p>



<a name="204970407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204970407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204970407">(Jul 24 2020 at 21:49)</a>:</h4>
<p>You can think of <code>fin n \to \R</code> as an ordered n-tuple of real numbers.</p>



<a name="204970434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204970434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204970434">(Jul 24 2020 at 21:49)</a>:</h4>
<p>So the difference is to make it ordered?</p>



<a name="204970565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204970565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204970565">(Jul 24 2020 at 21:51)</a>:</h4>
<p>It might help to see what the full definition in Lean would look like.</p>



<a name="204970575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204970575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204970575">(Jul 24 2020 at 21:51)</a>:</h4>
<p>Yes. Mathematically, it's the difference between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1,\ldots,x_n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x_1,\ldots,x_n\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>.</p>



<a name="204971239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971239">(Jul 24 2020 at 22:01)</a>:</h4>
<p>Are we defining a proposition like, is_partition, or the partition itself?</p>



<a name="204971407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971407">(Jul 24 2020 at 22:03)</a>:</h4>
<p>I thought a bit more about this and I agree with Reid. The disadvantage with a finset is that there is no good interface to access the i'th element. Lists would also be a pain because you probably won't be concatenating them or appending to the left, you will be mostly using them via their i'th element, so Reid's suggestion of a map from fin(n+1) (to ensure non-emptiness) to real is I think the best. Make a new definition! When you use it you'll figure out what API you'll need for it. I would love to watch the progress of this one.</p>



<a name="204971452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971452">(Jul 24 2020 at 22:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204970575">said</a>:</p>
<blockquote>
<p>Yes. Mathematically, it's the difference between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1,\ldots,x_n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x_1,\ldots,x_n\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>.</p>
</blockquote>
<p>Wait, with this definition I don't see where's the proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">x_0 &lt; x_1 &lt; \ldots </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span>. Isn't it just a tuple, with no order between the values?</p>



<a name="204971479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971479">(Jul 24 2020 at 22:04)</a>:</h4>
<p>You can still do it inductively with <code>fin</code>.</p>



<a name="204971496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971496">(Jul 24 2020 at 22:04)</a>:</h4>
<p>Since <code>fin.tail</code> is a thing.</p>



<a name="204971538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971538">(Jul 24 2020 at 22:05)</a>:</h4>
<p>You can define a partition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> of length n as the data of a partition of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a_1,b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>∈</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_1 \in (a,b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</p>



<a name="204971598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971598">(Jul 24 2020 at 22:06)</a>:</h4>
<p>And defining the empty partition is easy :)</p>



<a name="204971614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971614">(Jul 24 2020 at 22:06)</a>:</h4>
<p>That's what I thought. I had actually started doing that myself some time ago.<br>
At that time I didn't know about <code>fin.tail</code>.</p>



<a name="204971670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971670">(Jul 24 2020 at 22:07)</a>:</h4>
<p>To do this inductive definition, you just need to get the element in <code>fin (n+1)</code> corresponding to the value <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, which is <code>(0 : fin n).succ</code>, I guess.</p>



<a name="204971774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971774">(Jul 24 2020 at 22:08)</a>:</h4>
<p><span class="user-mention" data-user-id="259857">@Dan Stanescu</span> yeah you have to add a proof that x_i &lt; x_{i+1}. Reid wrote <code>...</code>, he didn't finish the definition. He did the data part and left the other mathematicians to do the proof part.</p>



<a name="204971827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971827">(Jul 24 2020 at 22:09)</a>:</h4>
<p>The rest is just the same, translate "for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_i &lt; x_{i+1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>" as something involving <code>∀ i : fin n, ...</code> or whatever.</p>



<a name="204971925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971925">(Jul 24 2020 at 22:10)</a>:</h4>
<p>Maybe it would be convenient to extend <code>x</code> to all of <code>nat</code> or even <code>int</code> by setting it to <code>a</code>/<code>b</code> outside the range <code>fin n</code></p>



<a name="204971930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971930">(Jul 24 2020 at 22:10)</a>:</h4>
<p>Unfortunately, <code>(i : fin n).succ</code> has type <code>fin (n+1)</code>.</p>



<a name="204971934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971934">(Jul 24 2020 at 22:10)</a>:</h4>
<p>I'm not sure that it will help to do the definition inductively. You're going to have a lot of lemmas where P is a partition and i is less than n and you want to talk about the interval [x_i, x_{i+1}]. If you make some fancy inductive definition then you'll have to work to get to the x_i</p>



<a name="204971954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971954">(Jul 24 2020 at 22:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204971930">said</a>:</p>
<blockquote>
<p>Unfortunately, <code>(i : fin n).succ</code> has type <code>fin (n+1)</code>.</p>
</blockquote>
<p>Yes, which is the input of <code>x</code></p>



<a name="204971963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971963">(Jul 24 2020 at 22:11)</a>:</h4>
<p>Oh right :)</p>



<a name="204971987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204971987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204971987">(Jul 24 2020 at 22:11)</a>:</h4>
<p>So yes, I agree this is the best option :)</p>



<a name="204972054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972054">(Jul 24 2020 at 22:12)</a>:</h4>
<p>You do have to do some cast to turn <code>i : fin n</code> to <code>i : fin (n+1)</code></p>



<a name="204972076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972076">(Jul 24 2020 at 22:12)</a>:</h4>
<p>Doesn't this exist as a coersion?</p>



<a name="204972128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972128">(Jul 24 2020 at 22:13)</a>:</h4>
<p>Not sure but it certainly exists in some form</p>



<a name="204972183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972183">(Jul 24 2020 at 22:14)</a>:</h4>
<p>I'm not sure I follow, but I think what Kevin said makes sense?</p>



<a name="204972189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972189">(Jul 24 2020 at 22:14)</a>:</h4>
<p>A good place to ask, would Riemann integrals still have a place somewhere in <code>mathlib</code> now? Same for Dedekind cuts.</p>



<a name="204972210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972210">(Jul 24 2020 at 22:14)</a>:</h4>
<p>Do you think it's worth storing the differences of the x_i, instead of the x_i themselves? Then you could use a <code>finsupp</code>.</p>



<a name="204972388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972388">(Jul 24 2020 at 22:17)</a>:</h4>
<p>You're also going to need to talk about points <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_i &lt; x &lt; x_{i+1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p>



<a name="204972464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972464">(Jul 24 2020 at 22:18)</a>:</h4>
<p>The partitions will at points probably need to be broken apart into sets of subintervals with sums over those sets.</p>



<a name="204972469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972469">(Jul 24 2020 at 22:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204972128">said</a>:</p>
<blockquote>
<p>Not sure but it certainly exists in some form</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cast_succ/src">src#fin.cast_succ</a></p>



<a name="204972495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972495">(Jul 24 2020 at 22:19)</a>:</h4>
<p>You can have a finsupp from nat or int to nnreal and then just define the x_i as partial sums.</p>



<a name="204972496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972496">(Jul 24 2020 at 22:19)</a>:</h4>
<p>Just in case it's helpful later.</p>



<a name="204972642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972642">(Jul 24 2020 at 22:21)</a>:</h4>
<p>Why is the function from fin (n + 1) \to \real and not \nat \to \real?</p>



<a name="204972702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972702">(Jul 24 2020 at 22:22)</a>:</h4>
<p>Well that's what your informal definition said right?</p>



<a name="204972752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972752">(Jul 24 2020 at 22:23)</a>:</h4>
<p>I guess I'm not sure what fin (n + 1) to real means? Is fin (n+1) a set?</p>



<a name="204972759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972759">(Jul 24 2020 at 22:23)</a>:</h4>
<p>It is the canonical type with n+1 elements</p>



<a name="204972773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972773">(Jul 24 2020 at 22:23)</a>:</h4>
<p>did you ask lean what <code>fin (n+1)</code> means?</p>



<a name="204972842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972842">(Jul 24 2020 at 22:24)</a>:</h4>
<p>You need a list of reals with n+1 elements and you need easy access to the i'th element of the list, so why not store the list internally as a function from a type with n+1 elements with names like 0,1,2,..,n to the reals.</p>



<a name="204972897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204972897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204972897">(Jul 24 2020 at 22:25)</a>:</h4>
<p><code>fin m</code> is a type. A term of type <code>fin m</code> is a pair consisting of a natural number i and a proof that i&lt;m. You take a term of this type apart with <code>cases</code>, which gives you the pair (the number and the proof), and you build terms of this type with the <code>\&lt;i, hi\&gt;</code> constructor, where i is a nat and hi is a proof that i&lt;m.</p>



<a name="204973300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973300">(Jul 24 2020 at 22:32)</a>:</h4>
<p>So fin m is not the type of finite ordered sets of natural numbers? I think I'm starting to see.</p>



<a name="204973341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973341">(Jul 24 2020 at 22:33)</a>:</h4>
<p>what would the <code>m</code> be doing there?</p>



<a name="204973342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973342">(Jul 24 2020 at 22:33)</a>:</h4>
<p><code>fin m</code> is exactly what I said it is. You can just <code>#check fin</code> if you have any more questions.</p>



<a name="204973349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973349">(Jul 24 2020 at 22:33)</a>:</h4>
<p>or #print</p>



<a name="204973397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973397">(Jul 24 2020 at 22:34)</a>:</h4>
<p>to elaborate on kevin's point, there's a literal definition and it is not very long</p>



<a name="204973400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973400">(Jul 24 2020 at 22:34)</a>:</h4>
<p>sorry yeah -- <code>#check fin</code> and then right click on <code>fin</code> and go to definition!</p>



<a name="204973413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973413">(Jul 24 2020 at 22:34)</a>:</h4>
<p>so if you read the definition you should either understand it or be able to find a part of it you don't understand</p>



<a name="204973435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973435">(Jul 24 2020 at 22:35)</a>:</h4>
<p>In math notation: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">fin</mi><mo>⁡</mo><mi>n</mi><mo>:</mo><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>x</mi><mo>&lt;</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex"> \operatorname{fin} n := \{ x \in \mathbb{N} \ | \ x &lt; n \}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mop"><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">}</span></span></span></span></p>



<a name="204973442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973442">(Jul 24 2020 at 22:35)</a>:</h4>
<p>except that it's a type, not a set</p>



<a name="204973458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973458">(Jul 24 2020 at 22:35)</a>:</h4>
<p>yeah, in lean <code>fin n := { x : \N // x &lt; n }</code></p>



<a name="204973515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973515">(Jul 24 2020 at 22:36)</a>:</h4>
<p>so in set theory you have <code>fin n \subseteq fin (n+1)</code> but in Lean this doesn't even make sense because <code>\subseteq</code> is for (sub)sets</p>



<a name="204973611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973611">(Jul 24 2020 at 22:38)</a>:</h4>
<p>You can see why <code>fin n</code> isn't a sub-thing of <code>fin (n+1)</code> because to give a term of type <code>fin n</code> is to give a pair (i,h) with h a proof that i&lt;n, and so now you don't have immediate access to a proof that i&lt;(n+1), you'll have to make this proof, and that is the content of the canonical map from fin n to fin(n+1) (it's not "the identity" -- work needs to be done)</p>



<a name="204973653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973653">(Jul 24 2020 at 22:39)</a>:</h4>
<p>I think I get it.</p>



<a name="204973774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973774">(Jul 24 2020 at 22:41)</a>:</h4>
<p>Thank you.</p>



<a name="204973861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204973861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204973861">(Jul 24 2020 at 22:42)</a>:</h4>
<p>I think it's a good exercise to write this definition. And here are some components which you'll need:</p>
<ol>
<li><code>fin.succ</code> is the successor function <code>fin n \to fin (n+1)</code>.</li>
<li>You can just write 0 for the first element of <code>fin (n+1)</code></li>
<li>You can write <code>fin.last n</code> for the last element of <code>fin (n+1)</code>.</li>
<li><code>fin.cast_succ</code> is the obvious inclusion <code>fin n \to fin (n+1)</code> that Kevin mentioned.</li>
</ol>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fin.last/src">src#fin.last</a> <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.succ/src">src#fin.succ</a> <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cast_succ/src">src#fin.cast_succ</a></p>



<a name="204974003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204974003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204974003">(Jul 24 2020 at 22:45)</a>:</h4>
<p>This would be an inductive definition? Kevin mentioned that maybe an inductive definition might not be ideal?</p>



<a name="204974019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204974019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204974019">(Jul 24 2020 at 22:45)</a>:</h4>
<p>No. This is if you want to follow Reid's suggestion.</p>



<a name="204974812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204974812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204974812">(Jul 24 2020 at 22:59)</a>:</h4>
<p>To be honest, I'm not sure I have a good idea of what form that definition would take. What would be the final type returned?</p>



<a name="204974839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204974839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204974839">(Jul 24 2020 at 22:59)</a>:</h4>
<p>The function?</p>



<a name="204975166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975166">(Jul 24 2020 at 23:05)</a>:</h4>
<p>You probably want a function with two real numbers <code>a</code> and <code>b</code> and the tuple <code>as : fin (n+1) \to \R</code> as inputs, and a <code>Prop</code> as the output. This should say that the <code>as</code> are the endpoints of the intervals of a partition of the interval with endpoints <code>a</code> and <code>b</code>.</p>



<a name="204975367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975367">(Jul 24 2020 at 23:08)</a>:</h4>
<p>Would it also take a proof that x_{0} &lt; x_{1} &lt; ... x_{n} as an input?</p>



<a name="204975412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975412">(Jul 24 2020 at 23:09)</a>:</h4>
<p>No, I guess that proof would be part of the returned Prop?</p>



<a name="204975478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975478">(Jul 24 2020 at 23:10)</a>:</h4>
<p>I was rather thinking about a function that takes <code>a</code>, <code>b</code> and <code>n</code> as inputs and returns a tuple.<br>
And the proof(s) that the points in the tuple are ordered, the first is <code>a</code> etc.</p>



<a name="204975502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975502">(Jul 24 2020 at 23:11)</a>:</h4>
<p>But there are many partitions of any given interval</p>



<a name="204975512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975512">(Jul 24 2020 at 23:11)</a>:</h4>
<p>True.</p>



<a name="204975708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204975708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204975708">(Jul 24 2020 at 23:14)</a>:</h4>
<p>I can still say things like "Let P be a partition such that ||P|| &lt; \delta" right? I just need to prove that one exists, probably by constructing it?</p>



<a name="204976128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976128">(Jul 24 2020 at 23:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="259857">Dan Stanescu</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204972189">said</a>:</p>
<blockquote>
<p>A good place to ask, would Riemann integrals still have a place somewhere in <code>mathlib</code> now? Same for Dedekind cuts.</p>
</blockquote>
<p>I would say yes.</p>



<a name="204976213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976213">(Jul 24 2020 at 23:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204975708">said</a>:</p>
<blockquote>
<p>I can still say things like "Let P be a partition such that ||P|| &lt; \delta" right? I just need to prove that one exists, probably by constructing it?</p>
</blockquote>
<p>In my view you could, but I'm not sure you could do that if you have a <code>Prop</code>.  <span class="user-mention" data-user-id="243562">@Adam Topaz</span> ?</p>



<a name="204976300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976300">(Jul 24 2020 at 23:27)</a>:</h4>
<p>You can use this prop to define a subtype, etc.</p>



<a name="204976537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976537">(Jul 24 2020 at 23:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204976128">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="259857">Dan Stanescu</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204972189">said</a>:</p>
<blockquote>
<p>A good place to ask, would Riemann integrals still have a place somewhere in <code>mathlib</code> now? Same for Dedekind cuts.</p>
</blockquote>
<p>I would say yes.</p>
</blockquote>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Where would you see them going to? The archive?</p>



<a name="204976600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976600">(Jul 24 2020 at 23:32)</a>:</h4>
<p>I think just a subdirectory called <code>riemann_integral</code> somewhere. Obviously it should have a thorough explanation in the module doc-strings that the rest of mathlib is build on top of more general constructions of integration.</p>



<a name="204976606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976606">(Jul 24 2020 at 23:32)</a>:</h4>
<p>Others may have other opinions on this, however.</p>



<a name="204976622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976622">(Jul 24 2020 at 23:33)</a>:</h4>
<p>Would it just be:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="204976625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204976625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204976625">(Jul 24 2020 at 23:33)</a>:</h4>
<p>We've got ZFC even though we're working in type theory, why not have Riemann integrals even though we're using Bochner? :-)</p>



<a name="204977770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204977770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204977770">(Jul 24 2020 at 23:57)</a>:</h4>
<p>How do you make a type out of a proposition?</p>



<a name="204977838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204977838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204977838">(Jul 24 2020 at 23:58)</a>:</h4>
<p>Propositions are types. Proofs of a proposition are terms of that type.</p>



<a name="204978101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204978101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204978101">(Jul 25 2020 at 00:03)</a>:</h4>
<p>I guess I'm not sure how I say let P be a partition of [a, b] such that...</p>



<a name="204978290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204978290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204978290">(Jul 25 2020 at 00:06)</a>:</h4>
<p>Is you define <code>is_partition {n} (a b : \R) (as : fin (n+1) \to \R)</code> then you would have some <code>as</code> with a proof of that prop.</p>



<a name="204978311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204978311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204978311">(Jul 25 2020 at 00:07)</a>:</h4>
<p>And the "such that" depends on what "such that" actually is.</p>



<a name="204978341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204978341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204978341">(Jul 25 2020 at 00:08)</a>:</h4>
<p>If "such that" is another prop, just include a proof of that prop as a variable</p>



<a name="204978391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204978391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204978391">(Jul 25 2020 at 00:08)</a>:</h4>
<p>I would make a <code>structure partition (a b : ℝ) := ...</code></p>



<a name="204979013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204979013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204979013">(Jul 25 2020 at 00:22)</a>:</h4>
<p>Also, how would you ever formalize the theorem that the riemann integral is weaker than the lebesgue integral without a formalization of the former?</p>



<a name="204979021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204979021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204979021">(Jul 25 2020 at 00:22)</a>:</h4>
<p>Same deal with dedekind reals being isomorphic to cauchy reals</p>



<a name="204979051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204979051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204979051">(Jul 25 2020 at 00:23)</a>:</h4>
<p>Turing machines are already in mathlib for this exact reason - even though the "official" foundations use partial recursive functions, we need the definition of a TM in order to state and prove the equivalence</p>



<a name="204980758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204980758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204980758">(Jul 25 2020 at 01:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/204978391">said</a>:</p>
<blockquote>
<p>I would make a <code>structure partition (a b : ℝ) := ...</code></p>
</blockquote>
<p>I'm not sure I follow. Does the structure use the proposition?</p>



<a name="204980995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204980995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204980995">(Jul 25 2020 at 01:08)</a>:</h4>
<p><code>n</code>, <code>x</code>, all the <code>n &gt; 0</code> etc. would be fields.</p>



<a name="204981342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981342">(Jul 25 2020 at 01:18)</a>:</h4>
<p>I'm not sure I understand how a value of type partition would be guaranteed to be a partition. I'm looking through the documentation on structures here: <a href="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html">https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html</a></p>



<a name="204981366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981366">(Jul 25 2020 at 01:19)</a>:</h4>
<p>your structure will be a bundle of data and propositions about that data</p>



<a name="204981416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981416">(Jul 25 2020 at 01:20)</a>:</h4>
<p>the subtype notation used in the definition of <code>fin n</code> is an example of a <code>structure</code></p>



<a name="204981425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981425">(Jul 25 2020 at 01:21)</a>:</h4>
<p>So one of the fields would be the is_partition proposition for example?</p>



<a name="204981430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981430">(Jul 25 2020 at 01:21)</a>:</h4>
<p>right, and if your proposition has an <code>and</code> in it, you probably want to break it into two fields</p>



<a name="204981493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981493">(Jul 25 2020 at 01:23)</a>:</h4>
<p><code>fin n</code> is an example of a structure</p>



<a name="204981545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981545">(Jul 25 2020 at 01:24)</a>:</h4>
<p>Can I then define a variable of type partition like I define a variable of type real, or do I have to always provide the fields?</p>



<a name="204981547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981547">(Jul 25 2020 at 01:24)</a>:</h4>
<p>it's morally equivalent (maybe literally defeq) to </p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="err">\</span><span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="err">\</span><span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">property</span> <span class="o">:</span> <span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="204981554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981554">(Jul 25 2020 at 01:24)</a>:</h4>
<p>I don't understand your question</p>



<a name="204981576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981576">(Jul 25 2020 at 01:25)</a>:</h4>
<p>I can say "let P be a partition" without constructing one?</p>



<a name="204981620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981620">(Jul 25 2020 at 01:26)</a>:</h4>
<p>Yes, e.g. if you have <code>structure partition (a b : ℝ) := ...</code> then later you can say</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">partition_eq_foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">\</span><span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">foo</span>
</code></pre></div>



<a name="204981629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981629">(Jul 25 2020 at 01:26)</a>:</h4>
<p><code>partition</code> has type <code>\R \to \R \to Type</code></p>



<a name="204981642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981642">(Jul 25 2020 at 01:27)</a>:</h4>
<p>Cool. Do I have to show that there is such a thing as a partition? That is, that the definition is not self contradicting?</p>



<a name="204981646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981646">(Jul 25 2020 at 01:27)</a>:</h4>
<p>no</p>



<a name="204981690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981690">(Jul 25 2020 at 01:28)</a>:</h4>
<p>you could define a partition and then prove </p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">partition_eq_foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">\</span><span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span>
</code></pre></div>



<a name="204981692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981692">(Jul 25 2020 at 01:28)</a>:</h4>
<p>(If you PR it to mathlib, the <code>inhabited</code> linter might want you to construct an instance.)</p>



<a name="204981702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981702">(Jul 25 2020 at 01:29)</a>:</h4>
<p>of course it is a good idea to construct an example as part of convincing yourself the definition is correct</p>



<a name="204981712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981712">(Jul 25 2020 at 01:29)</a>:</h4>
<p>you should also try to prove lemmas that are mathematically obvious</p>



<a name="204981772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981772">(Jul 25 2020 at 01:30)</a>:</h4>
<p>Interesting.</p>



<a name="204981789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981789">(Jul 25 2020 at 01:31)</a>:</h4>
<p>this is the same as saying that you don't have to prove a proposition in order to talk about it</p>



<a name="204981839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981839">(Jul 25 2020 at 01:32)</a>:</h4>
<p>You can write <code>def fermat : Prop := \ex a b c n, n &gt; 2 \and a \ne 0 \and a ^ n = b^n + c^n</code></p>



<a name="204981914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981914">(Jul 25 2020 at 01:34)</a>:</h4>
<p>Makes sense I guess.</p>



<a name="204981937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204981937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204981937">(Jul 25 2020 at 01:35)</a>:</h4>
<p>a <code>def</code> is like a 0-field <code>structure</code></p>



<a name="204982396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204982396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204982396">(Jul 25 2020 at 01:48)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">x</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_partition</span> <span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="204982452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204982452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204982452">(Jul 25 2020 at 01:50)</a>:</h4>
<p>Or is it better to combine them into just the structure?</p>



<a name="204982521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204982521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204982521">(Jul 25 2020 at 01:52)</a>:</h4>
<p>Depends if you anticipate using <code>is_partition</code> outside of defining <code>partition</code> instances.</p>



<a name="204982536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204982536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204982536">(Jul 25 2020 at 01:54)</a>:</h4>
<p>True.</p>



<a name="204983491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204983491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204983491">(Jul 25 2020 at 02:19)</a>:</h4>
<p>I think about formalizing Riemann integral too. Still not sure what is the best way to deal with it.</p>



<a name="204983542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204983542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204983542">(Jul 25 2020 at 02:20)</a>:</h4>
<p>E.g., should I support <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>b</mi><mi>a</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_b^a f(x)\,dx=-\int_a^b f(x)\,dx</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.215112em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8592920000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.399828em;vertical-align:-0.35582em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span> right away, or start with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_a^b f(x)\,dx</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.399828em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\le b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>.</p>



<a name="204983592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204983592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204983592">(Jul 25 2020 at 02:22)</a>:</h4>
<p>If I'll formalize this, then I'll formalize <a href="https://en.wikipedia.org/wiki/Henstock–Kurzweil_integral">Henstock-Kurzweil</a> and McShane integrals as well.</p>



<a name="204983599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204983599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204983599">(Jul 25 2020 at 02:23)</a>:</h4>
<p>Right now I'm trying to make a usable <code>interval_integral</code> based on Bochner integration.</p>



<a name="204984707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204984707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204984707">(Jul 25 2020 at 02:54)</a>:</h4>
<p>BTW, I think it's better to assume only non-strict inequalities on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> because this way your definition will work for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a=b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>.</p>



<a name="204984845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204984845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204984845">(Jul 25 2020 at 02:58)</a>:</h4>
<p>I wanted to try to do the exercises in the book, so I wanted to use the book's definition. Wouldn't that also lead to partitions like {5,5,5}?</p>



<a name="204985161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985161">(Jul 25 2020 at 03:08)</a>:</h4>
<p>what's wrong with the partition {5,5,5}?</p>



<a name="204985170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985170">(Jul 25 2020 at 03:09)</a>:</h4>
<p>Just not intuitive to me I guess.</p>



<a name="204985177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985177">(Jul 25 2020 at 03:09)</a>:</h4>
<p>i don't think it's good to wed yourself to a definition written on paper. if it's in a book that means it's battle tested as a way to get humans to learn math</p>



<a name="204985224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985224">(Jul 25 2020 at 03:10)</a>:</h4>
<p>but you should optimize your definitions to make it easy to write lean code with</p>



<a name="204985287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985287">(Jul 25 2020 at 03:12)</a>:</h4>
<p>Maybe. I'm doing this for pedagogy though.</p>



<a name="204985361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985361">(Jul 25 2020 at 03:14)</a>:</h4>
<p><code>{5, 5}</code> in a partition will add nothing to the Riemann sum, so it changes nothing.</p>



<a name="204985369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985369">(Jul 25 2020 at 03:15)</a>:</h4>
<p>But with <code>≤</code> the space of partitions has better properties.</p>



<a name="204985371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985371">(Jul 25 2020 at 03:15)</a>:</h4>
<p>E.g., you can insert a point without caring whether it's already in your set.</p>



<a name="204985380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985380">(Jul 25 2020 at 03:15)</a>:</h4>
<p>And the space of partitions of a given size is compact (not sure if it's important)</p>



<a name="204985435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985435">(Jul 25 2020 at 03:17)</a>:</h4>
<p>Sorry, I didn't mean to be adversarial. When I say you "should" do something, I just mean that I think that's the easiest path to having code that works</p>



<a name="204985448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985448">(Jul 25 2020 at 03:17)</a>:</h4>
<p>No, that's fine. I appreciate the input.</p>



<a name="204985494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985494">(Jul 25 2020 at 03:18)</a>:</h4>
<p>Also I have to remind myself every few messages that some people write Lean code for a reason different from "PR it to mathlib".</p>



<a name="204985499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985499">(Jul 25 2020 at 03:18)</a>:</h4>
<p>:)</p>



<a name="204985511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204985511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204985511">(Jul 25 2020 at 03:19)</a>:</h4>
<p>No problem.</p>



<a name="204994426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204994426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204994426">(Jul 25 2020 at 08:24)</a>:</h4>
<p>Patrick your is_partition definition is not right: the implications after the colon should be and's, or moved before the colon. A structure is a better idea. I agree that &lt;= will be much easier to work with than &lt;. The theorem statements will be much neater. You'll find that the book-writers just use &lt; for psychological reasons rather than anything else. There's no harm in having rectangles of width 0. Do you have a candidate structure definition yet?</p>



<a name="204994517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/204994517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#204994517">(Jul 25 2020 at 08:26)</a>:</h4>
<p>I don't think n&gt;0 should be there either in is_partition,  and your quantifiers over m in nat are bad because you can't evaluate x at m. Remember x eats a term of type fin n+1 so it needs to be fed a pair consisting of a natural and a proof.</p>



<a name="205015953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205015953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205015953">(Jul 25 2020 at 18:32)</a>:</h4>
<p>The <code>n &gt; 0</code> is there to ensure that there are at least two points in the partition, <code>a</code> and <code>b</code>.</p>
<p>"Remember x eats a term of type fin n+1 so it needs to be fed a pair consisting of a natural and a proof." Does that mean that <code>x 0 = a</code> and <code>x n = b</code> are also wrong? I was following the example from earlier in the thread and Lean didn't complain. What should it be?</p>



<a name="205015985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205015985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205015985">(Jul 25 2020 at 18:33)</a>:</h4>
<p><code>a</code> and <code>b</code> should be parameters anyways since you will constantly want to quantify over partitions of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>.</p>



<a name="205016006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016006">(Jul 25 2020 at 18:33)</a>:</h4>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo mathvariant="normal">≠</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \ne b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n &gt; 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> is forced anyways</p>



<a name="205016058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016058">(Jul 25 2020 at 18:34)</a>:</h4>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a = b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> then you might as well allow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> I suppose.</p>



<a name="205016129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016129">(Jul 25 2020 at 18:36)</a>:</h4>
<p>So if I want to keep the strict inequality then I should force <code>a &lt; b</code> instead?</p>



<a name="205016164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016164">(Jul 25 2020 at 18:36)</a>:</h4>
<p><code>a</code> and <code>b</code> are parameters aren't they?</p>



<a name="205016165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016165">(Jul 25 2020 at 18:36)</a>:</h4>
<p>Surely you <em>don't</em> want to force <code>a &lt; b</code> though? Isn't <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>a</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_a^a f(x) \, dx</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.215112em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8592920000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span> well-defined (as zero)?</p>



<a name="205016173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016173">(Jul 25 2020 at 18:37)</a>:</h4>
<p>Apparently there's a coercion from <code>nat</code> to <code>fin n</code>--I didn't realize this</p>



<a name="205016174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016174">(Jul 25 2020 at 18:37)</a>:</h4>
<p>not sure what it does on out of range inputs</p>



<a name="205016238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016238">(Jul 25 2020 at 18:38)</a>:</h4>
<p>I guess it isn't defined in this book. Interesting point.</p>



<a name="205016274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016274">(Jul 25 2020 at 18:39)</a>:</h4>
<p>What would it look like without the coercion? That is, what should <code>x 0</code> be replaced with?</p>



<a name="205016339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016339">(Jul 25 2020 at 18:41)</a>:</h4>
<p><code>x 0</code> doesn't need a coercion because <code>fin m</code> has a <code>has_zero</code> instance (I guess I don't know what happens for <code>m = 0</code> but anyways it's not possible here).</p>



<a name="205016386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205016386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205016386">(Jul 25 2020 at 18:42)</a>:</h4>
<p>Otherwise, use library functions for <code>fin</code>--these were discussed above</p>



<a name="205017244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205017244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205017244">(Jul 25 2020 at 19:04)</a>:</h4>
<p>Like this?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>
</code></pre></div>



<a name="205021046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021046">(Jul 25 2020 at 20:46)</a>:</h4>
<p>Note that this will work for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \le b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>. Textbooks often say something like "we can deal with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≥</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \ge b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> in the same way" but you can't do this in Lean. If you want to deal with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>1</mn><mn>0</mn></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_1^0 f(x)\,dx</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.3648280000000002em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0090080000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span>, then you have (at least) three options:</p>
<ol>
<li>Support this in your definition right away. E.g., say something like <code>cmp (x m.cast_succ) (x m.succ) = cmp a b</code> in <code>h2</code>.</li>
<li><code>def integral f a b := if a ≤ b then integral_aux f a b else -integral_aux f b a</code>.</li>
<li>If <code>integral_aux f a b = 0</code> whenever <code>a ≥ b</code>, then you can also use <code>def integral f a b := integral_aux f a b - integral_aux f b a</code>.</li>
</ol>



<a name="205021051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021051">(Jul 25 2020 at 20:46)</a>:</h4>
<p>Currently I use option 3 to define <code>interval_integral</code> based on Lebesgue integral.</p>



<a name="205021064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021064">(Jul 25 2020 at 20:47)</a>:</h4>
<p>The main issue with option 2 is that you can't prove anything without <code>by_cases hab : a ≤ b</code>.</p>



<a name="205021215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021215">(Jul 25 2020 at 20:52)</a>:</h4>
<p>Option 1 gives you the correct definition right away but it's harder to prove lemmas along the way.</p>



<a name="205021275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021275">(Jul 25 2020 at 20:54)</a>:</h4>
<p>I guess a fourth option is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>x</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mi>t</mi><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\int_a^b f(x)\, dx = \int_0^1 f(a+(b-a)t)\,(b-a)dt</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.399828em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3648280000000002em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0090080000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span>. But it doesn't look too good for composing intervals.</p>



<a name="205021481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021481">(Jul 25 2020 at 21:01)</a>:</h4>
<p>And option 4' is to use a partition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> in the definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup></mrow><annotation encoding="application/x-tex">\int_a^b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.399828em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.044008em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="205021708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021708">(Jul 25 2020 at 21:07)</a>:</h4>
<p>I'm trying to define the norm of P that is <span class="tex-error">$$max_{i \leq 1 \leq n) (x_{i} - x_{i-1})$$</span>. As a starting point I have:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">norm</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="bp">...</span>
</code></pre></div>


<p>But then I don't know how to induct on the function.</p>



<a name="205021812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021812">(Jul 25 2020 at 21:10)</a>:</h4>
<p>I'd probably use <code>finset.sup</code></p>



<a name="205021864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021864">(Jul 25 2020 at 21:13)</a>:</h4>
<p>I used option 2 in metamath. You don't need to case split everything, in particular once you have additivity of endpoints you can mostly forget about this detail</p>



<a name="205021924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205021924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205021924">(Jul 25 2020 at 21:15)</a>:</h4>
<p>Actually I didn't have any <code>integral_aux</code> in option 2, it was just the lebesgue integral over <code>Ioo a b</code></p>



<a name="205022071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205022071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205022071">(Jul 25 2020 at 21:19)</a>:</h4>
<p>It's actually pretty important to have this function for stating the FTC</p>



<a name="205024165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205024165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205024165">(Jul 25 2020 at 22:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205021812">said</a>:</p>
<blockquote>
<p>I'd probably use <code>finset.sup</code></p>
</blockquote>
<p>I'm not sure what you mean. Do you mean something like <code>def norm : finset ℝ → ℝ := ...</code>?</p>



<a name="205025123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205025123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205025123">(Jul 25 2020 at 22:48)</a>:</h4>
<p>i mean that <code>finset.sup</code> reduces the problem to writing an appropriate function</p>
<div class="codehilite"><pre><span></span><code><span class="n">foo</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">finset</span> <span class="err">\</span><span class="n">R</span>
</code></pre></div>


<p>and composing this with <code>finset.sup</code></p>



<a name="205027291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205027291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205027291">(Jul 25 2020 at 23:51)</a>:</h4>
<p>I'm trying option 3 with Lebesgue integral over <code>Ico a b</code>. This way you can use any measure, not only Lebesgue.</p>



<a name="205029282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029282">(Jul 26 2020 at 00:55)</a>:</h4>
<p>finset: "This file builds the basic theory of <code>finset α</code>, modelled as a <code>multiset α</code> without duplicates."<br>
Then "<code>multiset α</code> is the quotient of <code>list α</code> by list permutation. The result  is a type of finite sets with duplicates allowed."<br>
I'm lost at quotient of a list.</p>



<a name="205029333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029333">(Jul 26 2020 at 00:57)</a>:</h4>
<p>Does defining foo not still require induction on the function?</p>



<a name="205029373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029373">(Jul 26 2020 at 00:58)</a>:</h4>
<p>A multiset is a set but where repetition is allowed. In lean, it is represented by a lists modulo an equivalence relation where two lists are considered equivalent if one is a permutation of the other.</p>



<a name="205029376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029376">(Jul 26 2020 at 00:58)</a>:</h4>
<p>Quotient types are definitely a bit tricky. They're not explained until almost the very end of TPiL: <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients</a></p>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> wrote a tutorial that demonstrates quotients in Lean here: <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/Zmod37.lean">https://github.com/leanprover-community/mathlib/blob/master/docs/tutorial/Zmod37.lean</a></p>



<a name="205029380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029380">(Jul 26 2020 at 00:58)</a>:</h4>
<p>These are just implementation details.</p>



<a name="205029390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029390">(Jul 26 2020 at 00:59)</a>:</h4>
<p>Yeah, in practice you don't need to worry about how things are implemented</p>



<a name="205029395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029395">(Jul 26 2020 at 00:59)</a>:</h4>
<p>As long as you know how to find/use the appropriate stuff in mathlib</p>



<a name="205029398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029398">(Jul 26 2020 at 00:59)</a>:</h4>
<p>I think that's still more "in theory" than "in practice", though things are getting better all the time.</p>



<a name="205029476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205029476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205029476">(Jul 26 2020 at 01:01)</a>:</h4>
<p>Let's make lots more things <code>@[irreducible]</code>! :-)</p>



<a name="205030061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030061">(Jul 26 2020 at 01:21)</a>:</h4>
<p>I can think of something like this, but replacing nat with fin n + 1, but this has a natural number to induct on (and it doesn't compile) (or terminate):</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">norm</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">x</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">norm</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
</code></pre></div>



<a name="205030325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030325">(Jul 26 2020 at 01:31)</a>:</h4>
<p>Well, this type already doesn't make much sense because what are the finite number of things you want to take the max of?</p>



<a name="205030362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030362">(Jul 26 2020 at 01:32)</a>:</h4>
<p>oh is that supposed to be the second argument?</p>



<a name="205030368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030368">(Jul 26 2020 at 01:32)</a>:</h4>
<p>That it doesn't terminate. Yeah :)</p>



<a name="205030422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030422">(Jul 26 2020 at 01:34)</a>:</h4>
<p>In general my advice is not to use induction for normal math</p>



<a name="205030423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030423">(Jul 26 2020 at 01:34)</a>:</h4>
<p>I'm not sure what your goals are though.</p>



<a name="205030437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030437">(Jul 26 2020 at 01:35)</a>:</h4>
<p>If you make a brand new recursive definition here, then you will have to prove all the lemmas about it by induction yourself.</p>



<a name="205030439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030439">(Jul 26 2020 at 01:35)</a>:</h4>
<p>Maybe that's actually what you prefer though, I don't know.</p>



<a name="205030442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030442">(Jul 26 2020 at 01:35)</a>:</h4>
<p>I'm happy not to use induction, it's confusing. I'm just not sure how to do it otherwise.</p>



<a name="205030494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030494">(Jul 26 2020 at 01:37)</a>:</h4>
<p>The best advice I have is to just read the parts of the library that seem relevant, like <code>data.finset</code>. Maybe someone else has something more specific to suggest.</p>



<a name="205030540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030540">(Jul 26 2020 at 01:38)</a>:</h4>
<p>How do you define a function on something that has a domain of the functions of type fin n + 1 to real?</p>



<a name="205030615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030615">(Jul 26 2020 at 01:40)</a>:</h4>
<p>If I had to guess, there is probably something in mathlib that gives you a <code>finset \R</code> that's the image of a map <code>fin (n+1) \to \R</code>, and something that gives you the max of a <code>finset \R</code>.</p>



<a name="205030678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030678">(Jul 26 2020 at 01:43)</a>:</h4>
<p>So, in general, I got the impression that just about everything in a functional programming language is done by some form of recursion?</p>



<a name="205030722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030722">(Jul 26 2020 at 01:44)</a>:</h4>
<p>if you want to implement these things from scratch, you'll use recursion. If you just compose functions that are already available, you can avoid it.</p>



<a name="205030795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030795">(Jul 26 2020 at 01:47)</a>:</h4>
<p>But why reimplement everything from scratch? I think in your statement "everything" only means "all elementary exercises when learning a functional programming language". :-)</p>



<a name="205030842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030842">(Jul 26 2020 at 01:48)</a>:</h4>
<p>You can use <code>(finset.univ : finset (fin n)).sup (λ j, (⟨x j.cast_succ - x j.succ, _⟩ : nnreal))</code></p>



<a name="205030851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030851">(Jul 26 2020 at 01:48)</a>:</h4>
<p>Or <code>⨆ i : fin n, x i.cast_succ - x i.succ</code></p>



<a name="205030859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030859">(Jul 26 2020 at 01:49)</a>:</h4>
<p>What is the first symbol in the second one?</p>



<a name="205030908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030908">(Jul 26 2020 at 01:51)</a>:</h4>
<p>The one that looks like a square U.</p>



<a name="205030962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205030962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205030962">(Jul 26 2020 at 01:53)</a>:</h4>
<p>That's notation for max, essentially. You can copy and paste that into vscode, and hover over it to see what it is notation for. Maybe even control-click to jump to defn?</p>



<a name="205031138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031138">(Jul 26 2020 at 01:59)</a>:</h4>
<p><code>⨆ i, f i</code> is <code>mathlib</code> notation for <code>Sup (range f)</code>.</p>



<a name="205031199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031199">(Jul 26 2020 at 02:01)</a>:</h4>
<p>The relevant instance for <code>real</code>s is <code>conditionally_complete_linear_order</code>, and most theorems about <code>⨆</code> will have <code>csupr</code> in their name, and assume <code>[nonempty α]</code> and/or <code>bdd_above (range f)</code>, where <code>f : α → real</code>.</p>



<a name="205031200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031200">(Jul 26 2020 at 02:01)</a>:</h4>
<p>For empty or unbounded sets <code>Sup</code> is defined to be <code>0</code>.</p>



<a name="205031241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031241">(Jul 26 2020 at 02:02)</a>:</h4>
<p>In most cases it doesn't matter which garbage value do we use for <code>Sup empty</code> but this way a few theorems don't need <code>bdd_above</code>/<code>nonempty</code> assumption.</p>



<a name="205031290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031290">(Jul 26 2020 at 02:04)</a>:</h4>
<p>I didn't know about the control click.</p>



<a name="205031305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031305">(Jul 26 2020 at 02:05)</a>:</h4>
<p>We have both <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sup">docs#finset.sup</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.max">docs#finset.max</a></p>



<a name="205031362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031362">(Jul 26 2020 at 02:06)</a>:</h4>
<p>So <code>def norm' (n : ℕ) (x : fin (n + 1) → ℝ) := ⨆ i : fin n, x i.cast_succ - x i.succ</code>?<br>
This gives me: <code>definition 'norm'' is noncomputable, it depends on 'real.lattice.conditionally_complete_linear_order'</code></p>



<a name="205031367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031367">(Jul 26 2020 at 02:07)</a>:</h4>
<p>They have slightly different assumptions. E.g., <code>sup</code> takes a function as an argument, and for <code>max</code> you need to use <code>map</code> or <code>image</code>. Also <code>sup</code> assumes that there exists a minimal element of the type (<code>bot</code>) and <code>max</code> returns <code>none</code> for an empty <code>finset</code> and <code>some x</code> for a non-empty finset.</p>



<a name="205031368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031368">(Jul 26 2020 at 02:07)</a>:</h4>
<p>Try <code>noncomputable theory</code> at the top of your file.</p>



<a name="205031414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031414">(Jul 26 2020 at 02:08)</a>:</h4>
<p>Most probably you don't want to try developing <code>computable</code> integrals. E.g., because real numbers are noncomputable in Lean.</p>



<a name="205031483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031483">(Jul 26 2020 at 02:10)</a>:</h4>
<p>Yes, that fixed it.<br>
So I thought that if i is of type fin n, then i.cast_succ gives back i of type fin n + 1 and i.succ gives back i + 1 of type fin n + 1?</p>



<a name="205031491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031491">(Jul 26 2020 at 02:11)</a>:</h4>
<p>The "supremum" part is noncomputable.</p>



<a name="205031656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031656">(Jul 26 2020 at 02:17)</a>:</h4>
<p>(deleted)</p>



<a name="205031733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205031733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205031733">(Jul 26 2020 at 02:19)</a>:</h4>
<p>The definition of norm above seems to be the other way around?</p>



<a name="205032789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205032789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205032789">(Jul 26 2020 at 02:54)</a>:</h4>
<p>So is <code>x i.cast_succ - x i.succ</code> the function passed to Sup (range f)? And i iterates over the domain of that function?</p>



<a name="205033085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033085">(Jul 26 2020 at 03:02)</a>:</h4>
<p>Yes. More precisely, the function <code>λ i : fin n, x i.cast_succ - x i.succ</code> is passed to <code>Sup (range f)</code>.</p>



<a name="205033376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033376">(Jul 26 2020 at 03:12)</a>:</h4>
<p>Cool. Am I misunderstanding the definition of cast_succ and succ? I'm guessing probably.</p>



<a name="205033434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033434">(Jul 26 2020 at 03:14)</a>:</h4>
<p><code>cast_succ</code> is just the "obvious" inclusion from <code>fin n</code> to <code>fin (n+1)</code>, while <code>succ</code> is the successor. So when you write <code>x i.cast_succ - x i.succ</code> it means, mathematically, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_i - x_{i+1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="205033446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033446">(Jul 26 2020 at 03:15)</a>:</h4>
<p>You probably want <code>i.succ - i.cast_succ</code></p>



<a name="205033449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033449">(Jul 26 2020 at 03:15)</a>:</h4>
<p>That was what I was wondering.</p>



<a name="205033499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033499">(Jul 26 2020 at 03:17)</a>:</h4>
<p>Thank you.</p>



<a name="205033501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205033501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205033501">(Jul 26 2020 at 03:17)</a>:</h4>
<p>No problem!</p>



<a name="205034505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034505">(Jul 26 2020 at 03:53)</a>:</h4>
<p>In summary:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">partition_norm</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span>
</code></pre></div>



<a name="205034559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034559">(Jul 26 2020 at 03:55)</a>:</h4>
<p>Looks good. You can make the <code>a</code> and <code>b</code> implicit in <code>partition_norm</code> since they can be inferred from the type of <code>P</code>. You can also give the fields in partition some more descriptive names.</p>



<a name="205034607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034607">(Jul 26 2020 at 03:56)</a>:</h4>
<p>Cool.</p>



<a name="205034616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034616">(Jul 26 2020 at 03:57)</a>:</h4>
<p>If you make <code>a</code> and <code>b</code> implicit in <code>partition_norm</code>, and <code>P</code> is a partition (for some <code>a</code> and <code>b</code>) you would be able to just write <code>partition_norm P</code> for the norm of <code>P</code>.</p>



<a name="205034664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034664">(Jul 26 2020 at 03:58)</a>:</h4>
<p>Sounds good.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">partition_norm</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span>
</code></pre></div>



<a name="205034672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034672">(Jul 26 2020 at 03:59)</a>:</h4>
<p>And if you're really up to it, look up how to write custom notation, so you can actually write something like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>P</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||P||</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">∣</span><span class="mord">∣</span></span></span></span></p>



<a name="205034762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034762">(Jul 26 2020 at 04:01)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">partition_norm</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span>

<span class="kn">notation</span> <span class="bp">`||`</span><span class="n">P</span><span class="bp">`||`</span> <span class="o">:=</span> <span class="n">partition_norm</span> <span class="n">P</span>
</code></pre></div>



<a name="205034847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034847">(Jul 26 2020 at 04:04)</a>:</h4>
<p>Alternatively, you can do something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">partition</span>
<span class="n">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="err">\</span><span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="err">\</span><span class="n">R</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kn">end</span> <span class="n">partition</span>
</code></pre></div>


<p>which will allow you to write <code>P.norm</code> instead of <code>partition.norm P</code>.</p>



<a name="205034885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034885">(Jul 26 2020 at 04:05)</a>:</h4>
<p>Good idea.</p>



<a name="205034935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034935">(Jul 26 2020 at 04:06)</a>:</h4>
<p>One thing to keep in mind when defining notation is the precedence levels.</p>



<a name="205034986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034986">(Jul 26 2020 at 04:08)</a>:</h4>
<p>I might wait and look into that latter.</p>



<a name="205034988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205034988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205034988">(Jul 26 2020 at 04:08)</a>:</h4>
<p>I need to move on to Riemann sums :)</p>



<a name="205035739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205035739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205035739">(Jul 26 2020 at 04:35)</a>:</h4>
<p>For each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, \ldots, n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span>, let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>∗</mo></mrow><annotation encoding="application/x-tex">x_{i}*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∗</span></span></span></span> be an arbitrary point in the interval <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x_{i-1}, x_{i}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">needs_a_name</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>
</code></pre></div>


<p>?</p>



<a name="205040383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205040383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205040383">(Jul 26 2020 at 07:20)</a>:</h4>
<p>I'd <code>extend</code> the original structure adding fields <code>x</code> and <code>x_mem_Icc</code></p>



<a name="205041239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205041239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205041239">(Jul 26 2020 at 07:50)</a>:</h4>
<blockquote>
<p>Cool. Am I misunderstanding the definition of cast_succ and succ? I'm guessing probably.</p>
</blockquote>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> you do know that you can just hover over a definition and see its docstring, and if it hasn't got one then you can right click on it and peek its definition, right? If you don't understand the definitions of <code>cast_succ</code> and <code>succ</code>as written in the source code then you should probably figure them out because you're going to have to get used to<code>fin m</code> at some point. A term of type <code>fin m</code> is a pair, consisting of a natural <code>i</code> and a proof that <code>i&lt;m</code>. That's all you need to know.</p>



<a name="205041311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205041311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205041311">(Jul 26 2020 at 07:53)</a>:</h4>
<p>But in general you should be able to get away with not reading definitions, and hoping that the stuff in the source code just after the definition is the interface you'll need.</p>



<a name="205041991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205041991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205041991">(Jul 26 2020 at 08:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205016129">said</a>:</p>
<blockquote>
<p>So if I want to keep the strict inequality then I should force <code>a &lt; b</code> instead?</p>
</blockquote>
<p>Re this: if you don't need that inequality, and in most places you don't, then you should go rogue and generalize the book <em>when making the definition</em> (as you did), and just insert it into the lemmas which actually need it. You'll probably be surprised to find that essentially no lemmas need it, and the authors just put this assumption in for psychological reasons. There is a big disadvantage in putting in a random assumption <code>0&lt;n</code> which is almost never needed: then every proof by induction on n, you'll have to do a fake base case, where the result is probably trivially true but the hypotheses are false anyway, and then an actual base case n=1, where the result is true but a bit less trivially, and would follow from the inductive hypothesis and the case n=0 apart from the fact that you didn't prove the n=0 case because you made the mistake of copying from the book so you can't use the n=0 case, and then an inductive step which will be the same.</p>
<p>Re finset: if you're reading the definition <code>finset</code> you're doing the wrong thing. <code>finset X</code> is the type of finite subsets of <code>X</code>. This is what you need to know. If you want to learn more about how to use <code>finset</code> then go to <code>data.finset.basic</code> and read (only) the <em>statements of the lemmas</em>. Skip the first 100-200 lines because they might be messy ones you'll never need, and then start reading from there and you'll see that the lemmas are a bunch of basic mathematical results about finite sets all of which have incomprehensible proofs which you don't need to worry about, because you are not making the <code>finset</code> API, you are just going to use it, and it's very thorough. This is all moot because it looks like you're not going to use it anyway.</p>
<p>Finally, getting the definitions right is hard. Once the definitions are there, you can start proving theorems, and it doesn't matter how messy your proofs are because they are compiled and then forgotten. But definitions you have to implement them in such a way that they are usable in practice, and it's hard for an inexperienced Lean user to set these things up. You should make a little project github repo (usnig <code>leanproject new</code>) with just one file in src for now, so you can point people to your definitions more easily. This set-up is easier to work with than one random file on your computer. <code>partition</code> and <code>partition_norm</code> are looking good but as Adam says it should be called <code>partition.norm, and your </code>h0<code>, </code>h1<code>, </code>h2` hypotheses have lousy names -- what are you -- a mathematician? Give things descriptive names. Here's what Yury means:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>

<span class="n">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">,</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span>

<span class="kn">notation</span> <span class="bp">`||`</span><span class="n">P</span><span class="bp">`||`</span> <span class="o">:=</span> <span class="n">P</span><span class="bp">.</span><span class="n">norm</span>

<span class="kn">end</span> <span class="n">partition</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kn">structure</span> <span class="n">pointed_partition</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>
</code></pre></div>


<p>Calling something <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> and then something else <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x^*</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> doesn't sound like a great idea to me. I called it <code>y</code>.</p>



<a name="205065855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205065855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205065855">(Jul 26 2020 at 20:20)</a>:</h4>
<p>Thank you. Do you have any advice for finding the things I need in mathlib? For example, I'm sure there must be a function in mathlib that allows me to easily take the sum over the range of the function on fin n, but I don't know of an easy way to find it.</p>



<a name="205066263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066263">(Jul 26 2020 at 20:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205030842">said</a>:</p>
<blockquote>
<p>You can use <code>(finset.univ : finset (fin n)).sup (λ j, (⟨x j.cast_succ - x j.succ, _⟩ : nnreal))</code><br>
Or <code>⨆ i : fin n, x i.cast_succ - x i.succ</code></p>
</blockquote>



<a name="205066333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066333">(Jul 26 2020 at 20:35)</a>:</h4>
<p>That takes the max, not the sum right?</p>



<a name="205066343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066343">(Jul 26 2020 at 20:35)</a>:</h4>
<p>Hint: it's going to be called finset.sum</p>



<a name="205066421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066421">(Jul 26 2020 at 20:37)</a>:</h4>
<p>You could do worse than read through data.finset.basic just looking at the statements of the theorems, and reading docstrings of definitions. This will give you a feeling for what's there</p>



<a name="205066472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066472">(Jul 26 2020 at 20:38)</a>:</h4>
<p>Alright.</p>



<a name="205066479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066479">(Jul 26 2020 at 20:39)</a>:</h4>
<p>you might prefer looking at it in the web browser<br>
<a href="https://leanprover-community.github.io/mathlib_docs/">https://leanprover-community.github.io/mathlib_docs/</a></p>



<a name="205066486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066486">(Jul 26 2020 at 20:39)</a>:</h4>
<p>this will automatically hide the proofs and emphasize docstrings</p>



<a name="205066535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066535">(Jul 26 2020 at 20:40)</a>:</h4>
<p>reading mathlib_docs directly is kind of like reading a book where all the proofs are exercises</p>



<a name="205066536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066536">(Jul 26 2020 at 20:40)</a>:</h4>
<p>Thanks. I didn't use finset earlier, is this a suggestion that I should have?</p>



<a name="205066542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066542">(Jul 26 2020 at 20:40)</a>:</h4>
<p>i don't know what you should do</p>



<a name="205066550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066550">(Jul 26 2020 at 20:41)</a>:</h4>
<p>if your goal is to get code reasonably quickly that expresses the mathematics you were talking about before, you should aim to take advantage of existing libraries</p>



<a name="205066559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066559">(Jul 26 2020 at 20:41)</a>:</h4>
<p>I guess that was directed to Kevin, when he said it is called finset.sum.</p>



<a name="205066621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066621">(Jul 26 2020 at 20:43)</a>:</h4>
<p>i think a literal interpretation of his words would say that kevin suggests that you find some lemma in the library called <code>finset.sum</code> or similar, literally read the statement, and try to figure out whether it applies to your situation</p>



<a name="205066635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066635">(Jul 26 2020 at 20:43)</a>:</h4>
<p>The reason I'd go for finset.sum is that the API for it is much better developed than for the other sums, or at least that was true in the past when I wanted to do finite sums</p>



<a name="205066675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066675">(Jul 26 2020 at 20:44)</a>:</h4>
<p>I see.</p>



<a name="205066679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066679">(Jul 26 2020 at 20:44)</a>:</h4>
<p>You can use finset.univ to make your finite subset of fin n</p>



<a name="205066699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066699">(Jul 26 2020 at 20:45)</a>:</h4>
<p>And if you read the relevant part of the finset API (and Jalex is right, you'd be much better off reading the docs than the source code) then you'd see it in action and also what the basic lemmas are</p>



<a name="205066755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066755">(Jul 26 2020 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205066635">said</a>:</p>
<blockquote>
<p>The reason I'd go for finset.sum is that the API for it is much better developed than for the other sums, or at least that was true in the past when I wanted to do finite sums</p>
</blockquote>
<p>And it has a nice notation too</p>



<a name="205066764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066764">(Jul 26 2020 at 20:46)</a>:</h4>
<p>Which hopefully you'll see in the docs. Is it used there?</p>



<a name="205066841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066841">(Jul 26 2020 at 20:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/algebra/big_operators/basic.html">https://leanprover-community.github.io/mathlib_docs/algebra/big_operators/basic.html</a></p>



<a name="205066852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066852">(Jul 26 2020 at 20:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/algebra/big_operators/basic.html#finset.sum">https://leanprover-community.github.io/mathlib_docs/algebra/big_operators/basic.html#finset.sum</a></p>



<a name="205066905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066905">(Jul 26 2020 at 20:50)</a>:</h4>
<p>Start there and go down and hopefully you'll see enough to figure how to use this stuff</p>



<a name="205066978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205066978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205066978">(Jul 26 2020 at 20:52)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathematics_in_lean/">#mil</a> should cover all this too, eventually.</p>



<a name="205080287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205080287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205080287">(Jul 27 2020 at 04:03)</a>:</h4>
<p>I wonder if it would be helpful to have examples of use in the mathlib documentation. It might help me.</p>



<a name="205080417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205080417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205080417">(Jul 27 2020 at 04:07)</a>:</h4>
<p>Yes, I would support that. There are some usage examples in the docstrings in <a href="https://leanprover-community.github.io/mathlib_docs/data/list/defs.html"><code>data.list.defs</code></a>, but very few elsewhere. Contributions are welcome!</p>



<a name="205080463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205080463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205080463">(Jul 27 2020 at 04:08)</a>:</h4>
<p>I would contribute if I knew how to use them. :)</p>



<a name="205080582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205080582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205080582">(Jul 27 2020 at 04:12)</a>:</h4>
<p>You can search mathlib itself for usage examples, sometimes that helps. But of course, questions here are always welcome too!</p>



<a name="205549886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205549886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205549886">(Jul 31 2020 at 01:26)</a>:</h4>
<p>This compiles:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">y</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">))</span>
</code></pre></div>


<p>I'm not sure I understand what finset.univ does.</p>
<p>If I try this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">∑</span>
</code></pre></div>


<p>then I get 'unexpected token' for the summation symbol. I have tried various imports, but have not found one that fixes it.</p>



<a name="205550110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205550110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205550110">(Jul 31 2020 at 01:32)</a>:</h4>
<p>Did you try <code>open_locale big_operators</code>?</p>



<a name="205550214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205550214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205550214">(Jul 31 2020 at 01:35)</a>:</h4>
<p>If I put that in front of the definition then I get a command expected error. Entire file:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>

<span class="n">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="c1">-- := ⨆ i : fin P.n, P.x i.succ - P.x i.cast_succ</span>
<span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>

<span class="kn">notation</span> <span class="bp">`||`</span><span class="n">P</span><span class="bp">`||`</span> <span class="o">:=</span> <span class="n">P</span><span class="bp">.</span><span class="n">norm</span>

<span class="kn">end</span> <span class="n">partition</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kn">structure</span> <span class="n">pointed_partition</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">def riemann_sum (a b : ℝ) (P : pointed_partition a b) (f : ℝ → ℝ) : ℝ</span>
<span class="cm">:= (finset.univ : finset (fin P.n)).sum (λ i, f (P.y i) * (P.x i.succ - P.x i.cast_succ))</span>
<span class="cm">-/</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">∑</span>
</code></pre></div>



<a name="205552123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205552123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205552123">(Jul 31 2020 at 02:22)</a>:</h4>
<p>the first error in the file is significantly before the definition of riemann sum</p>



<a name="205552538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205552538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205552538">(Jul 31 2020 at 02:35)</a>:</h4>
<p>Yeah the notation for Sum needs some arguments after it.</p>



<a name="205553002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205553002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205553002">(Jul 31 2020 at 02:48)</a>:</h4>
<p>So this should be what you want i think:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">∑</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">y</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">n</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span>
</code></pre></div>



<a name="205554546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205554546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205554546">(Jul 31 2020 at 03:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205552123">said</a>:</p>
<blockquote>
<p>the first error in the file is significantly before the definition of riemann sum</p>
</blockquote>
<p>Yeah, it was fine in Visual Studio Code, but when I pasted it into the lean web page it gave a bunch of errors. I'm updating my OS, etc. now.</p>



<a name="205554916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205554916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205554916">(Jul 31 2020 at 03:38)</a>:</h4>
<p>I think I had to add the import <code>data.fintype.basic</code> to makee it work on my mathlib</p>



<a name="205555025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555025">(Jul 31 2020 at 03:41)</a>:</h4>
<p>In the web editor I get <code>file 'data/fintype/basic' not found in the LEAN_PATH</code>.</p>



<a name="205555093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555093">(Jul 31 2020 at 03:43)</a>:</h4>
<p><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%20data.set.intervals%20data.finset%20algebra.big_operators%20data.fintype.basic%0A%0Anoncomputable%20theory%0A%0Astructure%20partition%20%28a%20%3A%20%E2%84%9D%29%20%28b%20%3A%20%E2%84%9D%29%20%3A%3D%0A%28n%20%3A%20%E2%84%95%29%0A%28x%20%3A%20fin%20%28n%20%2B%201%29%20%E2%86%92%20%E2%84%9D%29%0A%28x_zero%20%3A%20x%200%20%3D%20a%29%0A%28x_last%20%3A%20x%20%28fin.last%20n%29%20%3D%20b%29%0A%28mono%20%3A%20%E2%88%80%20m%20%3A%20fin%20n%2C%20x%20m.cast_succ%20%E2%89%A4%20x%20m.succ%29%0A%0Anamespace%20partition%0A%0Adef%20norm%20%7Ba%20b%20%3A%20%E2%84%9D%7D%20%28P%20%3A%20partition%20a%20b%29%20%3A%20%E2%84%9D%0A--%20%3A%3D%20%E2%A8%86%20i%20%3A%20fin%20P.n%2C%20P.x%20i.succ%20-%20P.x%20i.cast_succ%0A%3A%3D%20%28finset.univ%20%3A%20finset%20%28fin%20P.n%29%29.sup%20%28%CE%BB%20j%2C%20%28P.x%20j.cast_succ%20-%20P.x%20j.succ%29%29%0A%0Anotation%20%60%7C%7C%60P%60%7C%7C%60%20%3A%3D%20P.norm%0A%0Aend%20partition%0A%0Aopen%20set%0A%0Astructure%20pointed_partition%20%28a%20b%20%3A%20%E2%84%9D%29%20extends%20partition%20a%20b%20%3A%3D%0A%28y%20%3A%20fin%20n%20%E2%86%92%20%E2%84%9D%29%0A%28mem_block%20%3A%20%E2%88%80%20m%20%3A%20fin%20n%2C%20y%20m%20%E2%88%88%20Icc%20%28x%20m.cast_succ%29%20%28x%20m.succ%29%29%0A%0Ainstance%20%28a%20b%20%3A%20%E2%84%9D%29%20%3A%20has_coe_to_fun%20%28pointed_partition%20a%20b%29%20%3A%3D%20%E2%9F%A8_%2C%20%CE%BB%20c%2C%20c.y%E2%9F%A9%0A%0A%2F-%0Adef%20riemann_sum%20%28a%20b%20%3A%20%E2%84%9D%29%20%28P%20%3A%20pointed_partition%20a%20b%29%20%28f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%29%20%3A%20%E2%84%9D%0A%3A%3D%20%28finset.univ%20%3A%20finset%20%28fin%20P.n%29%29.sum%20%28%CE%BB%20i%2C%20f%20%28P.y%20i%29%20*%20%28P.x%20i.succ%20-%20P.x%20i.cast_succ%29%29%0A-%2F%0A%0Aopen_locale%20big_operators%0A%0Adef%20riemann_sum%20%28a%20b%20%3A%20%E2%84%9D%29%20%28P%20%3A%20pointed_partition%20a%20b%29%20%28f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%29%20%3A%20%E2%84%9D%0A%3A%3D%20%E2%88%91%20n%2C%20f%20%28P%20n%29%20*%20%28P.x%20n.succ%20-%20P.x%20n.cast_succ%29%0A%0A%23print%20riemann_sum">https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%20data.set.intervals%20data.finset%20algebra.big_operators%20data.fintype.basic%0A%0Anoncomputable%20theory%0A%0Astructure%20partition%20%28a%20%3A%20%E2%84%9D%29%20%28b%20%3A%20%E2%84%9D%29%20%3A%3D%0A%28n%20%3A%20%E2%84%95%29%0A%28x%20%3A%20fin%20%28n%20%2B%201%29%20%E2%86%92%20%E2%84%9D%29%0A%28x_zero%20%3A%20x%200%20%3D%20a%29%0A%28x_last%20%3A%20x%20%28fin.last%20n%29%20%3D%20b%29%0A%28mono%20%3A%20%E2%88%80%20m%20%3A%20fin%20n%2C%20x%20m.cast_succ%20%E2%89%A4%20x%20m.succ%29%0A%0Anamespace%20partition%0A%0Adef%20norm%20%7Ba%20b%20%3A%20%E2%84%9D%7D%20%28P%20%3A%20partition%20a%20b%29%20%3A%20%E2%84%9D%0A--%20%3A%3D%20%E2%A8%86%20i%20%3A%20fin%20P.n%2C%20P.x%20i.succ%20-%20P.x%20i.cast_succ%0A%3A%3D%20%28finset.univ%20%3A%20finset%20%28fin%20P.n%29%29.sup%20%28%CE%BB%20j%2C%20%28P.x%20j.cast_succ%20-%20P.x%20j.succ%29%29%0A%0Anotation%20%60%7C%7C%60P%60%7C%7C%60%20%3A%3D%20P.norm%0A%0Aend%20partition%0A%0Aopen%20set%0A%0Astructure%20pointed_partition%20%28a%20b%20%3A%20%E2%84%9D%29%20extends%20partition%20a%20b%20%3A%3D%0A%28y%20%3A%20fin%20n%20%E2%86%92%20%E2%84%9D%29%0A%28mem_block%20%3A%20%E2%88%80%20m%20%3A%20fin%20n%2C%20y%20m%20%E2%88%88%20Icc%20%28x%20m.cast_succ%29%20%28x%20m.succ%29%29%0A%0Ainstance%20%28a%20b%20%3A%20%E2%84%9D%29%20%3A%20has_coe_to_fun%20%28pointed_partition%20a%20b%29%20%3A%3D%20%E2%9F%A8_%2C%20%CE%BB%20c%2C%20c.y%E2%9F%A9%0A%0A%2F-%0Adef%20riemann_sum%20%28a%20b%20%3A%20%E2%84%9D%29%20%28P%20%3A%20pointed_partition%20a%20b%29%20%28f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%29%20%3A%20%E2%84%9D%0A%3A%3D%20%28finset.univ%20%3A%20finset%20%28fin%20P.n%29%29.sum%20%28%CE%BB%20i%2C%20f%20%28P.y%20i%29%20*%20%28P.x%20i.succ%20-%20P.x%20i.cast_succ%29%29%0A-%2F%0A%0Aopen_locale%20big_operators%0A%0Adef%20riemann_sum%20%28a%20b%20%3A%20%E2%84%9D%29%20%28P%20%3A%20pointed_partition%20a%20b%29%20%28f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%29%20%3A%20%E2%84%9D%0A%3A%3D%20%E2%88%91%20n%2C%20f%20%28P%20n%29%20*%20%28P.x%20n.succ%20-%20P.x%20n.cast_succ%29%0A%0A%23print%20riemann_sum</a></p>



<a name="205555132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555132">(Jul 31 2020 at 03:44)</a>:</h4>
<p>works fine for me except it doesn't like your definition of norm, as it needs a bottom element for when the set is empty</p>



<a name="205555194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555194">(Jul 31 2020 at 03:46)</a>:</h4>
<p>A possible solution is to make <code>(P.x j.cast_succ - P.x j.succ)</code> land in nnreal so that the bottom element is 0.</p>



<a name="205555198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555198">(Jul 31 2020 at 03:46)</a>:</h4>
<p>Huh, that is a different web editor than the one I was using. I get a failed to synthesize error on this line <code>:= (finset.univ : finset (fin P.n)).sup (λ j, (P.x j.cast_succ - P.x j.succ))</code> in that.</p>



<a name="205555258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555258">(Jul 31 2020 at 03:48)</a>:</h4>
<p>Yeah always use the community web editor!</p>



<a name="205555272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555272">(Jul 31 2020 at 03:49)</a>:</h4>
<p>And yes that's the error I'm talking about, if you want to take sup over a set the Type the set is valued in needs to have an infimum or bottom element so that if you take the sup of the empty set you get a decent value back.</p>



<a name="205555541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555541">(Jul 31 2020 at 03:56)</a>:</h4>
<p>So I need a case for when <code>(finset.univ : finset (fin P.n))</code> is empty?</p>



<a name="205555709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555709">(Jul 31 2020 at 04:00)</a>:</h4>
<p>Yeah or you can use max instead of sup, which returns <code>none</code> if the input is empty, so your norm would land in <code>option real</code> instead of <code>real</code>. But I think the <code>nnreal</code> way is nicer.</p>



<a name="205555789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555789">(Jul 31 2020 at 04:03)</a>:</h4>
<p>Actually I just tried to do this and noticed that your norm is negatively valued!</p>



<a name="205555855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205555855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205555855">(Jul 31 2020 at 04:05)</a>:</h4>
<p>I guess that's not intentional so I switched it to this</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">nnreal</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>
<span class="n">open_locale</span> <span class="n">nnreal</span>

<span class="n">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span>
<span class="c1">-- := ⨆ i : fin P.n, P.x i.succ - P.x i.cast_succ</span>
<span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">mono</span> <span class="n">P</span> <span class="n">j</span><span class="o">]</span><span class="bp">⟩</span><span class="o">)</span>

<span class="kn">notation</span> <span class="bp">`||`</span><span class="n">P</span><span class="bp">`||`</span> <span class="o">:=</span> <span class="n">P</span><span class="bp">.</span><span class="n">norm</span>

<span class="kn">end</span> <span class="n">partition</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kn">structure</span> <span class="n">pointed_partition</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="bp">.</span><span class="n">y</span><span class="bp">⟩</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">def riemann_sum (a b : ℝ) (P : pointed_partition a b) (f : ℝ → ℝ) : ℝ</span>
<span class="cm">:= (finset.univ : finset (fin P.n)).sum (λ i, f (P.y i) * (P.x i.succ - P.x i.cast_succ))</span>
<span class="cm">-/</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="err">∑</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">n</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">riemann_sum</span>
</code></pre></div>



<a name="205556027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556027">(Jul 31 2020 at 04:10)</a>:</h4>
<p>There is a proof in the definition?</p>



<a name="205556090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556090">(Jul 31 2020 at 04:12)</a>:</h4>
<p>Yep, to give an element of the nonnegative reals (ℝ≥0)  we give an element of  <code>ℝ</code> and a proof that it is nonnegative, as this is defined as a subtype in lean.</p>



<a name="205556191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556191">(Jul 31 2020 at 04:15)</a>:</h4>
<p>I see.</p>



<a name="205556899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556899">(Jul 31 2020 at 04:33)</a>:</h4>
<p>Why does making it nnreal satisfy the need for an empty case?</p>



<a name="205556955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556955">(Jul 31 2020 at 04:34)</a>:</h4>
<p>Because the nnreal are bounded below and hence have a sup?</p>



<a name="205556960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556960">(Jul 31 2020 at 04:34)</a>:</h4>
<p>Actually an inf right?</p>



<a name="205556974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205556974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205556974">(Jul 31 2020 at 04:35)</a>:</h4>
<p>Yeah exactly, because nnreal has a smallest element (0) so that when you give an empty set the supremum has something sensible to be. You would want reals with  a negative infinity if you really wanted values in reals, but as your terms are all positive this seemed cleaner</p>



<a name="205557039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205557039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205557039">(Jul 31 2020 at 04:37)</a>:</h4>
<p>So the sup of an empty subset of the nnreals is 0?</p>



<a name="205557054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205557054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205557054">(Jul 31 2020 at 04:37)</a>:</h4>
<p>Is that by convention?</p>



<a name="205557257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205557257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205557257">(Jul 31 2020 at 04:42)</a>:</h4>
<p>No, I guess that makes sense. Every nnreal is an upper bound, so the least of those is 0.</p>



<a name="205701761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701761">(Aug 01 2020 at 23:00)</a>:</h4>
<p>As an aside, does this make sense? Is using structures like this a reasonable way to define the upper bound and the least upper bound?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_lub</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">not</span> <span class="n">is_ub</span><span class="o">)</span>
</code></pre></div>



<a name="205701827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701827">(Aug 01 2020 at 23:02)</a>:</h4>
<p>You mean</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>


<p>&amp; similarly for <code>lub</code></p>



<a name="205701874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701874">(Aug 01 2020 at 23:04)</a>:</h4>
<p>If I take out the Prop it seems to break the use of is_ub in the definition of lub.</p>



<a name="205701881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701881">(Aug 01 2020 at 23:04)</a>:</h4>
<p>oh yes, I didn't notice that part is separately wrong.</p>



<a name="205701886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701886">(Aug 01 2020 at 23:05)</a>:</h4>
<p>What did I do wrong?</p>



<a name="205701899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701899">(Aug 01 2020 at 23:05)</a>:</h4>
<p>It just doesn't make any sense.</p>



<a name="205701902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701902">(Aug 01 2020 at 23:05)</a>:</h4>
<p><code>:=</code> is for default values, it's rarely useful.</p>



<a name="205701906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701906">(Aug 01 2020 at 23:05)</a>:</h4>
<p>You need to replace it with what it means to be a least upper bound</p>



<a name="205701951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701951">(Aug 01 2020 at 23:06)</a>:</h4>
<p>So I want to say that the ub and the lub are real numbers. That is done by the t : \real right?</p>



<a name="205701966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701966">(Aug 01 2020 at 23:07)</a>:</h4>
<p>In <code>ub</code> you're saying (with the corrected version) that an upper bound of a set <code>S</code> is a real number <code>t</code> such that <code>∀ s ∈ S, s ≤ t</code>.</p>



<a name="205701968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205701968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205701968">(Aug 01 2020 at 23:07)</a>:</h4>
<p>Which is right.</p>



<a name="205702011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702011">(Aug 01 2020 at 23:08)</a>:</h4>
<p>The original said that an upper bound is any real number <code>t</code> together with any proposition which, if you don't supply it, defaults to <code>∀ s ∈ S, s ≤ t</code>.</p>



<a name="205702017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702017">(Aug 01 2020 at 23:09)</a>:</h4>
<p>I see. Ok. So now I'm not sure how to make use of the is_ub in the lub. I tried not is_ub r, but that doesn't seem to work.</p>



<a name="205702021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702021">(Aug 01 2020 at 23:09)</a>:</h4>
<p>You don't need to make use of it</p>



<a name="205702027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702027">(Aug 01 2020 at 23:09)</a>:</h4>
<p>True. I thought it might be easier to read though.</p>



<a name="205702030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702030">(Aug 01 2020 at 23:09)</a>:</h4>
<p>Maybe start with the definition in math?</p>



<a name="205702035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702035">(Aug 01 2020 at 23:10)</a>:</h4>
<p>(you also can't use it in any sensible way)</p>



<a name="205702073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702073">(Aug 01 2020 at 23:10)</a>:</h4>
<p>I mean, since the structure already contains the field <code>is_ub</code> you don't need to repeat the fact that it is an upper bound in the fact that it is a <em>least</em> upper bound, I guess.</p>



<a name="205702127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702127">(Aug 01 2020 at 23:12)</a>:</h4>
<p>That isn't how I wanted to use it. I can write:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_lub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">))</span>
</code></pre></div>


<p>but the last part is just stating that r is not an ub.</p>



<a name="205702131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702131">(Aug 01 2020 at 23:12)</a>:</h4>
<p>ub of S that is.</p>



<a name="205702189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702189">(Aug 01 2020 at 23:15)</a>:</h4>
<p>These extra <code>¬</code>s are a little awkward (normal definition would be that if <code>r</code> is another upper bound, then <code>t &lt;= r</code>) but that works.</p>



<a name="205702198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702198">(Aug 01 2020 at 23:15)</a>:</h4>
<p>You could also reuse the whole structure <code>ub</code></p>



<a name="205702248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702248">(Aug 01 2020 at 23:16)</a>:</h4>
<p>What do you mean by reuse the whole structure ub?</p>



<a name="205702363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702363">(Aug 01 2020 at 23:20)</a>:</h4>
<p>Quantify over all <code>ub S</code> in the type of <code>is_lub</code>, rather than writing out the two hypotheses separately</p>



<a name="205702370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702370">(Aug 01 2020 at 23:21)</a>:</h4>
<p>Also, you might not really want a structure in the first place.</p>



<a name="205702415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702415">(Aug 01 2020 at 23:22)</a>:</h4>
<p>mathlib style is more like <code>def is_ub (S : set \R) (t : \R) : Prop := \all s \in S, s \le t</code> and <code>def is_lub (S : set \R) (t : \R) : Prop := ...</code> (can use <code>is_ub</code>).</p>



<a name="205702428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702428">(Aug 01 2020 at 23:23)</a>:</h4>
<p>I thought it might make things cleaner to say r : ub S, then both r : real and is_ub r S. It would look closer to proofs on paper.</p>



<a name="205702471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702471">(Aug 01 2020 at 23:24)</a>:</h4>
<p>If I try to do:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="c1">--(is_lub : ∀ r : ℝ, r &lt; t → ¬ (∀ s ∈ S, s ≤ r))</span>
<span class="o">(</span><span class="n">is_lub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ub</span> <span class="n">S</span><span class="o">,</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span>
</code></pre></div>


<p>I get an error on the last leq.</p>



<a name="205702482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702482">(Aug 01 2020 at 23:25)</a>:</h4>
<p>abomination incoming:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>
<span class="o">(</span><span class="n">t_is_ub</span> <span class="o">:</span> <span class="n">is_ub</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_lub</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">not</span> <span class="n">is_ub</span><span class="o">)</span>
<span class="o">(</span><span class="n">t_is_lub</span> <span class="o">:</span> <span class="n">is_lub</span><span class="o">)</span>
</code></pre></div>



<a name="205702483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702483">(Aug 01 2020 at 23:25)</a>:</h4>
<p>that's because <code>r : ub S</code> and not <code>r : \R</code></p>



<a name="205702486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702486">(Aug 01 2020 at 23:25)</a>:</h4>
<p>you would have to write <code>r.t</code> instead</p>



<a name="205702529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702529">(Aug 01 2020 at 23:26)</a>:</h4>
<p>What does r.t mean?</p>



<a name="205702530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702530">(Aug 01 2020 at 23:26)</a>:</h4>
<p><code>ub.t r</code></p>



<a name="205702532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702532">(Aug 01 2020 at 23:26)</a>:</h4>
<p>i.e. the <code>t</code> field</p>



<a name="205702533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702533">(Aug 01 2020 at 23:26)</a>:</h4>
<p>Oh.</p>



<a name="205702539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702539">(Aug 01 2020 at 23:27)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a></p>



<a name="205702540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702540">(Aug 01 2020 at 23:27)</a>:</h4>
<p>Ch. 9</p>



<a name="205702587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702587">(Aug 01 2020 at 23:28)</a>:</h4>
<p>I don't really think the bundled structure is more like informal math. The big difference from informal math is in Lean you're generally forced to refer to statements you know (like "<code>r</code> is an upper bound of <code>S</code>") explicitly somehow--whether that statement is called <code>r.is_ub</code> or <code>h</code>, you still have to name it.</p>



<a name="205702637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702637">(Aug 01 2020 at 23:30)</a>:</h4>
<p>The disadvantage of the structure is that it forces you to introduce both <code>r</code> and the hypothesis that it is the (least) upper bound of something simultaneously--if you already had an <code>r</code> you were interested in then you have to jump through extra hoops to just state that it is an upper bound.</p>



<a name="205702641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702641">(Aug 01 2020 at 23:30)</a>:</h4>
<p>Why was it better to use a structure for the definition of a partition instead of saying is_partition?</p>



<a name="205702656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702656">(Aug 01 2020 at 23:31)</a>:</h4>
<p>It's not necessarily better or worse</p>



<a name="205702657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702657">(Aug 01 2020 at 23:31)</a>:</h4>
<p>just different</p>



<a name="205702701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702701">(Aug 01 2020 at 23:32)</a>:</h4>
<p>But, it's probably not as frequent in math that you have a random collection of subsets of a set lying around and you want to talk about whether or not it is a partition</p>



<a name="205702707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702707">(Aug 01 2020 at 23:32)</a>:</h4>
<p>but it does seem quite likely that you would have a random real number lying around and want to talk about whether or not it is an upper bound</p>



<a name="205702713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702713">(Aug 01 2020 at 23:33)</a>:</h4>
<p>For example with the structure <code>ub</code> alone it's quite awkward to express "<code>t</code> is not an upper bound of <code>S</code>"</p>



<a name="205702722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702722">(Aug 01 2020 at 23:33)</a>:</h4>
<p>I see.</p>



<a name="205702764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702764">(Aug 01 2020 at 23:34)</a>:</h4>
<p>And somehow, talking about something not being an upper bound feels plausible in a way that talking about something not being a partition does not</p>



<a name="205702771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702771">(Aug 01 2020 at 23:35)</a>:</h4>
<p>I believe the correct answer is "you'll know which implementation is better as you go on proving things about it"</p>



<a name="205702818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702818">(Aug 01 2020 at 23:36)</a>:</h4>
<p>you want to say, if <code>s</code> is an LUB of <code>A</code> and <code>t</code> of <code>B</code> then <code>s+t</code> of <code>A+B</code></p>



<a name="205702821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702821">(Aug 01 2020 at 23:36)</a>:</h4>
<p>which means the implementation without structure is better</p>



<a name="205702887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702887">(Aug 01 2020 at 23:39)</a>:</h4>
<p>Alright. Just out of pure curiosity, is there a way to replace the ¬ ∀ s ∈ S, s ≤ t with the simpler statement that r is not an ub as previously defined?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="c1">-- upper bound</span>
<span class="kn">structure</span> <span class="n">ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_ub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>

<span class="c1">-- least upper bound</span>
<span class="kn">structure</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_lub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&lt;</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">r</span><span class="o">)</span>
</code></pre></div>



<a name="205702991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205702991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205702991">(Aug 01 2020 at 23:42)</a>:</h4>
<p>I imagine a similar question might come up in the definition of something else as a structure that makes more sense.</p>



<a name="205703013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703013">(Aug 01 2020 at 23:43)</a>:</h4>
<p>you can say "there does not exist a <code>ub</code> whose <code>t</code> equals the given <code>t</code>"</p>



<a name="205703019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703019">(Aug 01 2020 at 23:43)</a>:</h4>
<p>but as I mentioned above it's awkward</p>



<a name="205703021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703021">(Aug 01 2020 at 23:44)</a>:</h4>
<p>this awkwardness would disappear with the usual definition</p>



<a name="205703064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703064">(Aug 01 2020 at 23:44)</a>:</h4>
<p>Alright.</p>



<a name="205703067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703067">(Aug 01 2020 at 23:44)</a>:</h4>
<p>Thank you.</p>



<a name="205703220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703220">(Aug 01 2020 at 23:50)</a>:</h4>
<p>Since we can prove the lub is unique, is a there a way to say the lub S instead of t is_lub S without the structure?</p>



<a name="205703382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703382">(Aug 01 2020 at 23:57)</a>:</h4>
<p>I end up defining things named lub_S to keep track that they are the lub of S. Just hoping there was a simpler way.</p>



<a name="205703540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703540">(Aug 02 2020 at 00:03)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">r</span>

<span class="n">def</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">epsilon</span> <span class="err">$</span> <span class="n">is_lub</span> <span class="n">S</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="205703591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703591">(Aug 02 2020 at 00:04)</a>:</h4>
<p>What does classical.epsilon $ is_lub S mean?</p>



<a name="205703602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703602">(Aug 02 2020 at 00:05)</a>:</h4>
<p><code>is_lub S</code> is a predicate on <code>\R</code></p>



<a name="205703605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703605">(Aug 02 2020 at 00:05)</a>:</h4>
<p><code>classical.epsilon</code> means, if there's some <code>r : \R</code> satisfying it, return <code>r</code></p>



<a name="205703606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703606">(Aug 02 2020 at 00:05)</a>:</h4>
<p>otherwise return a default element</p>



<a name="205703712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703712">(Aug 02 2020 at 00:09)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">},</span> <span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">r</span>

<span class="n">def</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">epsilon</span> <span class="err">$</span> <span class="n">is_lub</span> <span class="n">S</span>

<span class="kn">theorem</span> <span class="n">is_lub_unique</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">t₁</span> <span class="n">t₂</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ht₁</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t₁</span><span class="o">)</span> <span class="o">(</span><span class="n">ht₂</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">t₁</span> <span class="bp">=</span> <span class="n">t₂</span> <span class="o">:=</span>
<span class="n">le_antisymm</span> <span class="o">(</span><span class="n">ht₁</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ht₂</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">ht₂</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ht₁</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">eq_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">lub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">is_lub_unique</span> <span class="n">ht</span> <span class="err">$</span> <span class="n">classical</span><span class="bp">.</span><span class="n">epsilon_spec</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="205703717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703717">(Aug 02 2020 at 00:09)</a>:</h4>
<p>any this is the API for <code>lub</code></p>



<a name="205703719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703719">(Aug 02 2020 at 00:09)</a>:</h4>
<p>so you can forget about its definition</p>



<a name="205703779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703779">(Aug 02 2020 at 00:11)</a>:</h4>
<p>What would happen if I used lub S in a proof, and one didn't exist? Would I get an error in Lean?</p>



<a name="205703824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703824">(Aug 02 2020 at 00:12)</a>:</h4>
<p>did you read the definition of <code>lub</code>? did you put it in your VSCode? do you know what classical.epsilon is?</p>



<a name="205703877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703877">(Aug 02 2020 at 00:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205703606">said</a>:</p>
<blockquote>
<p>otherwise return a default element</p>
</blockquote>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span></p>



<a name="205703884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703884">(Aug 02 2020 at 00:14)</a>:</h4>
<p>you wouldn't get any error</p>



<a name="205703885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703885">(Aug 02 2020 at 00:14)</a>:</h4>
<p>but you wouldn't be able to prove anything about it in that case</p>



<a name="205703893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703893">(Aug 02 2020 at 00:15)</a>:</h4>
<p>treat it as an unspecified constant</p>



<a name="205703896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703896">(Aug 02 2020 at 00:15)</a>:</h4>
<p>I guess it isn't any different than saying t is_lub S. The assumption that t exists is in the statement.</p>



<a name="205703947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205703947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205703947">(Aug 02 2020 at 00:16)</a>:</h4>
<p>Why wouldn't I be able to prove anything about it?</p>



<a name="205704001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704001">(Aug 02 2020 at 00:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205703824">said</a>:</p>
<blockquote>
<p>did you read the definition of <code>lub</code>? did you put it in your VSCode? do you know what classical.epsilon is?</p>
</blockquote>
<p>Yes, but did not understand the result.</p>



<a name="205704064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704064">(Aug 02 2020 at 00:21)</a>:</h4>
<p>ah, it looks like the docstring for classical.epsilon just tells you the math name for the concept</p>



<a name="205704167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704167">(Aug 02 2020 at 00:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/205703947">said</a>:</p>
<blockquote>
<p>Why wouldn't I be able to prove anything about it?</p>
</blockquote>
<p>because it has no definition</p>



<a name="205704168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704168">(Aug 02 2020 at 00:24)</a>:</h4>
<p>it uses <code>classical.choice</code></p>



<a name="205704170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704170">(Aug 02 2020 at 00:24)</a>:</h4>
<p>which produces an element of any type <code>A</code> from a proof of <code>nonempty A</code> by fiat</p>



<a name="205704406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704406">(Aug 02 2020 at 00:32)</a>:</h4>
<p>(deleted)</p>



<a name="205704526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704526">(Aug 02 2020 at 00:37)</a>:</h4>
<p>I'm not sure I entirely follow. I guess my worry is that it is something like the definition of 0 - 1 = 0 if 0 and 1 are natural numbers. That is, I might prove something that I didn't expect I could.</p>



<a name="205704571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704571">(Aug 02 2020 at 00:38)</a>:</h4>
<p>if <code>S</code> doesn't have an LUB, then <code>lub S</code> will be some real number whose value is outside of your knowledge</p>



<a name="205704573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704573">(Aug 02 2020 at 00:38)</a>:</h4>
<p>it will behave like an arbiratry real number</p>



<a name="205704628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704628">(Aug 02 2020 at 00:40)</a>:</h4>
<p>I guess it isn't much different than saying t is_lub S then?</p>



<a name="205704631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704631">(Aug 02 2020 at 00:40)</a>:</h4>
<p>That is <code>t : \R</code> and <code>t is_lub S</code>.</p>



<a name="205704640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704640">(Aug 02 2020 at 00:41)</a>:</h4>
<p>Or is it actually safer?</p>



<a name="205704686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205704686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205704686">(Aug 02 2020 at 00:42)</a>:</h4>
<p>Because the arbitrary number won't have the properties of the lub to use?</p>



<a name="205705628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205705628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205705628">(Aug 02 2020 at 01:16)</a>:</h4>
<p>How do I get at the properties of lub S? That is, use the fact that it is an ub of S and it is leq to any ub of S in a proof.</p>



<a name="205709698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205709698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205709698">(Aug 02 2020 at 03:34)</a>:</h4>
<p>I guess I need to prove: <code>example (S : set ℝ) : is_lub S (lub S) :=</code> ?</p>



<a name="205709765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205709765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205709765">(Aug 02 2020 at 03:36)</a>:</h4>
<p>that would mean every set has lub</p>



<a name="205709877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205709877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205709877">(Aug 02 2020 at 03:41)</a>:</h4>
<p>How do I get at the properties of lub S?</p>



<a name="205716405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205716405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205716405">(Aug 02 2020 at 07:32)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">},</span> <span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">r</span>

<span class="n">def</span> <span class="n">lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">epsilon</span> <span class="err">$</span> <span class="n">is_lub</span> <span class="n">S</span>

<span class="kn">theorem</span> <span class="n">is_lub_unique</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">t₁</span> <span class="n">t₂</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ht₁</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t₁</span><span class="o">)</span> <span class="o">(</span><span class="n">ht₂</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">t₁</span> <span class="bp">=</span> <span class="n">t₂</span> <span class="o">:=</span>
<span class="n">le_antisymm</span> <span class="o">(</span><span class="n">ht₁</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ht₂</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">ht₂</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ht₁</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">is_lub_lub</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="o">(</span><span class="n">lub</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">epsilon_spec</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">eq_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">lub</span> <span class="n">S</span> <span class="o">:=</span>
<span class="n">is_lub_unique</span> <span class="n">ht</span> <span class="err">$</span> <span class="n">is_lub_lub</span> <span class="n">ht</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="205716406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205716406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205716406">(Aug 02 2020 at 07:32)</a>:</h4>
<p>is this enough API?</p>



<a name="205716407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205716407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205716407">(Aug 02 2020 at 07:32)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span></p>



<a name="205737796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205737796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205737796">(Aug 02 2020 at 18:15)</a>:</h4>
<p>Thank you!</p>



<a name="205930211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/205930211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Shapero <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#205930211">(Aug 04 2020 at 16:43)</a>:</h4>
<p>I was curious about defining Riemann integration and started experimenting with it as well -- I was wondering whether it might be easier to define partitions as a vector of real numbers rather than a mapping from <code>fin</code>? If it's a vector, you can easily pull in some of the existing machinery for sorting lists; for example merging two partitions just reduces to a single library call</p>



<a name="206189521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206189521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206189521">(Aug 06 2020 at 20:00)</a>:</h4>
<p>That sounds simpler. I don't know though, I'm new at this.</p>



<a name="206318611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206318611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206318611">(Aug 07 2020 at 23:04)</a>:</h4>
<p>I would also be interested in hearing opinions on this.</p>



<a name="206321731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206321731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Dan Stanescu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206321731">(Aug 08 2020 at 00:04)</a>:</h4>
<p>It may just largely be a matter of preference. After having used <code>fin</code> for one proof I realize that you need to have everything set up very well from the very beginning in order not to bump into nasty coercion problems. For people with computational background thinking in terms of <code>vector</code> will probably seem more natural. I'm curious what other people with more Lean experience have to say, but it's good to bear in mind that the interface/API (i.e. for <code>fin</code> and <code>vector</code>) is of utmost importance. Also, I don't think you'll have to "sort" in the classical computer-science meaning of the term, where you really handle list/vector elements (like in a "quicksort" algorithm, say). You'll just be dealing with proofs that your sequences are <code>monotone</code>.</p>



<a name="206329453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206329453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206329453">(Aug 08 2020 at 03:36)</a>:</h4>
<p>I'm trying to fill in the first sorry in this theorem. By using a rewrite and <code>set.​mem_set_of_eq</code> I can get to<code>z ∈ Z = ∃ x ∈ X, ∃ y ∈ Y, z = x + y</code>, but then I get stuck. I'm wondering it it would be simpler if I had stated the theorem differently, but I'm not sure how.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="o">(</span><span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">≥</span> <span class="n">t</span><span class="o">)</span>


<span class="kn">theorem</span> <span class="n">sum_of_lub</span>
<span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">X</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">Z</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">})</span>
<span class="o">:</span> <span class="n">is_lub</span> <span class="n">Z</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">is_ub</span> <span class="n">Z</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
  <span class="k">assume</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">Z</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s10</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">s10</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s100</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">Z</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">s100</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="206330050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206330050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206330050">(Aug 08 2020 at 03:57)</a>:</h4>
<p>I guess finish works. I don't understand the description of finish though.</p>



<a name="206333403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206333403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206333403">(Aug 08 2020 at 05:42)</a>:</h4>
<p>I'm not sure what I have done wrong here:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>


<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="o">(</span><span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">≥</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">example</span>
<span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">X</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">Z</span> <span class="bp">=</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">})</span>
<span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">Z</span><span class="o">,</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">Z</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="n">finish</span><span class="o">,</span>
  <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">s2</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">x&#39;</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">y&#39;</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">y&#39;</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x&#39;</span> <span class="bp">+</span> <span class="n">y&#39;</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">is_ub</span> <span class="n">X</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h0</span><span class="bp">.</span><span class="n">elim_left</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">s4</span> <span class="n">x&#39;</span> <span class="n">a2</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">is_ub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1</span><span class="bp">.</span><span class="n">elim_left</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">y&#39;</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">s6</span> <span class="n">y&#39;</span> <span class="n">a3</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span>
  <span class="o">)</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="206334756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206334756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206334756">(Aug 08 2020 at 06:26)</a>:</h4>
<p><code>(Z = {z | ∃ x ∈ X, ∃ y ∈ Y, z = x + y})</code> is just incorrect</p>



<a name="206334790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206334790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206334790">(Aug 08 2020 at 06:27)</a>:</h4>
<p>ok, incorrect is a bit strong, but it doesn't have its intended meaning?</p>



<a name="206334833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206334833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206334833">(Aug 08 2020 at 06:28)</a>:</h4>
<p>Lean treats it as <code>(Z) (H : Z = {z | ∃ x ∈ X, ∃ y ∈ Y, z = x + y})</code></p>



<a name="206334840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206334840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206334840">(Aug 08 2020 at 06:28)</a>:</h4>
<p>which I guess still works</p>



<a name="206335059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206335059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206335059">(Aug 08 2020 at 06:35)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pointwise</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">⦃</span><span class="n">s</span><span class="o">⦄,</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span> <span class="c1">-- implicit argument</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">⦄,</span> <span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">≤</span> <span class="n">r</span> <span class="c1">-- we prefer `≤`; extra bracket removed; implicit</span>

<span class="kn">theorem</span> <span class="n">is_lub_add</span>
  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">X</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_lub</span> <span class="o">(</span><span class="n">X</span> <span class="bp">+</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="c1">-- `X + Y := { z | ∃ x y, x ∈ X ∧ y ∈ Y ∧ x + y = z }`</span>
<span class="bp">⟨λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hxy</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hz</span> <span class="k">in</span>
  <span class="n">hxy</span> <span class="bp">▸</span> <span class="n">add_le_add</span> <span class="o">(</span><span class="n">h0</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hx</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hy</span><span class="o">),</span>
<span class="bp">λ</span> <span class="n">r</span> <span class="n">hr</span><span class="o">,</span> <span class="n">add_le_of_le_sub_left</span> <span class="err">$</span> <span class="n">h1</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">le_sub</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">h0</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">le_sub_iff_add_le</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span>
  <span class="n">hr</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩⟩</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="206335061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206335061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206335061">(Aug 08 2020 at 06:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> deja vu?</p>



<a name="206336348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336348">(Aug 08 2020 at 07:19)</a>:</h4>
<p>Do you know why I get <code>type mismatch at application</code> for the  <code>exists.elim s2</code>?</p>



<a name="206336352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336352">(Aug 08 2020 at 07:19)</a>:</h4>
<p>don't use <code>exists.elim</code></p>



<a name="206336353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336353">(Aug 08 2020 at 07:19)</a>:</h4>
<p>use <code>let</code></p>



<a name="206336453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336453">(Aug 08 2020 at 07:22)</a>:</h4>
<p>That works on existential elimination?</p>



<a name="206336460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336460">(Aug 08 2020 at 07:23)</a>:</h4>
<p>Is there an example somewhere?</p>



<a name="206336690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Utensil Song <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336690">(Aug 08 2020 at 07:32)</a>:</h4>
<p>Another more natural choice is to use <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#obtain">tactic#obtain</a> , example:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">lint</span>

<span class="kn">open</span> <span class="n">int</span>

<span class="kn">theorem</span> <span class="n">le</span><span class="bp">.</span><span class="n">antisymm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">},</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">assume</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="k">assume</span> <span class="o">(</span><span class="n">H₁</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H₂</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">),</span>
<span class="k">obtain</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">Hn</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">le</span><span class="bp">.</span><span class="n">dest</span> <span class="n">H₁</span><span class="o">,</span>
<span class="k">obtain</span> <span class="bp">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">Hm</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">le</span><span class="bp">.</span><span class="n">dest</span> <span class="n">H₂</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H₃</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span>
  <span class="k">calc</span>
    <span class="n">a</span> <span class="bp">+</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span>                     <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">of_nat_eq_coe</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span>                       <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_assoc</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">m</span>                           <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">Hn</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span>                               <span class="o">:</span> <span class="n">Hm</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span>                           <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_zero</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H₄</span> <span class="o">:</span> <span class="n">of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">of_nat</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">add_left_cancel</span> <span class="n">H₃</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H₅</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>                 <span class="k">from</span> <span class="n">of_nat</span><span class="bp">.</span><span class="n">inj</span> <span class="n">H₄</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h₆</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>                     <span class="k">from</span> <span class="n">nat</span><span class="bp">.</span><span class="n">eq_zero_of_add_eq_zero_right</span> <span class="n">H₅</span><span class="o">,</span>
<span class="k">show</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span>
  <span class="k">calc</span>
    <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">0</span>    <span class="o">:</span> <span class="k">by</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">]</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">n</span>    <span class="o">:</span> <span class="k">by</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">h₆</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_zero</span><span class="o">]</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span>        <span class="o">:</span> <span class="n">Hn</span>
<span class="kn">end</span>
</code></pre></div>



<a name="206336844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336844">(Aug 08 2020 at 07:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/206336460">said</a>:</p>
<blockquote>
<p>Is there an example somewhere?</p>
</blockquote>
<p>look at my proof</p>



<a name="206336847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206336847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206336847">(Aug 08 2020 at 07:36)</a>:</h4>
<p>the <code>let</code> I used is the existential elimination</p>



<a name="206338859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206338859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206338859">(Aug 08 2020 at 08:42)</a>:</h4>
<p>Bit higher level than Kenny's:</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">intros</span> <span class="n">z</span> <span class="n">a1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">H</span><span class="o">]</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">a1</span><span class="o">,</span>
  <span class="n">linarith</span> <span class="o">[</span><span class="n">h0</span><span class="bp">.</span><span class="n">left</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">h1</span><span class="bp">.</span><span class="n">left</span> <span class="n">y</span> <span class="n">hy</span><span class="o">],</span>
</code></pre></div>



<a name="206356861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206356861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206356861">(Aug 08 2020 at 17:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/206335061">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> deja vu?</p>
</blockquote>
<p>?</p>



<a name="206357641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206357641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206357641">(Aug 08 2020 at 18:01)</a>:</h4>
<p>Is there a way to make it more verbose? Something like <code>obtain (x : ℝ, hx : x ∈ X, y : ℝ, hy : y ∈ Y, h : z = x + y) from a1,</code>?</p>



<a name="206362001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362001">(Aug 08 2020 at 20:02)</a>:</h4>
<p>Something like</p>
<div class="codehilite"><pre><span></span><code><span class="k">obtain</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">}</span> <span class="o">:=</span> <span class="n">a1</span><span class="o">,</span>
</code></pre></div>


<p>(untested)</p>



<a name="206362169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362169">(Aug 08 2020 at 20:07)</a>:</h4>
<p>Sorry, I was thinking more along the lines of showing explicitly what <code>hx</code>, <code>hy</code>,  and <code>h</code> get assigned to in the <code>obtain</code> statement.</p>



<a name="206362533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362533">(Aug 08 2020 at 20:17)</a>:</h4>
<p>Yeah, I don't think that's possible</p>



<a name="206362585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362585">(Aug 08 2020 at 20:18)</a>:</h4>
<p>:(</p>



<a name="206362779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362779">(Aug 08 2020 at 20:24)</a>:</h4>
<p>I might prefer the <code>exists.elim</code> then, as it shows more of the details in the proof itself. I'm still not sure why I get <code>type mismatch at application</code> for the <code>exists.elim s2</code> though.</p>



<a name="206362918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362918">(Aug 08 2020 at 20:29)</a>:</h4>
<p>That's definitely possible</p>



<a name="206362974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362974">(Aug 08 2020 at 20:30)</a>:</h4>
<p>use <code>rcases a_eq : a1 with  ⟨x, hx, y, hy, h⟩</code></p>



<a name="206362979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206362979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206362979">(Aug 08 2020 at 20:30)</a>:</h4>
<p>I don't know if <code>obtain</code> has a similar syntax</p>



<a name="206363057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363057">(Aug 08 2020 at 20:34)</a>:</h4>
<p>Sorry, I'm not sure I see the difference. I still need to go to the other window to read what x, hx, etc. are?</p>



<a name="206363096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363096">(Aug 08 2020 at 20:34)</a>:</h4>
<p>what's the mwe?</p>



<a name="206363109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363109">(Aug 08 2020 at 20:35)</a>:</h4>
<p>Oh I misunderstood your question</p>



<a name="206363160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363160">(Aug 08 2020 at 20:36)</a>:</h4>
<p>I've been planning to add support for type ascriptions in rcases/obtain, so that you could write</p>
<div class="codehilite"><pre><span></span><code><span class="k">obtain</span> <span class="bp">⟨</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">h</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">⟩</span> <span class="k">from</span> <span class="n">a1</span><span class="o">,</span>
</code></pre></div>



<a name="206363170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363170">(Aug 08 2020 at 20:37)</a>:</h4>
<p>Yes, that is what I meant. That would be great.</p>



<a name="206363181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363181">(Aug 08 2020 at 20:37)</a>:</h4>
<p>you might have to put parentheses around the type ascriptions, for consistency with other uses of type ascription</p>



<a name="206363229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363229">(Aug 08 2020 at 20:38)</a>:</h4>
<p>it also might interact with <code>|</code> in a weird way if you have a notation that uses <code>|</code></p>



<a name="206363550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206363550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206363550">(Aug 08 2020 at 20:49)</a>:</h4>
<p>I don't mind using exists.elim, but I think I am applying it to the double exists wrong?</p>



<a name="206364293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206364293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206364293">(Aug 08 2020 at 21:14)</a>:</h4>
<p>I think I got it!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">pointwise</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">def</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_ub</span> <span class="n">S</span> <span class="n">t</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="o">(</span><span class="n">is_ub</span> <span class="n">S</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">≥</span> <span class="n">t</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">is_lub_add</span>
  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">X</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">is_ub</span> <span class="o">(</span><span class="n">X</span> <span class="bp">+</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">+</span> <span class="n">Y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">),</span> <span class="k">from</span> <span class="n">a1</span><span class="o">,</span>
  <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">s1</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">x&#39;</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">x&#39;</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span> <span class="bp">∧</span> <span class="n">x&#39;</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span>
      <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">a2</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">y&#39;</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
        <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="err">∈</span> <span class="n">X</span> <span class="bp">∧</span> <span class="n">y&#39;</span> <span class="err">∈</span> <span class="n">Y</span> <span class="bp">∧</span> <span class="n">x&#39;</span> <span class="bp">+</span> <span class="n">y&#39;</span> <span class="bp">=</span> <span class="n">z</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">is_ub</span> <span class="n">X</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">h0</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span> <span class="n">s2</span> <span class="n">x&#39;</span> <span class="n">a3</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">is_ub</span> <span class="n">Y</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">h1</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">y&#39;</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">s4</span> <span class="n">y&#39;</span> <span class="n">a3</span><span class="bp">.</span><span class="n">right</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="bp">+</span> <span class="n">y&#39;</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
        <span class="k">show</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span>
      <span class="o">)</span>
  <span class="o">)</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="206366973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206366973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206366973">(Aug 08 2020 at 22:32)</a>:</h4>
<p>Where does this error come from?<br>
<a href="/user_uploads/3121/JpWWXTYgBcdKd0dmile1ToAF/Screenshot-from-2020-08-08-15-31-29.png">Screenshot-from-2020-08-08-15-31-29.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/JpWWXTYgBcdKd0dmile1ToAF/Screenshot-from-2020-08-08-15-31-29.png" title="Screenshot-from-2020-08-08-15-31-29.png"><img src="/user_uploads/3121/JpWWXTYgBcdKd0dmile1ToAF/Screenshot-from-2020-08-08-15-31-29.png"></a></div>



<a name="206366986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206366986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206366986">(Aug 08 2020 at 22:33)</a>:</h4>
<p>Oh</p>



<a name="206366993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206366993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206366993">(Aug 08 2020 at 22:33)</a>:</h4>
<p>I got this one quite a lot, I was about to ask the same thing</p>



<a name="206367067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367067">(Aug 08 2020 at 22:34)</a>:</h4>
<p>Well, I know why this happens : the hypothesis <code>is_ub (X+Y) r</code> in the implication is implicitly named <code>a</code>, shadowing the <code>a</code> you want</p>



<a name="206367153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367153">(Aug 08 2020 at 22:37)</a>:</h4>
<p>But the only way to avoid this I know is writing the implication as a forall, namely <code>\for (h : is_ub (X+Y) r), ...</code>. This way you can name the hypothesis so no problem of shadowing. But this is quite ugly, so maybe there's a better solution ?</p>



<a name="206367307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367307">(Aug 08 2020 at 22:41)</a>:</h4>
<p>How are you able to tell that the hypothesis is implicitly named <code>a</code>?</p>



<a name="206367378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367378">(Aug 08 2020 at 22:43)</a>:</h4>
<p>By reading the error message <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span> The type of <code>a</code> is exactly the left side of your implication, which means precisely that <code>a</code> is a proof of <code>is_ub (X+Y) r</code></p>



<a name="206367435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367435">(Aug 08 2020 at 22:44)</a>:</h4>
<p>I see. Well, changing <code>a</code> and <code>b</code> to <code>t0</code> and <code>t1</code> fixes it. That works I guess.</p>



<a name="206367450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367450">(Aug 08 2020 at 22:45)</a>:</h4>
<p>Thank you.</p>



<a name="206367538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206367538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206367538">(Aug 08 2020 at 22:48)</a>:</h4>
<p>No problem ! It would be nice for this to be fixed at some point anyway, but maybe it's harder than I imagine</p>



<a name="206379893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206379893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206379893">(Aug 09 2020 at 05:24)</a>:</h4>
<p>just use <code>guard_hyp</code></p>



<a name="206380029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206380029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206380029">(Aug 09 2020 at 05:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/206363160">said</a>:</p>
<blockquote>
<p>I've been planning to add support for type ascriptions in rcases/obtain, so that you could write</p>
<div class="codehilite"><pre><span></span><code><span class="k">obtain</span> <span class="bp">⟨</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="n">h</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">⟩</span> <span class="k">from</span> <span class="n">a1</span><span class="o">,</span>
</code></pre></div>


</blockquote>
<p>This works now, as of <a href="https://github.com/leanprover-community/mathlib/issues/3730">#3730</a>, which is a significant rewrite of <code>rcases</code> to support some more flexible pattern syntax. You can now use parentheses like <code>(a | b) | c</code> in patterns instead of the previous strict alternation of and/or</p>



<a name="206388310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206388310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206388310">(Aug 09 2020 at 10:06)</a>:</h4>
<p>Build is failing.</p>



<a name="206409589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206409589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206409589">(Aug 09 2020 at 20:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/206379893">said</a>:</p>
<blockquote>
<p>just use <code>guard_hyp</code></p>
</blockquote>
<p>Could you explain a bit more what you meant ?</p>



<a name="206428801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206428801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206428801">(Aug 10 2020 at 05:14)</a>:</h4>
<p>you can use <code>guard_hyp</code> to assert that a hypothesis has a certain type</p>



<a name="206428809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/206428809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#206428809">(Aug 10 2020 at 05:15)</a>:</h4>
<p>so if you want to assert that <code>hx</code> has type <code>x \in X</code> then just use <code>guard_hyp</code></p>



<a name="209937624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209937624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209937624">(Sep 13 2020 at 16:02)</a>:</h4>
<p>I'm trying to define a partition using a list. Is this a good definition?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_head</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">head&#39;</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">last&#39;</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span>   <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">real</span><span class="bp">.</span><span class="n">le</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>


<p>I think the <code>x_head</code> and <code>x_last</code> constructors ensure that the list is not empty?<br>
Using that I am trying to define the norm. I looked at using <code>list.foldr</code> for taking the max, but it requires an initial accumulator value that I would like to avoid.</p>



<a name="209937832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209937832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209937832">(Sep 13 2020 at 16:07)</a>:</h4>
<p>I think maybe I need something like the <code>foldr1</code> function in Haskell.</p>



<a name="209941127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941127">(Sep 13 2020 at 17:30)</a>:</h4>
<p>Is there a way to have an option to show the types in the mathlib generated documentation?</p>



<a name="209941319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941319">(Sep 13 2020 at 17:35)</a>:</h4>
<p>For example that <code>l</code> is a list in the definition of a vector?<br>
<a href="https://leanprover-community.github.io/mathlib_docs/core/data/vector.html#vector">https://leanprover-community.github.io/mathlib_docs/core/data/vector.html#vector</a></p>



<a name="209941381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941381">(Sep 13 2020 at 17:36)</a>:</h4>
<p>If you click on "source" you see <code>def vector (α : Type u) (n : ℕ) := { l : list α // l.length = n }</code> . Does this answer your question?</p>



<a name="209941401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941401">(Sep 13 2020 at 17:37)</a>:</h4>
<p>I was being lazy and thought it might be nice to have an option to avoid that :)</p>



<a name="209941477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941477">(Sep 13 2020 at 17:39)</a>:</h4>
<p>Sorry</p>



<a name="209941485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941485">(Sep 13 2020 at 17:40)</a>:</h4>
<p><code>#print vector</code> within a Lean file should also tell you everything about it</p>



<a name="209941548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941548">(Sep 13 2020 at 17:41)</a>:</h4>
<p>Even more work :)</p>



<a name="209941558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941558">(Sep 13 2020 at 17:41)</a>:</h4>
<p>If you hover over <code>.length</code> in <code>l.length</code>, you can see that the URL ends in <code>list.length</code> which is a clue. But feel free to open an issue <a href="https://github.com/leanprover-community/doc-gen/issues">here</a>.</p>



<a name="209941574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209941574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209941574">(Sep 13 2020 at 17:41)</a>:</h4>
<p>Ok. Thank you.</p>



<a name="209942003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209942003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209942003">(Sep 13 2020 at 17:52)</a>:</h4>
<p>Added: <a href="https://github.com/leanprover-community/doc-gen/issues/63">https://github.com/leanprover-community/doc-gen/issues/63</a></p>



<a name="209944740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944740">(Sep 13 2020 at 18:56)</a>:</h4>
<p>If a vector is based on a list, how do you use the functions defined for lists on it? Do you have to cast it to a list first?</p>



<a name="209944750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944750">(Sep 13 2020 at 18:57)</a>:</h4>
<p>A vector is a pair consisting of a list and a proof.</p>



<a name="209944827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944827">(Sep 13 2020 at 18:58)</a>:</h4>
<p><code> vector α n = {l // l.length = n}</code> defines a list and a proof?</p>



<a name="209944839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944839">(Sep 13 2020 at 18:59)</a>:</h4>
<p>The proof comes from the type somehow?</p>



<a name="209944914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944914">(Sep 13 2020 at 19:00)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html?highlight=subtype#inductively-defined-propositions">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html?highlight=subtype#inductively-defined-propositions</a></p>



<a name="209944929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209944929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209944929">(Sep 13 2020 at 19:00)</a>:</h4>
<p>the proof comes from the proof which you'll supply that l.length=n when you're making the term. vector is a subtype -- see the link above.</p>



<a name="209946379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209946379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209946379">(Sep 13 2020 at 19:34)</a>:</h4>
<p>So I should be able to get at the list by using <code>.val</code>?</p>



<a name="209946598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209946598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209946598">(Sep 13 2020 at 19:41)</a>:</h4>
<p>Got it. Thank you.</p>



<a name="209947869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209947869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209947869">(Sep 13 2020 at 20:14)</a>:</h4>
<p>Is there a function defined similar to <code>vector.head</code> for getting the last element of the vector where you don't have to worry about the vector being <code>nil</code>?</p>



<a name="209948965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209948965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209948965">(Sep 13 2020 at 20:48)</a>:</h4>
<p>I'm trying to make something like this work:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">vector</span><span class="bp">.</span><span class="n">head</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">vector</span><span class="bp">.</span><span class="n">last</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">real</span><span class="bp">.</span><span class="n">le</span> <span class="n">x</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">pointed_partition</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">ℝ</span> <span class="n">n</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">y</span><span class="bp">.</span><span class="n">at</span> <span class="n">m</span> <span class="err">∈</span> <span class="n">set</span><span class="bp">.</span><span class="n">Icc</span> <span class="o">((</span><span class="n">x</span><span class="bp">.</span><span class="n">at</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">at</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span>
</code></pre></div>



<a name="209950071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950071">(Sep 13 2020 at 21:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/209947869">said</a>:</p>
<blockquote>
<p>Is there a function defined similar to <code>vector.head</code> for getting the last element of the vector where you don't have to worry about the vector being <code>nil</code>?</p>
</blockquote>
<p>I don't know the vector or list API's at all but why don't you just write the precise function you want and then ask whether this precise function is already there?</p>



<a name="209950089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950089">(Sep 13 2020 at 21:21)</a>:</h4>
<p>I can write the type, but I'm having trouble defining it.</p>



<a name="209950151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950151">(Sep 13 2020 at 21:23)</a>:</h4>
<p>The same as this but returns the last element instead of the first:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">head</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">⟨</span> <span class="o">[],</span>    <span class="n">h</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="bp">⟨</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">v</span><span class="o">,</span> <span class="n">h</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="n">a</span>
</code></pre></div>



<a name="209950326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950326">(Sep 13 2020 at 21:28)</a>:</h4>
<p>It doesn't seem to exist already.  One way is to define it with <code>vector.nth</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>

<span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">last</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">v</span><span class="bp">.</span><span class="n">nth</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">less_than_or_equal</span><span class="bp">.</span><span class="n">refl</span><span class="bp">⟩</span>
</code></pre></div>



<a name="209950378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950378">(Sep 13 2020 at 21:30)</a>:</h4>
<p>Nice. Thank you.</p>



<a name="209950383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950383">(Sep 13 2020 at 21:30)</a>:</h4>
<p>Another is in terms of <code>list.last</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>

<span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">last</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="o">[],</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">a</span> <span class="bp">::</span> <span class="n">v</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">::</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">last</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span>
</code></pre></div>



<a name="209950397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950397">(Sep 13 2020 at 21:31)</a>:</h4>
<p>In the first, should n be n + 1 in the body?</p>



<a name="209950455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950455">(Sep 13 2020 at 21:33)</a>:</h4>
<p>I don't think so, since if you have a vector of length n+1, since it's zero-indexed the last element will be indexed by n.</p>



<a name="209950462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950462">(Sep 13 2020 at 21:33)</a>:</h4>
<p>Oh. Right.</p>



<a name="209950589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950589">(Sep 13 2020 at 21:36)</a>:</h4>
<p>I don't know how heavily you're invested in <code>vector</code>, but all of these things (I think) are already in the API for <code>fin n</code>, i.e. representations of <code>n</code>-tuples as <code>fin n \to A</code>.</p>



<a name="209950602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950602">(Sep 13 2020 at 21:37)</a>:</h4>
<p>And data.matrix.notation has nice notation for those</p>



<a name="209950733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950733">(Sep 13 2020 at 21:40)</a>:</h4>
<p>Not completely invested. I just figured that since there is a lot of beginner documentation and tutorials on lists and vectors that I would understand it better by going with that.</p>



<a name="209950769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950769">(Sep 13 2020 at 21:41)</a>:</h4>
<p>For example I don't understand <code>(finset.univ : finset (fin P.n)).sup (λ j, (P.x j.cast_succ - P.x j.succ))</code></p>



<a name="209950824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950824">(Sep 13 2020 at 21:43)</a>:</h4>
<p>Where's that from?</p>



<a name="209950877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950877">(Sep 13 2020 at 21:44)</a>:</h4>
<p>Much earlier in the thread.</p>



<a name="209950939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950939">(Sep 13 2020 at 21:46)</a>:</h4>
<p>Oh, I see. In the link for the lean web editor? Note the commented out notation there :)</p>



<a name="209950945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209950945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209950945">(Sep 13 2020 at 21:46)</a>:</h4>
<p>That should be approximately familiar mathematical notation.</p>



<a name="209951021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951021">(Sep 13 2020 at 21:48)</a>:</h4>
<p>Yeah. I'm going to have to prove things about it though.</p>



<a name="209951036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951036">(Sep 13 2020 at 21:49)</a>:</h4>
<p>This is another reason to use <code>fin n</code>if the API is more developed.</p>



<a name="209951092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951092">(Sep 13 2020 at 21:50)</a>:</h4>
<p>True.</p>



<a name="209951100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951100">(Sep 13 2020 at 21:51)</a>:</h4>
<p>If I understand the API :)</p>



<a name="209951165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951165">(Sep 13 2020 at 21:53)</a>:</h4>
<p>I'll probably move on to it at some point.</p>



<a name="209951440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951440">(Sep 13 2020 at 22:00)</a>:</h4>
<p>What is the * after Type by the way?</p>



<a name="209951447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951447">(Sep 13 2020 at 22:00)</a>:</h4>
<p>It tells lean to go and figure out the universe variable.</p>



<a name="209951448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209951448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209951448">(Sep 13 2020 at 22:00)</a>:</h4>
<p>Ah.</p>



<a name="209952950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209952950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209952950">(Sep 13 2020 at 22:40)</a>:</h4>
<p>The finset.univ line says that, for all values of (fin P.n), that is, from 0 to n-1.</p>



<a name="209952971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209952971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209952971">(Sep 13 2020 at 22:41)</a>:</h4>
<p>Then the supremum of the set of all those values, under the map taking each such value j to P.x[j + 1] - P.x[j]</p>



<a name="209952974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209952974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209952974">(Sep 13 2020 at 22:41)</a>:</h4>
<p>In python list accession syntax</p>



<a name="209953096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209953096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209953096">(Sep 13 2020 at 22:44)</a>:</h4>
<p>finset.univ means a finset (a finite set) of all the terms for a given type</p>



<a name="209962399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962399">(Sep 14 2020 at 03:30)</a>:</h4>
<p>For my own understanding, this seemed to work? Is this right?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kn">inductive</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>


<span class="kn">inductive</span> <span class="n">vector</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">vector</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>
<span class="c1">-- a : element to prepend, n : length of vector to prepend to, v : vector to prepend to</span>
<span class="c1">-- note the use of n in the type of v</span>


<span class="n">def</span> <span class="n">first</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span>


<span class="n">def</span> <span class="n">v1</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">nil</span>
<span class="n">def</span> <span class="n">v2</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="n">v1</span>
<span class="n">def</span> <span class="n">v3</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="n">succ</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:=</span> <span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="n">succ</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="n">succ</span> <span class="n">v2</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">first</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="n">v2</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">first</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">.</span><span class="n">succ</span> <span class="n">v3</span>


<span class="n">def</span> <span class="n">last</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">vector</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span> <span class="n">vector</span><span class="bp">.</span><span class="n">nil</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">cons</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">last</span> <span class="n">n</span> <span class="n">v</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="209962464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962464">(Sep 14 2020 at 03:32)</a>:</h4>
<p><code>first</code> and <code>last</code> didn't seem to need a proof that the vector wasn't empty like the ones in the library, so I'm a little unsure. I am guessing that is because of the way that <code>vector</code> was defined?</p>



<a name="209962477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962477">(Sep 14 2020 at 03:33)</a>:</h4>
<p>Functionally I think this is equivalent though?</p>



<a name="209962680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962680">(Sep 14 2020 at 03:39)</a>:</h4>
<p>The proof that it isn't empty in your definition is that the patterns you're matching on require a vector of length (n + 1)</p>



<a name="209962740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962740">(Sep 14 2020 at 03:41)</a>:</h4>
<p>If you want to play more with these definitions, you could make se arguments implicit, like making the length argument to cons or first or last implicit. Since it can be inferred from the type of vector.</p>



<a name="209962746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962746">(Sep 14 2020 at 03:41)</a>:</h4>
<p>Also, look into Pi types, which are type level foralls</p>



<a name="209962855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962855">(Sep 14 2020 at 03:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/209962680">said</a>:</p>
<blockquote>
<p>The proof that it isn't empty in your definition is that the patterns you're matching on require a vector of length (n + 1)</p>
</blockquote>
<p>That is what I was guessing.</p>



<a name="209962858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/209962858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#209962858">(Sep 14 2020 at 03:44)</a>:</h4>
<p>Thank you.</p>



<a name="210618445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210618445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210618445">(Sep 19 2020 at 14:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/209952950">said</a>:</p>
<blockquote>
<p>The finset.univ line says that, for all values of (fin P.n), that is, from 0 to n-1.</p>
</blockquote>
<p>I'm sorry, I'm still not sure I get this. Maybe if the steps were broken apart it would be easier to see? How would it look if we first took the differences and then the sup? What would be the least abstract way to build this up from just the definition of fin?</p>



<a name="210619916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210619916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210619916">(Sep 19 2020 at 15:13)</a>:</h4>
<p><code>fin n</code> is the subtype of <code>nat</code> of nats which are less than <code>n</code>.<br>
<code>finset (fin n)</code> is the type of all finite sets (unordered lists with no duplicates) whose members are all from <code>fin n</code>.<br>
<code>univ</code> (or <code>finset.univ</code> if the namespace isn't open) is the term of <code>finset X</code> containing all terms of type <code>X</code> when <code>X</code> is a type with only finitely many terms (which <code>fin n</code> is).<br>
If you just type <code>#check finset.univ</code> lean doesn't know what you want a finset of so <code>(finset.univ : finset (fin n))</code> is the term representing the set of all the terms of <code>fin n</code>.<br>
<code>finset.sup</code> then takes the supremum of the function <code>(λ j, (P.x j.cast_succ - P.x j.succ))</code> over the specified set, with the dot notation so it comes after the set, in this case <code>univ</code>.</p>



<a name="210620038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210620038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210620038">(Sep 19 2020 at 15:16)</a>:</h4>
<p>I think this code is taking the differences first then the sup already. The <code>(λ j, (P.x j.cast_succ - P.x j.succ))</code> function is applied to each term of <code>fin P.n</code> and the sup is taken of those values as it goes.</p>



<a name="210620251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210620251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210620251">(Sep 19 2020 at 15:21)</a>:</h4>
<p>So <code>finset (fin 3)</code> has the terms <code>[0, 1, 2], [0, 2, 1], [1, 0, 2]</code> etc.?</p>



<a name="210620346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210620346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210620346">(Sep 19 2020 at 15:23)</a>:</h4>
<p>By unordered I mean the ordering doesn't matter, so its<br>
<code>{}, {0}, {1}, {2}, {0,1}, {0,2}, {1,2}, {0,1,2}</code><br>
and the last one there is <code>univ</code>.</p>



<a name="210620567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210620567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210620567">(Sep 19 2020 at 15:29)</a>:</h4>
<p>I see.<br>
What happens if the set has only one element? If I'm reading the definition of partition correctly, I think it allows that?</p>



<a name="210621960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210621960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210621960">(Sep 19 2020 at 16:01)</a>:</h4>
<p>It looks like it is using some kind of fold. Maybe it defaults to some value?</p>



<a name="210623422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210623422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210623422">(Sep 19 2020 at 16:35)</a>:</h4>
<p>If the partition has 1 element then <code>n = 0</code> as it is a map from <code>fin (n + 1) \to \R\ge0</code> so I think in that case its the <code>sup</code> over the empty set, which defaults to the infimum of the whole target. Which version of the code are you using, it changed a bit throughout this thread.</p>



<a name="210623971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210623971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210623971">(Sep 19 2020 at 16:46)</a>:</h4>
<p>I was thinking that since it is taking adjacent differences there would be a problem with the set of only one element, since that element does not have an adjacent element.</p>



<a name="210624063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624063">(Sep 19 2020 at 16:48)</a>:</h4>
<p>I had been looking at the following code, but now it gives an error next to the .sup:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>

<span class="n">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="c1">-- := ⨆ i : fin P.n, P.x i.succ - P.x i.cast_succ</span>
<span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P</span><span class="bp">.</span><span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">-</span> <span class="n">P</span><span class="bp">.</span><span class="n">x</span> <span class="n">j</span><span class="bp">.</span><span class="n">succ</span><span class="o">))</span>

<span class="kn">end</span> <span class="n">partition</span>
</code></pre></div>



<a name="210624343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624343">(Sep 19 2020 at 16:55)</a>:</h4>
<p>Also, why is it <code>(finset.univ : finset (fin P.n))</code> instead of <code>(finset.univ (finset (fin P.n)))</code>?</p>



<a name="210624473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624473">(Sep 19 2020 at 16:58)</a>:</h4>
<p>the colon is specifying the type of the term on the left. <code>finset.univ</code> takes no explicit arguments, if you type <code>#check finset.univ</code> you should see <code>finset.univ : finset ?M_1</code>, so there are no arguments to be filled in, but there is a metavariable in the type, which means that lean doesn't know what sort of  finset the term <code> finset.univ</code>  is without extra hints, which is what the <code>: </code> is doing, telling lean what type you expect it to be.</p>



<a name="210624540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624540">(Sep 19 2020 at 17:00)</a>:</h4>
<p>You could instead tell lean you want to specify implicit arguments as arguments directly,  by using <code>@finset.univ</code>, the type of this is now  <code>finset.univ : Π {α : Type u_1} [_inst_1 : fintype α], finset α</code>, which we see has 2 arguments, the type and the fact it is a fintype, so we could write instead, <code>(@finset.univ (fin P.n)).sup ...</code></p>



<a name="210624635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624635">(Sep 19 2020 at 17:02)</a>:</h4>
<p>I see. Thank you.</p>



<a name="210624636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624636">(Sep 19 2020 at 17:02)</a>:</h4>
<p>The error next to the sup is discussed somewhere above in the thread, but its basically the issue you are worried about, if there is only one thing in the partition lean want to assign some default value to the norm, as its a sup over an empty set, but it doesn't have a sensible choice, as <code>\R</code> has no minimal element. Thats why in the version I gave a while ago I switched it to <code> \R\ge0</code>, which has a minimal element!</p>



<a name="210624713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624713">(Sep 19 2020 at 17:04)</a>:</h4>
<p>When the partition has <code>n+1</code> points in it, the list of things we take the sup over only has <code>n</code>.</p>



<a name="210624803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/210624803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#210624803">(Sep 19 2020 at 17:06)</a>:</h4>
<p>I see.</p>



<a name="215045463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215045463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215045463">(Oct 30 2020 at 00:34)</a>:</h4>
<p>Sorry, I'm trying to define something from scratch so that I  can better understand it. It seems that this does not work, and I am guessing it may be why finset is involved? Is there a way to fix this definition?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">norm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">f</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">m</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">min</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="n">m</span> <span class="n">sorry</span><span class="o">)</span> <span class="bp">-</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">sorry</span><span class="o">))</span> <span class="o">(</span><span class="n">norm</span> <span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>



<a name="215045491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215045491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215045491">(Oct 30 2020 at 00:35)</a>:</h4>
<p>Not the sorrys, but the passing of m-1 to norm.</p>



<a name="215046533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215046533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215046533">(Oct 30 2020 at 00:54)</a>:</h4>
<p>First comment, you probably want to do something that looks like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">def</span> <span class="n">norm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">f</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">min</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">sorry</span><span class="o">)</span> <span class="bp">-</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="n">m</span> <span class="n">sorry</span><span class="o">))</span> <span class="o">(</span><span class="n">norm</span> <span class="n">m</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>



<a name="215046573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215046573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215046573">(Oct 30 2020 at 00:54)</a>:</h4>
<p>that is, once you've taken care of the 0 case, do the succ pattern. and avoid subtraction.</p>



<a name="215046583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215046583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215046583">(Oct 30 2020 at 00:54)</a>:</h4>
<p>what's the error you get now?</p>



<a name="215046819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215046819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215046819">(Oct 30 2020 at 00:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">norm</span> <span class="n">m</span> <span class="n">f</span>
<span class="n">term</span>
  <span class="n">f</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">ℝ</span>
</code></pre></div>



<a name="215046886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215046886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215046886">(Oct 30 2020 at 01:00)</a>:</h4>
<p>What exactly are you trying to define? Can you describe it in words?</p>



<a name="215047015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215047015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215047015">(Oct 30 2020 at 01:03)</a>:</h4>
<p>I'm using a function from fin n to R to define an ordered list of real numbers. If there is only one element in that 'list' I want to return 0. If the 'list' is [a, b, c, ...] I want to return the minimum of {b -a, c - b, ...}.</p>



<a name="215047205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215047205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215047205">(Oct 30 2020 at 01:06)</a>:</h4>
<p>Oops, make that the max of those numbers.</p>



<a name="215047419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215047419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215047419">(Oct 30 2020 at 01:11)</a>:</h4>
<p>Just so you know, <code>fin 0</code> is isomorphic to the empty type. So in your wording, it would be the empty list.</p>



<a name="215047486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215047486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215047486">(Oct 30 2020 at 01:13)</a>:</h4>
<p>Ok.</p>



<a name="215047492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215047492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215047492">(Oct 30 2020 at 01:13)</a>:</h4>
<p>Are you wedded to having it as a <code>fin n \to R</code>?</p>



<a name="215047494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215047494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215047494">(Oct 30 2020 at 01:13)</a>:</h4>
<p>You might want to express this as a fold over lists.</p>



<a name="215047565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215047565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215047565">(Oct 30 2020 at 01:15)</a>:</h4>
<p>In the meantime, maybe something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">norm</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">f</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span>       <span class="n">f</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">min</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">f</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">norm</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span>
</code></pre></div>



<a name="215047628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215047628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215047628">(Oct 30 2020 at 01:16)</a>:</h4>
<p>Interesting. Thank you!</p>



<a name="215049550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215049550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215049550">(Oct 30 2020 at 02:01)</a>:</h4>
<p>For the standard definition of a list, how would you write something like "every element in the list is 0" or "every element in the list is 0 except for n elements that are 1"?</p>



<a name="215050001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215050001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215050001">(Oct 30 2020 at 02:10)</a>:</h4>
<p>I guess you would need to define a function that returns the nth element of the list.</p>



<a name="215050227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215050227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215050227">(Oct 30 2020 at 02:15)</a>:</h4>
<p>But then that function should take a proof that n is less than the length of the list, and I'm not sure how that proof would be supplied in something like <code>forall n : nat, n &lt; list.len -&gt; list.at n (sorry) = 0</code>.</p>



<a name="215051049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215051049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215051049">(Oct 30 2020 at 02:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>
<span class="kn">import</span> <span class="n">data.list.basic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="215051056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215051056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215051056">(Oct 30 2020 at 02:33)</a>:</h4>
<p>The functions you're thinking about are <a href="https://leanprover-community.github.io/mathlib_docs/find/list.nth">docs#list.nth</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/list.nth_le">docs#list.nth_le</a></p>



<a name="215051060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215051060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215051060">(Oct 30 2020 at 02:33)</a>:</h4>
<p>There's also <a href="https://leanprover-community.github.io/mathlib_docs/find/list.of_fn">docs#list.of_fn</a></p>



<a name="215051111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215051111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215051111">(Oct 30 2020 at 02:34)</a>:</h4>
<p>And also <a href="https://leanprover-community.github.io/mathlib_docs/find/vector">docs#vector</a>.</p>



<a name="215051121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215051121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215051121">(Oct 30 2020 at 02:34)</a>:</h4>
<p>But which you should use is probably dependent on what you want to use this list for!</p>



<a name="215051783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215051783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215051783">(Oct 30 2020 at 02:50)</a>:</h4>
<p>Thank you.</p>



<a name="215165930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215165930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215165930">(Oct 31 2020 at 00:40)</a>:</h4>
<p>Is there a way to say that <code>l</code> is not <code>list.nil</code> because that case has been exhausted?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">last</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">list.nil</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">absurd</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">list.nil</span><span class="o">)</span> <span class="n">h</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">list.cons</span> <span class="n">a</span> <span class="n">list.nil</span><span class="o">)</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">list.cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">last</span> <span class="n">l</span> <span class="n">sorry</span>
</code></pre></div>



<a name="215180181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215180181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215180181">(Oct 31 2020 at 08:08)</a>:</h4>
<p>Change that l to <code>list.cons b m</code>?</p>



<a name="215258324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215258324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215258324">(Nov 01 2020 at 19:31)</a>:</h4>
<p>I see. Thank you.</p>



<a name="215258615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215258615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215258615">(Nov 01 2020 at 19:38)</a>:</h4>
<p>I'm sorry, I'm still having a hard time understanding quotients and setoids. Is there a simpler way to define the norm and Riemann sum that doesn't rely on these? Perhaps casting fin n to a list?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span> <span class="n">data.finset</span> <span class="n">algebra.big_operators</span> <span class="n">data.fintype.basic</span> <span class="n">data.real.nnreal</span>

<span class="kd">noncomputable theory</span>

<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>
<span class="n">open_locale</span> <span class="n">nnreal</span>

<span class="kd">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span>
<span class="o">:=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P.n</span><span class="o">))</span><span class="bp">.</span><span class="n">sup</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="o">⟨</span><span class="n">P.x</span> <span class="n">j.succ</span> <span class="bp">-</span> <span class="n">P.x</span> <span class="n">j.cast_succ</span><span class="o">,</span> <span class="kd">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">mono</span> <span class="n">P</span> <span class="n">j</span><span class="o">]⟩)</span>

<span class="kd">notation</span> <span class="bp">`||`</span><span class="n">P</span><span class="bp">`||`</span> <span class="o">:=</span> <span class="n">P.norm</span>

<span class="kd">end</span> <span class="n">partition</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="kd">structure</span> <span class="n">pointed_partition</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">m.succ</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">c.y</span><span class="o">⟩</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="bp">∑</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">n.succ</span> <span class="bp">-</span> <span class="n">P.x</span> <span class="n">n.cast_succ</span><span class="o">)</span>
</code></pre></div>



<a name="215258972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215258972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215258972">(Nov 01 2020 at 19:47)</a>:</h4>
<p>you mean like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>

<span class="kd">inductive</span> <span class="n">pointed_partition</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">(</span><span class="n">y</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span> <span class="n">pointed_partition</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">c</span>

<span class="kd">def</span> <span class="n">riemann_sum</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">pointed_partition.nil</span> <span class="n">a</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">pointed_partition.cons</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">y</span> <span class="n">_</span> <span class="n">P</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="n">riemann_sum</span> <span class="n">P</span> <span class="n">f</span>
</code></pre></div>



<a name="215259130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259130">(Nov 01 2020 at 19:51)</a>:</h4>
<p>I was actually thinking of keeping the definition of partition and pointed partition the same, but casting fin n to a list in the definition of norm and sum.</p>



<a name="215259291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259291">(Nov 01 2020 at 19:55)</a>:</h4>
<p>I guess it's not clear to me what you are optimizing then</p>



<a name="215259294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259294">(Nov 01 2020 at 19:55)</a>:</h4>
<p>you have no theorems</p>



<a name="215259309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259309">(Nov 01 2020 at 19:55)</a>:</h4>
<p>I don't see anything particularly gratuitous in the definitions of norm and sum, assuming the definition of a partition is fixed</p>



<a name="215259355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259355">(Nov 01 2020 at 19:56)</a>:</h4>
<p>you can skip the linarith proof if you want, dunno if that's better</p>



<a name="215259372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259372">(Nov 01 2020 at 19:57)</a>:</h4>
<p>Just trying to make definitions that I understand so that I know how to use them. When I follow the definition of finset in mathlib I still get lost.</p>



<a name="215259381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259381">(Nov 01 2020 at 19:57)</a>:</h4>
<p>how do you want to use them?</p>



<a name="215259434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259434">(Nov 01 2020 at 19:58)</a>:</h4>
<p>The definitions of norm and sum? To prove properties of the Riemann integral.</p>



<a name="215259445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259445">(Nov 01 2020 at 19:58)</a>:</h4>
<p>okay, so pick a theorem and prove it</p>



<a name="215259455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259455">(Nov 01 2020 at 19:58)</a>:</h4>
<p>you won't know if the definition is usable until you try to use it</p>



<a name="215259480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259480">(Nov 01 2020 at 19:59)</a>:</h4>
<p>Won't it be a  bad start if I don't understand the definitions I am using?</p>



<a name="215259566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259566">(Nov 01 2020 at 20:01)</a>:</h4>
<p>Or do you mean try to make my own definitions and use them and see how it goes?</p>



<a name="215259667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215259667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215259667">(Nov 01 2020 at 20:03)</a>:</h4>
<p>Easy way of making a list from a <code>fin n</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/list.of_fn">docs#list.of_fn</a>. But proving things about it will be harder than what you have. Try to make the statement of a theorem you want to prove. That will require some sort of basic definitions. Then you can try proving it. Clunky definitions will make proving things difficult. You can then alternate changing definitions, proving a little more, refining the theorem statament, etc</p>



<a name="215260179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215260179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215260179">(Nov 01 2020 at 20:14)</a>:</h4>
<p>Alright.</p>



<a name="215262521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215262521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215262521">(Nov 01 2020 at 21:13)</a>:</h4>
<p>Maybe instead of extending the definition of partition, pointed_partition should take a partition as a parameter? Because P' in this definition has no reference to P right? And it needs to.</p>
<div class="codehilite" data-code-language="def"><pre><span></span><code>∀ ε : ℝ, ε &gt; 0 → ∃ δ : ℝ, δ &gt; 0 ∧ ∀ P : partition a b, (partition.norm P) &lt; δ → ∀ P' : pointed_partition a b, abs ((riemann_sum a b P' f) - R) &lt; ε
</code></pre></div>



<a name="215263120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215263120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215263120">(Nov 01 2020 at 21:28)</a>:</h4>
<p>I guess I could do this, but it seems a little unnatural?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_integral</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span>
<span class="bp">∃</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">nnreal</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">partition.norm</span> <span class="o">(</span><span class="n">pointed_partition.to_partition</span> <span class="n">P</span><span class="o">))</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span>
<span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">a</span> <span class="n">b</span> <span class="n">P</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span>
</code></pre></div>



<a name="215263126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215263126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215263126">(Nov 01 2020 at 21:28)</a>:</h4>
<p>like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">partition.points</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">Π</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">)</span>
</code></pre></div>



<a name="215263275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215263275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215263275">(Nov 01 2020 at 21:32)</a>:</h4>
<p>I also want to observe that if you just wanted to say <code>norm P &lt; delta</code> then there is no need to define <code>norm</code></p>



<a name="215263311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215263311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215263311">(Nov 01 2020 at 21:33)</a>:</h4>
<p>you can define that more simply as <code> ∀ j, P.x j.succ - P.x j.cast_succ &lt; delta</code></p>



<a name="215263358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215263358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215263358">(Nov 01 2020 at 21:34)</a>:</h4>
<p>Or like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">pointed_partition'</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">))</span>
</code></pre></div>



<a name="215263363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215263363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215263363">(Nov 01 2020 at 21:34)</a>:</h4>
<p>you could do that, yes</p>



<a name="215263383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215263383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215263383">(Nov 01 2020 at 21:35)</a>:</h4>
<p>Any foreseeable issues?</p>



<a name="215263540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215263540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215263540">(Nov 01 2020 at 21:40)</a>:</h4>
<p>well it's two things instead of one thing</p>



<a name="215265283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215265283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215265283">(Nov 01 2020 at 22:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span> <span class="n">algebra.big_operators</span>

<span class="kd">noncomputable theory</span>

<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>


<span class="kd">structure</span> <span class="n">pointed_partition</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">))</span>


<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">def</span> <span class="n">riemann_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">P'</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="bp">∑</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">P'.y</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">n.succ</span> <span class="bp">-</span> <span class="n">P.x</span> <span class="n">n.cast_succ</span><span class="o">)</span>


<span class="kd">def</span> <span class="n">is_integral</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span>
<span class="bp">∃</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">P.x</span> <span class="n">j.succ</span> <span class="bp">-</span> <span class="n">P.x</span> <span class="n">j.cast_succ</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span>
<span class="bp">∀</span> <span class="n">P'</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">a</span> <span class="n">b</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">a</span> <span class="n">b</span> <span class="n">P</span> <span class="n">P'</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span>
</code></pre></div>



<a name="215278168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278168">(Nov 02 2020 at 04:16)</a>:</h4>
<p>Why is the declaration of this example an invalid expression?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>

<span class="kd">structure</span> <span class="n">part</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">pt_part</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">))</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">P'</span> <span class="o">:</span> <span class="n">pt_part</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="215278453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278453">(Nov 02 2020 at 04:24)</a>:</h4>
<p>An exists statement can only state something that is a Prop. Your <code>pt_part P</code> is a structure that has data, not just propositions.</p>



<a name="215278467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278467">(Nov 02 2020 at 04:25)</a>:</h4>
<p>What would the <code>P'</code> do?</p>



<a name="215278601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278601">(Nov 02 2020 at 04:29)</a>:</h4>
<p>It was going to be used in my theorem that the definition of the riemann integral is uniquely defined.</p>
<p>I guess maybe I should instead  define a default p_part for an arbitrary part?</p>



<a name="215278664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278664">(Nov 02 2020 at 04:31)</a>:</h4>
<p>You could, but I'm not sure what you were trying to state with your example.</p>



<a name="215278678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278678">(Nov 02 2020 at 04:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>


<span class="kd">structure</span> <span class="n">part</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>


<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">norm_aux</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">f</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span>       <span class="n">f</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">f</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">norm_aux</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">norm_aux</span> <span class="n">P.n</span> <span class="n">P.x</span>

<span class="kd">lemma</span> <span class="n">blah</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="o">:=</span> <span class="n">sorry</span>


<span class="kd">structure</span> <span class="n">pt_part</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">))</span>

<span class="c1">--lemma blah2 {a b : ℝ} (P : part a b) : ∃ P' : pt_part P := sorry</span>

<span class="kd">def</span> <span class="n">rsum_aux</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">_</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">rsum_aux</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.succ</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">rsum</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">(</span><span class="n">P'</span> <span class="o">:</span> <span class="n">pt_part</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="o">:=</span> <span class="n">rsum_aux</span> <span class="n">P.n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="o">(</span><span class="n">P'.y</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span> <span class="bp">-</span> <span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">))</span>


<span class="kd">def</span> <span class="n">is_rint</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">P'</span> <span class="o">:</span> <span class="n">pt_part</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">rsum</span> <span class="n">P'</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span>


<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">R₀</span> <span class="n">R₁</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">is_rint</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="n">R₀</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_rint</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="n">R₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">R₀</span> <span class="bp">=</span> <span class="n">R₁</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">abs</span> <span class="o">(</span><span class="n">R₀</span> <span class="bp">-</span> <span class="n">R₁</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">δ₀</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ₀</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ₀</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">P'</span> <span class="o">:</span> <span class="n">pt_part</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">rsum</span> <span class="n">P'</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R₀</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">h0</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="n">s2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">δ₁</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ₁</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ₁</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">P'</span> <span class="o">:</span> <span class="n">pt_part</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">rsum</span> <span class="n">P'</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R₁</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">h1</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="n">s2</span><span class="o">,</span>
  <span class="n">exists.elim</span> <span class="n">s3</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">δ₀</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">δ₀</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ₀</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">P'</span> <span class="o">:</span> <span class="n">pt_part</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">rsum</span> <span class="n">P'</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R₀</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span>
    <span class="n">exists.elim</span> <span class="n">s4</span> <span class="o">(</span>
      <span class="k">assume</span> <span class="n">δ₁</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
      <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">δ₁</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ₁</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">P'</span> <span class="o">:</span> <span class="n">pt_part</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">rsum</span> <span class="n">P'</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R₁</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span>
      <span class="k">let</span> <span class="n">δ</span> <span class="o">:=</span> <span class="n">min</span> <span class="n">δ₀</span> <span class="n">δ₁</span> <span class="k">in</span>
      <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="o">:=</span> <span class="n">blah</span> <span class="n">δ</span> <span class="n">s5</span><span class="o">,</span>
      <span class="n">exists.elim</span> <span class="n">s6</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
        <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span><span class="o">,</span>
        <span class="c1">-- get an arbitrary p_part of P here.</span>
      <span class="o">)</span>
    <span class="o">)</span>
  <span class="o">)</span>
<span class="o">),</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="215278731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278731">(Nov 02 2020 at 04:32)</a>:</h4>
<p>"Given P, a partition of [a, b], there exists a P' such that the pt_part of P is ...?"</p>



<a name="215278734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278734">(Nov 02 2020 at 04:32)</a>:</h4>
<p>What's the ... there?</p>



<a name="215278807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278807">(Nov 02 2020 at 04:34)</a>:</h4>
<p>Do you just want to say that for any <code>P : part a b</code> one can make a <code>pt_part P</code>?</p>



<a name="215278823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278823">(Nov 02 2020 at 04:34)</a>:</h4>
<p>Yes. I just need an arbitrary riemann sum of P.</p>



<a name="215278885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278885">(Nov 02 2020 at 04:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>

<span class="kd">structure</span> <span class="n">part</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">pt_part</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">pt_part</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨{</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">mem_block</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">}⟩</span>
</code></pre></div>



<a name="215278910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278910">(Nov 02 2020 at 04:38)</a>:</h4>
<p>Providing an <code>inhabited</code> instance allows you to use <code>default</code> for a default value, or <code>arbitrary</code> for a default value that one should not introspect</p>



<a name="215278955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278955">(Nov 02 2020 at 04:38)</a>:</h4>
<p>You don't have to supply the definition of <code>y</code> and a proof of <code>mem_block</code>?</p>



<a name="215278957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278957">(Nov 02 2020 at 04:39)</a>:</h4>
<p>You do.</p>



<a name="215278960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278960">(Nov 02 2020 at 04:39)</a>:</h4>
<p>You have to fill in those underscores</p>



<a name="215278964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278964">(Nov 02 2020 at 04:39)</a>:</h4>
<p>But once you do it in that instance declaration, you don't have to do it again when you invoke <code>default</code></p>



<a name="215278969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215278969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215278969">(Nov 02 2020 at 04:39)</a>:</h4>
<p>Ah. Ok. Thank you.</p>



<a name="215279020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215279020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215279020">(Nov 02 2020 at 04:40)</a>:</h4>
<p>We'll see. This might not work because of the <code>P</code> argument</p>



<a name="215279161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215279161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215279161">(Nov 02 2020 at 04:45)</a>:</h4>
<p>What is the syntax to get the default?</p>



<a name="215279265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215279265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215279265">(Nov 02 2020 at 04:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>

<span class="kd">structure</span> <span class="n">part</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">pt_part</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">y</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">pt_part</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨{</span> <span class="n">y</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">mem_block</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}⟩</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">part</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">pt_part</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">default</span> <span class="n">_</span>
</code></pre></div>



<a name="215279271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215279271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215279271">(Nov 02 2020 at 04:49)</a>:</h4>
<p>So in a place that would expect a <code>pt_part P</code> for some inferable P, you could just write <code>default _</code></p>



<a name="215279314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215279314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215279314">(Nov 02 2020 at 04:50)</a>:</h4>
<p>because <code>default : Π (α : Sort u_1) [c : inhabited α], α</code></p>



<a name="215279327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215279327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215279327">(Nov 02 2020 at 04:50)</a>:</h4>
<p>That is, <code>default</code> gives you some <code>α</code> if you tell it what <code>α</code> you want and it can find an instance of <code>inhabited α</code>. And in the example, we can use an underscore, because the type <code>α</code> is inferable from the context.</p>



<a name="215279456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215279456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215279456">(Nov 02 2020 at 04:55)</a>:</h4>
<p>Nice. Thank you.</p>



<a name="215403252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215403252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215403252">(Nov 03 2020 at 01:38)</a>:</h4>
<p>Is this a correct definition for saying that <code>R</code> is the Riemann integral of <code>f</code> on <code>[a,b]</code>? I'm not sure about the <code>∧</code> after the <code>δ &gt; 0</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_riemann_integral</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">pointed_partition</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span>
</code></pre></div>



<a name="215406853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215406853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215406853">(Nov 03 2020 at 02:27)</a>:</h4>
<p>Also, how can I state this correctly?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_riemann_integral</span> <span class="mi">0</span> <span class="mi">2</span> <span class="n">f</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="215408554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215408554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215408554">(Nov 03 2020 at 03:08)</a>:</h4>
<p>I'd say just do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>  <span class="o">:</span> <span class="n">is_riemann_integral</span> <span class="mi">0</span> <span class="mi">2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="215408568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215408568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215408568">(Nov 03 2020 at 03:09)</a>:</h4>
<p>But</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>  <span class="o">:</span> <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="k">in</span> <span class="n">is_riemann_integral</span> <span class="mi">0</span> <span class="mi">2</span> <span class="n">f</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>is more like what you had, if <code>f</code>is some long expression you want to use twice this can be helpful.</p>



<a name="215408653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215408653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215408653">(Nov 03 2020 at 03:11)</a>:</h4>
<p>Ok. Thank you!</p>



<a name="215931987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215931987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215931987">(Nov 07 2020 at 04:43)</a>:</h4>
<p>How would I set up the induction tactic for <code>all_le_b</code> so that it is decreasing?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">structure</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>


<span class="kd">lemma</span> <span class="n">lt_succ_1</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_succ_2</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">zero_lt_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>


<span class="kd">def</span> <span class="n">cast_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a.i</span> <span class="o">(</span><span class="n">lt_succ_1</span> <span class="n">a.h</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">a.i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lt_succ_2</span> <span class="n">a.h</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">fin_zero</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="n">zero_lt_succ</span>

<span class="kd">def</span> <span class="n">fin_last</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span> <span class="o">(</span><span class="n">lt_succ</span> <span class="n">n</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">n = 0 :</span>
<span class="cm">x : 0 → ℝ</span>
<span class="cm">a = x 0 = b</span>
<span class="cm">n = 1 :</span>
<span class="cm">x : [0, 1] → ℝ</span>
<span class="cm">a = x 0 ≤ x 1 = b</span>
<span class="cm">-/</span>
<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="n">fin_zero</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="n">fin_last</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="o">(</span><span class="n">cast_succ</span> <span class="n">m</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">))</span>


<span class="c">/-</span><span class="cm"></span>
<span class="cm">nat.zero</span>
<span class="cm">Goal : a ≤ P.x {0, 0 &lt; P.n + 1}</span>

<span class="cm">nat.succ</span>
<span class="cm">IH : m &lt; P.n + 1 → a ≤ P.x {m, m &lt; P.n + 1}</span>
<span class="cm">Goal : m + 1 &lt; P.n + 1 → a ≤ P.x {m + 1, m + 1 &lt; P.n + 1}</span>
<span class="cm">-/</span>
<span class="kd">lemma</span> <span class="n">a_le_all</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">induction</span> <span class="n">m</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">m_i</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat.zero</span> <span class="o">{</span>
  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">P.x</span> <span class="n">fin_zero</span> <span class="o">:=</span> <span class="n">eq.symm</span> <span class="n">P.x_zero</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="n">fin_zero</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span>
<span class="o">},</span>
<span class="n">case</span> <span class="n">nat.succ</span> <span class="o">:</span> <span class="n">m</span> <span class="n">IH</span> <span class="o">{</span>
  <span class="c1">-- m_h : m.succ &lt; P.n + 1</span>
  <span class="c1">-- IH : ∀ (m_h : m &lt; P.n + 1), a ≤ P.x {i := m, h := m_h}</span>
  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">m_h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">P.n</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">cast_succ</span> <span class="o">{</span><span class="n">i</span> <span class="o">:=</span> <span class="n">m</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">s1</span><span class="o">})</span> <span class="o">:=</span> <span class="n">IH</span> <span class="n">s2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">cast_succ</span> <span class="o">{</span><span class="n">i</span> <span class="o">:=</span> <span class="n">m</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">s1</span><span class="o">})</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">succ</span> <span class="o">{</span><span class="n">i</span> <span class="o">:=</span> <span class="n">m</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">s1</span><span class="o">})</span> <span class="o">:=</span> <span class="n">P.mono</span> <span class="o">{</span><span class="n">i</span> <span class="o">:=</span> <span class="n">m</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">s1</span><span class="o">},</span>
  <span class="k">show</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">succ</span> <span class="o">{</span><span class="n">i</span> <span class="o">:=</span> <span class="n">m</span><span class="o">,</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">s1</span><span class="o">}),</span> <span class="k">from</span> <span class="n">le_trans</span> <span class="n">s3</span> <span class="n">s4</span>
<span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">a_le_b</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="o">(</span><span class="bp">@</span><span class="n">fin_last</span> <span class="n">P.n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a_le_all</span> <span class="n">P</span> <span class="o">(</span><span class="bp">@</span><span class="n">fin_last</span> <span class="n">P.n</span><span class="o">),</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">P.x</span> <span class="o">(</span><span class="bp">@</span><span class="n">fin_last</span> <span class="n">P.n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">P.x_last</span><span class="o">,</span>
<span class="k">show</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">all_le_b</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">P.x</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
<span class="n">induction</span> <span class="n">m</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">m_i</span> <span class="n">using</span> <span class="bp">?</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="215943113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215943113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215943113">(Nov 07 2020 at 07:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">fin</span>

<span class="kd">theorem</span> <span class="n">lt_succ_iff</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">},</span>
  <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">fin.succ</span> <span class="n">n</span> <span class="bp">↔</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">cast_succ</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">nat.lt_succ_iff</span> <span class="n">m</span> <span class="n">n</span>

<span class="kd">end</span> <span class="n">fin</span>

<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">m</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.succ</span> <span class="n">m</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">mono'</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)}</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">P.x</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">fin.induction_on</span> <span class="n">j</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">le_antisymm</span> <span class="n">h</span> <span class="o">(</span><span class="n">fin.zero_le</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">j</span> <span class="n">IH</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">lt_or_eq_of_le</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h</span> <span class="bp">|</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">IH</span> <span class="o">(</span><span class="n">fin.lt_succ_iff.1</span> <span class="n">h</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">P.mono</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">a_le_all</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">P.x_zero</span><span class="o">]</span> <span class="n">using</span> <span class="n">mono'</span> <span class="n">P</span> <span class="o">(</span><span class="n">fin.zero_le</span> <span class="n">m</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">a_le_b</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">P.x_last</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">a_le_all</span>

<span class="kd">lemma</span> <span class="n">all_le_b</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">P.x</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">P.x_last</span><span class="o">]</span> <span class="n">using</span> <span class="n">mono'</span> <span class="n">P</span> <span class="o">(</span><span class="n">fin.le_last</span> <span class="n">m</span><span class="o">)</span>
</code></pre></div>



<a name="215978023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215978023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215978023">(Nov 07 2020 at 23:11)</a>:</h4>
<p>Thank you.</p>



<a name="215980379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215980379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215980379">(Nov 08 2020 at 00:17)</a>:</h4>
<p>What is it in the mathlib definition of <code>fin</code> that allows for <code>apply fin.induction_on j</code>? It doesn't seem to work with my definition of <code>fin</code>.</p>



<a name="215980503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215980503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215980503">(Nov 08 2020 at 00:20)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fin.induction_on">docs#fin.induction_on</a> is a lemma that's in mathlib about the mathlib definition of <code>fin</code>; you'd have to prove an analogue involving your <code>fin</code> for <code>apply fin.induction_on</code> to work with your type.</p>



<a name="215980564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/215980564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#215980564">(Nov 08 2020 at 00:22)</a>:</h4>
<p>Oh, right. Thank you.</p>



<a name="216044806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216044806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216044806">(Nov 09 2020 at 05:19)</a>:</h4>
<p>How would I get something that represents the maximum of an arbitrary choice of the <code>m</code>s in this example (that would be an upper bound for <code>abs f</code> on <code>[a, b])</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>

<span class="kd">def</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">M</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">M</span>

<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">m</span> <span class="o">:=</span> <span class="o">(</span>
<span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
<span class="n">a0</span> <span class="n">i</span>
<span class="o">),</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="216159266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216159266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216159266">(Nov 10 2020 at 00:13)</a>:</h4>
<p>Do I need to make some kind of inhabited data type?</p>



<a name="216170215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216170215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216170215">(Nov 10 2020 at 03:48)</a>:</h4>
<p>Hmm. Perhaps:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
<span class="k">let</span> <span class="n">m</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">Exists.some</span> <span class="o">(</span><span class="n">a0</span> <span class="n">i</span><span class="o">)</span> <span class="k">in</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="216828640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216828640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216828640">(Nov 16 2020 at 03:02)</a>:</h4>
<p>I was wondering if someone could help me understand what is going wrong with and how to fix <code>s2</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">P.x</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">eq.symm</span> <span class="n">P.x_zero</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">P.n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">P.x_last</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">fin.last</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">eq.subst</span> <span class="n">ℕ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">fin.last</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="n">P.n</span> <span class="mi">0</span> <span class="n">a0</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">P.n</span><span class="o">)),</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">P.x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s2</span> <span class="n">s1</span><span class="o">,</span>
<span class="n">eq.trans</span> <span class="n">s0</span> <span class="n">s3</span>
</code></pre></div>



<a name="216830734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216830734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216830734">(Nov 16 2020 at 04:00)</a>:</h4>
<p>I guess this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">P.x</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">eq.symm</span> <span class="n">P.x_zero</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">P.n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">P.x_last</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">fin.last</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">fin.ext</span> <span class="n">a0</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">P.x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s2</span> <span class="n">s1</span><span class="o">,</span>
<span class="n">eq.trans</span> <span class="n">s0</span> <span class="n">s3</span>
</code></pre></div>



<a name="216833317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216833317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216833317">(Nov 16 2020 at 05:10)</a>:</h4>
<p>Can I ask, is there a reason you prefer these tactic mode proofs?</p>



<a name="216833386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216833386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216833386">(Nov 16 2020 at 05:12)</a>:</h4>
<p>Do you mean non tactic? I just like to make it readable independent of Lean.</p>



<a name="216837591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216837591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216837591">(Nov 16 2020 at 06:53)</a>:</h4>
<p>What parts of Lean would you consider lean dependent in reading? I find the "ext" and "eq.subst" more difficult to parse. I think of those to be pretty Lean dependent in reading.</p>



<a name="216837656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216837656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216837656">(Nov 16 2020 at 06:55)</a>:</h4>
<p>Perhaps a <code>calc</code> style proof would be the most readable in such a case</p>



<a name="216911575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216911575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216911575">(Nov 16 2020 at 18:26)</a>:</h4>
<p>"I find the "ext" and "eq.subst" more difficult to parse. I think of those to be pretty Lean dependent in reading."<br>
What would you replace them with?</p>



<a name="216911606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216911606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216911606">(Nov 16 2020 at 18:26)</a>:</h4>
<p>tactics!</p>



<a name="216911800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216911800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216911800">(Nov 16 2020 at 18:28)</a>:</h4>
<p>I mean which tactics :)</p>



<a name="216911840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216911840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216911840">(Nov 16 2020 at 18:28)</a>:</h4>
<p>rw?</p>



<a name="216912084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216912084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216912084">(Nov 16 2020 at 18:30)</a>:</h4>
<p><code>rw</code> is the <code>eq.subst</code> tactic, yes. The tactic which does <code>ext</code> is in fact called <code>ext</code> :-)</p>



<a name="216912568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216912568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216912568">(Nov 16 2020 at 18:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">P</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">mono</span><span class="o">⟩,</span>
  <span class="k">show</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">congr'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216912762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216912762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216912762">(Nov 16 2020 at 18:34)</a>:</h4>
<p>Personally I find that a lot harder to read, especially without Lean.</p>



<a name="216912823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216912823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216912823">(Nov 16 2020 at 18:35)</a>:</h4>
<p>But you don't need to read this proof because the result is trivial.</p>



<a name="216912968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216912968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216912968">(Nov 16 2020 at 18:36)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">-</span><span class="o">⟩</span> <span class="o">(</span><span class="n">rfl</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span> <span class="n">refl</span> <span class="o">}</span>
</code></pre></div>



<a name="216913156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216913156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216913156">(Nov 16 2020 at 18:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- Let n and x be the data associated to P</span>
  <span class="n">rcases</span> <span class="n">P</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">mono</span><span class="o">⟩,</span>
  <span class="c1">-- assume n = 0.</span>
  <span class="k">show</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="c1">-- The goal is now to prove x 0 = x (fin.last 0)</span>
  <span class="c1">-- but this is trivial</span>
  <span class="n">congr'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216913259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216913259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216913259">(Nov 16 2020 at 18:38)</a>:</h4>
<p><code>(rfl : a = b)</code> is a nice trick</p>



<a name="216913266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216913266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216913266">(Nov 16 2020 at 18:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/216912823">said</a>:</p>
<blockquote>
<p>But you don't need to read this proof because the result is trivial.</p>
</blockquote>
<p>Perhaps. I still like to though. Its too bad there isn't a mechanism to turn tactic proofs into something a mathematician without Lean could follow.</p>



<a name="216913360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216913360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216913360">(Nov 16 2020 at 18:39)</a>:</h4>
<p>Well, I guess I can read some proofs fine without using Lean, because I can "be the compiler" (something Mario used to encourage me to do when I was a beginner).</p>



<a name="216913377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216913377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216913377">(Nov 16 2020 at 18:39)</a>:</h4>
<p>You can also do this in "term mode" using the equation compiler for a similar proof</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="n">rfl</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="216913413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216913413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216913413">(Nov 16 2020 at 18:39)</a>:</h4>
<p>But for long proofs, I agree, you are better off running a copy of Lean and looking at the code within it.</p>



<a name="216913958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216913958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216913958">(Nov 16 2020 at 18:44)</a>:</h4>
<p>But in case you haven't noticed yet, my strategy for making readable proofs is to get them over with as quickly as possible, which forces the proof to be pretty slick and hopefully convincing the reader that they didn't want to read the proof anyway</p>



<a name="216914264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216914264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216914264">(Nov 16 2020 at 18:46)</a>:</h4>
<p>For longer proofs, tactic mode is much better than term mode for conveying structure and order to the proof, and you don't really want to read these proofs without tool assistance anyway because the local context is super important and much harder to read in any static textual form</p>



<a name="216914395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216914395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216914395">(Nov 16 2020 at 18:47)</a>:</h4>
<p>The only static form I really think does the job is <code>#explode</code> / metamath proofs, which are crazy verbose unless you are really regimented about your context management</p>



<a name="216914514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216914514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216914514">(Nov 16 2020 at 18:48)</a>:</h4>
<p>What is #explode?</p>



<a name="216914542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216914542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216914542">(Nov 16 2020 at 18:48)</a>:</h4>
<p>It's a tactic that will print out a metamath style proof of any lean theorem</p>



<a name="216914633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216914633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216914633">(Nov 16 2020 at 18:49)</a>:</h4>
<p>Huh. Cool. I'll take a look.</p>



<a name="216914710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216914710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216914710">(Nov 16 2020 at 18:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="bp">#</span><span class="n">explode</span> <span class="n">classical.em</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">classical.em</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">p</span>
<span class="mi">0</span><span class="bp">│</span>     <span class="bp">│</span> <span class="n">p</span>                                <span class="bp">├</span> <span class="kt">Prop</span>
<span class="mi">1</span><span class="bp">│</span>     <span class="bp">│</span> <span class="n">_private.1778634979.not_uv_or_p</span>  <span class="bp">│</span> <span class="n">u</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">p</span>
<span class="mi">2</span><span class="bp">│</span>     <span class="bp">│</span> <span class="n">hne</span>                              <span class="bp">│</span> <span class="bp">┌</span> <span class="n">u</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">v</span> <span class="n">p</span>
<span class="mi">3</span><span class="bp">│</span>     <span class="bp">│</span> <span class="n">_private.4061111967.p_implies_uv</span> <span class="bp">│</span> <span class="bp">│</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">u</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">v</span> <span class="n">p</span>
<span class="mi">4</span><span class="bp">│</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span>  <span class="bp">│</span> <span class="n">mt</span>                               <span class="bp">│</span> <span class="bp">│</span> <span class="bp">¬</span><span class="n">p</span>
<span class="mi">5</span><span class="bp">│</span><span class="mi">4</span>    <span class="bp">│</span> <span class="n">or.inr</span>                           <span class="bp">│</span> <span class="bp">│</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">p</span>
<span class="mi">6</span><span class="bp">│</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span>  <span class="bp">│</span> <span class="bp">∀</span><span class="n">I</span>                               <span class="bp">│</span> <span class="n">u</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">v</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">p</span>
<span class="mi">7</span><span class="bp">│</span>     <span class="bp">│</span> <span class="n">or.inl</span>                           <span class="bp">│</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">p</span>
<span class="mi">8</span><span class="bp">│</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="bp">│</span> <span class="n">or.elim</span>                          <span class="bp">│</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">p</span>
<span class="mi">9</span><span class="bp">│</span><span class="mi">0</span><span class="o">,</span><span class="mi">8</span>  <span class="bp">│</span> <span class="bp">∀</span><span class="n">I</span>                               <span class="bp">│</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">p</span>
</code></pre></div>



<a name="216915062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216915062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216915062">(Nov 16 2020 at 18:52)</a>:</h4>
<p>Interesting.</p>



<a name="216916339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216916339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216916339">(Nov 16 2020 at 19:02)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span>
<span class="k">have</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">fin.last</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">fin.eq_of_veq</span> <span class="n">h</span><span class="o">,</span>
<span class="k">calc</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">P.x</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">P.x_zero.symm</span>
<span class="bp">...</span>    <span class="bp">=</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">P.n</span><span class="o">)</span> <span class="o">:</span> <span class="n">congr_arg</span> <span class="n">P.x</span> <span class="n">hn.symm</span>
<span class="bp">...</span>    <span class="bp">=</span> <span class="n">b</span> <span class="o">:</span> <span class="n">P.x_last</span>
</code></pre></div>



<a name="216916872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/216916872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#216916872">(Nov 16 2020 at 19:06)</a>:</h4>
<p>This gives the proof state explicitly, and the Lean steps to convert from one state to another. It's difficult to avoid "Lean-like" terms or syntax, because of <code>fin</code>.</p>



<a name="217483144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217483144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217483144">(Nov 21 2020 at 03:58)</a>:</h4>
<p>I'm a bit confused. Why does this compile, when <code>s</code> may not have type <code>fin (n + 1)</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">def</span> <span class="n">blah</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">s</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">f</span> <span class="n">s</span>
</code></pre></div>



<a name="217483273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217483273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217483273">(Nov 21 2020 at 04:03)</a>:</h4>
<p>You can do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">blah._main</span>
</code></pre></div>
<p>to see whats produced is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">polynomial.blah._main</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">m.cases_on</span> <span class="o">(</span><span class="n">id_rhs</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">f</span> <span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">id_rhs</span> <span class="n">ℝ</span> <span class="o">(</span><span class="n">f</span> <span class="bp">↑</span><span class="n">m</span><span class="o">))</span>
</code></pre></div>



<a name="217483286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217483286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217483286">(Nov 21 2020 at 04:03)</a>:</h4>
<p>So its coercing naturals to <code>fin (n+1)</code></p>



<a name="217483334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217483334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217483334">(Nov 21 2020 at 04:04)</a>:</h4>
<p>What happens if <code>m</code> can not be coerced?</p>



<a name="217483399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217483399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217483399">(Nov 21 2020 at 04:06)</a>:</h4>
<p>It always can be coerced, in this case it takes <code>m</code> mod <code>n+1</code>,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="mi">7</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">-- 1</span>
</code></pre></div>



<a name="217483428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217483428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217483428">(Nov 21 2020 at 04:07)</a>:</h4>
<p>Huh. Why does it do that?</p>



<a name="217483661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217483661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217483661">(Nov 21 2020 at 04:14)</a>:</h4>
<p>I guess because it is defined to :)</p>



<a name="217483695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217483695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217483695">(Nov 21 2020 at 04:14)</a>:</h4>
<p>Here's one way to find out:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">ℕ</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">nat.cast_coe : has_coe_t ℕ (fin (n + 1))</span>
<span class="cm">-/</span>
</code></pre></div>
<p>That points to <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.cast_coe">docs#nat.cast_coe</a>, which is an instance that defines a coercion from <code>ℕ</code> to any type with <code>has_zero</code>, <code>has_one</code> and <code>has_add</code>.</p>



<a name="217483749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217483749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217483749">(Nov 21 2020 at 04:16)</a>:</h4>
<p>Unfolding the definition, you get to <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.cast/src">src#nat.cast</a>, which is defined as the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Canonical homomorphism from `ℕ` to a type `α` with `0`, `1` and `+`. -/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">cast</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cast</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>
</code></pre></div>



<a name="217483822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217483822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217483822">(Nov 21 2020 at 04:19)</a>:</h4>
<p>The way Lean finds coercions is explained in <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#coercions-using-type-classes">this section of TPiL</a>.</p>



<a name="217484132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217484132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217484132">(Nov 21 2020 at 04:29)</a>:</h4>
<p>Thank you.</p>



<a name="217484138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217484138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217484138">(Nov 21 2020 at 04:29)</a>:</h4>
<p>FYI this cast is not recommended; you should use <code>fin.last n</code> instead</p>



<a name="217484347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217484347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217484347">(Nov 21 2020 at 04:35)</a>:</h4>
<p>Given a definition like the following, is there a way to supply some chosen parameters to it, and see what everything gets assigned to in each step as it unfolds, as a way to verify that it works as intended?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">fin_max</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span>
</code></pre></div>



<a name="217484862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217484862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217484862">(Nov 21 2020 at 04:51)</a>:</h4>
<p>Does it have to be <code>ℝ</code>? That definition looks like it would work on any type</p>



<a name="217484866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217484866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217484866">(Nov 21 2020 at 04:51)</a>:</h4>
<p>If you use a computational type you can <code>#eval</code> it</p>



<a name="217484932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217484932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217484932">(Nov 21 2020 at 04:53)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fin_max</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">))</span>

<span class="k">#eval</span> <span class="n">fin_max</span> <span class="mi">5</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i.1</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">-- 7</span>
</code></pre></div>



<a name="217484936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217484936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217484936">(Nov 21 2020 at 04:53)</a>:</h4>
<p>I was actually thinking in more general terms, for any inductive definition. Like it prints out:<br>
iteration 0:<br>
param_name_0 = ...<br>
param_name_1 = ...</p>
<p>iteration 1:<br>
param_name_0 = ...<br>
param_name_1 = ...<br>
...</p>



<a name="217485050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217485050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217485050">(Nov 21 2020 at 04:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">fin_max</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_to_format</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">f</span> <span class="o">:=</span>
  <span class="n">trace</span> <span class="o">(</span><span class="n">to_string</span> <span class="n">format</span><span class="bp">!</span><span class="s2">"iteration 0: {f 0}"</span><span class="o">)</span> <span class="bp">$</span> <span class="n">f</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">fin_max</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">trace</span> <span class="o">(</span><span class="n">to_string</span> <span class="n">format</span><span class="bp">!</span><span class="s2">"iteration {m + 1}: max {a} {b} = {max a b}"</span><span class="o">)</span> <span class="bp">$</span>
  <span class="n">max</span> <span class="n">a</span> <span class="n">b</span>

<span class="k">#eval</span> <span class="n">fin_max</span> <span class="mi">5</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i.1</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">-- 7</span>
<span class="c1">-- iteration 0: 2</span>
<span class="c1">-- iteration 1: max 3 2 = 3</span>
<span class="c1">-- iteration 2: max 4 3 = 4</span>
<span class="c1">-- iteration 3: max 5 4 = 5</span>
<span class="c1">-- iteration 4: max 6 5 = 6</span>
<span class="c1">-- iteration 5: max 7 6 = 7</span>
</code></pre></div>



<a name="217485112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217485112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217485112">(Nov 21 2020 at 04:58)</a>:</h4>
<p>Cool! Thanks!</p>



<a name="217584168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217584168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217584168">(Nov 23 2020 at 02:49)</a>:</h4>
<p>I can prove it, but is there an existing theorem that says that if <code>i : fin 1</code> then <code>i = 0</code>? Is there also an existing theorem that breaks <code>i : fin n + 1</code> into the cases <code>i = fin.last n</code> and <code>i : fin n</code>?</p>



<a name="217584246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217584246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217584246">(Nov 23 2020 at 02:51)</a>:</h4>
<p>Probably Lean knows that <code>fin 1</code> is a subsingleton</p>



<a name="217584255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217584255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217584255">(Nov 23 2020 at 02:52)</a>:</h4>
<p>and the second question is probably answered by some sort of induction/cases</p>



<a name="217584599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217584599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217584599">(Nov 23 2020 at 02:59)</a>:</h4>
<p>A recent commit added <code>fin.eq_zero</code>: <a href="https://github.com/leanprover-community/mathlib/commit/c4132e9ae950e8b28eafc964062311ff21fe4d08">https://github.com/leanprover-community/mathlib/commit/c4132e9ae950e8b28eafc964062311ff21fe4d08</a></p>



<a name="217584716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217584716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217584716">(Nov 23 2020 at 03:01)</a>:</h4>
<p>What do you mean by breaking a <code>fin (n + 1)</code> into <code>fin n</code>? They're different types. Can you prove your statement for <code>0 : fin (n + 1)</code> and using that, the inductive step? Then you can use <code>fin.induction_on</code>. Or if you have no need to induct, you can use <code>refine fin.cases _ _ i</code>. Do you need to break it into <code>[0, n)</code> and <code>{n}</code>? Then we can write <code>fin.decreasing_induction</code></p>



<a name="217584825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217584825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217584825">(Nov 23 2020 at 03:04)</a>:</h4>
<p>I was thinking about an easier and more readable way to do the <code>or.elim</code> here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>


<span class="kd">def</span> <span class="n">fin_max</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">))</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">n</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat.zero</span> <span class="o">{</span>
  <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">fin.le_last</span> <span class="n">i</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">nat.eq_zero_of_le_zero</span> <span class="n">s0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">fin.ext</span> <span class="n">s1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">f</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s2</span> <span class="o">(</span><span class="n">le_refl</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)),</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">fin_max</span> <span class="mi">0</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">fin_max</span> <span class="mi">0</span> <span class="n">f</span><span class="o">),</span>
  <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin_max</span> <span class="mi">0</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">s4</span><span class="o">)</span> <span class="n">s3</span>
<span class="o">},</span>
<span class="n">case</span> <span class="n">nat.succ</span> <span class="o">:</span> <span class="n">n</span> <span class="n">IH</span> <span class="o">{</span>
  <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">f'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">,</span>

  <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">fin_max</span> <span class="n">n.succ</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">n</span> <span class="n">f'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">n.succ</span> <span class="n">f</span><span class="o">),</span>

  <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">n</span> <span class="n">f'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">le_max_left</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">n</span> <span class="n">f'</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">fin_max</span> <span class="n">n.succ</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">s5</span><span class="o">)</span> <span class="n">s6</span><span class="o">,</span>

  <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">fin_max</span> <span class="n">n</span> <span class="n">f'</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">n</span> <span class="n">f'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">le_max_right</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">n</span> <span class="n">f'</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s9</span> <span class="o">:</span> <span class="n">fin_max</span> <span class="n">n</span> <span class="n">f'</span> <span class="bp">≤</span> <span class="n">fin_max</span> <span class="n">n.succ</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">s5</span><span class="o">)</span> <span class="n">s8</span><span class="o">,</span>

  <span class="k">have</span> <span class="n">s10</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">≤</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="n">fin.le_last</span> <span class="n">i</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s11</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span> <span class="bp">∨</span> <span class="n">i.val</span> <span class="bp">=</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="n">lt_or_eq_of_le</span> <span class="n">s10</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.elim</span> <span class="n">s11</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">i'</span> <span class="o">:=</span> <span class="n">fin.mk</span> <span class="n">i.val</span> <span class="n">a0</span> <span class="k">in</span>
    <span class="k">have</span> <span class="n">s12</span> <span class="o">:</span> <span class="n">f'</span> <span class="n">i'</span> <span class="bp">≤</span> <span class="n">fin_max</span> <span class="n">n</span> <span class="n">f'</span> <span class="o">:=</span> <span class="n">IH</span> <span class="n">f'</span> <span class="n">i'</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s13</span> <span class="o">:</span> <span class="n">f'</span> <span class="n">i'</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">i'.cast_succ</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i'</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">s14</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i'.cast_succ</span> <span class="bp">≤</span> <span class="n">fin_max</span> <span class="n">n</span> <span class="n">f'</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s13</span> <span class="n">s12</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s15</span> <span class="o">:</span> <span class="n">i'.cast_succ</span> <span class="bp">=</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">fin.mk_coe</span> <span class="n">i</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s16</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin_max</span> <span class="n">n</span> <span class="n">f'</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s15</span> <span class="n">s14</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin_max</span> <span class="n">n.succ</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span> <span class="n">le_trans</span> <span class="n">s16</span> <span class="n">s9</span>
  <span class="o">)</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">=</span> <span class="n">n.succ</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s17</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">fin.last</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="n">fin.ext</span> <span class="n">a1</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin_max</span> <span class="n">n.succ</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">s17</span><span class="o">)</span> <span class="n">s7</span>
  <span class="o">)</span>
<span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="217585755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217585755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217585755">(Nov 23 2020 at 03:25)</a>:</h4>
<p>Does this help?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">fin_max</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">fin_max</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">))</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">fin_max</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">fin_max</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">apply</span> <span class="n">fin.induction_on</span> <span class="n">i</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">fin_max</span><span class="o">,</span> <span class="n">le_max_iff</span><span class="o">],</span>
      <span class="n">right</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span> <span class="n">f</span> <span class="n">k.cast_succ</span><span class="o">)</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hn</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="217586375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217586375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217586375">(Nov 23 2020 at 03:35)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">fin_max</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">fin_max</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">le_fin_max</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin_max</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">subsingleton.elim</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">fin_max</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">hi</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">n.succ</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">fin.cast_succ_cast_lt</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">le_max_right_of_le</span> <span class="o">(</span><span class="n">ih</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">i.cast_lt</span> <span class="n">hi</span><span class="o">))</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">fin.eq_last_of_not_lt</span> <span class="n">hi</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">le_max_left</span> <span class="n">_</span> <span class="n">_</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="217587187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/217587187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#217587187">(Nov 23 2020 at 03:52)</a>:</h4>
<p>Thank you both.</p>



<a name="218185704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218185704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218185704">(Nov 28 2020 at 23:14)</a>:</h4>
<p>How can I use my definition of <code>fin.max</code> in the last example? Should I change my definition or the statement of the lemmas somehow?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.order</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">structure</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop</span> <span class="o">:</span> <span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>


<span class="kd">lemma</span> <span class="n">lt_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_succ_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">succ_pos</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_one</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">le_of_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>


<span class="kd">def</span> <span class="n">fin.cast_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a.val</span> <span class="o">(</span><span class="n">lt_lt_succ</span> <span class="n">a.prop</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">fin.succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">a.val</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lt_succ_lt_succ</span> <span class="n">a.prop</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="o">{</span><span class="n">zero</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="n">succ_pos</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">fin.last</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span> <span class="n">lt_succ</span>


<span class="kd">lemma</span> <span class="n">fin.eq_of_veq</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">=</span> <span class="n">j.val</span> <span class="bp">→</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">sorry</span>


<span class="kd">@[elab_as_eliminator]</span> <span class="kd">def</span> <span class="n">fin.induction</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">C</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">C</span> <span class="n">i.cast_succ</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span> <span class="n">C</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">@[elab_as_eliminator]</span> <span class="kd">def</span> <span class="n">fin.induction_on</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">C</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">C</span> <span class="n">i.cast_succ</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">fin.induction</span> <span class="n">h0</span> <span class="n">hs</span> <span class="n">i</span>


<span class="kd">def</span> <span class="n">fin.max</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">f</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">fin.max</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span><span class="o">)))</span>


<span class="kd">lemma</span> <span class="n">fin.all_le_max</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">fin.max</span> <span class="n">n</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat.zero</span> <span class="o">{</span>
  <span class="c1">-- f : fin (0 + 1) → α</span>
  <span class="k">show</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="mi">0</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span>
  <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">i.prop</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">lt_one</span> <span class="n">s0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">fin.eq_of_veq</span> <span class="n">s1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">fin.max</span> <span class="mi">0</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">fin.max</span> <span class="mi">0</span> <span class="n">f</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">fin.max</span> <span class="mi">0</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">s2</span><span class="o">)</span> <span class="n">s3</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="mi">0</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span> <span class="n">eq.ge</span> <span class="n">s4</span>
<span class="o">},</span>
<span class="n">case</span> <span class="n">nat.succ</span> <span class="o">:</span> <span class="n">n</span> <span class="n">IH</span> <span class="o">{</span>
  <span class="c1">-- f : fin (n.succ + 1) → α</span>
  <span class="c1">-- IH : ∀ (f : fin (n + 1) → α) (i : fin (n + 1)), f i ≤ fin.max n f</span>
  <span class="k">show</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="n">n.succ</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span>
  <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">f'</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">fin.max</span> <span class="n">n.succ</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin.max</span> <span class="n">n</span> <span class="n">f'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">fin.max</span> <span class="n">n.succ</span> <span class="n">f</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin.max</span> <span class="n">n</span> <span class="n">f'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">le_max_left</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin.max</span> <span class="n">n</span> <span class="n">f'</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="n">n.succ</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">s5</span><span class="o">)</span> <span class="n">s6</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">fin.max</span> <span class="n">n</span> <span class="n">f'</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin.max</span> <span class="n">n</span> <span class="n">f'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">le_max_right</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin.max</span> <span class="n">n</span> <span class="n">f'</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s9</span> <span class="o">:</span> <span class="n">fin.max</span> <span class="n">n</span> <span class="n">f'</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="n">n.succ</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">s5</span><span class="o">)</span> <span class="n">s8</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s10</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">i.prop</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s11</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">≤</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="n">le_of_lt_succ</span> <span class="n">s10</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s12</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span> <span class="bp">∨</span> <span class="n">i.val</span> <span class="bp">=</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="n">lt_or_eq_of_le</span> <span class="n">s11</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="n">n.succ</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span> <span class="n">or.elim</span> <span class="n">s12</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">i'</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="n">fin.mk</span> <span class="n">i.val</span> <span class="n">a0</span> <span class="k">in</span>
    <span class="k">have</span> <span class="n">s13</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i'</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">i.val</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i'</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s14</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">fin.eq_of_veq</span> <span class="n">s13</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s15</span> <span class="o">:</span> <span class="n">f'</span> <span class="n">i'</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="n">n</span> <span class="n">f'</span> <span class="o">:=</span> <span class="n">IH</span> <span class="n">f'</span> <span class="n">i'</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s16</span> <span class="o">:</span> <span class="n">f'</span> <span class="n">i'</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i'</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i'</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">s17</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i'</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="n">n</span> <span class="n">f'</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s16</span> <span class="n">s15</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s18</span> <span class="o">:</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="n">n</span> <span class="n">f'</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s14</span> <span class="n">s15</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="n">n.succ</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span> <span class="n">le_trans</span> <span class="n">s18</span> <span class="n">s9</span>
  <span class="o">)</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">=</span> <span class="n">n.succ</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s19</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">fin.last</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="n">fin.eq_of_veq</span> <span class="n">a1</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">fin.max</span> <span class="n">n.succ</span> <span class="n">f</span><span class="o">,</span> <span class="k">from</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">s19</span><span class="o">)</span> <span class="n">s7</span>
  <span class="o">)</span>
<span class="o">}</span>
<span class="kd">end</span>


<span class="kd">def</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">M</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">M</span>

<span class="kd">lemma</span> <span class="n">singleton_bounded</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">a</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="k">in</span>
<span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">a</span><span class="o">,</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">s1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">s1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">le_antisymm</span> <span class="n">s3</span> <span class="n">s2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)),</span>
  <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s4</span> <span class="n">s5</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">s6</span><span class="o">,</span>
  <span class="n">eq.le</span> <span class="n">s7</span>
<span class="o">),</span>
<span class="n">exists.intro</span> <span class="n">M</span> <span class="n">s0</span>


<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>


<span class="kd">lemma</span> <span class="n">singleton_partition</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">fin.last</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">fin.eq_of_veq</span> <span class="n">a0</span><span class="o">,</span>
<span class="k">calc</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">P.x</span> <span class="mi">0</span>              <span class="o">:</span> <span class="n">eq.symm</span> <span class="n">P.x_zero</span>
<span class="bp">...</span>    <span class="bp">=</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">P.n</span><span class="o">)</span> <span class="o">:</span> <span class="n">congr_arg</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">s0</span><span class="o">)</span>
<span class="bp">...</span>    <span class="bp">=</span> <span class="n">b</span>                  <span class="o">:</span> <span class="n">P.x_last</span>


<span class="kd">lemma</span> <span class="n">partition_mem</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">P.n</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
<span class="n">by_contradiction</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">lt_or_eq_of_le</span> <span class="n">s1</span><span class="o">,</span>
  <span class="n">or.elim</span> <span class="n">s2</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">P.x</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">(</span>
      <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
      <span class="n">fin.induction_on</span> <span class="n">i</span>
      <span class="o">(</span>
        <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="n">P.x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">P.x_zero</span><span class="o">,</span>
        <span class="k">show</span> <span class="n">P.x</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">s4</span><span class="o">)</span> <span class="n">a3</span>
      <span class="o">)</span>
      <span class="o">(</span>
        <span class="k">assume</span> <span class="n">i'</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
        <span class="k">assume</span> <span class="n">IH</span> <span class="o">:</span> <span class="n">P.x</span> <span class="n">i'.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">P.x</span> <span class="n">i'.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">le_of_lt</span> <span class="n">IH</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i'.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i'.succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">s0</span> <span class="n">i'</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i'.cast_succ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i'.succ</span><span class="o">))</span> <span class="o">:=</span> <span class="n">s6</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i'.cast_succ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i'.succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s9</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i'.succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">s8</span> <span class="n">s5</span><span class="o">,</span>
        <span class="k">show</span> <span class="n">P.x</span> <span class="n">i'.succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span>
      <span class="o">)</span>
    <span class="o">),</span>
    <span class="k">have</span> <span class="n">s10</span> <span class="o">:</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">P.n</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">s3</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">P.n</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">s11</span> <span class="o">:</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">P.n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">P.x_last</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s12</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s11</span> <span class="n">s10</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s13</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s14</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a1</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s13</span> <span class="n">s14</span>
  <span class="o">)</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s15</span> <span class="o">:</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">P.x_zero</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s16</span> <span class="o">:</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">eq.trans_le</span> <span class="n">s15</span> <span class="n">s1</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s17</span> <span class="o">:</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">eq.trans</span> <span class="n">s15</span> <span class="n">a4</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s18</span> <span class="o">:</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">cast_succ</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:=</span> <span class="n">P.mono</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">s19</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s17</span> <span class="n">s18</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s20</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">and.intro</span> <span class="n">s16</span> <span class="n">s19</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s21</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">s0</span> <span class="o">(</span><span class="n">fin.mk</span> <span class="mi">0</span> <span class="n">a0</span><span class="o">),</span>
    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">s21</span> <span class="n">s20</span>
  <span class="o">)</span>
<span class="o">)</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">a0</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">P.n</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
<span class="n">or.elim</span> <span class="n">s1</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">singleton_partition</span> <span class="n">P</span> <span class="n">a1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">a</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">singleton_bounded</span> <span class="n">a</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">eq.subst</span> <span class="n">s2</span> <span class="n">s3</span>
<span class="o">)</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">P.n</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">Exists.some</span> <span class="o">(</span><span class="n">s0</span> <span class="n">i</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">m</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
    <span class="n">Exists.some_spec</span> <span class="o">(</span><span class="n">s0</span> <span class="n">i</span><span class="o">)</span>
  <span class="o">),</span>
  <span class="k">let</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">fin.max</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">m</span> <span class="k">in</span>
  <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">m</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">fin.all_le_max</span> <span class="o">(</span><span class="n">P.n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">m</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">partition_mem</span> <span class="n">P</span> <span class="n">a2</span> <span class="n">x</span> <span class="n">a3</span><span class="o">,</span>
    <span class="n">exists.elim</span> <span class="n">s7</span> <span class="o">(</span>
      <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
      <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">m</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">s4</span> <span class="n">i</span> <span class="n">x</span> <span class="n">a4</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s9</span> <span class="o">:</span> <span class="n">m</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">s5</span> <span class="n">i</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">M</span><span class="o">,</span> <span class="k">from</span> <span class="n">le_trans</span> <span class="n">s8</span> <span class="n">s9</span>
    <span class="o">)</span>
  <span class="o">),</span>
  <span class="n">exists.intro</span> <span class="n">M</span> <span class="n">s6</span>
<span class="o">)</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="218189051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218189051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218189051">(Nov 29 2020 at 00:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lt_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">omega</span>
<span class="kd">lemma</span> <span class="n">lt_succ_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">omega</span>
<span class="kd">lemma</span> <span class="n">lt_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">omega</span>
<span class="kd">lemma</span> <span class="n">succ_pos</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">omega</span>
<span class="kd">lemma</span> <span class="n">lt_one</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">omega</span>
<span class="kd">lemma</span> <span class="n">le_of_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">omega</span>
</code></pre></div>



<a name="218189111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218189111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218189111">(Nov 29 2020 at 01:00)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">fin.eq_of_veq</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">=</span> <span class="n">j.val</span> <span class="bp">→</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">cases</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218189265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218189265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218189265">(Nov 29 2020 at 01:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[elab_as_eliminator]</span> <span class="kd">def</span> <span class="n">fin.induction</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">C</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">C</span> <span class="n">i.cast_succ</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span> <span class="n">C</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩,</span>
  <span class="n">induction</span> <span class="n">i</span> <span class="k">with</span> <span class="n">j</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h0</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">hs</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">(</span><span class="n">hj</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">nat.lt_of_succ_lt_succ</span> <span class="n">hi</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218189577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218189577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218189577">(Nov 29 2020 at 01:15)</a>:</h4>
<p>Your problem with <code>fin.max</code> can be seen from the error:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>type mismatch at application
  fin.max (P.n - 1) m
term
  m
has type
  fin P.n → ℝ : Type
but is expected to have type
  fin (P.n - 1 + 1) → ?m_1 : Type ?
</code></pre></div>
<p>For a general natural number <code>x</code>, <code>x-1+1</code> isn't equal to x. This is why you should avoid natural number subtraction. I would recommend using <code>a2 : 0 &lt; P.n</code> to actually get your hands on some natural <code>r</code> such that <code>P.n=r+1</code> and then using <code>r</code> instead. Like this: Add something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">temp_lemma</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m.succ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>(I'm surprised this isn't in the library) and then</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">...</span>
    <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
    <span class="n">Exists.some_spec</span> <span class="o">(</span><span class="n">s0</span> <span class="n">i</span><span class="o">)</span>
  <span class="o">),</span>
  <span class="kd">begin</span>
    <span class="n">cases</span> <span class="n">temp_lemma</span> <span class="n">a2</span> <span class="k">with</span> <span class="n">r</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hr</span> <span class="n">at</span> <span class="n">m</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">fin.max</span> <span class="n">r</span> <span class="n">m</span> <span class="k">with</span> <span class="n">hM</span><span class="o">,</span>
    <span class="n">sorry</span>
  <span class="kd">end</span>
</code></pre></div>
<p>(I'm switching to tactic mode because this proof is massive, doing it in term mode seems crazy to me).</p>



<a name="218189824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218189824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218189824">(Nov 29 2020 at 01:22)</a>:</h4>
<p>Thank you!</p>



<a name="218190698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218190698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218190698">(Nov 29 2020 at 01:50)</a>:</h4>
<p>Sorry, if you don't mind, how would you handle the <code>rw hr at m</code> without tactics?</p>



<a name="218194646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218194646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218194646">(Nov 29 2020 at 04:00)</a>:</h4>
<p>I think I got it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">a0</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">P.n</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
<span class="n">or.elim</span> <span class="n">s1</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">singleton_partition</span> <span class="n">P</span> <span class="n">a1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">a</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">singleton_bounded</span> <span class="n">a</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">eq.subst</span> <span class="n">s2</span> <span class="n">s3</span>
<span class="o">)</span>
<span class="o">(</span>
  <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">P.n</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">Exists.some</span> <span class="o">(</span><span class="n">s0</span> <span class="n">i</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">m</span> <span class="n">i</span> <span class="o">:=</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
    <span class="n">Exists.some_spec</span> <span class="o">(</span><span class="n">s0</span> <span class="n">i</span><span class="o">)</span>
  <span class="o">),</span>
  <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">exists_succ_eq</span> <span class="n">a2</span><span class="o">,</span>
  <span class="n">exists.elim</span> <span class="n">s5</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">P.n</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">m'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">m</span> <span class="o">(</span><span class="bp">@</span><span class="n">fin.mk</span> <span class="n">P.n</span> <span class="n">i.val</span> <span class="o">(</span><span class="n">eq.subst</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="n">a3</span><span class="o">)</span> <span class="o">(</span><span class="n">i.prop</span><span class="o">)))</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">fin.max</span> <span class="n">r</span> <span class="n">m'</span> <span class="k">in</span>
    <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">m</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">(</span>
      <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">&lt;</span> <span class="n">P.n</span> <span class="o">:=</span> <span class="n">i.prop</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">i.val</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">a3</span> <span class="n">s7</span><span class="o">,</span>
      <span class="k">let</span> <span class="n">i'</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">i.val</span> <span class="n">s8</span> <span class="k">in</span>
      <span class="k">have</span> <span class="n">s9</span> <span class="o">:</span> <span class="n">m'</span> <span class="n">i'</span> <span class="bp">=</span> <span class="n">m</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">m'</span> <span class="n">i'</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">s10</span> <span class="o">:</span> <span class="n">m'</span> <span class="n">i'</span> <span class="bp">≤</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">fin.all_le_max</span> <span class="n">r</span> <span class="n">m'</span> <span class="n">i'</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">m</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">M</span><span class="o">,</span> <span class="k">from</span> <span class="n">eq.subst</span> <span class="n">s9</span> <span class="n">s10</span>
    <span class="o">),</span>
    <span class="k">have</span> <span class="n">s11</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">(</span>
      <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
      <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s12</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">partition_mem</span> <span class="n">P</span> <span class="n">a2</span> <span class="n">x</span> <span class="n">a4</span><span class="o">,</span>
      <span class="n">exists.elim</span> <span class="n">s12</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
        <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span>
        <span class="k">have</span> <span class="n">s13</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">m</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">s4</span> <span class="n">i</span> <span class="n">x</span> <span class="n">a4</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s14</span> <span class="o">:</span> <span class="n">m</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">s6</span> <span class="n">i</span><span class="o">,</span>
        <span class="k">show</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">M</span><span class="o">,</span> <span class="k">from</span> <span class="n">le_trans</span> <span class="n">s13</span> <span class="n">s14</span>
      <span class="o">)</span>
    <span class="o">),</span>
    <span class="n">exists.intro</span> <span class="n">M</span> <span class="n">s11</span>
  <span class="o">)</span>
<span class="o">)</span>
</code></pre></div>



<a name="218227172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218227172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218227172">(Nov 29 2020 at 19:47)</a>:</h4>
<p>What is the correct way to define the function <code>t</code> here?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">is_riemann_integral</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">is_riemann_integral</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="n">R</span><span class="o">,</span>
<span class="n">by_contradiction</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exists.elim</span> <span class="n">a0</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">is_riemann_integral</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="n">R</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="mi">1</span> <span class="k">in</span>
    <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">a2</span> <span class="n">ε</span> <span class="n">s0</span><span class="o">,</span>
    <span class="n">exists.elim</span> <span class="n">s1</span> <span class="o">(</span>
      <span class="k">assume</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
      <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a3</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a3</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="o">:=</span> <span class="n">norm_delta_exists</span> <span class="n">δ</span> <span class="n">s2</span><span class="o">,</span>
      <span class="n">exists.elim</span> <span class="n">s4</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
        <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">s3</span> <span class="n">P</span> <span class="n">a4</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
        <span class="n">exists.elim</span> <span class="n">s6</span> <span class="o">(</span>
          <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
          <span class="k">assume</span> <span class="n">a5</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
          <span class="k">let</span> <span class="n">Q</span> <span class="o">:=</span> <span class="n">default</span> <span class="o">(</span><span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">(</span><span class="n">Q.t</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">))</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">T</span> <span class="o">:=</span> <span class="n">R</span> <span class="bp">-</span> <span class="n">S</span> <span class="k">in</span>
          <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">((</span><span class="n">T</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)))</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
          <span class="n">exists.elim</span> <span class="n">s7</span> <span class="o">(</span>
            <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
            <span class="k">assume</span> <span class="n">a6</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)),</span> <span class="n">abs</span> <span class="o">((</span><span class="n">T</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)))</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">ε</span><span class="o">,</span>
            <span class="n">exists.elim</span> <span class="n">a6</span> <span class="o">(</span>
              <span class="k">assume</span> <span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span>
              <span class="k">assume</span> <span class="n">a7</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">((</span><span class="n">T</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)))</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">ε</span><span class="o">,</span>
              <span class="k">let</span> <span class="n">t</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P.n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">j</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P.n</span><span class="o">),</span> <span class="k">if</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">Q.t</span> <span class="n">j</span> <span class="k">in</span>
            <span class="o">)</span>
          <span class="o">)</span>
        <span class="o">)</span>
      <span class="o">)</span>
    <span class="o">)</span>
  <span class="o">)</span>
<span class="o">)</span>
</code></pre></div>



<a name="218232664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218232664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218232664">(Nov 29 2020 at 21:55)</a>:</h4>
<p>I can't make this compile. Can you give a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> ?</p>



<a name="218233372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218233372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218233372">(Nov 29 2020 at 22:12)</a>:</h4>
<p>I'm trying to fix the error in the definition of <code>t</code>. Actually, I think this is going to be a mess dealing with rearranging the sum, but I don't know of a way to make it any easier.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.order</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">structure</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop</span> <span class="o">:</span> <span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>


<span class="kd">lemma</span> <span class="n">lt_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_succ_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">succ_pos</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_one</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">le_of_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">exists_succ_eq</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">zero_le</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">def</span> <span class="n">fin.cast_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a.val</span> <span class="o">(</span><span class="n">lt_lt_succ</span> <span class="n">a.prop</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">fin.succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">a.val</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lt_succ_lt_succ</span> <span class="n">a.prop</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="o">{</span><span class="n">zero</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="n">succ_pos</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">fin.last</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span> <span class="n">lt_succ</span>


<span class="kd">def</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">M</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">abs</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">M</span>


<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>


<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">norm</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">norm_delta_exists</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="o">:=</span> <span class="n">sorry</span>


<span class="kd">structure</span> <span class="n">tagged_partition</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">t</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>


<span class="kd">def</span> <span class="n">riemann_sum</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">sorry</span>


<span class="kd">def</span> <span class="n">is_riemann_integral</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span>


<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">is_riemann_integral</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">is_riemann_integral</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="n">R</span><span class="o">,</span>
<span class="n">by_contradiction</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">exists.elim</span> <span class="n">a0</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">is_riemann_integral</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="n">R</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="mi">1</span> <span class="k">in</span>
    <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">a2</span> <span class="n">ε</span> <span class="n">s0</span><span class="o">,</span>
    <span class="n">exists.elim</span> <span class="n">s1</span> <span class="o">(</span>
      <span class="k">assume</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
      <span class="k">assume</span> <span class="n">a3</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">and.left</span> <span class="n">a3</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">and.right</span> <span class="n">a3</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="o">:=</span> <span class="n">norm_delta_exists</span> <span class="n">δ</span> <span class="n">s2</span><span class="o">,</span>
      <span class="n">exists.elim</span> <span class="n">s4</span> <span class="o">(</span>
        <span class="k">assume</span> <span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
        <span class="k">assume</span> <span class="n">a4</span> <span class="o">:</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">,</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">s3</span> <span class="n">P</span> <span class="n">a4</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
        <span class="n">exists.elim</span> <span class="n">s6</span> <span class="o">(</span>
          <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
          <span class="k">assume</span> <span class="n">a5</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
          <span class="k">let</span> <span class="n">Q</span> <span class="o">:=</span> <span class="n">default</span> <span class="o">(</span><span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">riemann_sum</span> <span class="n">Q</span> <span class="n">f</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">(</span><span class="n">Q.t</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">))</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">T</span> <span class="o">:=</span> <span class="n">R</span> <span class="bp">-</span> <span class="n">S</span> <span class="k">in</span>
          <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">((</span><span class="n">T</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)))</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
          <span class="n">exists.elim</span> <span class="n">s7</span> <span class="o">(</span>
            <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
            <span class="k">assume</span> <span class="n">a6</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)),</span> <span class="n">abs</span> <span class="o">((</span><span class="n">T</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)))</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">ε</span><span class="o">,</span>
            <span class="n">exists.elim</span> <span class="n">a6</span> <span class="o">(</span>
              <span class="k">assume</span> <span class="n">H</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span>
              <span class="k">assume</span> <span class="n">a7</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">((</span><span class="n">T</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)))</span> <span class="bp">-</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≥</span> <span class="n">ε</span><span class="o">,</span>
              <span class="k">let</span> <span class="n">t</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P.n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">j</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P.n</span><span class="o">),</span> <span class="k">if</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">Q.t</span> <span class="n">j</span> <span class="k">in</span>
            <span class="o">)</span>
          <span class="o">)</span>
        <span class="o">)</span>
      <span class="o">)</span>
    <span class="o">)</span>
  <span class="o">)</span>
<span class="o">)</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="218235712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218235712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218235712">(Nov 29 2020 at 23:19)</a>:</h4>
<p>Here's a close to your state, but in tactic format, which is easier for me to parse:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">R</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">is_riemann_integral</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_bounded_on</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">sum</span><span class="o">,</span> <span class="n">hsum</span><span class="o">⟩,</span>
  <span class="n">by_contra</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="mi">1</span> <span class="k">with</span> <span class="n">hε</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">εpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">hε</span><span class="o">,</span> <span class="n">exact</span> <span class="n">zero_lt_one</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">δ</span><span class="o">,</span> <span class="n">δpos</span><span class="o">,</span> <span class="n">hδ</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">tP</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">),</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">tP</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">sum</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">hsum</span> <span class="n">ε</span> <span class="n">εpos</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">P</span><span class="o">,</span> <span class="n">hP</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">),</span> <span class="n">norm</span> <span class="n">P</span> <span class="bp">&lt;</span> <span class="n">δ</span> <span class="o">:=</span> <span class="n">norm_delta_exists</span> <span class="n">δ</span> <span class="n">δpos</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">htag</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">tP</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">),</span> <span class="n">abs</span> <span class="o">((</span><span class="n">riemann_sum</span> <span class="n">tP</span> <span class="n">f</span><span class="o">)</span> <span class="bp">-</span> <span class="n">sum</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">hδ</span> <span class="n">P</span> <span class="n">hP</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">),</span> <span class="bp">¬</span> <span class="n">is_bounded_on</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">tP</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">default</span> <span class="n">_</span> <span class="k">with</span> <span class="n">htP</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">tagged_sum</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">riemann_sum</span> <span class="n">tP</span> <span class="n">f</span> <span class="k">with</span> <span class="n">htsum</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">rect</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">(</span><span class="n">tP.t</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">))</span> <span class="k">with</span> <span class="n">hrect</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">overflow</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">tagged_sum</span> <span class="bp">-</span> <span class="n">rect</span> <span class="k">with</span> <span class="n">hover</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">htpmem</span> <span class="o">:</span> <span class="n">tP.t</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tP.mem_block</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hx'</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span>
    <span class="n">ε</span> <span class="bp">≤</span> <span class="n">abs</span> <span class="o">((</span><span class="n">overflow</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">((</span><span class="n">P.x</span> <span class="n">i.succ</span> <span class="bp">-</span> <span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)))</span> <span class="bp">-</span> <span class="n">sum</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">is_bounded_on</span> <span class="n">at</span> <span class="n">H</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">push_neg</span> <span class="n">at</span> <span class="n">H</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218249325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218249325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218249325">(Nov 30 2020 at 05:05)</a>:</h4>
<p>Now we need to create a new tagged partition that uses the <code>x</code> from the last obtain right? That is what I am struggling with.</p>



<a name="218253968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218253968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218253968">(Nov 30 2020 at 07:03)</a>:</h4>
<p>Well I think that you would have to make that definition and associated API outside of the proof context.</p>



<a name="218254008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218254008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218254008">(Nov 30 2020 at 07:03)</a>:</h4>
<p>Right now you have no formalized way of constructing tagged partitions at all, your inhabited instance (which really encodes data, and not proof) is sorried.</p>



<a name="218352791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218352791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218352791">(Nov 30 2020 at 22:05)</a>:</h4>
<p>Does this work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">default</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">t</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">,</span>
    <span class="n">mem_block</span> <span class="o">:=</span> <span class="o">(</span>
      <span class="k">assume</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">P.x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="n">m.cast_succ</span> <span class="o">:=</span> <span class="n">le_refl</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">P.x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="n">m.succ</span> <span class="o">:=</span> <span class="n">P.mono</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">and.intro</span> <span class="n">s0</span> <span class="n">s1</span>
    <span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>I'm still not sure how to construct a new tagged partition using <code>x</code>. I think that has to be done? Is there a better approach to this proof? Different definitions or statements of the theorems?</p>



<a name="218359294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218359294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218359294">(Nov 30 2020 at 23:06)</a>:</h4>
<p>A possibly more minimal MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.order</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">structure</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop</span> <span class="o">:</span> <span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>


<span class="kd">lemma</span> <span class="n">lt_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_succ_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">succ_pos</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_one</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">le_of_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">exists_succ_eq</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">zero_le</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">def</span> <span class="n">fin.cast_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a.val</span> <span class="o">(</span><span class="n">lt_lt_succ</span> <span class="n">a.prop</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">fin.succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">a.val</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lt_succ_lt_succ</span> <span class="n">a.prop</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="o">{</span><span class="n">zero</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="n">succ_pos</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">fin.last</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span> <span class="n">lt_succ</span>


<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>


<span class="kd">structure</span> <span class="n">tagged_partition</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">t</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">default</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">t</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">,</span>
    <span class="n">mem_block</span> <span class="o">:=</span> <span class="o">(</span>
      <span class="k">assume</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">P.x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="n">m.cast_succ</span> <span class="o">:=</span> <span class="n">le_refl</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">P.x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="n">m.succ</span> <span class="o">:=</span> <span class="n">P.mono</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">and.intro</span> <span class="n">s0</span> <span class="n">s1</span>
    <span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">tagged_partition_replace</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span>
<span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">j</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P.n</span><span class="o">),</span> <span class="k">if</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">Q.t</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">mem_block</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="o">}</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="218360475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218360475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218360475">(Nov 30 2020 at 23:20)</a>:</h4>
<p>You still need to come up with a way of generating a <code>tagged_partition P</code> to begin with</p>



<a name="218360592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218360592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218360592">(Nov 30 2020 at 23:22)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.order</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">structure</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop</span> <span class="o">:</span> <span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>


<span class="kd">lemma</span> <span class="n">lt_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_succ_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">succ_pos</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_one</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">le_of_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">exists_succ_eq</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">zero_le</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">def</span> <span class="n">fin.cast_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a.val</span> <span class="o">(</span><span class="n">lt_lt_succ</span> <span class="n">a.prop</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">fin.succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">a.val</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lt_succ_lt_succ</span> <span class="n">a.prop</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="o">{</span><span class="n">zero</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="n">succ_pos</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">fin.last</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">fin.mk</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span> <span class="n">lt_succ</span>


<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>


<span class="kd">structure</span> <span class="n">tagged_partition</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">t</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">default</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">t</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">,</span>
    <span class="n">mem_block</span> <span class="o">:=</span> <span class="o">(</span>
      <span class="k">assume</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">P.x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="n">m.cast_succ</span> <span class="o">:=</span> <span class="n">le_refl</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">P.x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">P.x</span> <span class="n">m.succ</span> <span class="o">:=</span> <span class="n">P.mono</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">and.intro</span> <span class="n">s0</span> <span class="n">s1</span>
    <span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">tagged_partition_replace</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span>
<span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">j</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="n">P.n</span><span class="o">),</span> <span class="k">if</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">Q.t</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">mem_block</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="o">}</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="218361181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218361181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218361181">(Nov 30 2020 at 23:30)</a>:</h4>
<p>I'm trying to resolve this error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
<span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
<span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">,</span>
<span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
<span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">),</span>
<span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span>
<span class="bp">⊢</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">j</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>



<a name="218361230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218361230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218361230">(Nov 30 2020 at 23:31)</a>:</h4>
<p><code>open_locale classical</code> will make it go away</p>



<a name="218361392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218361392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218361392">(Nov 30 2020 at 23:32)</a>:</h4>
<p>And not defining your own <code>fin</code>.</p>



<a name="218361437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218361437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218361437">(Nov 30 2020 at 23:33)</a>:</h4>
<p>In fact, you don't need <code>open_locale classical</code> if you don't define your own <code>fin</code></p>



<a name="218361482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218361482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218361482">(Nov 30 2020 at 23:33)</a>:</h4>
<p>What is different about my <code>fin</code> that causes this?</p>



<a name="218361642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218361642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218361642">(Nov 30 2020 at 23:35)</a>:</h4>
<p>You didn't prove a decidable equality instance for it. Which, you have two options for, either assume classical, or say that decidable equality of the values makes them equal.</p>



<a name="218361904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218361904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218361904">(Nov 30 2020 at 23:38)</a>:</h4>
<p>What actually does it mean for two instances of a structure to be equal in Lean? Is that a built in definition somewhere?</p>



<a name="218361954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218361954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218361954">(Nov 30 2020 at 23:39)</a>:</h4>
<p>Normally if you make a new structure then straight afterwards you prove an extensionality lemma, which is a practical way to prove that two instances are equal.</p>



<a name="218362064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362064">(Nov 30 2020 at 23:40)</a>:</h4>
<p>But more recently people got sick of this and so now you can put <code>@[derive ext]</code> just before your structure definition, and then the <code>ext</code>tactic will do the best it can to prove a sensible theorem of the form "if the data parts are equal, then the instances are equal"</p>



<a name="218362066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362066">(Nov 30 2020 at 23:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.order</span> <span class="n">data.real.basic</span> <span class="n">data.set.intervals</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">structure</span> <span class="n">partition</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_zero</span> <span class="o">:</span> <span class="n">x</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_last</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">mono</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">x</span> <span class="n">m.cast_succ</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">m.succ</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">tagged_partition</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_block</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">,</span> <span class="n">t</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">m.succ</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">default_tp</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="o">⟨</span><span class="n">le_rfl</span><span class="o">,</span> <span class="n">P.mono</span> <span class="n">m</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">default_tp</span> <span class="n">P</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">tagged_partition_replace</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span>
<span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">function.update</span> <span class="n">Q.t</span> <span class="n">i</span> <span class="n">x</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hm</span> <span class="o">:</span> <span class="o">(</span><span class="n">m</span> <span class="bp">=</span> <span class="n">i</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">hm</span><span class="o">,</span> <span class="n">function.update_apply</span><span class="o">,</span> <span class="n">if_true</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">]</span> <span class="n">using</span> <span class="n">h0</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">hm</span><span class="o">,</span> <span class="n">function.update_noteq</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">]</span> <span class="n">using</span> <span class="n">Q.mem_block</span> <span class="n">m</span><span class="o">},</span>
<span class="kd">end</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="218362254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362254">(Nov 30 2020 at 23:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/218362064">said</a>:</p>
<blockquote>
<p>But more recently people got sick of this and so now you can put <code>@[derive ext]</code> just before your structure definition, and then the <code>ext</code>tactic will do the best it can to prove a sensible theorem of the form "if the data parts are equal, then the instances are equal"</p>
</blockquote>
<p>What is the definition of 'the instances are equal' that has to be proven?</p>



<a name="218362284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362284">(Nov 30 2020 at 23:43)</a>:</h4>
<p>the data fields are equal.</p>



<a name="218362373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362373">(Nov 30 2020 at 23:44)</a>:</h4>
<p>What is the difference between 'the data parts are equal' and 'the data fields are equal'?</p>



<a name="218362386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362386">(Nov 30 2020 at 23:44)</a>:</h4>
<p>nothing</p>



<a name="218362409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362409">(Nov 30 2020 at 23:44)</a>:</h4>
<p>two complex numbers are equal if and only if their real and imaginary parts are equal</p>



<a name="218362447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362447">(Nov 30 2020 at 23:45)</a>:</h4>
<p>two terms of type <code>fin n</code> are equal if the natural parts are equal, I don't need to worry about whether the proofs are equal.</p>



<a name="218362462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362462">(Nov 30 2020 at 23:45)</a>:</h4>
<p>I thought you said we have to prove that 'if the data parts are equal, then the instances are equal'.</p>



<a name="218362480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362480">(Nov 30 2020 at 23:45)</a>:</h4>
<p>Yes.</p>



<a name="218362531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362531">(Nov 30 2020 at 23:46)</a>:</h4>
<p>Um, sorry, this seems circular.</p>



<a name="218362584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362584">(Nov 30 2020 at 23:47)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/c3f4d1b8bf781c5ba55b0bb3d4588174d1a00d38/src/data/complex/basic.lean#L43-L44">There's an example</a></p>



<a name="218362623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362623">(Nov 30 2020 at 23:47)</a>:</h4>
<p>It's the point in mathlib where it is proved that two complex numbers are equal if their real and imaginary parts are equal.</p>



<a name="218362691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362691">(Nov 30 2020 at 23:48)</a>:</h4>
<p>But it needed to be proved.</p>



<a name="218362714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362714">(Nov 30 2020 at 23:48)</a>:</h4>
<p>Here's how core Lean does it for <code>fin</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">decidable_of_decidable_of_iff</span>
  <span class="o">(</span><span class="n">nat.decidable_eq</span> <span class="n">i.val</span> <span class="n">j.val</span><span class="o">)</span> <span class="o">⟨</span><span class="n">eq_of_veq</span><span class="o">,</span> <span class="n">veq_of_eq</span><span class="o">⟩</span>
</code></pre></div>



<a name="218362758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362758">(Nov 30 2020 at 23:49)</a>:</h4>
<p>If you make a new structure, it's your job to make a useful test for equality of terms of that structure.</p>



<a name="218362825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362825">(Nov 30 2020 at 23:50)</a>:</h4>
<p>In any case, just use regular ol' <code>fin</code> instead of spinning your own</p>



<a name="218362832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362832">(Nov 30 2020 at 23:50)</a>:</h4>
<p>Unless you have some issues with it?</p>



<a name="218362854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362854">(Nov 30 2020 at 23:50)</a>:</h4>
<p>Yakov's code is a proof that there's an algorithm to determine equality of two terms of type <code>fin n</code>, and the proof is "we already know there's an algorithm to check to see if two natural numbers are equal, and all the rest is noise"</p>



<a name="218362864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362864">(Nov 30 2020 at 23:50)</a>:</h4>
<p>I mean, you're using <code>\R</code> for reals, so why not use <code>fin</code> as provided?</p>



<a name="218362913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362913">(Nov 30 2020 at 23:51)</a>:</h4>
<p>I don't agree that it's "just noise", someone does have to write the <code>eq_of_veq</code> and <code>veq_of_eq</code>, which is what is needed for the custom <code>fin</code></p>



<a name="218362949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362949">(Nov 30 2020 at 23:52)</a>:</h4>
<p>If you don't use mathlib's fin then it's your job to make all the bells and whistles which you'll need to make your fin usable.</p>



<a name="218362963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218362963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218362963">(Nov 30 2020 at 23:52)</a>:</h4>
<p>It's just the tedium of formalization, even more tedious than plain old real analysis</p>



<a name="218363218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363218">(Nov 30 2020 at 23:54)</a>:</h4>
<p>In any case, this is all a detour from your <code>partition</code> question, to which I provided a definition that works above. In this sort of formalization, you have to choose how far "down the rabbit hole" you want to go. I think it's fine to <code>sorry</code> the lemmas about <code>fin</code> behavior, etc, just know that <code>function.update</code> expects a <code>decidable_eq</code> instance (which you can also sorry, or do <code>open_locale_classical</code> or whatever). Since you aren't really working on formalizing <code>fin</code>, but something about the summability of partitions, I think it's fine to <code>sorry</code> it.</p>



<a name="218363265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363265">(Nov 30 2020 at 23:55)</a>:</h4>
<p>I was just using my own <code>fin</code> to make sure I understood how it worked. I can abandon it I guess.</p>



<a name="218363285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363285">(Nov 30 2020 at 23:55)</a>:</h4>
<p>I used <code>function.update</code> because it comes with nice lemmas and API about how to deal with when things are equal or not. If you prefer the <code>if j = i then x else ...</code> that forces a classical context anyway.</p>



<a name="218363342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363342">(Nov 30 2020 at 23:56)</a>:</h4>
<p>And then you would use <code>if_pos</code> and <code>if_neg</code> instead of <code>function.update_apply</code> and <code>function.update_noteq</code></p>



<a name="218363405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363405">(Nov 30 2020 at 23:56)</a>:</h4>
<p>"how it worked" is a scary hole to go down..., but laden with great questions!</p>



<a name="218363422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363422">(Nov 30 2020 at 23:57)</a>:</h4>
<p>I hope that some of that explanation re <code>fin</code> was useful. If you're interested, we can discuss that more, or focus more on the <code>partition</code> problem</p>



<a name="218363462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363462">(Nov 30 2020 at 23:57)</a>:</h4>
<p>I've looked down a lot of the <code>fin</code> hole, but haven't looked at all how the reals are defined...</p>



<a name="218363533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363533">(Nov 30 2020 at 23:58)</a>:</h4>
<p>I guess I'll focus on the partition problem for now.</p>



<a name="218363581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363581">(Nov 30 2020 at 23:59)</a>:</h4>
<p>Thank you!</p>



<a name="218363702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363702">(Dec 01 2020 at 00:00)</a>:</h4>
<p>Even if we use <code>if ... then ... else ...</code> it still is unhappy about <code>decidable</code>. So you can just do <code>open_locale classical</code> to avoid that</p>



<a name="218363729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363729">(Dec 01 2020 at 00:00)</a>:</h4>
<p>In any case, here's an equivalent definition in <code>if then else</code> style:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">tagged_partition_replace'</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span><span class="o">)</span>
<span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">P.n</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">set.Icc</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">P.x</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="n">tagged_partition</span> <span class="n">P</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="k">if</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">Q.t</span> <span class="n">j</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">hm</span><span class="o">]</span> <span class="n">using</span> <span class="n">h0</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">Q.mem_block</span> <span class="n">m</span> <span class="o">},</span>
<span class="kd">end</span><span class="o">⟩</span>
</code></pre></div>



<a name="218363893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363893">(Dec 01 2020 at 00:02)</a>:</h4>
<p>Cool.</p>



<a name="218363990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218363990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218363990">(Dec 01 2020 at 00:03)</a>:</h4>
<p>where <code>split_ifs</code> knows how to break the <code>if then  else</code> into two cases and give you the resulting goals</p>



<a name="218364166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218364166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218364166">(Dec 01 2020 at 00:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/218362254">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/218362064">said</a>:</p>
<blockquote>
<p>But more recently people got sick of this and so now you can put <code>@[derive ext]</code> just before your structure definition, and then the <code>ext</code>tactic will do the best it can to prove a sensible theorem of the form "if the data parts are equal, then the instances are equal"</p>
</blockquote>
<p>What is the definition of 'the instances are equal' that has to be proven?</p>
</blockquote>
<p>Equal as in <code>=</code>, which is defined uniformly for all types, as an inductive type</p>



<a name="218364828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218364828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218364828">(Dec 01 2020 at 00:11)</a>:</h4>
<p>Hmm. Ok.</p>



<a name="218364971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218364971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218364971">(Dec 01 2020 at 00:12)</a>:</h4>
<p>I had looked at the definition of equal earlier, and had been surprised to see that it was defined inductively, but had set aside worrying about it until later :)</p>



<a name="218365002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365002">(Dec 01 2020 at 00:13)</a>:</h4>
<p>Looking at the definition doesn't really help. Equality in type theory is something you just get used to.</p>



<a name="218365032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365032">(Dec 01 2020 at 00:13)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}=\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> is neither provable nor disprovable in Lean.</p>



<a name="218365160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365160">(Dec 01 2020 at 00:14)</a>:</h4>
<p>Is that a statement that the types are equal?</p>



<a name="218365174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365174">(Dec 01 2020 at 00:14)</a>:</h4>
<p>You can just think of <code>=</code> as built-in, as the thing that lets you <code>subst</code> (or <code>rw</code>, etc.)</p>



<a name="218365180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365180">(Dec 01 2020 at 00:14)</a>:</h4>
<p>Right. Equality of types is really random.</p>



<a name="218365304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365304">(Dec 01 2020 at 00:15)</a>:</h4>
<p>Equality of terms is a bit saner, but even then it's still quite random. If you've played the natural number game you'll know that if <code>n : nat</code> then <code>0 + n = n</code> and <code>n + 0 = n</code>, but one of these can be proved by <code>refl</code> and the other can't, because the internal definition of <code>+</code> is asymmetric.</p>



<a name="218365389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365389">(Dec 01 2020 at 00:16)</a>:</h4>
<p>Yes, I remember that.</p>



<a name="218365390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365390">(Dec 01 2020 at 00:16)</a>:</h4>
<p>Both are true, but they're true for different reasons.</p>



<a name="218365506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365506">(Dec 01 2020 at 00:17)</a>:</h4>
<p>So when you're talking about whether two instances of a structure are equal, you can ask whether they're equal by definition, or whether they can be proved to be equal, and these are two different questions. As a mathematician I tend to disregard definitional equality, this is some implementation-dependent question. This is why I tag my structures with <code>@[derive ext]</code> and take the theorem which is on offer.</p>



<a name="218365682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365682">(Dec 01 2020 at 00:20)</a>:</h4>
<p>Is equal by definition the same as the lamba calculus equality? I forget what it is called, beta reduction or something?</p>



<a name="218365725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365725">(Dec 01 2020 at 00:20)</a>:</h4>
<p>Lean just has some random set of rules about what is equal by definition. Just above that <code>complex.ext</code> link above is the definition of <code>complex.eta</code>, which is the theorem that if you start with a complex number z, and then make the complex number whose real part is re(z) and whose imaginary part is im(z), then the complex number you get is z. These two complex numbers are not definitionally equal however. Why not? Don't ask me, this is all part of Lean's definition of definitionally equal, and the issues here are well beyond my understanding of type theory.</p>



<a name="218365777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365777">(Dec 01 2020 at 00:21)</a>:</h4>
<p>Yeah exactly, this reduction and that reduction. I guess the thing I just said must be eta reduction if the lemma is called <code>eta</code>. In the reference manual there's a list of which greek letter reductions are true by definition, and then the other ones aren't.</p>



<a name="218365803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365803">(Dec 01 2020 at 00:21)</a>:</h4>
<p><a href="https://leanprover.github.io/reference/expressions.html#computation">https://leanprover.github.io/reference/expressions.html#computation</a></p>



<a name="218365885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365885">(Dec 01 2020 at 00:22)</a>:</h4>
<p>This is a really careful definition of what definitional equality is (although I'm always confused by it because there is some theorem about quotients whose proof is <code>rfl</code> and it's not mentioned there)</p>



<a name="218365945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365945">(Dec 01 2020 at 00:22)</a>:</h4>
<p>eta equivalence for functions is on the list, eta equivalence for structures is not. Go figure. These are subtle design issues.</p>



<a name="218365983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218365983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218365983">(Dec 01 2020 at 00:23)</a>:</h4>
<p>What matters (to me) is not what is true by definition, but what is true (or more precisely what is provable).</p>



<a name="218366665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366665">(Dec 01 2020 at 00:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/218365725">said</a>:</p>
<blockquote>
<p>[...] then make the complex number whose real part is re(z) and whose imaginary part is im(z), then the complex number you get is z. These two complex numbers are not definitionally equal however. </p>
</blockquote>
<p>In my mind, I hand-wave that as the difference between:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">mk</span> <span class="o">(</span><span class="n">re</span> <span class="o">(</span><span class="n">mk</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">im</span> <span class="o">(</span><span class="n">mk</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">mk</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>



<a name="218366713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366713">(Dec 01 2020 at 00:32)</a>:</h4>
<p>But <code>mk (re (mk a b)) (im (mk a b)) = mk a b</code> probably _is_ definitional!</p>



<a name="218366783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366783">(Dec 01 2020 at 00:32)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.complex.basic</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">mk</span> <span class="o">(</span><span class="n">re</span> <span class="o">(</span><span class="n">mk</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">im</span> <span class="o">(</span><span class="n">mk</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="218366827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366827">(Dec 01 2020 at 00:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.complex.basic</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">mk</span> <span class="o">(</span><span class="n">re</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">im</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="218366854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366854">(Dec 01 2020 at 00:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.complex.basic</span>

<span class="kn">open</span> <span class="n">complex</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">mk</span> <span class="o">(</span><span class="n">re</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">im</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">z</span><span class="bp">;</span> <span class="n">refl</span> <span class="c1">-- works</span>
</code></pre></div>



<a name="218366859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366859">(Dec 01 2020 at 00:34)</a>:</h4>
<p>Is some lemma somewhere tagged with <code>[refl]</code>in one case and not in another?</p>



<a name="218366923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366923">(Dec 01 2020 at 00:34)</a>:</h4>
<p>no, the difference is simply the difference between <code>z : \C</code> and <code>complex.mk a b : \C</code></p>



<a name="218366965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366965">(Dec 01 2020 at 00:35)</a>:</h4>
<p>This is exactly how you prove the <code>ext</code> lemmas: if you have <code>a b : X</code> where <code>X</code> is your structure, then you do cases on <code>a</code> and <code>b</code> and then let the dust settle.</p>



<a name="218366970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366970">(Dec 01 2020 at 00:35)</a>:</h4>
<p>Fascinating</p>



<a name="218366978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366978">(Dec 01 2020 at 00:35)</a>:</h4>
<p>crazy, if you ask me</p>



<a name="218366988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218366988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218366988">(Dec 01 2020 at 00:35)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="n">rfl</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_2</span> <span class="bp">=</span> <span class="bp">?</span><span class="n">m_2</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="o">{</span><span class="n">re</span> <span class="o">:=</span> <span class="n">z.re</span><span class="o">,</span> <span class="n">im</span> <span class="o">:=</span> <span class="n">z.im</span><span class="o">}</span> <span class="bp">=</span> <span class="n">z</span>
</code></pre></div>



<a name="218367038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367038">(Dec 01 2020 at 00:36)</a>:</h4>
<p>right. But if you take z apart, it works fine.</p>



<a name="218367058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367058">(Dec 01 2020 at 00:36)</a>:</h4>
<p>because <code>re (mk a b) = a</code> is definitional, because some greek letter happens to be in some set of definitional greek letters.</p>



<a name="218367121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367121">(Dec 01 2020 at 00:37)</a>:</h4>
<p>I think this might all go back to all those fractions which stop me getting past page 1 of Mario's thesis.</p>



<a name="218367204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367204">(Dec 01 2020 at 00:38)</a>:</h4>
<p><a href="https://github.com/digama0/lean-type-theory/releases/download/v1.0/main.pdf">https://github.com/digama0/lean-type-theory/releases/download/v1.0/main.pdf</a></p>



<a name="218367245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367245">(Dec 01 2020 at 00:39)</a>:</h4>
<p>Oh it's p6 where the fractions start.</p>



<a name="218367367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367367">(Dec 01 2020 at 00:41)</a>:</h4>
<p>Maybe something on page 8, 9 or 10 says <code>re (mk a b) = a</code> is definitional. But for me definitional equality is not important, the only things I know about it are things I've randomly picked up when making stuff like the <a href="https://github.com/ImperialCollegeLondon/complex-number-game">complex number game</a>.</p>



<a name="218367436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367436">(Dec 01 2020 at 00:42)</a>:</h4>
<p>I guess <code>mk a b</code> is a nice pleasant structured <code>z</code> unlike <code>z \in</code> </p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mn>0</mn><mo>=</mo><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi mathvariant="normal">∞</mi></munderover><mfrac><mn>1</mn><msup><mi>n</mi><mi>z</mi></msup></mfrac></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle 0 =\sum _{n=1}^{\infty }{\frac {1}{n^{z}}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9185100000000004em;vertical-align:-1.267113em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></span></p>



<a name="218367633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367633">(Dec 01 2020 at 00:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis/near/218367367">said</a>:</p>
<blockquote>
<p>Maybe something on page 8, 9 or 10 says <code>re (mk a b) = a</code> is definitional. But for me definitional equality is not important, the only things I know about it are things I've randomly picked up when making stuff like the <a href="https://github.com/ImperialCollegeLondon/complex-number-game">complex number game</a>.</p>
</blockquote>
<p>fwiw, it's the first "fraction" (inference rule) in section 2.6.4, on page 12</p>



<a name="218367677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367677">(Dec 01 2020 at 00:45)</a>:</h4>
<p>After failed attempts at explaining to undergraduate mathematicians why <code>0 + n = n</code> needed a proof but <code>n + 0 = n</code> was true by definition, I gave up, told them that <code>add_zero</code> was an axiom, disabled post-refl testing in <code>rw</code> and the natural number game in its current form was born, where people have to <code>rw add_zero, refl</code> to prove <code>n + 0 = n</code> even though <code>refl</code> would do it (but they don't know this, although people discover it by accident and file bug reports).</p>



<a name="218367759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367759">(Dec 01 2020 at 00:46)</a>:</h4>
<p>You could even use <code>constant</code>/<code>axiom</code> to introduce <code>+</code>, but maybe it would be too disruptive</p>



<a name="218367777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367777">(Dec 01 2020 at 00:47)</a>:</h4>
<p>maybe I'll try that for the filter game.</p>



<a name="218367860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367860">(Dec 01 2020 at 00:48)</a>:</h4>
<p>maybe not.</p>



<a name="218367869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218367869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218367869">(Dec 01 2020 at 00:48)</a>:</h4>
<p>Aah! So it's iota reduction.</p>



<a name="218376835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218376835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218376835">(Dec 01 2020 at 03:27)</a>:</h4>
<p>I'm guessing there are already theorems for this example, and others, like rearranging sums, splitting sums, etc, in mathlib using <code>finset</code> or <code>fintype</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fin.sum</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">+</span> <span class="o">(</span><span class="n">fin.sum</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span><span class="o">)))</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_sub</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x₀</span> <span class="n">x₁</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="bp">¬</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">x₁</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">x₀</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
<span class="n">fin.sum</span> <span class="n">n</span> <span class="n">x₁</span> <span class="bp">=</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="n">x₀</span> <span class="bp">-</span> <span class="n">x₀</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">x₁</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="218377718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218377718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218377718">(Dec 01 2020 at 03:44)</a>:</h4>
<p>Hmm. Could probably use <code>finset.add_sum_diff_singleton</code>.</p>



<a name="218377958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218377958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218377958">(Dec 01 2020 at 03:49)</a>:</h4>
<p>How do you make a <code>finset</code> from <code>fin</code> using <code>finset.mk</code>?</p>



<a name="218378560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218378560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218378560">(Dec 01 2020 at 04:01)</a>:</h4>
<p>If I click on the source for <a href="https://leanprover-community.github.io/mathlib_docs/algebra/big_operators/basic.html#finset.sum">https://leanprover-community.github.io/mathlib_docs/algebra/big_operators/basic.html#finset.sum</a> it takes me to the definition for <code>finset.prod</code>, and I can't seem to find the definition for <code>finset.sum</code>.</p>



<a name="218380026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218380026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218380026">(Dec 01 2020 at 04:34)</a>:</h4>
<p>It's defined automatically from the prod definition via the to_additive attribute. This is a metaprogram that converts addition symbols in the definition to multiplication and defines the analogous definition with the word prod replaced with sum</p>



<a name="218380051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218380051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218380051">(Dec 01 2020 at 04:35)</a>:</h4>
<p>Oh. Ok. Thank you.</p>



<a name="218380101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218380101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218380101">(Dec 01 2020 at 04:36)</a>:</h4>
<p>Related: <a href="https://leanprover-community.github.io/mathlib_docs/attributes.html#to_additive">attr#to_additive</a></p>



<a name="218381940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218381940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218381940">(Dec 01 2020 at 05:19)</a>:</h4>
<p>Is this actually not possible, because there is no guarantee that the function maps to all unique values?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fin_fn_to_finset</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">finset.mk</span> <span class="o">(</span><span class="n">list.of_fn</span> <span class="n">f</span><span class="o">)</span> <span class="n">sorry</span>
</code></pre></div>



<a name="218382011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218382011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218382011">(Dec 01 2020 at 05:20)</a>:</h4>
<p>And if I forced it, then the sums etc. using finset would not be as expected.</p>



<a name="218382105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218382105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218382105">(Dec 01 2020 at 05:23)</a>:</h4>
<p>(deleted)</p>



<a name="218397553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218397553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218397553">(Dec 01 2020 at 09:30)</a>:</h4>
<p>I think the <code>sum</code> stuff in <code>algebra.big_operators</code> will work over any <code>fintype</code> (and <code>fin n</code> is a fintype), but it might be worth writing explicit stuff for <code>fin</code> anyway because there are more possibilities for induction principlles.</p>



<a name="218504869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218504869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218504869">(Dec 02 2020 at 01:21)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x₀</span> <span class="n">x₁</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="bp">¬</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">x₁</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">x₀</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">x₁</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">x₀</span> <span class="n">i</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x₀</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">x₁</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">fin.sum_univ_succ_above</span> <span class="n">_</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">fin.sum_univ_succ_above</span> <span class="n">_</span> <span class="n">j</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span> <span class="o">(</span><span class="n">x₀</span> <span class="n">j</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">add_sub_assoc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sub_self</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_zero</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_right_cancel_iff</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">finset.sum_congr</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h0</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">fin.succ_above_ne</span> <span class="n">j</span> <span class="n">i</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218504925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218504925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218504925">(Dec 02 2020 at 01:22)</a>:</h4>
<p>I expanded out all the <code>rw</code> steps as opposed to a <code>simp</code> so that you can see the way the proof state is transformed.</p>



<a name="218505019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218505019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218505019">(Dec 02 2020 at 01:23)</a>:</h4>
<p>In simp style:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x₀</span> <span class="n">x₁</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="bp">¬</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">x₁</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">x₀</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">x₁</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">x₀</span> <span class="n">i</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x₀</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">x₁</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">fin.sum_univ_succ_above</span> <span class="n">_</span> <span class="n">j</span><span class="o">,</span> <span class="n">h0</span><span class="o">,</span> <span class="n">fin.succ_above_ne</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">]</span>
</code></pre></div>



<a name="218505106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218505106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218505106">(Dec 02 2020 at 01:24)</a>:</h4>
<p>In fact, it's true even for <code>fin n</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x₀</span> <span class="n">x₁</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">x₁</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">x₀</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">x₁</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">x₀</span> <span class="n">i</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x₀</span> <span class="n">j</span> <span class="bp">+</span> <span class="n">x₁</span> <span class="n">j</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">fin_zero_elim</span> <span class="n">j</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">fin.sum_univ_succ_above</span> <span class="n">_</span> <span class="n">j</span><span class="o">,</span> <span class="n">h0</span><span class="o">,</span> <span class="n">fin.succ_above_ne</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218507257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218507257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218507257">(Dec 02 2020 at 02:02)</a>:</h4>
<p>Nice! Thank you!<br>
Do you think it is still worth writing explicit stuff for <code>fin</code> as Kevin suggested? It could be fun and informative.</p>



<a name="218507512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218507512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218507512">(Dec 02 2020 at 02:06)</a>:</h4>
<p>I learnt a lot about Lean by making my own natural numbers, complex numbers, and groups. In fact me and some undergraduates have developed more group theory using our own version of groups than there is in Lean right now!</p>



<a name="218511907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218511907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218511907">(Dec 02 2020 at 03:32)</a>:</h4>
<p>It could be - the main complexity with fin is coercions to nat and back, in my opinion. And learning how to provide the coercion instances in a way that works well with other lemmas can be tricky.</p>



<a name="218961161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218961161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218961161">(Dec 06 2020 at 00:33)</a>:</h4>
<p>I'm trying to figure out why neither attempt at <code>s1</code> works. I think it has something to do with casting, but I'm not sure.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin</span>

<span class="kd">def</span> <span class="n">fin.sum</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">+</span> <span class="o">(</span><span class="n">fin.sum</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span><span class="o">)))</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
<span class="n">fin.sum</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat.zero</span> <span class="o">{</span>
  <span class="k">show</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="k">from</span>
  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">zero_add</span> <span class="mi">1</span><span class="o">,</span>
  <span class="c1">-- have s1 : c * 1 = c * (0 + 1) := @eq.subst α (fun x : α, c * 1 = c * x) 1 (0 + 1) s0 (eq.refl (c * 1)),</span>
  <span class="c1">-- have s1 : c * 1 = c * (0 + 1), by rw s0,</span>
  <span class="k">calc</span>
  <span class="n">fin.sum</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">fin.sum</span> <span class="mi">0</span> <span class="n">x</span><span class="o">)</span>
  <span class="bp">...</span>         <span class="bp">=</span> <span class="n">c</span> <span class="o">:</span> <span class="n">h</span> <span class="mi">0</span>
  <span class="bp">...</span>         <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">eq.symm</span> <span class="o">(</span><span class="n">mul_one</span> <span class="n">c</span><span class="o">))</span>
  <span class="bp">...</span>         <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">sorry</span>
<span class="o">},</span>
<span class="n">case</span> <span class="n">nat.succ</span> <span class="o">:</span> <span class="n">n</span> <span class="n">IH</span> <span class="o">{</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  IH : ∀ (x : fin (n + 1) → α), (∀ (i : fin (n + 1)), x i = c) → fin.sum n x = c * (↑n + 1),</span>
<span class="cm">  x : fin (n.succ + 1) → α,</span>
<span class="cm">  h : ∀ (i : fin (n.succ + 1)), x i = c</span>
<span class="cm">  -/</span>
  <span class="k">show</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="k">from</span>
  <span class="k">let</span> <span class="n">x'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">h</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">x</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s0</span> <span class="n">s1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">x'</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="bp">→</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">IH</span> <span class="n">x'</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">x'</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">s5</span> <span class="o">:</span> <span class="n">x'</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">x</span> <span class="n">i.cast_succ</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="o">(</span><span class="n">x'</span> <span class="n">i</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">s6</span> <span class="o">:</span> <span class="n">x</span> <span class="n">i.cast_succ</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">i.cast_succ</span><span class="o">,</span>
    <span class="n">eq.trans</span> <span class="n">s5</span> <span class="n">s6</span>
  <span class="o">),</span>
  <span class="k">have</span> <span class="n">s7</span> <span class="o">:</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">s3</span> <span class="n">s4</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s8</span> <span class="o">:</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq.subst</span> <span class="n">s7</span> <span class="n">s2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s9</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">eq.trans</span> <span class="n">s8</span> <span class="n">s9</span>
<span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218961415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218961415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218961415">(Dec 06 2020 at 00:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
</code></pre></div>
<p>works, the <code>rw s0</code> version doesn't as s0 is an equality of natural numbers, you probably want</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">zero_add</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
</code></pre></div>
<p>instead</p>



<a name="218961556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218961556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218961556">(Dec 06 2020 at 00:45)</a>:</h4>
<p>That works. Thank you!</p>



<a name="218966309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218966309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218966309">(Dec 06 2020 at 03:20)</a>:</h4>
<p>Is there a single tactic that would work for the last sorry?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin</span>


<span class="kd">def</span> <span class="n">fin.sum</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">+</span> <span class="o">(</span><span class="n">fin.sum</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span><span class="o">)))</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
<span class="n">fin.sum</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat.zero</span> <span class="o">{</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  x : fin (0 + 1) → α,</span>
<span class="cm">  h : ∀ (i : fin (0 + 1)), x i = c</span>
<span class="cm">  -/</span>
  <span class="k">show</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="k">from</span>
  <span class="k">calc</span>
  <span class="n">fin.sum</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="mi">0</span>         <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="bp">...</span>         <span class="bp">=</span> <span class="n">c</span>           <span class="o">:</span> <span class="n">h</span> <span class="mi">0</span>
  <span class="bp">...</span>         <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span>
<span class="o">},</span>
<span class="n">case</span> <span class="n">nat.succ</span> <span class="o">:</span> <span class="n">n</span> <span class="n">IH</span> <span class="o">{</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  IH : ∀ (x : fin (n + 1) → α), (∀ (i : fin (n + 1)), x i = c) → fin.sum n x = c * (↑n + 1),</span>
<span class="cm">  x : fin (n.succ + 1) → α,</span>
<span class="cm">  h : ∀ (i : fin (n.succ + 1)), x i = c</span>
<span class="cm">  -/</span>
  <span class="k">show</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="k">from</span>
  <span class="k">let</span> <span class="n">x'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">x'</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
    <span class="k">calc</span>
    <span class="n">x'</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">x</span> <span class="n">i.cast_succ</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
    <span class="bp">...</span>  <span class="bp">=</span> <span class="n">c</span>             <span class="o">:</span> <span class="n">h</span> <span class="n">i.cast_succ</span>
  <span class="o">),</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">IH</span> <span class="n">x'</span> <span class="n">s0</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">h</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">),</span>
  <span class="k">calc</span>
  <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="n">x'</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="bp">...</span>              <span class="bp">=</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>  <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">s1</span>
  <span class="bp">...</span>              <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>                    <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">s2</span>
  <span class="bp">...</span>              <span class="bp">=</span> <span class="n">c</span> <span class="bp">*</span> <span class="o">((</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>                  <span class="o">:</span> <span class="kd">by</span> <span class="n">sorry</span>
<span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="218966330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218966330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218966330">(Dec 06 2020 at 03:22)</a>:</h4>
<p><code>by noncomm_ring</code> does it</p>



<a name="218966374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218966374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218966374">(Dec 06 2020 at 03:22)</a>:</h4>
<p><code>by rw [mul_add, nat.cast_one, mul_one, add_comm]</code> should work (haven't tested)</p>



<a name="218966376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218966376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218966376">(Dec 06 2020 at 03:22)</a>:</h4>
<p>if you count that as "one tactic"</p>



<a name="218966386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/218966386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#218966386">(Dec 06 2020 at 03:23)</a>:</h4>
<p><code>noncomm_ring</code> worked. Thank you!</p>



<a name="219778303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/219778303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#219778303">(Dec 13 2020 at 20:03)</a>:</h4>
<p>Any recommendations on which sum definition to go with, or something else?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin</span> <span class="n">tactic</span> <span class="n">algebra.order</span>


<span class="kd">def</span> <span class="n">fin.sum</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">+</span> <span class="o">(</span><span class="n">fin.sum</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span><span class="o">)))</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span>
<span class="n">fin.sum</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">ite</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>


<span class="kd">def</span> <span class="n">fin.sum'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">m</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">fin.sum</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span><span class="o">)))</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
<span class="n">fin.sum'</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum'</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">fin.cast_succ</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="219779703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/219779703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#219779703">(Dec 13 2020 at 20:28)</a>:</h4>
<p>Go with the one that's already in the library! Unless you want to go through the whole process of proving sum(a_n + b_n)  = sum a_n + sum b_n, sum(c)=N*c, a_n &lt;= b_n implies sum a_n &lt;= sum b_n and the 100 other lemmas you need to make a working sum theory by yourself (which you might want to do -- I have made group theory in Lean from first principle with undergraduates and it was rewarding from a teaching perspective)</p>



<a name="219779829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/219779829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#219779829">(Dec 13 2020 at 20:31)</a>:</h4>
<p>I was trying your suggestion: "I think the sum stuff in algebra.big_operators will work over any fintype (and fin n is a fintype), but it might be worth writing explicit stuff for fin anyway because there are more possibilities for induction principlles."</p>



<a name="219780090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/219780090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#219780090">(Dec 13 2020 at 20:36)</a>:</h4>
<p>I'm not sure in what sense "there are more possibilities for induction principlles." Would you have an example?</p>



<a name="219780190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/219780190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#219780190">(Dec 13 2020 at 20:38)</a>:</h4>
<p>Maybe I mean "there are more possibilities for lemmas". For example a sum over fin(a+b) is a sum over fin(a) plus an appropriately shifted sum over fin(b). I don't know what I was talking about with induction principles.</p>



<a name="219780933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/219780933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#219780933">(Dec 13 2020 at 20:57)</a>:</h4>
<p>I found that when I thought I had special cases for fin, what I actually had were lemmas about sum types (not to be confused with summations), and the <code>fin (n + m)</code> case fell out of  <a href="https://leanprover-community.github.io/mathlib_docs/find/sum_fin_sum_equiv">docs#sum_fin_sum_equiv</a></p>



<a name="219782279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/219782279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#219782279">(Dec 13 2020 at 21:28)</a>:</h4>
<p>What is a sum type? I'm not sure I follow the idea from the definition.</p>



<a name="221182353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221182353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221182353">(Dec 30 2020 at 01:25)</a>:</h4>
<p>Is there a tactic that will break an equality into separate goals for each subexpression?<br>
For example to change <code>|- a + (b + c) = d + (e + f)</code> into <code>|- a = d |- b = e |- c = f</code>.</p>



<a name="221182426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221182426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221182426">(Dec 30 2020 at 01:26)</a>:</h4>
<p><code>congr</code></p>



<a name="221182442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221182442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221182442">(Dec 30 2020 at 01:26)</a>:</h4>
<p>or more cleanly, likely <code>congr' 1</code></p>



<a name="221182529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221182529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221182529">(Dec 30 2020 at 01:28)</a>:</h4>
<p>Nice. Thank you!</p>



<a name="221184320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221184320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221184320">(Dec 30 2020 at 02:14)</a>:</h4>
<p>Is there a tactic to compute instances of function application?</p>



<a name="221184465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221184465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221184465">(Dec 30 2020 at 02:19)</a>:</h4>
<p>For example, to change</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>   <span class="k">let</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">fin.mk</span> <span class="n">x.val</span> <span class="n">a0</span> <span class="k">in</span>
   <span class="k">let</span> <span class="n">f'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span> <span class="k">in</span>
   <span class="bp">|-</span> <span class="n">f'</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span>
</code></pre></div>
<p>to <code>f x'.cast_succ = f x</code>.</p>



<a name="221184811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221184811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221184811">(Dec 30 2020 at 02:28)</a>:</h4>
<p>try <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#dsimp">tactic#dsimp</a> if that doesn't do what you want please post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="221185773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221185773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221185773">(Dec 30 2020 at 02:52)</a>:</h4>
<p>I'm not sure how to fix the syntax to make a mwe. Something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x'</span> <span class="o">:=</span> <span class="n">fin.mk</span> <span class="n">x.val</span> <span class="n">h0</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">f'</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="221185954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221185954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221185954">(Dec 30 2020 at 02:56)</a>:</h4>
<p>Is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span><span class="o">)</span> <span class="o">:</span>
<span class="k">let</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">fin.mk</span> <span class="n">x.val</span> <span class="n">h0</span><span class="o">,</span> <span class="n">f'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span> <span class="k">in</span>
<span class="n">f'</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">begin</span>
<span class="n">dsimp</span><span class="o">,</span>
<span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>what you meant then?</p>



<a name="221185956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221185956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221185956">(Dec 30 2020 at 02:56)</a>:</h4>
<p>So <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#dsimp">tactic#dsimp</a> does work?</p>



<a name="221186236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221186236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221186236">(Dec 30 2020 at 03:03)</a>:</h4>
<p>Hmm. I thought that would be a mwe. This is what doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin</span> <span class="n">tactic</span>

<span class="kd">lemma</span> <span class="n">le_of_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_one</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">fin.lt_one_eq_zero</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">x.prop</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">lt_one</span> <span class="n">s0</span><span class="o">,</span>
<span class="n">fin.eq_of_veq</span> <span class="n">s1</span>


<span class="kd">def</span> <span class="n">fin.sum</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">m</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span> <span class="n">x</span> <span class="n">i.cast_succ</span><span class="o">)</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
<span class="n">fin.sum</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat.zero</span> <span class="o">{</span>
  <span class="k">show</span> <span class="n">fin.sum</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">)),</span> <span class="k">from</span>
  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">fin.lt_one_eq_zero</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">calc</span>
  <span class="n">fin.sum</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span>                         <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="bp">...</span>               <span class="bp">=</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span>                                    <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="bp">...</span>               <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span>                                    <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">s0</span>
  <span class="bp">...</span>               <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">0</span>                                                                           <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="bp">...</span>               <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="o">},</span>
<span class="n">case</span> <span class="n">nat.succ</span> <span class="o">:</span> <span class="n">n</span> <span class="n">IH</span> <span class="o">{</span>
  <span class="k">show</span> <span class="n">fin.sum</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">)),</span> <span class="k">from</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span> <span class="bp">∨</span> <span class="n">x.val</span> <span class="bp">=</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="n">lt_or_eq_of_le</span> <span class="o">(</span><span class="n">le_of_lt_succ</span> <span class="n">x.prop</span><span class="o">),</span>
  <span class="n">or.elim</span> <span class="n">s1</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">fin.mk</span> <span class="n">x.val</span> <span class="n">a0</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">f'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span> <span class="k">in</span>
    <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">f'</span> <span class="bp">=</span> <span class="n">f'</span> <span class="n">x'</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x'</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:=</span> <span class="n">IH</span> <span class="n">f'</span> <span class="n">x'</span><span class="o">,</span>
    <span class="k">calc</span>
    <span class="n">fin.sum</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">f'</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f'</span> <span class="n">x'</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x'</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.succ</span><span class="o">)))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">s2</span>
    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f'</span> <span class="n">x'</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x'</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.succ</span><span class="o">)))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">noncomm_ring</span>
    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span>
                           <span class="bp">+</span> <span class="o">((</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span>
                           <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="n">i.cast_succ</span><span class="o">))</span> <span class="o">:</span>
                           <span class="kd">begin</span>
                           <span class="n">congr</span><span class="o">,</span>
                           <span class="n">dsimp</span><span class="o">,</span>

                           <span class="kd">end</span>


    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="o">)</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">=</span> <span class="n">n.succ</span><span class="o">,</span>
    <span class="k">calc</span>
    <span class="n">fin.sum</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">:</span> <span class="gr">sorry</span>
    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="gr">sorry</span>
  <span class="o">)</span>
<span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221186588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221186588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221186588">(Dec 30 2020 at 03:12)</a>:</h4>
<p>I see, there are no lets in the goal, when you wrote</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>   <span class="k">let</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">fin.mk</span> <span class="n">x.val</span> <span class="n">a0</span> <span class="k">in</span>
   <span class="k">let</span> <span class="n">f'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span> <span class="k">in</span>
   <span class="bp">|-</span> <span class="n">f'</span> <span class="n">x'</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span>
</code></pre></div>
<p>it looked like there would be, its really helpful to post actual lean code in this case, the working + example parts are more helpful then being minimal in this case <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.<br>
Anyway you can do those substitutions with simp like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin</span> <span class="n">tactic</span>

<span class="kd">lemma</span> <span class="n">le_of_lt_succ</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">lemma</span> <span class="n">lt_one</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">fin.lt_one_eq_zero</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">x.prop</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">lt_one</span> <span class="n">s0</span><span class="o">,</span>
<span class="n">fin.eq_of_veq</span> <span class="n">s1</span>


<span class="kd">def</span> <span class="n">fin.sum</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">m</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">m</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span> <span class="n">x</span> <span class="n">i.cast_succ</span><span class="o">)</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
<span class="n">fin.sum</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat.zero</span> <span class="o">{</span>
  <span class="k">show</span> <span class="n">fin.sum</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">)),</span> <span class="k">from</span>
  <span class="k">have</span> <span class="n">s0</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">fin.lt_one_eq_zero</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">calc</span>
  <span class="n">fin.sum</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span>                         <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="bp">...</span>               <span class="bp">=</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span>                                    <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="bp">...</span>               <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span>                                    <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">s0</span>
  <span class="bp">...</span>               <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">0</span>                                                                           <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="bp">...</span>               <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="mi">0</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="o">},</span>
<span class="n">case</span> <span class="n">nat.succ</span> <span class="o">:</span> <span class="n">n</span> <span class="n">IH</span> <span class="o">{</span>
  <span class="k">show</span> <span class="n">fin.sum</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">)),</span> <span class="k">from</span>
  <span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span> <span class="bp">∨</span> <span class="n">x.val</span> <span class="bp">=</span> <span class="n">n.succ</span> <span class="o">:=</span> <span class="n">lt_or_eq_of_le</span> <span class="o">(</span><span class="n">le_of_lt_succ</span> <span class="n">x.prop</span><span class="o">),</span>
  <span class="n">or.elim</span> <span class="n">s1</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a0</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">&lt;</span> <span class="n">n.succ</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">x'</span> <span class="o">:=</span> <span class="n">fin.mk</span> <span class="n">x.val</span> <span class="n">a0</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">f'</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span> <span class="k">in</span>
    <span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">f'</span> <span class="bp">=</span> <span class="n">f'</span> <span class="n">x'</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x'</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:=</span> <span class="n">IH</span> <span class="n">f'</span> <span class="n">x'</span><span class="o">,</span>
    <span class="k">calc</span>
    <span class="n">fin.sum</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="n">f'</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f'</span> <span class="n">x'</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x'</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.succ</span><span class="o">)))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">s2</span>
    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f'</span> <span class="n">x'</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x'</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="n">i.succ</span><span class="o">)))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">noncomm_ring</span>
    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span>
                           <span class="bp">+</span> <span class="o">((</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span>
                           <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="n">i.cast_succ</span><span class="o">))</span> <span class="o">:</span>
                           <span class="kd">begin</span>
                           <span class="n">congr</span><span class="o">,</span>
                           <span class="n">simp</span> <span class="o">[</span><span class="n">f'</span><span class="o">,</span> <span class="n">x'</span><span class="o">],</span>
                           <span class="n">congr</span><span class="o">,</span>
                           <span class="n">exact</span> <span class="n">fin.eta</span> <span class="n">x</span> <span class="n">_</span><span class="o">,</span>
                           <span class="kd">end</span>


    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
  <span class="o">)</span>
  <span class="o">(</span>
    <span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x.val</span> <span class="bp">=</span> <span class="n">n.succ</span><span class="o">,</span>
    <span class="k">calc</span>
    <span class="n">fin.sum</span> <span class="o">(</span><span class="n">n.succ</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">:</span> <span class="gr">sorry</span>
    <span class="bp">...</span>                    <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">fin.sum</span> <span class="n">n.succ</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">i.cast_succ</span> <span class="bp">&lt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.cast_succ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">i.succ</span><span class="o">))</span> <span class="o">:</span> <span class="gr">sorry</span>
  <span class="o">)</span>
<span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221186739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221186739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221186739">(Dec 30 2020 at 03:16)</a>:</h4>
<p>Thank you!</p>



<a name="221186755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221186755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221186755">(Dec 30 2020 at 03:16)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>                           <span class="kd">begin</span>
                           <span class="n">simp</span> <span class="o">[</span><span class="n">f'</span><span class="o">,</span> <span class="n">x'</span><span class="o">],</span>
                           <span class="n">congr</span><span class="o">,</span>
                           <span class="n">exact</span> <span class="n">fin.eta</span> <span class="n">x</span> <span class="n">_</span><span class="o">,</span>
                           <span class="n">rw</span> <span class="n">if_neg</span><span class="o">,</span>
                           <span class="n">simp</span><span class="o">,</span>
                           <span class="n">exact</span> <span class="n">le_of_lt_succ</span> <span class="n">a0</span><span class="o">,</span>
                           <span class="n">ext</span><span class="o">,</span><span class="n">congr</span><span class="o">,</span>
                           <span class="n">exact</span> <span class="n">fin.cast_succ_fin_succ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
                           <span class="kd">end</span>
</code></pre></div>
<p>does that inner goal completely <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>, these goals are very messy though, I wonder if there are some lemmas that need splitting out ?</p>



<a name="221186892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221186892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221186892">(Dec 30 2020 at 03:20)</a>:</h4>
<p>Maybe, I'm not sure.</p>



<a name="221188145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221188145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221188145">(Dec 30 2020 at 03:54)</a>:</h4>
<p>I agree, it does seem rather messy. I'm not sure what to pull out for lemmas though.</p>



<a name="221202436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221202436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221202436">(Dec 30 2020 at 10:06)</a>:</h4>
<p>I think your <code>fin.lt_one_eq_zero</code> is <a href="https://leanprover-community.github.io/mathlib_docs/find/subsingleton.elim">docs#subsingleton.elim</a> or similar</p>



<a name="221240808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221240808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221240808">(Dec 30 2020 at 19:45)</a>:</h4>
<p>Looks like it might be <code>fin.eq_zero</code>.</p>



<a name="221240915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221240915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221240915">(Dec 30 2020 at 19:46)</a>:</h4>
<p>Is there a fold operation defined for <code>fin</code>? I wonder if that would make it simpler.</p>



<a name="221241137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221241137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221241137">(Dec 30 2020 at 19:49)</a>:</h4>
<p>There is <code>finset.fold</code> which you could apply on <code>univ</code>. Not sure if that is helpful.</p>



<a name="221243566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20definitions%20for%20real%20analysis/near/221243566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/formalizing.20definitions.20for.20real.20analysis.html#221243566">(Dec 30 2020 at 20:23)</a>:</h4>
<p>Yeah, I should probably just move to the library definition anyway. I had started this lemma, so I had wanted to finish it first.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html">invalid nat.cases_on application</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="179237461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179237461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Gilbey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179237461">(Oct 28 2019 at 14:47)</a>:</h4>
<p>Hi, I'm just getting my head around Lean 3, and working through the Logic and Proof book on the Lean github page.  I'm trying to prove that \le is a total order on the naturals, but my code gives an error which I'm struggling to make sense of.  Any help would be much appreciated!   The code is below.  (Yes, I know my coding style is very rudimentary, and I haven't yet learnt how to use rw effectively.  I'll get there!  Any pointers in that direction would be helpful, but in the meantime, what is this bizarre error?  It would be good to have a "minimal example", but I don't know how to trim this one down, I'm afraid.)</p>
<p>The error message reads:</p>
<div class="codehilite"><pre><span></span>error: invalid &#39;nat.cases_on&#39; application, elaborator has special support for this kind of application (it is handled as an &quot;eliminator&quot;), but expected type must not contain metavariables
  ?m_1
</pre></div>


<p>and here is my code:</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">nat</span>

<span class="c1">-- we define ≼ to mean less than or equal to, using the following definition</span>
<span class="c1">-- rather than the inductive definition lean uses; yes, they&#39;re equivalent,</span>
<span class="c1">-- but let&#39;s see how this one goes!</span>
<span class="n">def</span> <span class="n">leq</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≼</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">leq</span>

<span class="kn">theorem</span> <span class="n">ineq_totality</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">zero_add</span><span class="o">,</span>
   <span class="k">have</span> <span class="n">hi</span> <span class="o">:</span> <span class="mi">0</span> <span class="err">≼</span> <span class="n">m</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">m</span> <span class="n">h</span><span class="o">,</span>
   <span class="k">show</span> <span class="mi">0</span> <span class="err">≼</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="err">≼</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">hi</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
   <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">n</span><span class="o">,</span>
   <span class="n">or</span><span class="bp">.</span><span class="n">elim</span>
     <span class="o">(</span><span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h1</span> <span class="err">$</span>
        <span class="k">assume</span> <span class="n">c</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">m</span><span class="o">),</span>
        <span class="n">nat</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">c</span>
         <span class="o">(</span><span class="k">have</span> <span class="n">he</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="k">calc</span>
              <span class="n">succ</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span><span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span>    <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">eq</span><span class="bp">.</span><span class="n">subst</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hc</span><span class="o">)</span>
                 <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span>         <span class="o">:</span> <span class="n">rfl</span><span class="o">,</span>
          <span class="k">have</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="mi">1</span> <span class="n">he</span><span class="o">,</span>
          <span class="k">show</span> <span class="n">succ</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">hi</span><span class="o">)</span>
         <span class="o">(</span><span class="k">assume</span> <span class="n">c</span><span class="o">,</span>
          <span class="k">have</span> <span class="n">he</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">m</span><span class="o">,</span> <span class="k">by</span> <span class="k">calc</span>
              <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>   <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">succ_add</span>
                     <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span>   <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_symm</span>
                     <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">n</span>     <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">succ_add</span>
                     <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">c</span>     <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_symm</span>
                     <span class="bp">...</span> <span class="bp">=</span> <span class="n">m</span>              <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">hc</span><span class="o">,</span>
          <span class="k">have</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">c</span> <span class="n">he</span><span class="o">,</span>
          <span class="k">show</span> <span class="n">succ</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">hi</span><span class="o">))</span>
     <span class="o">(</span><span class="k">assume</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">n</span><span class="o">,</span>
      <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h1</span> <span class="err">$</span>
        <span class="k">assume</span> <span class="n">c</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">n</span><span class="o">),</span>
        <span class="k">have</span> <span class="n">he</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="k">calc</span>
            <span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>   <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">succ_add</span>
                   <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span>         <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">c</span> <span class="n">he</span><span class="o">,</span>
        <span class="k">show</span> <span class="n">succ</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">hi</span><span class="o">))</span>
</pre></div>


<p>Many thanks!</p>



<a name="179240233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179240233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179240233">(Oct 28 2019 at 15:15)</a>:</h4>
<p>The step where you use <code>or.elim</code> looks wrong to me. If I insert <code>by {}; exact</code> before <code>or.elim</code> (a handy trick from <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> to inspect the goal in "term-mode" proofs), I see:</p>
<div class="codehilite"><pre><span></span>1 goal
m n n : ℕ,
ih : n ≼ m ∨ m ≼ n
⊢ succ n ≼ m ∨ m ≼ succ n
</pre></div>


<p><del>But <code>or.elim</code> has type <code>∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c</code> which doesn't clear something like this. Naïvely, you would want to use <code>or.inl</code> or <code>or.inr</code> instead. But in fact that won't work because you don't know which case you're in. So I think you need to apply classical logic somewhere, maybe <code>classical.em : ∀ (p : Prop), p ∨ ¬p</code>.</del></p>
<p><del>(Not sure about this, but I think the error appears because Lean introduces a metavariable when trying to unify the <code>or.elim</code> stuff with the goal and these aren't allowed in the goal when you use <code>nat.cases_on</code>.)</del></p>
<p><strong>Edit</strong>: whoops, I was way off. Sorry, see the messages below!</p>



<a name="179241079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179241079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179241079">(Oct 28 2019 at 15:23)</a>:</h4>
<p>This is just horrible. Beginners writing their proofs with all that have, show, assume stuff. Tactic mode is absolutely the canonical way to prove something like this. This exercise makes a beginner think that using a theorem prover is hell.</p>



<a name="179241561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179241561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179241561">(Oct 28 2019 at 15:27)</a>:</h4>
<p><span class="user-mention" data-user-id="242660">@Julian Gilbey</span> the line <code>or.elim</code> (L17) should be <code>or.elim ih</code></p>



<a name="179241570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179241570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179241570">(Oct 28 2019 at 15:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span> <span class="c1">-- mathlib tactics</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="c1">-- we define ≼ to mean less than or equal to, using the following definition</span>
<span class="c1">-- rather than the inductive definition lean uses; yes, they&#39;re equivalent,</span>
<span class="c1">-- but let&#39;s see how this one goes!</span>
<span class="n">def</span> <span class="n">leq</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≼</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">leq</span>

<span class="kn">theorem</span> <span class="n">ineq_totality</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- base case</span>
    <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">right</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- inductive step,</span>
    <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n&#39;</span><span class="o">,</span>
      <span class="n">left</span><span class="o">,</span> <span class="n">use</span> <span class="n">succ</span> <span class="n">d</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hd</span> <span class="n">n&#39;</span><span class="o">,</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">e</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">he</span><span class="o">,</span> <span class="n">add_succ</span><span class="o">],</span>
    <span class="n">right</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">he</span><span class="o">,</span> <span class="n">add_succ</span><span class="o">],</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="179241613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179241613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179241613">(Oct 28 2019 at 15:27)</a>:</h4>
<p><span class="user-mention" data-user-id="242660">@Julian Gilbey</span> the real problem is that the entire thing should be in tactic mode so you can see what you're doing.</p>



<a name="179241698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179241698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179241698">(Oct 28 2019 at 15:28)</a>:</h4>
<p>Check out chapter 5 of Theorem Proving In Lean to get you out of this assume, show, have hell.</p>



<a name="179242163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179242163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179242163">(Oct 28 2019 at 15:32)</a>:</h4>
<p><span class="user-mention" data-user-id="242660">@Julian Gilbey</span> and if you insist using term mode you can use some syntactic sugars to make it look nicer:</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">nat</span>

<span class="c1">-- we define ≼ to mean less than or equal to, using the following definition</span>
<span class="c1">-- rather than the inductive definition lean uses; yes, they&#39;re equivalent,</span>
<span class="c1">-- but let&#39;s see how this one goes!</span>
<span class="n">def</span> <span class="n">leq</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≼</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">leq</span>

<span class="kn">theorem</span> <span class="n">ineq_totality</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero_add</span> <span class="n">m</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">ineq_totality</span> <span class="n">m</span> <span class="n">n</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span>   <span class="n">hc</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">hc</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_zero</span> <span class="n">n</span><span class="o">]</span><span class="bp">⟩</span>
    <span class="bp">|</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨</span><span class="n">c</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hc</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨</span><span class="n">c</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_comm</span> <span class="mi">1</span> <span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">]</span><span class="bp">⟩</span>
    <span class="bp">|</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="bp">⟨</span><span class="n">c</span><span class="o">,</span>   <span class="n">hc</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="bp">⟨</span><span class="n">c</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">hc</span><span class="o">]</span><span class="bp">⟩</span>
    <span class="kn">end</span>
</pre></div>



<a name="179242432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179242432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Gilbey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179242432">(Oct 28 2019 at 15:35)</a>:</h4>
<blockquote>
<p>This is just horrible. Beginners writing their proofs with all that have, show, assume stuff. Tactic mode is absolutely the canonical way to prove something like this. This exercise makes a beginner think that using a theorem prover is hell.</p>
</blockquote>
<p>Yes, quite! And I am a complete beginner <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span>   So I'm looking forward to learning tactic mode!</p>



<a name="179242486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179242486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Gilbey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179242486">(Oct 28 2019 at 15:35)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="242660">Julian Gilbey</span> the line <code>or.elim</code> (L17) should be <code>or.elim ih</code></p>
</blockquote>
<p>Thanks!  And then I can correct my remaining errors which now appear...</p>



<a name="179242493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179242493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179242493">(Oct 28 2019 at 15:35)</a>:</h4>
<p>In tactic mode you can see all goals at all times and exactly what you are assuming.</p>



<a name="179242578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179242578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179242578">(Oct 28 2019 at 15:36)</a>:</h4>
<p>Let me stress that this is not your fault! This is just the method that Avigad uses to teach people, perhaps because it's more suited to the kind of elementary questions that beginner CS people have.</p>



<a name="179242604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179242604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179242604">(Oct 28 2019 at 15:36)</a>:</h4>
<p>But you're working on a very natural maths question so you should try tactic mode.</p>



<a name="179242627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179242627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179242627">(Oct 28 2019 at 15:37)</a>:</h4>
<p>I think this question is somewhere in world 5 on <a href="http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/" target="_blank" title="http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/">http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/</a></p>



<a name="179242658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179242658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179242658">(Oct 28 2019 at 15:37)</a>:</h4>
<p>oh no it's not quite there yet. It's coming up in v1.1, to be released this weekend.</p>



<a name="179243217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179243217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179243217">(Oct 28 2019 at 15:43)</a>:</h4>
<p>Inequality world DLC</p>



<a name="179243417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179243417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179243417">(Oct 28 2019 at 15:45)</a>:</h4>
<p>I think the use of this style in Jeremy's proofs reflects influence from the Isar proofs in Isabelle</p>



<a name="179243437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179243437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179243437">(Oct 28 2019 at 15:45)</a>:</h4>
<p>If you really really want to use <code>cases_on</code>: The error comes from the fact that the elaborator can't figure out the motive because it doesn't appear in the type signature. You need to perform <code>cases_on</code> <em>before</em>  <code>assume (hc : n + c = m)</code> so that <code>c</code> can be replaced by zero or <code>succ c</code> in the two case branches.</p>
<div class="codehilite"><pre><span></span>        <span class="k">assume</span> <span class="n">c</span><span class="o">,</span>
        <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">succ</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">c</span>
            <span class="o">(</span><span class="k">assume</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span>
            <span class="o">(</span><span class="k">assume</span> <span class="n">c</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span>
</pre></div>



<a name="179243499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179243499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179243499">(Oct 28 2019 at 15:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="c1">-- we define ≼ to mean less than or equal to, using the following definition</span>
<span class="c1">-- rather than the inductive definition lean uses; yes, they&#39;re equivalent,</span>
<span class="c1">-- but let&#39;s see how this one goes!</span>
<span class="n">def</span> <span class="n">leq</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≼</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">leq</span>

<span class="kn">theorem</span> <span class="n">ineq_totality</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">n</span> <span class="err">≼</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="err">≼</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- The goal is ∀ so we intro everything.</span>
  <span class="n">intros</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
  <span class="c1">-- We do induction on n.</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="c1">-- Now there are two cases.</span>
  <span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">{</span>
    <span class="c1">-- The goal is ∨ and we know that the left one is true.</span>
    <span class="n">left</span><span class="o">,</span>
    <span class="c1">-- The goal is 0 ≼ m but is secretly an ∃ so I use m.</span>
    <span class="n">use</span> <span class="n">m</span><span class="o">,</span>
    <span class="c1">-- The goal is 0 + m = m which we know is nat.zero_add.</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero_add</span> <span class="n">m</span> <span class="o">},</span>
  <span class="c1">-- Now we go to the second case.</span>
  <span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="n">n</span> <span class="n">ih</span> <span class="o">{</span>
    <span class="c1">-- We case on ih.</span>
    <span class="n">cases</span> <span class="n">ih</span><span class="o">,</span>
    <span class="c1">-- We now have two cases.</span>
    <span class="n">case</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">:</span> <span class="n">h1</span> <span class="o">{</span>
      <span class="c1">-- h1 says n ≼ m but is secretly an ∃ so we cases on it.</span>
      <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span>
      <span class="c1">-- We case on c instead of induction because we don&#39;t need an induction hypothesis.</span>
      <span class="n">cases</span> <span class="n">c</span><span class="o">,</span>
      <span class="c1">-- Now we have two cases.</span>
      <span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">{</span>
        <span class="c1">-- The goal is ∨ and the right hand side is true.</span>
        <span class="n">right</span><span class="o">,</span>
        <span class="c1">-- The goal is m ≼ succ n but is secretly an ∃.</span>
        <span class="n">use</span> <span class="mi">1</span><span class="o">,</span>
        <span class="c1">-- From n + 0 = m we readily derive m + 1 = succ n.</span>
        <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">hc</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_zero</span> <span class="n">n</span><span class="o">]</span> <span class="o">},</span>
      <span class="c1">-- We proceed to the second case.</span>
      <span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="n">c</span> <span class="o">{</span>
        <span class="c1">-- The goal is ∨ and the left hand side is true.</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="c1">-- The goal is succ n ≼ m but is secretly an ∃.</span>
        <span class="n">use</span> <span class="n">c</span><span class="o">,</span>
        <span class="c1">-- From n + succ c = m we readily derive succ n + c = m.</span>
        <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">hc</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_add</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
    <span class="c1">-- We are now in the second case.</span>
    <span class="n">case</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="o">:</span> <span class="n">h1</span> <span class="o">{</span>
      <span class="c1">-- h1 says m ≼ n but is secretly an ∃.</span>
      <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span>
      <span class="c1">-- The goal is ∨ and the right hand side is true.</span>
      <span class="n">right</span><span class="o">,</span>
      <span class="c1">-- The goal is m ≼ succ n but is secretly and ∃.</span>
      <span class="n">use</span> <span class="n">c</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span>
      <span class="c1">-- From m + c = n we readily derive m + (c + 1) = succ n.</span>
      <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">hc</span><span class="o">,</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_assoc</span><span class="o">]</span>
    <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="179243521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179243521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Ayers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179243521">(Oct 28 2019 at 15:46)</a>:</h4>
<p>(deleted)</p>



<a name="179243526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179243526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179243526">(Oct 28 2019 at 15:46)</a>:</h4>
<p><span class="user-mention" data-user-id="242660">@Julian Gilbey</span> annotated tactics</p>



<a name="179243957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179243957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Gilbey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179243957">(Oct 28 2019 at 15:50)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="242660">Julian Gilbey</span> annotated tactics</p>
</blockquote>
<p>Wow, thanks!  This will take some getting used to... chapter 5, here I come (or at least once I've finished my marking and the paper I'm drafting!)</p>



<a name="179243964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179243964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179243964">(Oct 28 2019 at 15:50)</a>:</h4>
<p>Thanks Kenny! Julian -- I hope this is giving you some indication that this sort of question can actually be worked on in Lean using a much easier-to-use framework than the one you are attempting to use, where 9 times out of 10 the error is "missing comma" and the user never recovers</p>



<a name="179244323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179244323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179244323">(Oct 28 2019 at 15:54)</a>:</h4>
<p>To counter Kevin's negativity, I would like to say that your initial proof is very nicely formatted</p>



<a name="179244387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179244387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179244387">(Oct 28 2019 at 15:54)</a>:</h4>
<p>Also you can also always see the goals in term mode by using underscores</p>



<a name="179244446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179244446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179244446">(Oct 28 2019 at 15:55)</a>:</h4>
<p>All this is true, but it's still completely impossible for a beginner to debug. That's why he's asking the question in the first place.</p>



<a name="179245778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/invalid%20nat.cases_on%20application/near/179245778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/invalid.20nat.2Ecases_on.20application.html#179245778">(Oct 28 2019 at 16:06)</a>:</h4>
<p>Ah, I answered way too hastily. <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span>‍♂️ Sorry for posting nonsense and thanks to everyone else for jumping in with great explanations!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/const_comp.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html">const_comp</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="201529101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201529101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201529101">(Jun 21 2020 at 10:49)</a>:</h4>
<p>Suppose that, in a proof, I find the following (<code>{A : Type*} {B : Type*} {C : Type*} (c : C) (f : A → B)</code>)</p>
<div class="codehilite"><pre><span></span><code><span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="err">∘</span> <span class="n">f</span>
</code></pre></div>


<p>in the goal. Simp does not simplify it to <code>(λ a : A, c)</code>. Library_search does not find an existing lemma for this but tells me it is true by rfl. In order to simplify it, should I define a lemma</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_const</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="err">∘</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>


<p>or am I supposed to use some kind of tactic that simplifies things true by definition that I am not aware of?</p>



<a name="201529162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201529162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201529162">(Jun 21 2020 at 10:51)</a>:</h4>
<p>Have you tried <code>dsimp</code> ?</p>



<a name="201529243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201529243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201529243">(Jun 21 2020 at 10:53)</a>:</h4>
<p>Yeah and it does not work as much as simp (even if I am not sure when I should try simp and when dsimp)</p>



<a name="201531121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201531121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201531121">(Jun 21 2020 at 11:51)</a>:</h4>
<p>I am certainly not an expert in <code>simp</code> but I will note that proving lemmas with <code>rfl</code> because <code>simp</code> needs to know about them is certainly not uncommon in the library -- it <a href="https://github.com/leanprover-community/mathlib/blob/8729fe211ebd7f2b40924e0f5ff0f6b5b1e56695/src/data/complex/basic.lean#L67-L77">happens all the time in data.complex.basic</a> for example.</p>



<a name="201531172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201531172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201531172">(Jun 21 2020 at 11:53)</a>:</h4>
<p>The difference between <code>simp</code> and <code>dsimp</code> is that <code>dsimp</code> will only apply <code>simp</code> lemmas whose proof is <code>rfl</code>, so it preserves definitional equality, whereas <code>simp</code> is just a general confluent rewriting system; it will know <code>add_zero</code> and <code>zero_add</code>, even though (at least on <code>nat</code>) only one of these is definitional.</p>



<a name="201531290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201531290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201531290">(Jun 21 2020 at 11:56)</a>:</h4>
<p>Oh just throwing random ideas, but sometimes unfolding <code>function.comp</code> helps with tactics.</p>



<a name="201531940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201531940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201531940">(Jun 21 2020 at 12:17)</a>:</h4>
<p>We can only help you if you provide an actual <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>.</p>



<a name="201538213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201538213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201538213">(Jun 21 2020 at 15:11)</a>:</h4>
<p>In general <code>∘</code> is not used heavily, so it doesn't surprise me much that this lemma would be absent</p>



<a name="201538861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201538861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201538861">(Jun 21 2020 at 15:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201531940">said</a>:</p>
<blockquote>
<p>We can only help you if you provide an actual <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>.</p>
</blockquote>
<p>Well my question was a general question about rfl lemmas, I am not interested specifically in this example, but if you want to try this case any toy example should work (I do not include my original proof because it is exagerately complicated to illustrate this example), for instance:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">basic</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">const_comp</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="err">∘</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_const</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="err">∘</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span><span class="n">X</span><span class="o">)</span>
<span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">((</span><span class="bp">λ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">f</span> <span class="err">∘</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span><span class="o">,</span> <span class="c">/-</span><span class="cm"> Seems not to work for me without the lemmas above -/</span>
  <span class="n">exact</span> <span class="n">continuous_const</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201538914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201538914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201538914">(Jun 21 2020 at 15:26)</a>:</h4>
<p>Lean works best if you keep things simple so Lean has less trouble working out what to unfold and what to leave alone. f \circ g can be expressed as <code>lam x, f(g(x))</code> and probably the latter is preferred because more primitive notions are involved.</p>



<a name="201538994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201538994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201538994">(Jun 21 2020 at 15:28)</a>:</h4>
<p>The easier way is just to eliminate function composition, like Kevin suggests</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span><span class="n">X</span><span class="o">)</span>
<span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">((</span><span class="bp">λ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">f</span> <span class="err">∘</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">)],</span>
  <span class="n">exact</span> <span class="n">continuous_const</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201538996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201538996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201538996">(Jun 21 2020 at 15:28)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span><span class="n">X</span><span class="o">)</span>
<span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">((</span><span class="bp">λ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">f</span> <span class="err">∘</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">continuous_const</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201539105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539105">(Jun 21 2020 at 15:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201538996">said</a>:</p>
<blockquote>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span><span class="n">X</span><span class="o">)</span>
<span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">((</span><span class="bp">λ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">f</span> <span class="err">∘</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">continuous_const</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


</blockquote>
<p>I tried <code>dsimp</code> before and it does not work for me! Are you including any import other than <code>topology.basic</code>?</p>



<a name="201539166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539166">(Jun 21 2020 at 15:31)</a>:</h4>
<p>One option here would be to get lazy people to PR their stuff, for instance <a href="https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/for_mathlib/topology.lean#L36-L39">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/for_mathlib/topology.lean#L36-L39</a></p>



<a name="201539209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539209">(Jun 21 2020 at 15:32)</a>:</h4>
<p>Another option is to fix some stupid binders in mathlib</p>



<a name="201539237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539237">(Jun 21 2020 at 15:33)</a>:</h4>
<p>In the mean time you can use the proof term <code>@continuous_const _ _ _ _ b,</code> (without any tactic)</p>



<a name="201539290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539290">(Jun 21 2020 at 15:34)</a>:</h4>
<p>A priori having <code>b</code> implicit in <code>continuous_const</code> goes against all rules. But indeed it is tempting since it's almost always clear from context.</p>



<a name="201539295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539295">(Jun 21 2020 at 15:34)</a>:</h4>
<p>I feel like it would actually be easy to improve the unifier to handle this problem</p>



<a name="201539310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539310">(Jun 21 2020 at 15:35)</a>:</h4>
<p>Of course improving elaboration could also solve this issue, but it's a different game</p>



<a name="201539359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539359">(Jun 21 2020 at 15:37)</a>:</h4>
<p>In case my messages are unclear, I mean:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">lemma</span> <span class="n">continuous_of_const</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="n">f</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">s</span> <span class="bp">_</span><span class="o">,</span> <span class="k">by</span> <span class="n">convert</span> <span class="bp">@</span><span class="n">is_open_const</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span><span class="bp">;</span> <span class="n">exact</span>
  <span class="n">set</span><span class="bp">.</span><span class="n">ext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">fa</span><span class="o">,</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">fa</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">fb</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">show</span> <span class="n">f</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">▸</span> <span class="n">fb</span><span class="bp">⟩</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span><span class="n">X</span><span class="o">)</span>
<span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">((</span><span class="bp">λ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">f</span> <span class="err">∘</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">continuous_const</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">b</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span><span class="n">X</span><span class="o">)</span>
<span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">((</span><span class="bp">λ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">f</span> <span class="err">∘</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">continuous_of_const</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span>
</code></pre></div>



<a name="201539361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539361">(Jun 21 2020 at 15:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201538994">said</a>:</p>
<blockquote>
<p>The easier way is just to eliminate function composition, like Kevin suggests</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">lemma</span> <span class="n">test</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span><span class="n">X</span><span class="o">)</span>
<span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">((</span><span class="bp">λ</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="err">∘</span> <span class="n">f</span> <span class="err">∘</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[(</span><span class="err">∘</span><span class="o">)],</span>
  <span class="n">exact</span> <span class="n">continuous_const</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


</blockquote>
<p>Ok thanks this makes sense! I mean sometimes compositions (as \circ) just appear in proofs themselves alone without me ever defining something with them (meaning something is defined in terms of them in Mathlib), so I was really looking for a method that works when compositions appear and I guess this would be a standard way to get rid of \circs</p>



<a name="201539369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539369">(Jun 21 2020 at 15:37)</a>:</h4>
<p>This is very sad for mathematicians, but Lean doesn't really like composition.</p>



<a name="201539417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539417">(Jun 21 2020 at 15:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201539237">said</a>:</p>
<blockquote>
<p>In the mean time you can use the proof term <code>@continuous_const _ _ _ _ b,</code> (without any tactic)</p>
</blockquote>
<p>This also works but I feel like <code>simp [(∘)]</code> is more scalable (for example in my original proof I did not have a tactic that could close the goal immediately and I just needed to simplify a very complicated expression)</p>



<a name="201539562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539562">(Jun 21 2020 at 15:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="267205">Nicolò Cavalleri</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201538861">said</a>:</p>
<blockquote>
<p>Patrick Massot <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201531940">said</a>:</p>
<blockquote>
<p>We can only help you if you provide an actual <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>.</p>
</blockquote>
<p>Well my question was a general question about rfl lemmas, I am not interested specifically in this example, but if you want to try this case any toy example should work (I do not include my original proof because it is exagerately complicated to illustrate this example), for instance:</p>
</blockquote>
<p>Did you notice the effect  of posting a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="201539694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539694">(Jun 21 2020 at 15:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="267205">Nicolò Cavalleri</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201539105">said</a>:</p>
<blockquote>
<p>I tried <code>dsimp</code> before and it does not work for me! Are you including any import other than <code>topology.basic</code>?</p>
</blockquote>
<p>I am not able to reproduce what I did. And indeed it doesn't work!</p>



<a name="201539754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539754">(Jun 21 2020 at 15:48)</a>:</h4>
<p>Note the effect of not posting a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>...</p>



<a name="201539970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201539970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201539970">(Jun 21 2020 at 15:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201539754">said</a>:</p>
<blockquote>
<p>Note the effect of not posting a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>...</p>
</blockquote>
<p>I am confused! Why is what I posted not a mwe?</p>



<a name="201540060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201540060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201540060">(Jun 21 2020 at 15:56)</a>:</h4>
<p>did you read the definition at the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> link? Ah I see you eventually posted working code</p>



<a name="201540067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201540067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201540067">(Jun 21 2020 at 15:56)</a>:</h4>
<p>Was replying to Sebastien.</p>



<a name="201540079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201540079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201540079">(Jun 21 2020 at 15:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201540067">said</a>:</p>
<blockquote>
<p>Was replying to Sebastien.</p>
</blockquote>
<p>Oh ok sorry!</p>



<a name="201540101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201540101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201540101">(Jun 21 2020 at 15:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201540060">said</a>:</p>
<blockquote>
<p>did you read the definition at the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> link?</p>
</blockquote>
<p>Yes I did! I believe it was a mwe...</p>



<a name="201540155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201540155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201540155">(Jun 21 2020 at 15:58)</a>:</h4>
<p>Less interesting that the working example with <code>simp</code>, but in this case you can simply replace it with <code>unfold function.comp</code></p>



<a name="201540172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201540172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201540172">(Jun 21 2020 at 15:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201539694">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="267205">Nicolò Cavalleri</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201539105">said</a>:</p>
<blockquote>
<p>I tried <code>dsimp</code> before and it does not work for me! Are you including any import other than <code>topology.basic</code>?</p>
</blockquote>
<p>I am not able to reproduce what I did. And indeed it doesn't work!</p>
</blockquote>
<p>Maybe it was because you did not comment out the two simp lemmas I wrote and dsimp used them!</p>



<a name="201540179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201540179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201540179">(Jun 21 2020 at 15:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="267205">Nicolò Cavalleri</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201540101">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201540060">said</a>:</p>
<blockquote>
<p>did you read the definition at the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> link?</p>
</blockquote>
<p>Yes I did! I believe it was a mwe...</p>
</blockquote>
<p>patrick was trying to point out that your first post didn't have working code, so you got imprecise answers, and then when you eventually posted working code, ou got more precise answers. I think patrick was trying to suggest that you should <em>start</em> with a working example in the future</p>



<a name="201540195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201540195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201540195">(Jun 21 2020 at 15:59)</a>:</h4>
<p>I actually tend to unfold <code>function.comp</code> really often because composition really blocks things sometimes</p>



<a name="201540254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201540254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201540254">(Jun 21 2020 at 16:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201540179">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="267205">Nicolò Cavalleri</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201540101">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201540060">said</a>:</p>
<blockquote>
<p>did you read the definition at the <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> link?</p>
</blockquote>
<p>Yes I did! I believe it was a mwe...</p>
</blockquote>
<p>patrick was trying to point out that your first post didn't have working code, so you got imprecise answers, and then when you eventually posted working code, ou got more precise answers. I think patrick was trying to suggest that you should <em>start</em> with a working example in the future</p>
</blockquote>
<p>He wasn't replying to Patrick's post I think</p>



<a name="201540602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201540602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201540602">(Jun 21 2020 at 16:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="268315">Anatole Dedecker</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201540195">said</a>:</p>
<blockquote>
<p>I actually tend to unfold <code>function.comp</code> really often because composition really blocks things sometimes</p>
</blockquote>
<p>Ok thanks I will keep this in mind!</p>



<a name="201541236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541236">(Jun 21 2020 at 16:05)</a>:</h4>
<p>It's surprising -- function.comp seems like a really natural thing, but it's just adding some "extra step" which Lean then has to unravel. This sort of phenomenon shows up everywhere. We like to package things up because it makes stuff neater, but not too much because how does Lean know what to unpack? It's not so obvious. Say Lean has a question about the real numbers. Should it unfold the definition of the real numbers and consider the equivalence class of Cauchy sequences? Almost certainly not! But should it unfold function composition? Maybe, maybe not. Humans are so good at this sort of thing. Machines are quite dumb. A lot of effort has gone into giving users access to various ways to give Lean hints about what to unfold when but it's still a hard problem.</p>



<a name="201541536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541536">(Jun 21 2020 at 16:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201541236">said</a>:</p>
<blockquote>
<p>It's surprising -- function.comp seems like a really natural thing, but it's just adding some "extra step" which Lean then has to unravel. This sort of phenomenon shows up everywhere. We like to package things up because it makes stuff neater, but not too much because how does Lean know what to unpack? It's not so obvious. Say Lean has a question about the real numbers. Should it unfold the definition of the real numbers and consider the equivalence class of Cauchy sequences? Almost certainly not! But should it unfold function composition? Maybe, maybe not. Humans are so good at this sort of thing. Machines are quite dumb. A lot of effort has gone into giving users access to various ways to give Lean hints about what to unfold when but it's still a hard problem.</p>
</blockquote>
<p>Is it not possible to modify <code>simp</code> so that it always unfolds composition when it sees it?</p>



<a name="201541620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541620">(Jun 21 2020 at 16:08)</a>:</h4>
<p>It is possible but is it a good idea?</p>



<a name="201541631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541631">(Jun 21 2020 at 16:08)</a>:</h4>
<p>If you always want to unfold composition in <code>simp</code> then why not just write the unfolded version in the first place?</p>



<a name="201541636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541636">(Jun 21 2020 at 16:08)</a>:</h4>
<p>then you also handle situations where you don't use simp</p>



<a name="201541658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541658">(Jun 21 2020 at 16:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201541631">said</a>:</p>
<blockquote>
<p>If you always want to unfold composition in <code>simp</code> then why not just write the unfolded version in the first place?</p>
</blockquote>
<p>Because it's much harder to read long statement full of lambda expressions for a mathematician when it is easier to read it with compositions!</p>



<a name="201541707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541707">(Jun 21 2020 at 16:10)</a>:</h4>
<p>II mean composition is easier to process instantaneously for humans</p>



<a name="201541723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541723">(Jun 21 2020 at 16:11)</a>:</h4>
<p>And it makes statements more elegant and more symmetric being similar to a group operation as far as notation is concerned</p>



<a name="201541726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541726">(Jun 21 2020 at 16:11)</a>:</h4>
<p>If you want to put <code>\circ</code> into results because you think it adds to readability, then just start your proofs with <code>simp only [(\circ)]</code>.</p>



<a name="201541786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541786">(Jun 21 2020 at 16:12)</a>:</h4>
<p>at some point you have to bridge the gap between what a human can read and what a computer can read</p>



<a name="201541855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201541855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201541855">(Jun 21 2020 at 16:14)</a>:</h4>
<p>The whole <code>simp</code> theory is very well-understood by computer scientists, it goes under the name of confluent rewriting systems. One idea is that things should be in some kind of normal form. Normal forms are decided, perhaps by computer scientists. At some point it was decided that function.comp wasn't part of the story. From a mathematician's perspective some of these decisions can be difficult to understand, especially if you're focussed on human-readability (and if you've looked at some of mathlib you'll know that not everyone here is). But <code>simp</code> is an amazing tool, and as someone who doesn't understand it I just accept how it's set up and learn how to use it. Perhaps an even better approach would be to understand it properly and then try and figure out how to add function.comp to the picture.</p>



<a name="201542642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201542642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201542642">(Jun 21 2020 at 16:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201531172">said</a>:</p>
<blockquote>
<p>The difference between <code>simp</code> and <code>dsimp</code> is that <code>dsimp</code> will only apply <code>simp</code> lemmas whose proof is <code>rfl</code>, so it preserves definitional equality, whereas <code>simp</code> is just a general confluent rewriting system; it will know <code>add_zero</code> and <code>zero_add</code>, even though (at least on <code>nat</code>) only one of these is definitional.</p>
</blockquote>
<p>Do you know if there is a way to get the output of <code>dsimp</code> as with <code>squeeze_simp</code> for <code>simp</code>?</p>



<a name="201543196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201543196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201543196">(Jun 21 2020 at 16:51)</a>:</h4>
<p>(I would guess squeeze_simp should produce it but it happened to me in the past that <code>dsimp</code> did something when <code>simp</code> could not do anything: I cannot easily ricreate a mwe of this right now but I can try to do it if you have no idea about what I am talking about)</p>



<a name="201543603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201543603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201543603">(Jun 21 2020 at 17:01)</a>:</h4>
<p>I don't think there's a squeeze_dsimp. Note however that if <code>dsimp</code> changes your goal to <code>X</code> then you can replace the call to <code>dsimp</code> with <code>change X</code> or <code>show X</code> (they are the same), because change and show will change a goal from Y to X if Y and X are definitionally equivalent.</p>



<a name="201543948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201543948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201543948">(Jun 21 2020 at 17:11)</a>:</h4>
<p>You could also use the trace output for simplify to get this, but I also do what Kevin suggests here</p>



<a name="201544527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201544527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201544527">(Jun 21 2020 at 17:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/113489-new-members/topic/const_comp/near/201543948">said</a>:</p>
<blockquote>
<p>You could also use the trace output for simplify to get this, but I also do what Kevin suggests here</p>
</blockquote>
<p>Thanks! What is the syntax for this?</p>



<a name="201546996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/const_comp/near/201546996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/const_comp.html#201546996">(Jun 21 2020 at 18:28)</a>:</h4>
<p><code>set_option trace.simplify true</code> or <code>set_option trace.simplify.rewrite true</code> for just the successful rewrites. See <a href="https://leanprover-community.github.io/extras/simp.html">https://leanprover-community.github.io/extras/simp.html</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html">Expressing ‚Ñï as a category and Fibonacci as a functor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="220198334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220198334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220198334">(Dec 17 2020 at 01:45)</a>:</h4>
<p>A <a href="https://www.math3ma.com/blog/fibonacci-sequence">blog post by Tai-Danae Bradley</a> shows that ‚Ñï is a complete category where</p>
<ul>
<li>The objects are non-negative integers</li>
<li>The morphism is divisibility</li>
</ul>
<p>and the Fibonacci sequence <code>F(n)</code> where is exactly <code>nat.fib</code> and roughly (but this doesn't quite work):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">F</span> <span class="o">:</span> <span class="n">‚Ñï</span> <span class="bp">‚Üí</span> <span class="n">‚Ñï</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="mi">2</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">F</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">F</span><span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>
<p>is a functor given <code>nat.gcd(F n) ( F m) = F (nat.gcd n m)</code>.</p>
<p>Using the <code>category</code> structure of <code>mathlib</code>, how do I prove <code>‚Ñï</code> is a category under <code>nat.gcd</code>?</p>
<p>I don't quite understand all I need to prove because the definition of <code>category</code> uses some complicated language <code>extends category_struct.{v} obj </code>.  With the inclusion of the tactic <code>. obviously</code>, the <code>category</code> fields should prove themselves for the most part:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">category</span> <span class="o">(</span><span class="n">obj</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kd">extends</span> <span class="n">category_struct.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">obj</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">id_comp'</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">obj</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">),</span> <span class="mi">ùüô</span> <span class="n">X</span> <span class="bp">‚â´</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">comp_id'</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">obj</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">),</span> <span class="n">f</span> <span class="bp">‚â´</span> <span class="mi">ùüô</span> <span class="n">Y</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">assoc'</span>   <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">{</span><span class="n">W</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">obj</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">W</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">),</span>
  <span class="o">(</span><span class="n">f</span> <span class="bp">‚â´</span> <span class="n">g</span><span class="o">)</span> <span class="bp">‚â´</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">‚â´</span> <span class="o">(</span><span class="n">g</span> <span class="bp">‚â´</span> <span class="n">h</span><span class="o">)</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</code></pre></div>
<p>Having proven <code>‚Ñï</code> is a category under divisibility, how do I show that <code>nat.fib</code> is a functor?</p>
<p>This is as far as I could get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.category.default</span>
<span class="kn">import</span> <span class="n">data.nat.fib</span>
<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">instance</span>  <span class="o">:</span> <span class="n">category</span> <span class="n">‚Ñï</span> <span class="o">:=</span> <span class="o">{</span>
<span class="c1">-- something with nat.gcd</span>
<span class="o">}</span>

<span class="k">#check</span> <span class="n">functor</span>
<span class="c1">-- something with nat.fib</span>
</code></pre></div>
<p>Also, what in <code>mathlib</code> marks that a category is a complete category?  <code>complete_space</code>?  <code>is_complete</code>?</p>



<a name="220200511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220200511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220200511">(Dec 17 2020 at 02:24)</a>:</h4>
<p>Here's a start to setting this up</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.fib</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>
<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">def</span> <span class="n">mynat</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">nat</span>
<span class="kd">def</span> <span class="n">to_nat</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">‚Üí</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">id</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_dvd</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">dvd</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">to_nat</span> <span class="n">a</span> <span class="bp">‚à£</span> <span class="n">b</span><span class="o">}</span>
<span class="kd">instance</span> <span class="n">a</span> <span class="o">:</span> <span class="n">preorder</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">‚à£</span><span class="o">),</span>
<span class="n">le_refl</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span><span class="o">,</span> <span class="n">dvd_refl</span> <span class="n">a</span><span class="o">,</span>
<span class="n">le_trans</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">h</span> <span class="n">g</span><span class="o">,</span> <span class="n">dvd_trans</span> <span class="n">h</span> <span class="n">g</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">lemma</span> <span class="n">fib_dvd_fib</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">‚Ñï</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">‚à£</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.fib</span> <span class="bp">‚à£</span> <span class="n">n.fib</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
<span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">‚•§</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="n">nat.fib</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">m</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">hom_of_le</span> <span class="o">(</span><span class="n">fib_dvd_fib</span> <span class="o">(</span><span class="n">le_of_hom</span> <span class="n">h</span><span class="o">)),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">}</span>
</code></pre></div>



<a name="220200640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220200640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220200640">(Dec 17 2020 at 02:26)</a>:</h4>
<p>We make mynat a type alias for nat so that we can put the divisibility order on it</p>



<a name="220200657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220200657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220200657">(Dec 17 2020 at 02:27)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/preorder.small_category">docs#preorder.small_category</a> automatically makes this a category then, so that the functor notation <code>‚•§</code> works</p>



<a name="220200678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220200678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220200678">(Dec 17 2020 at 02:28)</a>:</h4>
<p>I don't think we have the key lemma about divisibility of fibonaccis yet?</p>



<a name="220237807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220237807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220237807">(Dec 17 2020 at 12:39)</a>:</h4>
<p>Thanks for the sketch <span class="user-mention" data-user-id="127136">@Alex J. Best</span> .</p>
<p>Tai-Danae Bradley  expressed the "functorial-ness" of <code>nat.fib</code> in terms of <code>nat.gcd(nat.fib n) ( nat.fib  m) = nat.fib  (nat.gcd n m)</code>.   How is this represented in the sketch, and how is <code>nat.gcd</code> as the greatest lower bound operator of the ‚Ñï lattice represented in your sketch?</p>
<p>Another question, the definition of <code>nat.fib</code> says "We use a stream iterator for better performance when compared to the naive recursive implementation."  The documentation for <code>stream</code> is terse.  Is there a writeup somewhere for the use of stream iterators?</p>



<a name="220238033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220238033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220238033">(Dec 17 2020 at 12:42)</a>:</h4>
<p>It's not, this was just the first step, setting up N with divisibility as a category and showing that fib defines a functor.</p>



<a name="220238217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220238217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220238217">(Dec 17 2020 at 12:44)</a>:</h4>
<p>If you want to formalise the rest you would be showing that this category has (co)products (this would be lcm / gcd) and that the fib functor preserves limits</p>



<a name="220238483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220238483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220238483">(Dec 17 2020 at 12:47)</a>:</h4>
<p>As for streams, I believe they're the same as the stream concept in haskell <a href="https://hackage.haskell.org/package/Stream-0.4.7.2/docs/Data-Stream.html">https://hackage.haskell.org/package/Stream-0.4.7.2/docs/Data-Stream.html</a></p>



<a name="220248676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220248676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220248676">(Dec 17 2020 at 14:22)</a>:</h4>
<p>How do you say that <code>mynat</code> is an instance of <code>category</code> and that it is a complete category?</p>



<a name="220249077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220249077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220249077">(Dec 17 2020 at 14:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>
<p>for the first, lean is doing this behind the scenes when you use the functor notation, that won't work unless lean "knows" that mynat is a category</p>



<a name="220249135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220249135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220249135">(Dec 17 2020 at 14:26)</a>:</h4>
<p>So adding that line to the file is only needed for you to check as a user that lean knows how to find the category instance.</p>



<a name="220249511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220249511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220249511">(Dec 17 2020 at 14:30)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_limits">docs#category_theory.limits.has_limits</a> is what mathlib calls a complete category I believe</p>



<a name="220249655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220249655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220249655">(Dec 17 2020 at 14:31)</a>:</h4>
<p>To actually make an instance of this class probably requires some work</p>



<a name="220250035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220250035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220250035">(Dec 17 2020 at 14:34)</a>:</h4>
<p>You can see several examples by searching for <code>instance has_limits</code> in mathlib</p>



<a name="220250660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220250660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220250660">(Dec 17 2020 at 14:39)</a>:</h4>
<p>Actually maybe I'm wrong and this is already there, if you import <code>category_theory.limits.lattice</code>  then proving an instance of <code>complete_lattice mynat</code>  will give you the <code>has_limits mynat</code>  instance for free</p>



<a name="220251036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220251036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220251036">(Dec 17 2020 at 14:42)</a>:</h4>
<p>ok but maybe mynat isn't a complete lattice? so the best you can do is make an instance of <code>semilattice_inf_top mynat</code>  and get <code>has_finite_limits mynat</code> from that, or maybe the dual lol</p>



<a name="220254316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220254316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220254316">(Dec 17 2020 at 15:08)</a>:</h4>
<p>Ok I guess it is a complete lattice after all but I'm not sure the best way to prove that, you need to define <code>has_Inf mynat</code> which should be the gcd of a (possibly infinite) set, the way I would do this by hand is just to say a set of naturals is a set of integers which generates some ideal, which is principal so take the positive generator to be the Inf of your set, no idea what the easiest way to do this in lean is.</p>



<a name="220254380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220254380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220254380">(Dec 17 2020 at 15:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.fib</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>
<span class="kn">import</span> <span class="n">category_theory.limits.limits</span>
<span class="kn">import</span> <span class="n">category_theory.limits.lattice</span>

<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">def</span> <span class="n">mynat</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">nat</span>
<span class="kd">def</span> <span class="n">to_nat</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">‚Üí</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">id</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_dvd</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">dvd</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">to_nat</span> <span class="n">a</span> <span class="bp">‚à£</span> <span class="n">b</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">semilattice_inf_top</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">‚à£</span><span class="o">),</span>
<span class="n">le_refl</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span><span class="o">,</span> <span class="n">dvd_refl</span> <span class="n">a</span><span class="o">,</span>
<span class="n">le_trans</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">h</span> <span class="n">g</span><span class="o">,</span> <span class="n">dvd_trans</span> <span class="n">h</span> <span class="n">g</span><span class="o">,</span>
<span class="n">top</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">‚Ñï</span><span class="o">),</span>
<span class="n">inf</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="o">,</span> <span class="n">nat.gcd</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
<span class="n">le_antisymm</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">nat.dvd_antisymm</span><span class="o">,</span>
<span class="n">inf_le_left</span> <span class="o">:=</span> <span class="n">nat.gcd_dvd_left</span><span class="o">,</span>
<span class="n">inf_le_right</span> <span class="o">:=</span> <span class="n">nat.gcd_dvd_right</span><span class="o">,</span>
<span class="n">le_top</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span><span class="o">,</span> <span class="o">‚ü®</span><span class="mi">0</span><span class="o">,</span> <span class="n">rfl</span><span class="o">‚ü©,</span>
<span class="n">le_inf</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">nat.dvd_gcd</span><span class="o">,</span>
 <span class="o">}</span>

<span class="c1">-- instance : complete_lattice mynat :=  complete_lattice_of_Inf mynat</span>
<span class="kd">lemma</span> <span class="n">fib_dvd_fib</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">‚Ñï</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">‚à£</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.fib</span> <span class="bp">‚à£</span> <span class="n">n.fib</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
<span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">‚•§</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="n">nat.fib</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">m</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">hom_of_le</span> <span class="o">(</span><span class="n">fib_dvd_fib</span> <span class="o">(</span><span class="n">le_of_hom</span> <span class="n">h</span><span class="o">)),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">}</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">limits.has_finite_limits</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>
<p>uses the category machinery to show finite limits at least</p>



<a name="220254841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220254841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220254841">(Dec 17 2020 at 15:13)</a>:</h4>
<p>Is there a <code>complete_lattice_of_Sup</code>?</p>



<a name="220254910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220254910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220254910">(Dec 17 2020 at 15:13)</a>:</h4>
<p>Yes, Sup seemed harder to define to me than Inf though?</p>



<a name="220255006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220255006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220255006">(Dec 17 2020 at 15:14)</a>:</h4>
<p>Isn't it <code>finset.lcm</code> for finite input and <code>0</code> otherwise?</p>



<a name="220255092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220255092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220255092">(Dec 17 2020 at 15:14)</a>:</h4>
<p>Ah yes it is</p>



<a name="220257016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220257016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220257016">(Dec 17 2020 at 15:27)</a>:</h4>
<p>Ok well I think these are the right definitions at least then, just a sorry to fill <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.fib</span>
<span class="kn">import</span> <span class="n">category_theory.functor</span>
<span class="kn">import</span> <span class="n">category_theory.limits.limits</span>
<span class="kn">import</span> <span class="n">category_theory.limits.lattice</span>
<span class="kn">import</span> <span class="n">data.finset.gcd</span>
<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">def</span> <span class="n">mynat</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">nat</span>
<span class="kd">def</span> <span class="n">to_nat</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">‚Üí</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">id</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_dvd</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">dvd</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">to_nat</span> <span class="n">a</span> <span class="bp">‚à£</span> <span class="n">b</span><span class="o">}</span>
<span class="c1">-- instance : semilattice_inf_top mynat :=</span>
<span class="c1">-- { le := (‚à£),</span>
<span class="c1">-- le_refl := Œª a, dvd_refl a,</span>
<span class="c1">-- le_trans := Œª a b c h g, dvd_trans h g,</span>
<span class="c1">-- top := (0 : ‚Ñï),</span>
<span class="c1">-- inf := Œª a b , nat.gcd a b,</span>
<span class="c1">-- le_antisymm := Œª a b, nat.dvd_antisymm,</span>
<span class="c1">-- inf_le_left := nat.gcd_dvd_left,</span>
<span class="c1">-- inf_le_right := nat.gcd_dvd_right,</span>
<span class="c1">-- le_top := Œª a, ‚ü®0, rfl‚ü©,</span>
<span class="c1">-- le_inf := Œª a b c, nat.dvd_gcd,</span>
<span class="c1">--  }</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">semilattice_sup_bot</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">‚à£</span><span class="o">),</span>
<span class="n">le_refl</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span><span class="o">,</span> <span class="n">dvd_refl</span> <span class="n">a</span><span class="o">,</span>
<span class="n">le_trans</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">h</span> <span class="n">g</span><span class="o">,</span> <span class="n">dvd_trans</span> <span class="n">h</span> <span class="n">g</span><span class="o">,</span>
<span class="n">bot</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">‚Ñï</span><span class="o">),</span>
<span class="n">sup</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="o">,</span> <span class="n">nat.lcm</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
<span class="n">le_antisymm</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">nat.dvd_antisymm</span><span class="o">,</span>
<span class="n">le_sup_left</span> <span class="o">:=</span> <span class="n">nat.dvd_lcm_left</span><span class="o">,</span>
<span class="n">le_sup_right</span> <span class="o">:=</span> <span class="n">nat.dvd_lcm_right</span><span class="o">,</span>
<span class="n">bot_le</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">‚Ñï</span><span class="o">),</span> <span class="o">‚ü®</span><span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">one_mul</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">‚ü©,</span>
<span class="n">sup_le</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">nat.lcm_dvd</span><span class="o">,</span>
 <span class="o">}</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">noncomputable theory</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_Sup</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">s</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">s.finite</span> <span class="k">then</span> <span class="n">finset.sup</span> <span class="o">(</span><span class="n">set.finite.to_finset</span> <span class="n">h</span><span class="o">)</span> <span class="n">id</span> <span class="k">else</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span> <span class="n">‚Ñï</span><span class="o">)‚ü©</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="n">complete_lattice_of_Sup</span> <span class="n">mynat</span>  <span class="o">(</span><span class="bp">Œª</span> <span class="n">s</span><span class="o">,</span> <span class="n">sorry</span><span class="o">)</span>
<span class="kd">lemma</span> <span class="n">fib_dvd_fib</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">‚Ñï</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">‚à£</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.fib</span> <span class="bp">‚à£</span> <span class="n">n.fib</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
<span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">‚•§</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="n">nat.fib</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">m</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">hom_of_le</span> <span class="o">(</span><span class="n">fib_dvd_fib</span> <span class="o">(</span><span class="n">le_of_hom</span> <span class="n">h</span><span class="o">)),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">}</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">limits.has_finite_limits</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="220259558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220259558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220259558">(Dec 17 2020 at 15:44)</a>:</h4>
<p>Am I right in thinking that<code>instance : semilattice_inf_top mynat</code> could be PR'd as <code>def dvd.semilattice_inf_top</code>?</p>



<a name="220259589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220259589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220259589">(Dec 17 2020 at 15:44)</a>:</h4>
<p>Seems like a nice way to group together all the structure, even if it's not desirable to register it as an instance</p>



<a name="220265616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220265616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220265616">(Dec 17 2020 at 16:25)</a>:</h4>
<p>Yes I think so? Or the complete lattice version if someone fills in the proof <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.<br>
Maybe <span class="user-mention" data-user-id="302826">@Aaron Anderson</span> has some ideas on whats a good way to set this all up though? Taking the naturals as a partial order w.r.t. divisibility is quite close to some of the moebius function machinery Aaron has developed.</p>



<a name="220265969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220265969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220265969">(Dec 17 2020 at 16:27)</a>:</h4>
<p>If only the order were total -- then it would be an answer to <a href="#narrow/stream/116395-maths/topic/There.20are.20no.20.60canonically_linear_ordered_monoid.60s/near/220239296">this</a></p>



<a name="220270037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220270037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220270037">(Dec 17 2020 at 16:57)</a>:</h4>
<p>There is already a partial order representing divisibility of naturals in mathlib - it‚Äôs <code>associates nat</code></p>



<a name="220270272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220270272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220270272">(Dec 17 2020 at 16:59)</a>:</h4>
<p>I haven‚Äôt explicitly defined an equivalence between N and that, but the ingredients are there (the assumption you want is <code>[unique (units N)]</code>)</p>



<a name="220270865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220270865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220270865">(Dec 17 2020 at 17:03)</a>:</h4>
<p>For any <code>comm_monoid</code>, there should be a <code>&lt;=</code> on <code>associates</code> which is defeq to <code>|</code>, and with possibly a few assumptions, it's a <code>partial_order</code>.</p>



<a name="220271120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220271120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220271120">(Dec 17 2020 at 17:05)</a>:</h4>
<p>Unfortunately, the lattice instances on it are defined only for <code>unique_factorization_monoid</code>, and not for <code>gcd_monoid</code>, and I've found that hard to generalize without screwing up the flow of the <code>unique_factorization_monoid</code> file, but that's ok for this, because we have <code>unique_factorization_monoid N</code>.</p>



<a name="220271385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220271385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220271385">(Dec 17 2020 at 17:07)</a>:</h4>
<p>We do not however have a <code>complete_lattice</code> instance.</p>



<a name="220271985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220271985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220271985">(Dec 17 2020 at 17:12)</a>:</h4>
<p>Some definitions I've been vaguely thinking about defining for a while is a <code>locally_finite_partial_order_with_top</code>, which would apply to the partial order of the <code>associates</code> of a <code>unique_factorization_monoid</code>,  and allow us to use your <code>complete_lattice</code> definition.</p>



<a name="220272444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220272444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220272444">(Dec 17 2020 at 17:15)</a>:</h4>
<p>Aah -- on a DVR the <code>&lt;=</code> on <code>associates will be totally ordered: does </code>associates<code> have </code>mul`?</p>



<a name="220272573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220272573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220272573">(Dec 17 2020 at 17:16)</a>:</h4>
<p>Oh it does! There's my example!</p>



<a name="220295786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220295786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220295786">(Dec 17 2020 at 20:13)</a>:</h4>
<p>Nice benchmark problem!  Thanks for thinking about it.</p>



<a name="220476883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220476883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220476883">(Dec 19 2020 at 16:30)</a>:</h4>
<p>It's a nice cold Saturday morning.  I'm looking at this again.  The above sketch from <span class="user-mention" data-user-id="127136">@Alex J. Best</span> creates an alias of ‚Ñï, <code>mynat</code>.  However I noticed that a lot of pieces are there already in ‚Ñï in particular</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">nat.has_dvd</span>
<span class="k">#check</span> <span class="n">nat.semilattice_sup_bot</span>
</code></pre></div>
<p>What's missing is <code>|</code> as a relation with the same status as <code>‚â§</code>, with corresponding <code>hom_of_dvd</code> and <code>dvd_of_hom</code> in <code>category</code>.  I tried to redo the sketch purely in ‚Ñï, but it fails at definitions of <code>hom_of_dvd</code> and <code>dvd_of_hom</code> and hence thereafter in this revised sketch:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.functor</span>
<span class="kn">import</span> <span class="n">category_theory.limits.limits</span>
<span class="kn">import</span> <span class="n">category_theory.limits.lattice</span>
<span class="kn">import</span> <span class="n">data.finset.gcd</span>
<span class="kn">import</span> <span class="n">data.nat.gcd</span>
<span class="kn">import</span> <span class="n">data.set.finite</span>
<span class="kn">import</span> <span class="n">data.nat.fib</span>

<span class="kn">open</span> <span class="n">category_theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">noncomputable theory</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_Sup</span> <span class="n">‚Ñï</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">s</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">s.finite</span> <span class="k">then</span> <span class="n">finset.sup</span> <span class="o">(</span><span class="n">set.finite.to_finset</span> <span class="n">h</span><span class="o">)</span> <span class="n">id</span> <span class="k">else</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span> <span class="n">‚Ñï</span><span class="o">)‚ü©</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="n">‚Ñï</span> <span class="o">:=</span> <span class="n">complete_lattice_of_Sup</span> <span class="n">‚Ñï</span>  <span class="o">(</span><span class="bp">Œª</span> <span class="n">s</span><span class="o">,</span> <span class="n">sorry</span><span class="o">)</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">Œ±</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">category_theory.hom_of_dvd</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">U</span> <span class="bp">|</span> <span class="n">V</span><span class="o">))</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">‚ü∂</span>  <span class="n">V</span> <span class="o">:=</span> <span class="n">ulift.up</span> <span class="o">(</span><span class="n">plift.up</span> <span class="n">h</span><span class="o">)</span> <span class="c1">-- ERROR</span>
<span class="kd">lemma</span> <span class="n">category_theory.dvd_of_hom</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">‚ü∂</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">U</span> <span class="bp">|</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h.down.down</span> <span class="c1">-- ERROR</span>

<span class="kd">def</span> <span class="n">nat.fib_as_functor</span> <span class="o">:</span> <span class="n">‚Ñï</span> <span class="bp">‚•§</span> <span class="n">‚Ñï</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="n">nat.fib</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">m</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">hom_of_dvd</span> <span class="o">(</span><span class="n">nat.fib_dvd_fib</span> <span class="o">(</span><span class="n">dvd_of_hom</span> <span class="n">h</span><span class="o">)),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span>
<span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nat.fib_dvd_fib</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">‚Ñï</span> <span class="o">}</span>  <span class="o">:</span> <span class="o">(</span><span class="n">m.fib_as_functor</span> <span class="bp">|</span> <span class="n">n.fib_as_functor</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="n">‚Ñï</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">limits.has_finite_limits</span> <span class="n">‚Ñï</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>
<p>If it's possible to make this work (with <code>sorry</code> in proofs is OK, just the types and ability to extend ‚Ñï directly without making a <code>mynat</code>), that would be interesting.</p>



<a name="220477074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220477074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220477074">(Dec 19 2020 at 16:34)</a>:</h4>
<p><span class="user-mention" data-user-id="364351">@Lars Ericson</span> it looks like you are trying to put two different order structures on the same type. Lean will not like that.</p>



<a name="220477192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220477192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220477192">(Dec 19 2020 at 16:37)</a>:</h4>
<p>OK I'll stick with the <code>mynat</code> version, thanks.</p>



<a name="220478277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220478277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220478277">(Dec 19 2020 at 17:02)</a>:</h4>
<p>Lean and typeclass inference should be able to deduce the category structure on the naturals obtained by divisibility using <code>associates nat</code> as Aaron hinted to above.</p>



<a name="220478546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220478546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lars Ericson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220478546">(Dec 19 2020 at 17:09)</a>:</h4>
<p>There are a number of assertions made in  <a href="https://www.math3ma.com/blog/fibonacci-sequence">Fibonacci Sequence as a Functor</a>. I'm using <code>x_y</code> for things defined in <code>mathlib</code> and <strong>x y</strong> for things that I don't know are defined in <code>mathlib</code>:</p>
<ul>
<li><code>‚Ñï</code> has a <code>partial_order</code> under divisibility<ul>
<li>Hence <code>‚Ñï</code> is a <code>category</code></li>
<li><code>‚Ñï</code> is also a <strong>complete category</strong></li>
</ul>
</li>
<li><code>‚Ñï</code> has a <strong>meet</strong> defined as <code>n ‚äì m = nat.gcd n m</code> <ul>
<li>Hence <code>‚Ñï</code> has a <strong>categorical limit</strong></li>
</ul>
</li>
<li><code>nat.fib</code> <strong>preserves meets</strong>, where we define  "preserve meets" by  <code>(nat.fib n)‚äì (nat.fib m) = nat.fib (n ‚äì m)</code><ul>
<li>Hence <code>‚Ñï</code> is a <strong>meet semilattice</strong></li>
<li>Hence <code>nat.fib</code> is a <strong>meet semilattice homomorphism</strong></li>
<li>Hence <code>nat.fib</code> is a <strong>functor</strong> because <code>nat.gcd(nat.fib n, nat.fib m) = nat.fib(nat.gcd n m)</code></li>
<li>Hence <code>nat.fib</code> is a <strong> continuous functor</strong>, because it preserves limits</li>
</ul>
</li>
<li><code>nat.gcd n m</code> is <br>
    * The <strong>categorical product</strong>  of  <code>n</code> and <code>m</code><br>
    * The <strong>pullback</strong> of <code>n</code> and <code>m</code><br>
    * The <strong>inverse limit</strong> of <code>n</code> and <code>m</code><br>
    * The <strong>equalizer</strong> of <code>n</code> and <code>m</code></li>
</ul>
<p>I would like to annotate the <code>mynat</code> proof sketch above with all of these assertions and be able to point out in Lean how each of the concepts is expressed.  My placement of assertions next to related proofs is very approximate:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.functor</span>
<span class="kn">import</span> <span class="n">category_theory.limits.limits</span>
<span class="kn">import</span> <span class="n">category_theory.limits.lattice</span>
<span class="kn">import</span> <span class="n">data.finset.gcd</span>
<span class="kn">import</span> <span class="n">data.nat.gcd</span>
<span class="kn">import</span> <span class="n">data.set.finite</span>
<span class="kn">import</span> <span class="n">data.nat.fib</span>

<span class="kn">open</span> <span class="n">category_theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">noncomputable theory</span>

<span class="c1">-- nat.gcd n m is the categorical product of n and m</span>
<span class="c1">-- nat.gcd n m is the pullback of n and m</span>
<span class="c1">-- nat.gcd n m is the inverse limit of n and m</span>
<span class="c1">-- nat.gcd n m is the equalizer of n and m</span>

<span class="kd">def</span> <span class="n">mynat</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">nat</span>
<span class="kd">def</span> <span class="n">to_nat</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">‚Üí</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">id</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_dvd</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="o">{</span><span class="n">dvd</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">to_nat</span> <span class="n">a</span> <span class="bp">‚à£</span> <span class="n">b</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">semilattice_sup_bot</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">‚à£</span><span class="o">),</span>
  <span class="n">le_refl</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span><span class="o">,</span> <span class="n">dvd_refl</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">le_trans</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">h</span> <span class="n">g</span><span class="o">,</span> <span class="n">dvd_trans</span> <span class="n">h</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">bot</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">‚Ñï</span><span class="o">),</span>
  <span class="n">sup</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="o">,</span> <span class="n">nat.lcm</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">le_antisymm</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">nat.dvd_antisymm</span><span class="o">,</span>
  <span class="n">le_sup_left</span> <span class="o">:=</span> <span class="n">nat.dvd_lcm_left</span><span class="o">,</span>
  <span class="n">le_sup_right</span> <span class="o">:=</span> <span class="n">nat.dvd_lcm_right</span><span class="o">,</span>
  <span class="n">bot_le</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">‚Ñï</span><span class="o">),</span> <span class="o">‚ü®</span><span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">one_mul</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">‚ü©,</span>
  <span class="n">sup_le</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">nat.lcm_dvd</span><span class="o">,</span>
 <span class="o">}</span>

<span class="c1">-- ‚Ñï has a partial_order under divisibility</span>
<span class="c1">-- ‚Ñï has a meet defined as n ‚äì m = nat.gcd n m</span>
<span class="c1">-- ‚Ñï is a meet semilattice</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_Sup</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">s</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">s.finite</span> <span class="k">then</span> <span class="n">finset.sup</span> <span class="o">(</span><span class="n">set.finite.to_finset</span> <span class="n">h</span><span class="o">)</span> <span class="n">id</span> <span class="k">else</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span> <span class="n">‚Ñï</span><span class="o">)‚ü©</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="n">complete_lattice_of_Sup</span> <span class="n">mynat</span>  <span class="o">(</span><span class="bp">Œª</span> <span class="n">s</span><span class="o">,</span> <span class="n">sorry</span><span class="o">)</span>

<span class="c1">-- nat.fib preserves meets, where we define  "preserve meets" by  (nat.fib n)‚äì (nat.fib m) = nat.fib (n ‚äì m)</span>
<span class="c1">-- nat.fib is a meet semilattice homomorphism</span>

<span class="kd">lemma</span> <span class="n">fib_dvd_fib</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">‚Ñï</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">‚à£</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.fib</span> <span class="bp">‚à£</span> <span class="n">n.fib</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="c1">-- nat.fib is a functor because nat.gcd(nat.fib n, nat.fib m) = nat.fib(nat.gcd n m)</span>
<span class="c1">-- nat.fib is a continuous functor, because it preserves limits</span>

<span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">‚•§</span> <span class="n">mynat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="n">nat.fib</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">m</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">hom_of_le</span> <span class="o">(</span><span class="n">fib_dvd_fib</span> <span class="o">(</span><span class="n">le_of_hom</span> <span class="n">h</span><span class="o">)),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">Œª</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">}</span>

<span class="c1">-- ‚Ñï is a category</span>
<span class="c1">-- ‚Ñï is also a complete category</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>

<span class="c1">-- ‚Ñï has a categorical limit</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">limits.has_finite_limits</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="220522837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220522837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220522837">(Dec 20 2020 at 14:41)</a>:</h4>
<p>The sketch provided doesn't show that fib preserves meets, the unproven lemma <code> lemma fib_dvd_fib {m n : ‚Ñï} (h : m ‚à£ n) : m.fib ‚à£ n.fib :=</code> just says that fib is order preserving with the order on mynat given by division.</p>



<a name="220522966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220522966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220522966">(Dec 20 2020 at 14:45)</a>:</h4>
<p>The reason for introducing mynat as a type alias for nat is to make use of notation and lemmas proved for types equipped with an order relation. Lean (naturally) gets confused if you put a two different order relations on the same type and want to use the same symbols to represent them both, so when you have two different relations on some type that both make it a preorder one way to circumvent this is to make a new type which is definitionally equal to the old one but with a different name. Lean will not automatically introduce the typeclasses from the old type for the new one, so we can set up an order relation on mynat that doesn't conflict with the usual ordering on natural numbers. As the types are equal by definition we can still use things proved about nat to prove things about mynat and lean will accept the proofs, hence why lines like <code>   le_sup_left := nat.dvd_lcm_left,</code> work to prove things about mynat.</p>



<a name="220523036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220523036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220523036">(Dec 20 2020 at 14:47)</a>:</h4>
<p>I'm not sure if you are intending your annotations to be before or after the corresponding declaration?</p>



<a name="220523084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220523084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220523084">(Dec 20 2020 at 14:48)</a>:</h4>
<p>The statement that fib is a functor isn't the same as <code>nat.gcd(nat.fib n, nat.fib m) = nat.fib(nat.gcd n m)</code> that is the statement that fib preserves limits.</p>



<a name="220523152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220523152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220523152">(Dec 20 2020 at 14:50)</a>:</h4>
<p>Being a complete category in lean is the statement <code>limits.has_limits</code> I believe, <code>has_finite_limits</code> would just be called finitely complete.</p>



<a name="220523206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Expressing%20%E2%84%95%20as%20a%20category%20and%20Fibonacci%20as%20a%20functor/near/220523206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Expressing.20.E2.84.95.20as.20a.20category.20and.20Fibonacci.20as.20a.20functor.html#220523206">(Dec 20 2020 at 14:52)</a>:</h4>
<p>But given that we've added an incomplete proof that mynat is a complete lattice, the last line can be changed to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">limits.has_finite_limits</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html">dec_trivial for zmod 8</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="238635751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238635751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238635751">(May 13 2021 at 15:18)</a>:</h4>
<p>Dear All,</p>
<p>I do not know anything about computability, but I would have thought that the lemma below should be provable "automatically".  I do not mind if you change the <code>set</code> to something more "decidable", but I would like to get Lean to check for me that the sum of 4 numbers that are all either 0 or 1 can be divisible by 8 iff each of the numbers is 0.</p>
<p>I would prefer a solution that "teaches" me how to work with decidable.  Something along the lines of "oh, you have to write this, to get a decidable instance on all props of this form...", ideally!</p>
<p>Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.basic</span>

<span class="kd">lemma</span> <span class="n">zmod.sq_mod_eight_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">8</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">se</span> <span class="o">:</span> <span class="o">({</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">8</span><span class="o">))</span> <span class="bp">⊆</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">})</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">dec_trivial</span><span class="bp">!</span>  <span class="c1">--fails, since it does not have a decidable instance:</span>
<span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="bp">⊢</span> <span class="n">decidable</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">8</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="o">{</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">}</span> <span class="bp">⊆</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="238638663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238638663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238638663">(May 13 2021 at 15:39)</a>:</h4>
<p><code>norm_fin</code> and <code>norm_num</code> should help here, or they should be taught to understand <code>zmod</code></p>



<a name="238638751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238638751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238638751">(May 13 2021 at 15:40)</a>:</h4>
<p>Like you say, you just have to change set to something more decidable, in this case <code>finset</code> works. I'm not sure I can teach anything other than that finite sets are inherently more decidable than infinite!<br>
You can see the instance used via</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">((({</span><span class="mi">0</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">8</span><span class="o">))</span> <span class="bp">⊆</span> <span class="o">{</span><span class="mi">0</span><span class="o">}))</span>
</code></pre></div>
<p>the analogous thing for set isn't found, however I think it is checking membership that makes the difference, compare</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">∈</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">8</span><span class="o">))))</span>

<span class="k">#check</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">∈</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">8</span><span class="o">))))</span>
</code></pre></div>
<p>curiously the second version works for singletons though</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">∈</span> <span class="o">({</span><span class="mi">1</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">8</span><span class="o">))))</span>
</code></pre></div>



<a name="238638904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238638904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238638904">(May 13 2021 at 15:41)</a>:</h4>
<p>Yakov, <code>by norm_num</code> says <code>failed to simplify</code>.  <code>norm_fin</code> might require an import that I do not have...</p>



<a name="238639039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238639039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238639039">(May 13 2021 at 15:42)</a>:</h4>
<p>Alex, thanks!  This is already good!  I will try to produce a <code>finset</code> instead of a <code>set</code>, then (or possibly try to stick with singletons <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span> ).</p>



<a name="238639327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238639327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238639327">(May 13 2021 at 15:44)</a>:</h4>
<p>Here's what I mean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.basic</span>
<span class="kn">import</span> <span class="n">tactic.norm_fin</span>

<span class="kd">lemma</span> <span class="n">zmod.sq_mod_eight_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">8</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">se</span> <span class="o">:</span> <span class="o">({</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">8</span><span class="o">))</span> <span class="bp">⊆</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">})</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">8</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">({</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">8</span><span class="o">))</span> <span class="bp">→</span>  <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">se</span> <span class="n">hx</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">ha</span> <span class="o">:=</span> <span class="n">this</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hb</span> <span class="o">:=</span> <span class="n">this</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hc</span> <span class="o">:=</span> <span class="n">this</span> <span class="n">c</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hd</span> <span class="o">:=</span> <span class="n">this</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">true_or</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">forall_true_left</span><span class="o">,</span> <span class="n">or_true</span><span class="o">,</span> <span class="n">finset.mem_insert</span><span class="o">,</span>
    <span class="n">finset.mem_singleton</span><span class="o">]</span> <span class="n">at</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">hc</span> <span class="n">hd</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">;</span>
  <span class="n">rcases</span> <span class="n">hb</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">;</span>
  <span class="n">rcases</span> <span class="n">hc</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">rfl</span><span class="bp">;</span>
  <span class="n">rcases</span> <span class="n">hd</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">rfl</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span> <span class="c1">-- the first goal is all zeros</span>
  <span class="n">any_goals</span> <span class="o">{</span>
    <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">norm_num</span>  <span class="o">}</span> <span class="c1">-- norm_num can figure out</span>
<span class="kd">end</span>
</code></pre></div>



<a name="238639760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238639760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238639760">(May 13 2021 at 15:48)</a>:</h4>
<p>Yakov, thanks a lot!  I will take a close look at your solution, although it feels a little long, given what it is trying to prove!</p>
<p>Alternatively, </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">zmod.sq_mod_eight_sum</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">8</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">se</span> <span class="o">:</span> <span class="o">({</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">8</span><span class="o">))</span> <span class="bp">⊆</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">})</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">dec_trivial</span><span class="bp">!</span>
</code></pre></div>
<p>actually works, but is a little slow, I think!</p>



<a name="238640568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238640568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238640568">(May 13 2021 at 15:54)</a>:</h4>
<p>Yakov, thanks a lot!  I looked at your code and I understand better what is going on.</p>
<p>I have a follow up question: you used <code>fin 8</code> instead of <code>zmod 8</code> to be able to use <code>norm_fin</code>?  (I had never seen <code>norm_fin</code> before.)</p>



<a name="238644814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238644814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238644814">(May 13 2021 at 16:25)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> My guess is that <code>dec_trivial!</code> has to loop through <code>(zmod 8)^4</code>.</p>



<a name="238644891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238644891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238644891">(May 13 2021 at 16:26)</a>:</h4>
<p>If you phrase it as <code>a b c d : nat</code> and add assumptions <code>a &lt;= 1</code> etc..., then there are only <code>2 ^ 4</code> options. That should be reasonably fast.</p>



<a name="238644938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238644938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238644938">(May 13 2021 at 16:26)</a>:</h4>
<p>And from the <code>nat</code>-version to the <code>zmod 8</code> version shouldn't be too much work either.</p>



<a name="238645141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238645141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238645141">(May 13 2021 at 16:28)</a>:</h4>
<p>I see, thanks for the suggestion, Johan!  There is also a further issue is that this was (partially) minimized: I really care about <code>a, b, c, d</code> being squares modulo 8, so they can also be <code>4</code> [in which case, they all are either 0 or 4, of course].  Still, it might be more efficient to use <code>a &lt;= 4</code> (but not 2 or 3), than what I was trying.</p>
<p>Thanks a lot!</p>



<a name="238658482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238658482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238658482">(May 13 2021 at 18:11)</a>:</h4>
<p>If you use <code>\forall a b c d \in [0, 1, 4]</code> it will only go through 3^4 options</p>



<a name="238659143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238659143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238659143">(May 13 2021 at 18:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> should norm_fin be extended to work on zmod automatically?</p>



<a name="238659310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238659310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238659310">(May 13 2021 at 18:18)</a>:</h4>
<p>Mario, thanks for the comment!  I think that I got it to work in 12secs.  Honestly, I do not know if this is fast or slow!  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="238659627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238659627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238659627">(May 13 2021 at 18:20)</a>:</h4>
<p>That's pretty slow. You could help it along to instead phrase the proof as something about the cardinality of finset zmod bit0 k less than bit0 k, where the finset is a subset of 0, 1, k</p>



<a name="238660224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238660224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238660224">(May 13 2021 at 18:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208/near/238659143">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> should norm_fin be extended to work on zmod automatically?</p>
</blockquote>
<p>Sure, but like norm_num it's not intended for quantified statements like this example</p>



<a name="238660355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238660355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238660355">(May 13 2021 at 18:26)</a>:</h4>
<p>Also you can solve for d to make it only 3^3 options</p>



<a name="238661417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/dec_trivial%20for%20zmod%208/near/238661417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/dec_trivial.20for.20zmod.208.html#238661417">(May 13 2021 at 18:34)</a>:</h4>
<p>Ok, I can see how these suggestions will cut down the number of computations.  I am happy that such case bashes are rare in the kind of arguments that I usually think about!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
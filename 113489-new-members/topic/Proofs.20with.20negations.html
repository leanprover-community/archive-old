---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Proofs.20with.20negations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html">Proofs with negations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="300601052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300601052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300601052">(Sep 25 2022 at 02:24)</a>:</h4>
<p>Still working through TPIL and totally flummoxed by proofs of negations. For example, working through De Morgan's laws, and have gotten this to work by copying the very terse <code>mathlib</code> proof, but I don't understand how it works.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">not_or_dist_left</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">hnpq</span><span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">),</span>
  <span class="k">show</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span>
    <span class="k">assume</span> <span class="n">hp</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">hnpq</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">hp</span><span class="o">))</span>
</code></pre></div>
<p>I've assumed <code>p</code>, provided that to <code>¬(p ∨ q)</code> and demonstrated <code>¬p</code>? It all feels very mindtwisty like there's a proof by contraction without stating <code>by_contradiction</code> or <code>absurd</code>.</p>



<a name="300601215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300601215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300601215">(Sep 25 2022 at 02:28)</a>:</h4>
<p>keep in mind that <code>¬p</code> is equivalent to <code>p → false</code>, so if you want to prove <code>¬p</code> all you need to do is assume <code>p</code> and derive <code>false</code> somehow</p>



<a name="300601371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300601371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300601371">(Sep 25 2022 at 02:32)</a>:</h4>
<p>also, since <code>¬p</code> is equivalent to <code>p → false</code>, if you have a proof of <code>¬p</code> and you apply <code>p</code> to it, you get <code>false</code> back (because what you're really doing is applying <code>p</code> to <code>p → false</code>)</p>



<a name="300601583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300601583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300601583">(Sep 25 2022 at 02:37)</a>:</h4>
<p>what the above proof is doing is this:</p>
<p>1) we assume the premise, <code>¬(p ∨ q)</code><br>
2) we want to prove <code>¬p</code> which is actually proving <code>p → false</code>, so we assume <code>p</code> is true and our goal is to prove <code>false</code><br>
3) since <code>p</code> is true, we know that <code>p ∨ q</code> is true (this is what <code>or.inl hp</code> is doing)<br>
4) now we know <code>p ∨ q</code> is true (represented by <code>or.inl hp</code>), and we also assumed <code>¬(p ∨ q)</code> is true (represented by <code>hnpq</code>), so we combine those to get <code>false</code> in the final line and we're done</p>



<a name="300601782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300601782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300601782">(Sep 25 2022 at 02:40)</a>:</h4>
<p>Cool, so it's a sort of proof by contraction because we <em>want</em> <code>false → p</code>...?</p>



<a name="300602133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300602133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300602133">(Sep 25 2022 at 02:48)</a>:</h4>
<p>not exactly... we don't want to derive <code>p</code> from <code>false</code>, but the other way around</p>



<a name="300602138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300602138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300602138">(Sep 25 2022 at 02:48)</a>:</h4>
<p>though certainly, once you have <code>false</code> you can derive whatever you want</p>



<a name="300602218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300602218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300602218">(Sep 25 2022 at 02:50)</a>:</h4>
<p>but the goal is to start with <code>p</code> and end up producing <code>false</code> somehow</p>
<p><code>¬p</code> just <em>is</em> <code>p → false</code> within Lean... that's how it's represented</p>



<a name="300602257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300602257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300602257">(Sep 25 2022 at 02:51)</a>:</h4>
<p>in other words, when you see <code>¬p</code> you should think to yourself "that's a function from <code>p</code> to <code>false</code>"</p>



<a name="300602312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300602312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300602312">(Sep 25 2022 at 02:53)</a>:</h4>
<p>(at least that's how I think of it, being a software engineer by trade... if you're a mathematician you can think of it as being equivalent to "if p, then false")</p>



<a name="300602469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300602469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300602469">(Sep 25 2022 at 02:56)</a>:</h4>
<p>but yes, it's a proof by contradiction in the sense that you prove <code>not p</code> by assuming <code>p</code> and deriving <code>false</code></p>



<a name="300602551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300602551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300602551">(Sep 25 2022 at 02:58)</a>:</h4>
<p>Thanks -- also software engineering by background and having a hard time reasoning over types here. I suppose like most things Lean I'll just get used to it.</p>



<a name="300602642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300602642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300602642">(Sep 25 2022 at 03:00)</a>:</h4>
<p>yeah, it's a bit weird at first but eventually it starts to click</p>



<a name="300607761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300607761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300607761">(Sep 25 2022 at 04:52)</a>:</h4>
<p>So to check understanding, this bit:<br>
<code>assume hp: p</code> is the premise to the function and we show <code>false</code> by <code>hnpq (or.inl hp)</code></p>
<p>And in the other side of the double implication we do the same thing for <code>¬(p ∨ q)</code> by assuming <code>p ∨ q</code> and showing each case leads to false...</p>



<a name="300608693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300608693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300608693">(Sep 25 2022 at 05:10)</a>:</h4>
<p>We don't actually assume <code>p v q</code>. The statement we're trying to prove is "<strong>if</strong> ¬(p ∨ q), <strong>then</strong> ¬p". In other words, we need to produce a function that takes in a proof of <code>¬(p ∨ q)</code> and returns a proof of <code>¬p</code>.</p>



<a name="300608731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300608731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300608731">(Sep 25 2022 at 05:11)</a>:</h4>
<p>So we assume <code>¬(p ∨ q)</code> at the start, and our goal is to return <code>¬p</code> (which is equivalent to saying that our goal is return a function from <code>p</code> to <code>false</code>).</p>



<a name="300608812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300608812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300608812">(Sep 25 2022 at 05:13)</a>:</h4>
<p>At the point where we assumed <code>p</code>, we were able to derive <code>p v q</code> from that because it logically follows: "if P is true, then P or Q is true"</p>



<a name="300608982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300608982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300608982">(Sep 25 2022 at 05:17)</a>:</h4>
<p>If <code>assume</code> is confusing, just remember that it's shorthand for <code>λ a</code>... it's just another way of declaring a function argument</p>



<a name="300609351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300609351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300609351">(Sep 25 2022 at 05:25)</a>:</h4>
<p>Here's another way to write out the same proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">not_or_dist_left</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">not_p_or_q</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">),</span>
  <span class="c1">-- we need a function from p to false</span>
  <span class="bp">λ</span> <span class="n">proof_of_p</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">p_or_q</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">or.inl</span> <span class="n">proof_of_p</span> <span class="k">in</span>
    <span class="n">not_p_or_q</span> <span class="n">p_or_q</span>
</code></pre></div>



<a name="300619532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300619532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300619532">(Sep 25 2022 at 08:10)</a>:</h4>
<p>Does it make more sense if you write the goal as <code>(p ∨ q → false) → (p → false)</code>?</p>



<a name="300620923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300620923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300620923">(Sep 25 2022 at 08:28)</a>:</h4>
<p>I also picture this proof in my mind as a proof by contradiction.  Maybe, with the comments below, the argument makes more sense?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">not_or_dist_left</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">hnpq</span><span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">),</span>  <span class="c1">-- Suppose that `p ∨ q` is false</span>
  <span class="k">show</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span>         <span class="c1">-- We want to show that `p` itself must be false</span>
    <span class="k">assume</span> <span class="n">hp</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span>         <span class="c1">-- By contradiction, suppose that `p` is true instead</span>
    <span class="n">hnpq</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">hp</span><span class="o">))</span>     <span class="c1">-- If `p` is true, then `p ∨ q` is true (this is the `or.inl` part),</span>
                          <span class="c1">-- contrary to the assumption `hnpq` that `p ∨ q` is false</span>
</code></pre></div>



<a name="300657381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300657381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300657381">(Sep 25 2022 at 14:32)</a>:</h4>
<p>Thanks for all of this , and I think I'm understanding. At the type level, our function is really <code>p ∨ q → false) → (p → false)</code>, inside the proof in the <code>show, from</code> step we are actually constructing a function <code>p→ false</code>, which, since it typechecks, constitutes proof,  but the sugared logical flow in that step looks like a proof by contradiction (assuming <code>p</code>, showing that it leads to <code>false</code>.</p>



<a name="300898875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300898875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300898875">(Sep 26 2022 at 20:57)</a>:</h4>
<p>I am <em>absurd</em>ly pleased by this, which took me far too much time to work out.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">classical</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">s</span><span class="o">))</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">s</span><span class="o">,</span>
  <span class="k">show</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">s</span><span class="o">),</span> <span class="k">from</span> <span class="o">(</span>
    <span class="n">or.elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
    <span class="o">(</span> <span class="k">assume</span> <span class="n">hp</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hrs</span><span class="o">:</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span> <span class="n">hp</span><span class="o">,</span>
      <span class="n">hrs.elim</span>
      <span class="o">(</span> <span class="k">assume</span> <span class="n">hr</span><span class="o">:</span> <span class="n">r</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hpr</span><span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">hp₂</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="n">hr</span><span class="o">,</span>
        <span class="k">show</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">s</span><span class="o">),</span> <span class="k">from</span> <span class="n">or.inl</span> <span class="n">hpr</span><span class="o">)</span>
      <span class="o">(</span> <span class="k">assume</span> <span class="n">hs</span><span class="o">:</span> <span class="n">s</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">hps</span><span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">hp₂</span><span class="o">,</span> <span class="n">hs</span><span class="o">,</span>
        <span class="k">show</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">s</span><span class="o">),</span> <span class="k">from</span> <span class="n">or.inr</span> <span class="n">hps</span><span class="o">)</span>
    <span class="o">)</span>
    <span class="o">(</span> <span class="k">assume</span> <span class="n">hnp</span><span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hpr</span><span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">hp</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">,</span>
      <span class="k">show</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">s</span><span class="o">),</span> <span class="k">from</span> <span class="n">or.inl</span> <span class="n">hpr</span><span class="o">)</span>
  <span class="o">)</span>
</code></pre></div>
<p>It seems that Lean knows that the three lambda expressions here occur in a context where it is already known that <code>p</code> is <code>true</code> or <code>false</code> as the case may be??</p>



<a name="300907458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300907458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300907458">(Sep 26 2022 at 22:07)</a>:</h4>
<p>Lean doesn't consider propositions to be true or false per se -- we consider a proposition to be "true" if we have a proof of it in context.</p>



<a name="300907527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300907527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300907527">(Sep 26 2022 at 22:08)</a>:</h4>
<p><span class="user-mention" data-user-id="542196">@Arien Malec</span> What programming language are you the most familiar with? I ask because there isn't really any magic going on in the above code (Lean doesn't have to "know" anything), and perhaps I can rewrite it in a way that demonstrates that</p>



<a name="300907543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300907543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300907543">(Sep 26 2022 at 22:08)</a>:</h4>
<p>It might be helpful to see the proof with a bunch of the syntactic sugar removed:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">classical</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">s</span><span class="o">))</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">s</span><span class="o">),</span>
    <span class="n">or.elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">hrs</span><span class="o">:</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span> <span class="n">hp</span><span class="o">,</span>
      <span class="n">hrs.elim</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="n">r</span><span class="o">),</span>
        <span class="k">have</span> <span class="n">hpr</span><span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">hp₂</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="n">hr</span><span class="o">,</span>
        <span class="n">or.inl</span> <span class="n">hpr</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s</span><span class="o">),</span>
        <span class="k">have</span> <span class="n">hps</span><span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">hp₂</span><span class="o">,</span> <span class="n">hs</span><span class="o">,</span>
        <span class="n">or.inr</span> <span class="n">hps</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">),</span>
      <span class="k">have</span> <span class="n">hpr</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">,</span>
      <span class="n">or.inl</span> <span class="n">hpr</span><span class="o">)</span>
</code></pre></div>



<a name="300907570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300907570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300907570">(Sep 26 2022 at 22:08)</a>:</h4>
<p>I still left the <code>have</code> clauses, which are yet another way to write lambda expressions</p>



<a name="300907688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300907688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300907688">(Sep 26 2022 at 22:10)</a>:</h4>
<p>The <code>show</code> clauses weren't completely necessary since you can get the goal from the goal view in VS Code or Emacs. There's no harm in keeping them, and I removed them just to illustrate that they're not doing any magic.</p>



<a name="300907804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300907804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300907804">(Sep 26 2022 at 22:11)</a>:</h4>
<p>Most relevant, Rust, enough Haskell to do stuff, but not be typesystem dangerous.</p>
<p><code>λ hp₂ : p, hr</code> is an anonymous lambda, which can be called with any value? It could be called in a context where <code>p</code> is <code>false</code>, yeah? But we know that we are are calling in in a context where <code>p</code> is true...</p>



<a name="300907927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300907927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300907927">(Sep 26 2022 at 22:12)</a>:</h4>
<p>Here's it with all the have's removed too:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">classical</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">s</span><span class="o">))</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">s</span><span class="o">),</span>
    <span class="n">or.elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">),</span>
      <span class="n">or.elim</span> <span class="o">(</span><span class="n">h</span> <span class="n">hp</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="n">r</span><span class="o">),</span> <span class="n">or.inl</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">p</span><span class="o">),</span> <span class="n">hr</span><span class="o">))</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s</span><span class="o">),</span> <span class="n">or.inr</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">p</span><span class="o">),</span> <span class="n">hs</span><span class="o">)))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">),</span>
      <span class="n">or.inl</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">),</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">))</span>
</code></pre></div>



<a name="300907971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300907971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300907971">(Sep 26 2022 at 22:12)</a>:</h4>
<p>Yes, <code>λ hp₂ : p, hr</code> can be called with any proof <code>hp₂</code> of <code>p</code>. It can only be called when <code>p</code> is "true" for that reason.</p>



<a name="300908077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300908077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300908077">(Sep 26 2022 at 22:13)</a>:</h4>
<p>It can only be called in a context when <code>p</code> is "false" when <code>p</code> is also "true" (i.e., when there's a logical contradiction)</p>



<a name="300908199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300908199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300908199">(Sep 26 2022 at 22:14)</a>:</h4>
<p>it's also true that <code>λ hp₂ : p, hr</code> by itself is a valid proof of <code>p → r</code> in a context where you already have a proof of <code>r</code> in a variable <code>hr</code></p>



<a name="300908584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300908584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300908584">(Sep 26 2022 at 22:18)</a>:</h4>
<blockquote>
<p>we are calling it in a context where <code>p</code> is true</p>
</blockquote>
<p>maybe there's a misunderstanding because we're not "calling " <code>(hp₂ : p), hr</code> anywhere (I think)</p>



<a name="300908661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300908661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300908661">(Sep 26 2022 at 22:19)</a>:</h4>
<p>we're writing it out as a proof of the proposition <code>(p → r)</code>, and then using it to prove <code>(p → r) ∨ (p → s)</code></p>



<a name="300908682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300908682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300908682">(Sep 26 2022 at 22:19)</a>:</h4>
<p>(I'll mention that it's a Lean theorem that if you have <code>h : p</code> (i.e., <code>p</code> is "true" since we have a proof of it) then you can conclude that <code>p = true</code>. But Lean generally won't replace <code>p</code> with <a href="https://leanprover-community.github.io/mathlib_docs/find/true">docs#true</a> on its own.)</p>



<a name="300911724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300911724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300911724">(Sep 26 2022 at 22:48)</a>:</h4>
<p><span class="user-mention" data-user-id="542196">@Arien Malec</span> I'm curious why you said we were "calling"  <code>λ hp₂ : p, hr</code>... are you imagining that the function has to be "called" to create a proof of <code>p → r</code>? Because it doesn't... the function <em>is</em> the proof.</p>



<a name="300911749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300911749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300911749">(Sep 26 2022 at 22:48)</a>:</h4>
<p>In the H-M type system languages I've used in anger (Ocaml, Rust, Swift, Haskell), if I define, say <code>|p: bool|  -&gt; bool {r}</code>, <code>r</code> in the lambda body is bound and captured, but <code>p</code> is free, and I'm saying "whatever <code>p</code> is, return the bound value of <code>r</code>",  which is a stronger proof than we want, yeah? It's a function from <code>¬p</code> to <code>r</code> as well. I have to know that <code>p</code> as well?</p>
<p>Put it another way, out of context that <code>p</code>, how could <code>λ h : p, hr</code> constitute a proof <code>(p → r)</code>?</p>



<a name="300911959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300911959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300911959">(Sep 26 2022 at 22:51)</a>:</h4>
<p><code>p → r</code> means "if you give me a proof of <code>p</code>, I'll give you a proof of <code>r</code>"... in other words, a function that takes in a proof of <code>p</code> and returns a proof of <code>r</code></p>



<a name="300911990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300911990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300911990">(Sep 26 2022 at 22:51)</a>:</h4>
<p>in this case, it so happens that we already have a proof of <code>r</code> in the variable <code>hr</code></p>



<a name="300912167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912167">(Sep 26 2022 at 22:53)</a>:</h4>
<p>it doesn't matter that we might not have a proof of <code>p</code>... an implication is just a hypothetical, saying <em>if</em> this is the case, <em>then</em> that is the case</p>



<a name="300912265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912265">(Sep 26 2022 at 22:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="380294">Matt Diamond</span> <a href="#narrow/stream/113489-new-members/topic/Proofs.20with.20negations/near/300911724">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="542196">Arien Malec</span> I'm curious why you said we were "calling"  <code>λ hp₂ : p, hr</code>... are you imagining that the function has to be "called" to create a proof of <code>p → r</code>? Because it doesn't... the function <em>is</em> the proof.</p>
</blockquote>
<p>I think I've got that (or it's getting grokked slowly). But it's only a proof when we already know that <code>p</code>, right?</p>
<p>If I dropped the same function  in to the other branch of the <code>elim</code>, it would constitute a proof of the opposite, right?</p>
<p><code>(λ (hnp : ¬p),  (λ (hr : r), or.inl (λ (hp₂ : p), hr))</code> in that context would be a proof that <code>¬p → r</code>?</p>



<a name="300912382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912382">(Sep 26 2022 at 22:55)</a>:</h4>
<p>Or…would that fail to typecheck, because <code>p</code> and <code>¬p</code> aren't values of a <code>bool</code>, they are totally different types…</p>



<a name="300912384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912384">(Sep 26 2022 at 22:55)</a>:</h4>
<p>the thing is that the implication doesn't require <code>p</code> to be true</p>



<a name="300912489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912489">(Sep 26 2022 at 22:56)</a>:</h4>
<p>in fact, you could replace the exact same function in the same place with <code>(hp₂ : ¬p), hr</code> and you would have a proof of <code>¬p → r</code></p>



<a name="300912540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912540">(Sep 26 2022 at 22:57)</a>:</h4>
<p>but Lean would be confused because the goal at that point is to prove <code>p → r</code></p>



<a name="300912546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912546">(Sep 26 2022 at 22:57)</a>:</h4>
<p>I think the lighbulb moment here is "p and ¬p aren't values of a bool, they are totally different types"</p>



<a name="300912778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912778">(Sep 26 2022 at 22:59)</a>:</h4>
<p><code>(λ (hnp : ¬p),  (λ (hr : r), or.inl (λ (hp₂ : p), hr))</code> would be a proof of <code>¬p → r → p ∨ r</code></p>



<a name="300912833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912833">(Sep 26 2022 at 23:00)</a>:</h4>
<p>which is just true in any context</p>



<a name="300912916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912916">(Sep 26 2022 at 23:01)</a>:</h4>
<p>it's like we need to prove "if aliens are real, then your name is Arien Malec" and we have a proof that your name is Arien Malec</p>



<a name="300912988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300912988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300912988">(Sep 26 2022 at 23:02)</a>:</h4>
<p>I'm walking around with a mental model of <code>Prop</code> being like <code>bool</code>, when <code>p: Prop</code> is already an assertion that <code>p</code>.</p>



<a name="300913043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300913043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300913043">(Sep 26 2022 at 23:02)</a>:</h4>
<p><code>p : Prop</code> is a proposition named <code>p</code>, it doesn't assert anything. However, <code>hp : p</code> is a proof of <code>p</code>.</p>



<a name="300913282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300913282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300913282">(Sep 26 2022 at 23:05)</a>:</h4>
<p>the "propositions are types and proofs are terms of them" model can be a bit tricky to wrap your mind around, for sure</p>



<a name="300913431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300913431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300913431">(Sep 26 2022 at 23:06)</a>:</h4>
<p>it's a bit confusing because the proposition <em>is</em> the type, while <code>Prop</code> is the type of propositions</p>



<a name="300913540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300913540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300913540">(Sep 26 2022 at 23:08)</a>:</h4>
<p>so if you had a variable <code>h</code> whose type was <code>∃ n, n &gt; 0</code>, then it would be a proof that there's a number greater than 0</p>



<a name="300913605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300913605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300913605">(Sep 26 2022 at 23:08)</a>:</h4>
<p>Mathlib has that there's a bijection between <code>Prop</code> and <code>bool</code>, so <code>Prop</code> being like <code>bool</code> isn't so far off (<a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.Prop_equiv_bool">docs#equiv.Prop_equiv_bool</a>)</p>
<p>The big difference is that when you have a term of <code>bool</code> in hand, you can tell whether it is <code>tt</code> or <code>ff</code> by computing long enough. But when you have <code>p : Prop</code>, there's no procedure you can use to decide (in general) whether <code>p = true</code> or <code>p = false</code>. You can only infer that <code>p = true</code> if you manage to find a proof <code>h : p</code> or that <code>p = false</code> if you manage to find a proof <code>h : ¬p</code>.</p>



<a name="300913731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300913731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300913731">(Sep 26 2022 at 23:10)</a>:</h4>
<p>There's also the big difference that <code>bool</code> and <code>Prop</code> are at different "levels", as Matt has mentioned.  Here's a diagram that tries to illustrate this: <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20Prop.20.3A.3D.20Sort.200.20Motivation/near/252362723">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.E2.9C.94.20Prop.20.3A.3D.20Sort.200.20Motivation/near/252362723</a></p>



<a name="300913733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300913733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300913733">(Sep 26 2022 at 23:10)</a>:</h4>
<p>right... Propositions are not necessarily decidable</p>



<a name="300913784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300913784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300913784">(Sep 26 2022 at 23:11)</a>:</h4>
<p>The "typechecking is proof" paradigm is super deep. Playing around with my proof the issue with proving <code> p ∨ r</code> in the <code>¬p</code> context is not the <code>p</code> vs <code>¬p</code> issue but that <em>I haven't found a proof <code>hr: r</code> in that context</em>.</p>



<a name="300913899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300913899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300913899">(Sep 26 2022 at 23:12)</a>:</h4>
<p>yeah that sounds right, in the sense that you're able to prove <code>p ∨ r</code> if you have a proof of <code>r</code> (though you could also prove it if you had a proof of <code>p</code>)</p>



<a name="300913940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300913940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300913940">(Sep 26 2022 at 23:13)</a>:</h4>
<p>Really appreciate the help getting my head wrapped the right way around these concepts.</p>



<a name="300914039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300914039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300914039">(Sep 26 2022 at 23:14)</a>:</h4>
<p>no problem!</p>



<a name="300914691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300914691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300914691">(Sep 26 2022 at 23:21)</a>:</h4>
<p>(did you mean to write <code>p → r</code> instead of <code>p ∨ r</code>above? if so, then you've got the right idea)</p>



<a name="300914805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300914805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300914805">(Sep 26 2022 at 23:22)</a>:</h4>
<p>I was interpreting that as, if you want to prove <code>p ∨ r</code> but you have <code>¬p</code>, then you know you need a proof of <code>r</code>.</p>



<a name="300915060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300915060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300915060">(Sep 26 2022 at 23:25)</a>:</h4>
<p>oh right... that also makes sense</p>
<blockquote>
<p><code>(λ (hnp : ¬p),  (λ (hr : r), or.inl (λ (hp₂ : p), hr))</code> would be a proof of <code>¬p → r → p ∨ r</code></p>
</blockquote>
<p>I wrote this above and I just realized it's not true, so I was hoping I didn't confuse him... the point is that it proves <code>(p → r) ∨ [anything else]</code>, not <code>p ∨ r</code></p>
<p>I'm sure he'll figure it out</p>



<a name="300919201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proofs%20with%20negations/near/300919201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Proofs.20with.20negations.html#300919201">(Sep 27 2022 at 00:07)</a>:</h4>
<p>I got it modulo typos!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
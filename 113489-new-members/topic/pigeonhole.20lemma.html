---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/pigeonhole.20lemma.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html">pigeonhole lemma</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209581883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209581883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209581883">(Sep 09 2020 at 23:38)</a>:</h4>
<p>Can anyone help me to simplify my proof of this pigeonhole lemma?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">lemma</span> <span class="n">pidgeonhole</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">s</span><span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">},</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">induction</span> <span class="bp">ℕ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">},</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)),</span>
  <span class="o">{</span>
     <span class="n">intro</span><span class="o">,</span>
     <span class="n">exfalso</span><span class="o">,</span>
     <span class="n">exact</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">not_mem_empty</span> <span class="o">(</span><span class="n">f</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">property</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">s</span> <span class="n">hn</span> <span class="n">hip</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">classical</span><span class="bp">.</span><span class="n">em</span> <span class="o">(</span><span class="bp">∃</span><span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">))</span> <span class="k">with</span> <span class="n">hbounded</span> <span class="n">hinf</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">k0</span><span class="o">,</span> <span class="n">hk0</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hbounded</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">fk</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="bp">⟨</span><span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k0</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">),</span>
    <span class="o">{</span>
      <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hip</span> <span class="n">fk</span><span class="o">,</span>
      <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">ha</span><span class="o">,</span>
      <span class="n">use</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">k0</span><span class="o">),</span>
      <span class="n">use</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">k0</span><span class="o">),</span>
      <span class="n">cases</span> <span class="n">hb</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">intro</span> <span class="n">heq</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">hb_left</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_right_cancel</span> <span class="n">heq</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">hb_right</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">ext</span> <span class="n">hb_right</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="n">hk0a</span> <span class="o">:=</span> <span class="o">(</span><span class="n">hk0</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k0</span><span class="o">))</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_add_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_mem_insert_of_ne</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k0</span><span class="o">))</span><span class="bp">.</span><span class="n">property</span> <span class="n">hk0a</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="k">have</span> <span class="n">hall</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">not_exists</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hinf</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">hk0</span> <span class="o">:=</span> <span class="n">hall</span> <span class="mi">0</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="mi">0</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="n">not_forall</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hk0</span><span class="o">,</span>
    <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">m0</span><span class="o">,</span> <span class="n">hm0</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">this</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hnn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">m0</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">f</span> <span class="n">m0</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≠</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">not_imp</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hm0</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hfm0</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="n">m0</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">not_not</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hnn</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>

    <span class="k">let</span> <span class="n">hk1</span> <span class="o">:=</span> <span class="n">hall</span> <span class="o">(</span><span class="n">m0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="n">m0</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="n">not_forall</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hk1</span><span class="o">,</span>
    <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">m1</span><span class="o">,</span> <span class="n">hm1</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">this</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hnn1</span> <span class="o">:</span> <span class="n">m0</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">m1</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">f</span> <span class="n">m1</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≠</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">not_imp</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hm1</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hfm1</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="n">m1</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">not_not</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hnn1</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">m0</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">m1</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="n">cases</span> <span class="n">hnn1</span><span class="o">,</span>
      <span class="n">linarith</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="n">m0</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="n">m1</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hfm0</span><span class="o">,</span> <span class="n">hfm1</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="n">this</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="209582293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209582293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209582293">(Sep 09 2020 at 23:44)</a>:</h4>
<p>Very mathlib style would be to deduce this from <a href="https://leanprover-community.github.io/mathlib_docs/find/infinite_pigeonhole./src">src#infinite_pigeonhole.</a> :-) I appreciate that's not what you're asking for!</p>



<a name="209582461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209582461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209582461">(Sep 09 2020 at 23:47)</a>:</h4>
<p>By "simplify" do you mean "but still using induction on <code>finset</code>"? Because my first suggest would be to not do that. :-)</p>



<a name="209582553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209582553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209582553">(Sep 09 2020 at 23:49)</a>:</h4>
<p>Given the result you're after, you could just <code>intro s</code>, say its <code>card</code> is <code>n</code>, and restrict <code>f</code> to <code>range (n+1)</code>, and use a finite pigeonhole principle.</p>



<a name="209582668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209582668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209582668">(Sep 09 2020 at 23:50)</a>:</h4>
<p>That on the same formulation of the lemma ? Or are you proposing another formulation ?</p>



<a name="209582721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209582721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209582721">(Sep 09 2020 at 23:51)</a>:</h4>
<p>I was suggesting to either use from a mathlib, or prove from scratch if that's the exercise, the usual finite pigeonhole principle for maps between <code>finset</code>s. Then reduce what <span class="user-mention" data-user-id="243791">@David Renshaw</span> wants to prove to that.</p>



<a name="209582818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209582818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209582818">(Sep 09 2020 at 23:53)</a>:</h4>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_image_of_injective./src">src#finset.card_image_of_injective.</a> Someone should PR the easy consequence that actually looks like the finite pigeonhole principle, and make sure to add a doc-string with the word "pigeonhole"!</p>



<a name="209583440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209583440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209583440">(Sep 10 2020 at 00:02)</a>:</h4>
<p>thanks! I tried searching mathlib for "pidgeonhole" but that was before I figured out that I was spelling it wrong. <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="209583906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209583906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209583906">(Sep 10 2020 at 00:08)</a>:</h4>
<p>I simplified your proof using some tricks I know.  I didn't know about <code>obtain</code>!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">lemma</span> <span class="n">pidgeonhole</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">})</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">finset</span><span class="bp">.</span><span class="n">induction</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">s</span> <span class="n">hn</span> <span class="n">hip</span> <span class="n">f</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span> <span class="n">s</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">not_mem_empty</span> <span class="o">(</span><span class="n">f</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">property</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">k0</span><span class="o">,</span> <span class="n">hk0</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">fk</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">⟨</span><span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k0</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="k">begin</span>
      <span class="k">have</span> <span class="n">hk0a</span> <span class="o">:=</span> <span class="n">hk0</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k0</span><span class="o">)</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_add_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span>
      <span class="n">exact</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_of_mem_insert_of_ne</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">k0</span><span class="o">))</span><span class="bp">.</span><span class="n">property</span> <span class="n">hk0a</span><span class="o">,</span>
    <span class="kn">end</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hne</span><span class="o">,</span> <span class="n">hfk</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hip</span> <span class="n">fk</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">a</span> <span class="bp">+</span> <span class="n">k0</span><span class="o">,</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">k0</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">revert</span> <span class="n">hne</span><span class="o">,</span>
      <span class="n">contrapose</span><span class="o">,</span> <span class="n">push_neg</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_right_cancel</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype</span><span class="bp">.</span><span class="n">mk_eq_mk</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">val_eq_coe</span><span class="o">]</span> <span class="n">at</span> <span class="n">hfk</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">ext</span> <span class="n">hfk</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">m0</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">hk0</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="mi">0</span><span class="o">,</span>
    <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">m1</span><span class="o">,</span> <span class="n">hne</span><span class="o">,</span> <span class="n">hk1</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="o">(</span><span class="n">m0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">m0</span><span class="o">,</span> <span class="n">m1</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">hne</span><span class="o">],</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">hk0</span><span class="o">,</span> <span class="n">hk1</span><span class="o">],</span> <span class="o">},</span> <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="209584312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209584312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209584312">(Sep 10 2020 at 00:15)</a>:</h4>
<p><code>obtain</code> is pretty awesome. :-)</p>



<a name="209584333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209584333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209584333">(Sep 10 2020 at 00:15)</a>:</h4>
<p>how would you use an existential without <code>obtain</code>?</p>



<a name="209584401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209584401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209584401">(Sep 10 2020 at 00:16)</a>:</h4>
<p>some combination of <code>have</code> and <code>Exists.some</code>, I guess?</p>



<a name="209584435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209584435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209584435">(Sep 10 2020 at 00:16)</a>:</h4>
<p>I always would do <code>rcases hip fk with ⟨a, b, hne, hfk⟩</code> rather than <code>obtain ⟨a, b, hne, hfk⟩ := hip fk</code>.</p>



<a name="209584532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209584532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209584532">(Sep 10 2020 at 00:18)</a>:</h4>
<p>It's pretty much the same, but I like how with <code>obtain</code> the expression is at the end, since it opens up having a larger expression being decomposed while still having somewhat readable code.</p>



<a name="209584651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209584651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209584651">(Sep 10 2020 at 00:20)</a>:</h4>
<p>Before I learned to use <code>rcases</code>, I would write horrible terms starting with <code>exists.elim</code>. I still need to get in the habit of using <code>obtain</code> though.</p>



<a name="209585476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209585476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209585476">(Sep 10 2020 at 00:36)</a>:</h4>
<p><span class="user-mention" data-user-id="243791">@David Renshaw</span> Found a way to simplify it even more:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">pigeonhole</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="o">(</span><span class="err">↑</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">by_contra</span> <span class="n">hc</span><span class="o">,</span>
  <span class="n">push_neg</span> <span class="n">at</span> <span class="n">hc</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hinj</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">contrapose</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hc</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">not_injective_infinite_fintype</span> <span class="n">f</span> <span class="n">hinj</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>(The <code>(↑s : set ℕ)</code> is another way to write <code>{x : ℕ // x ∈ s}</code>)</p>



<a name="209585529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209585529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209585529">(Sep 10 2020 at 00:37)</a>:</h4>
<p>cool!</p>



<a name="209585639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209585639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209585639">(Sep 10 2020 at 00:39)</a>:</h4>
<p>At this point, you're essentially relying on an existing proof of the pigeonhole principle, and this proof is just providing the glue.</p>



<a name="209585720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209585720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209585720">(Sep 10 2020 at 00:41)</a>:</h4>
<p>That's good enough for me! Working through the induction was a fun exercise, but I'm mostly concerned with learning how to do things idiomatically.</p>



<a name="209585953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209585953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209585953">(Sep 10 2020 at 00:45)</a>:</h4>
<p>ah... <code>push_neg</code> is quite convenient</p>



<a name="209586127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209586127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209586127">(Sep 10 2020 at 00:48)</a>:</h4>
<p>I wouldn't really call these the pigeonhole principle, but maybe I've been too influenced by a Dijkstra essay.  His formulation was, essentially, that if you have a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> a finite set, then the maximum cardinality of a preimage is at least <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">∣</mo><mi>A</mi><mo stretchy="false">∣</mo><mi mathvariant="normal">/</mi><mo stretchy="false">∣</mo><mi>B</mi><mo stretchy="false">∣</mo></mrow><annotation encoding="application/x-tex">\lvert A\rvert / \lvert B\rvert</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">∣</span><span class="mord mathnormal">A</span><span class="mclose">∣</span><span class="mord">/</span><span class="mopen">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">∣</span></span></span></span>.  So, for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : \mathbb{N} \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, I'd like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>b</mi><mo>∈</mo><mi>B</mi><mo separator="true">,</mo><mo stretchy="false">∣</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">∣</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\exists b \in B, \lvert f^{-1}(b)\rvert = \infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∃</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mclose">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>.</p>



<a name="209586264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209586264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209586264">(Sep 10 2020 at 00:51)</a>:</h4>
<p>You're saying that there's a stronger lemma that better deserves the name <code>pigeonhole</code>? That sounds like a reasonable stance to me.</p>



<a name="209586749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209586749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209586749">(Sep 10 2020 at 01:01)</a>:</h4>
<p>You can say that there's a hole that contains at least the average number of pigeons per hole.  I'm not sure the best way to formalize that in Lean, though.</p>
<p>Following <span class="user-mention" data-user-id="110087">@Scott Morrison</span>'s suggestion, it seems like it might be worth creating an analogue of <code>not_injective_infinite_fintype</code> for <code>fintype.card_le_of_injective</code> and adding documentation comments that these are the classic pigeonhole principles for finitely many and infinitely many pigeons.  All I really did with my last simplification was using <code>push_neg</code> to recover the hidden <code>function.injective</code>.</p>



<a name="209586958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209586958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209586958">(Sep 10 2020 at 01:06)</a>:</h4>
<p>(Issue <a href="https://github.com/leanprover-community/mathlib/issues/2772">#2772</a> is also about the pigeonhole principle.)</p>



<a name="209587125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209587125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209587125">(Sep 10 2020 at 01:10)</a>:</h4>
<p>(Ah, found it: <a href="https://github.com/leanprover-community/mathlib/issues/2272">#2272</a>)</p>



<a name="209588228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209588228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209588228">(Sep 10 2020 at 01:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/pigeonhole.20lemma/near/209585476">said</a>:</p>
<blockquote>
<p>(The <code>(↑s : set ℕ)</code> is another way to write <code>{x : ℕ // x ∈ s}</code>)</p>
</blockquote>
<p>what do these notations mean?</p>



<a name="209588284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209588284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209588284">(Sep 10 2020 at 01:40)</a>:</h4>
<p>(or how would I look up <code>//</code> other than grepping around mathlib which takes me to some pretty low-level files)</p>



<a name="209588364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209588364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209588364">(Sep 10 2020 at 01:42)</a>:</h4>
<p>One thing you can do is <code>set_option pp.notation false</code></p>



<a name="209588445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209588445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209588445">(Sep 10 2020 at 01:45)</a>:</h4>
<p>I find that when I jump-to-definition on the opening <code>{</code> of <code>{x : ℕ // x ∈ s}</code>, I get properly taken the definition of <code>subtype</code>. It does not work on the <code>//</code> or the closing <code>}</code>.</p>



<a name="209588458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209588458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Renshaw <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209588458">(Sep 10 2020 at 01:45)</a>:</h4>
<p>(in emacs)</p>



<a name="209588518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209588518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209588518">(Sep 10 2020 at 01:46)</a>:</h4>
<p>aha cool, that helps, thanks (pp.notation works here), lemme try jump to definition</p>



<a name="209588535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209588535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209588535">(Sep 10 2020 at 01:47)</a>:</h4>
<p><span class="user-mention" data-user-id="243791">@David Renshaw</span> awesome, that works too as long as yeah I do it on the <code>{</code> and not <code>//</code> which is what I tried before. Appreciated!</p>



<a name="209593996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209593996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209593996">(Sep 10 2020 at 04:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/pigeonhole.20lemma/near/209586958">said</a>:</p>
<blockquote>
<p>(Issue <a href="https://github.com/leanprover-community/mathlib/issues/2272">#2272</a> is also about the pigeonhole principle.)</p>
</blockquote>
<p>Ok, here they are! <a href="https://github.com/leanprover-community/mathlib/issues/4096">#4096</a></p>



<a name="209599288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/pigeonhole%20lemma/near/209599288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/pigeonhole.20lemma.html#209599288">(Sep 10 2020 at 06:11)</a>:</h4>
<p>Adrian Mathias told me that the pigeonhole principle was that if there were two pigeons in one hole, then one hole contained two pigeons. He then remarked that this idea could be generalized</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
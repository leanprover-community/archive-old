---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/anonymous.20instance.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html">anonymous instance?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="266940978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266940978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266940978">(Jan 05 2022 at 14:22)</a>:</h4>
<p>In TPIL, the example syntax for the <code>instance</code> declaration is given as (for example)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">Prop_inhabited</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">inhabited.mk</span> <span class="n">true</span>
</code></pre></div>
<p>In reading the source code for the <code>list</code> type, I see something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">is_left_id</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="n">has_append.append</span> <span class="o">[]</span> <span class="o">:=</span>
<span class="o">⟨</span> <span class="n">nil_append</span> <span class="o">⟩</span>
</code></pre></div>
<p>A few questions:</p>
<ul>
<li>why is there no name for this instance?</li>
<li>if I do the command <code>#print instances is_left_id</code> if find that <code>list.nil.is_left_id</code> shows up, which, it seems to me, is the instance declared above.  But how did it get associated with <code>list.nil</code>?</li>
<li>I gather that the <code>\&lt; \&gt;</code> is a default constructor of some kind, so <code>nil_append</code> proves the claim that <code>[]</code> is in fact a left identity element for <code>list.append</code>. But how is this actually being done?</li>
</ul>
<p>I could add that it appears the reference manual doesn't yet cover the syntax for instances.... unless I'm looking in the wrong place.</p>



<a name="266942450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266942450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266942450">(Jan 05 2022 at 14:37)</a>:</h4>
<blockquote>
<p>why is there no name for this instance?</p>
</blockquote>
<p><code>instance</code> will attempt to autogenerate a name for you if you do not provide one</p>
<blockquote>
<p>But how did it get associated with list.nil?</p>
</blockquote>
<p>Presumably it saw <code>[]</code> (which is syntax for list.nil) and named it after that</p>



<a name="266942565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266942565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266942565">(Jan 05 2022 at 14:38)</a>:</h4>
<blockquote>
<p>But how is this actually being done?</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.nil_append/src">src#list.nil_append</a> is the actual proof</p>



<a name="266942860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266942860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266942860">(Jan 05 2022 at 14:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/anonymous.20instance.3F/near/266942565">said</a>:</p>
<blockquote>
<blockquote>
<p>But how is this actually being done?</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.nil_append/src">src#list.nil_append</a> is the actual proof</p>
</blockquote>
<p>I get that, but what is the purpose of the <code>\&lt; \&gt;</code>?</p>



<a name="266943064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266943064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266943064">(Jan 05 2022 at 14:43)</a>:</h4>
<p>(deleted)</p>



<a name="266943881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266943881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266943881">(Jan 05 2022 at 14:50)</a>:</h4>
<p>It's calling the constructor of <code>is_left_id</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">qq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_left_id</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="n">has_append.append</span> <span class="o">[]</span> <span class="o">:=</span>
<span class="n">is_left_id.mk</span> <span class="n">list.nil_append</span>
</code></pre></div>



<a name="266943974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266943974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266943974">(Jan 05 2022 at 14:50)</a>:</h4>
<p>This is the definition of <code>is_left_id</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[algebra]</span> <span class="kd">class</span> <span class="n">is_left_id</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">out_param</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">left_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">op</span> <span class="n">o</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="266944487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266944487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266944487">(Jan 05 2022 at 14:54)</a>:</h4>
<p>I'm going to write it in a strange syntax so maybe it's clearer:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">//</span> <span class="n">this</span> <span class="n">is</span> <span class="n">not</span> <span class="n">lean</span><span class="bp">!</span>
<span class="kd">instance</span> <span class="n">qq</span> <span class="o">{</span><span class="n">α'</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="bp">=</span> <span class="n">is_left_id</span><span class="o">(</span>
  <span class="n">α</span> <span class="bp">=</span> <span class="n">list</span> <span class="n">α'</span><span class="o">,</span>
  <span class="n">op</span> <span class="bp">=</span> <span class="n">has_append.append</span><span class="o">,</span>
  <span class="n">o</span> <span class="bp">=</span> <span class="o">[]</span>
<span class="o">)</span>
</code></pre></div>



<a name="266945109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266945109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266945109">(Jan 05 2022 at 14:59)</a>:</h4>
<p>(Almost?) every type in Lean is an inductive type. Structures are a special kind of inductive types, with only one constructor. For structure <code>foo</code>, this constructor is (usually) called <code>foo.mk</code> and that's what <code>⟨ ⟩</code> does under the hood. <code>⟨h1, h2, h3⟩ : foo</code> is interpreted as <code>foo.mk h1 h2 h3</code></p>



<a name="266945216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266945216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266945216">(Jan 05 2022 at 15:00)</a>:</h4>
<p>Meanwhile <code>list.nil_append</code> says</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nil_append</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">\</span><span class="n">alpha</span><span class="o">)</span> <span class="o">:</span> <span class="o">[]</span> <span class="bp">++</span><span class="n">s</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>so how does this get disassembled to yield the proper arguments for <code>is_left_id.mk</code>?</p>



<a name="266945272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266945272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266945272">(Jan 05 2022 at 15:00)</a>:</h4>
<p>To take a familiar example, if <code>p : P</code> and <code>q : Q</code> then <code>⟨p, q⟩ : P ∧ Q</code>.</p>



<a name="266945476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266945476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266945476">(Jan 05 2022 at 15:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="462625">Jeremy Teitelbaum</span> <a href="#narrow/stream/113489-new-members/topic/anonymous.20instance.3F/near/266945216">said</a>:</p>
<blockquote>
<p>Meanwhile <code>list.nil_append</code> says</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nil_append</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">\</span><span class="n">alpha</span><span class="o">)</span> <span class="o">:</span> <span class="o">[]</span> <span class="bp">++</span><span class="n">s</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>so how does this get disassembled to yield the proper arguments for <code>is_left_id.mk</code>?</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">list.nil_append</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">@[_refl_lemma, _simp_cache, simp]</span>
<span class="cm">theorem list.nil_append : ∀ {α : Type u} (s : list α), list.nil ++ s = s :=</span>
<span class="cm">λ {α : Type u} (s : list α), rfl</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="266945613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266945613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266945613">(Jan 05 2022 at 15:02)</a>:</h4>
<p>replace <code>list.nil ++ s</code> for <code>list.append list.nil s</code> and you'd get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">list.nil_append</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">list.append</span> <span class="n">list.nil</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s</span>
</code></pre></div>



<a name="266945652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266945652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266945652">(Jan 05 2022 at 15:02)</a>:</h4>
<p>(deleted)</p>



<a name="266945792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266945792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266945792">(Jan 05 2022 at 15:04)</a>:</h4>
<p>That is, <code>list.nil_append</code> is exactly of the expected type</p>



<a name="266946004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266946004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266946004">(Jan 05 2022 at 15:05)</a>:</h4>
<p>Yes, this is uncomfortable, I get you</p>



<a name="266946737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266946737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266946737">(Jan 05 2022 at 15:11)</a>:</h4>
<p>Compare this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">op</span> <span class="n">o</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
</code></pre></div>
<p>With this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">list.append</span> <span class="n">list.nil</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s</span>
</code></pre></div>
<p>Can you see the pattern here?</p>



<a name="266947169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266947169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266947169">(Jan 05 2022 at 15:14)</a>:</h4>
<p>This is super helpful, thanks for your patience.  I see that pattern. But that is on the right hand side of the function definition for <code>is_left_id</code>,<br>
and somehow I thought we were looking for arguments for the left side (in the definition). SO when you call <code>is_left_id.mk</code>, the effect is<br>
to pull this apart and extract the components?</p>



<a name="266947257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266947257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266947257">(Jan 05 2022 at 15:15)</a>:</h4>
<p>An argument being on the left or right of the <code>:</code> has (the immense majority of the time) no effect.</p>



<a name="266947407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266947407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266947407">(Jan 05 2022 at 15:16)</a>:</h4>
<p>I'm more concerned about the <code>:=</code> then then <code>:</code>.</p>



<a name="266947972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266947972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266947972">(Jan 05 2022 at 15:21)</a>:</h4>
<p>I hope to have understood your doubt. Let's see if I did.<br>
Going back to <code>is_left_id</code>, you can see:<br>
<code>(left_id : ∀ a, op o a = a)</code></p>
<p>If you had instead:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="n">some_foo_type</span><span class="o">)</span>
<span class="o">(</span><span class="n">bar</span> <span class="o">:</span> <span class="n">some_bar_type</span><span class="o">)</span>
</code></pre></div>
<p>Calling <code>is_left_id.mk</code> would expect two parameters in the exact order defined above (<code>some_foo_type</code> then <code>some_bar_type</code>)</p>



<a name="266947980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266947980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266947980">(Jan 05 2022 at 15:21)</a>:</h4>
<p>Well, I just looked at <code>is_left_id.mk</code> and I think some light is dawning:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">is_left_id.mk</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">?</span><span class="n">M_1</span><span class="o">),</span> <span class="bp">?</span><span class="n">M_2</span> <span class="bp">?</span><span class="n">M_3</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_left_id</span> <span class="bp">?</span><span class="n">M_1</span> <span class="bp">?</span><span class="n">M_2</span> <span class="bp">?</span><span class="n">M_3</span>
</code></pre></div>
<p>SO this is exactly what we want.</p>



<a name="266948535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266948535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266948535">(Jan 05 2022 at 15:25)</a>:</h4>
<p>Yeah, it's a function that, if you provide a term of type <code>(∀ (a : ?M_1), ?M_2 ?M_3 a = a)</code>, it returns a term of type <code>is_left_id ?M_1 ?M_2 ?M_3</code></p>



<a name="266948944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266948944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266948944">(Jan 05 2022 at 15:28)</a>:</h4>
<p>And <code>list.nil_append</code> is of type <code>∀ (s : list α), list.append list.nil s = s</code>. So if you feed it to <code>is_left_id.mk</code> it will return a term of type <code>is_left_id (list α) list.append list.nil</code></p>



<a name="266949978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266949978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266949978">(Jan 05 2022 at 15:35)</a>:</h4>
<p>There's extra stuff going on with this instance involving type classes. It's not a good minimal example of anonymous instance</p>



<a name="266951446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266951446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266951446">(Jan 05 2022 at 15:47)</a>:</h4>
<p>Just to beat this into the ground, suppose i do </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">is_left_id.mk</span> <span class="n">list.nil_append</span>
</code></pre></div>
<p>Then <code>#check</code> tells me that I have a term of type <code>is_left_id (list ?M_1) list.append list.nil</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span><span class="n">left_id</span> <span class="o">:=</span> <span class="n">list.nil_append</span> <span class="bp">?</span><span class="n">M_1</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_left_id</span> <span class="o">(</span><span class="n">list</span> <span class="bp">?</span><span class="n">M_1</span><span class="o">)</span> <span class="n">append</span> <span class="n">list.nil</span>
</code></pre></div>
<p>This term has a field <code>left_id</code> which is <code>list.nil_append ?M_1</code>.</p>
<p>How would I fill in the placeholder <code>?M_1</code>?</p>



<a name="266951621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266951621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266951621">(Jan 05 2022 at 15:49)</a>:</h4>
<p>I'm not entirely sure of the context, but presumably ?M_1 is coming from an input in <code>{}</code> brackets. If you use <code>@foo</code> instead of <code>foo</code> then Lean will let you fill in the <code>{}</code> inputs instead of getting the unifier to do it.</p>



<a name="266951792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266951792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266951792">(Jan 05 2022 at 15:50)</a>:</h4>
<p>e.g. <code>#check is_left_id.mk (@list.nil_append ℕ)</code></p>



<a name="266952148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266952148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266952148">(Jan 05 2022 at 15:53)</a>:</h4>
<p>Yes after your comment I tried that and it cleared things up:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span><span class="n">is_left_id.mk</span> <span class="o">(</span><span class="bp">@</span><span class="n">list.nil_append</span> <span class="bp">\</span><span class="n">N</span> <span class="o">)</span> <span class="o">)</span><span class="bp">.</span><span class="n">left_id</span>
</code></pre></div>
<p>is a term:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">is_left_id.left_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">list.nil</span> <span class="bp">++</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
</code></pre></div>



<a name="266952167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266952167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266952167">(Jan 05 2022 at 15:53)</a>:</h4>
<p>Alternatively tell Lean the type you expect:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span><span class="n">is_left_id.mk</span> <span class="n">list.nil_append</span> <span class="o">:</span> <span class="n">is_left_id</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="n">append</span> <span class="n">list.nil</span><span class="o">)</span>
</code></pre></div>



<a name="266952445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266952445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266952445">(Jan 05 2022 at 15:55)</a>:</h4>
<p>Is it fair to say that <code>is_left_id (list bool) append list.nil</code> is a proposition that asserts that <code>list.nil</code> is a left identity for <code>list.append</code>, and<br>
<code>is_left_id.mk</code> constructs a proof of that proposition?  I need to keep types and terms of a given type straight in my head.</p>



<a name="266952608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266952608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266952608">(Jan 05 2022 at 15:56)</a>:</h4>
<p>Yes -- <code>is_left_id (list bool) append list.nil</code> is the theorem statement and <code>is_left_id.mk list.nil_append</code> is the proof.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">is_left_id</span> <span class="o">(</span><span class="n">list</span> <span class="n">bool</span><span class="o">)</span> <span class="n">append</span> <span class="n">list.nil</span> <span class="c1">-- Prop</span>
</code></pre></div>



<a name="266953340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266953340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266953340">(Jan 05 2022 at 16:01)</a>:</h4>
<p>Hovering over <code>is_left_id</code> you can see the ultimate output is a term of type Prop (i.e. a theorem statement, which is a kind of type), and hovering over <code>is_left_id.mk</code> you can see that the ultimate output is a term of type <code>is_left_id α op o</code> which isn't a universe so must be a type of some kind (indeed it's a proposition) so this must be a term (i.e., in this case, a proof)</p>



<a name="266954114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266954114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266954114">(Jan 05 2022 at 16:08)</a>:</h4>
<p>To return to the original question, how would one use this anonymous instance in practice?  My informal interpretation is that we have<br>
proven the general fact that <code>list.append</code> has a left identity element <code>list.nil</code> and so the <code>list</code> class belongs to <code>has_append</code> and also its <code>append</code> method has this property.  Is there a way to see where this might be invoked?</p>



<a name="266954187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266954187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266954187">(Jan 05 2022 at 16:08)</a>:</h4>
<p>In practice the instance should be automatically resolved by type class resolution whenever required.</p>



<a name="266954397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266954397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266954397">(Jan 05 2022 at 16:10)</a>:</h4>
<p>I think he's asking for an example of such "whenever required" context, but it's not clear to me either <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="266954672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266954672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266954672">(Jan 05 2022 at 16:12)</a>:</h4>
<p>Here's a trivial example.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">[]</span> <span class="bp">++</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="o">:=</span><span class="gr">sorry</span><span class="o">,</span>
</code></pre></div>
<p>It seems like this result should be relevant here.</p>



<a name="266954772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266954772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266954772">(Jan 05 2022 at 16:13)</a>:</h4>
<p><code>example : [] ++ [0,1,2] = [0,1,2] := rfl</code> ;-)</p>



<a name="266954855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266954855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266954855">(Jan 05 2022 at 16:14)</a>:</h4>
<p>Which brings me back to the question of what we needed the instance for in the first place.</p>



<a name="266955018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955018">(Jan 05 2022 at 16:15)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">[]</span> <span class="bp">++</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="o">:=</span> <span class="n">is_left_id.left_id</span> <span class="n">_</span>
</code></pre></div>



<a name="266955103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955103">(Jan 05 2022 at 16:16)</a>:</h4>
<p>I think the instance is what allows you to prove <code>[] ++ [0,1,2] = [0,1,2]</code> with <code>rfl</code></p>



<a name="266955127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955127">(Jan 05 2022 at 16:16)</a>:</h4>
<p>no, this just follows from definition of <code>++</code></p>



<a name="266955179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955179">(Jan 05 2022 at 16:16)</a>:</h4>
<p>Oh I take that back!</p>



<a name="266955209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955209">(Jan 05 2022 at 16:16)</a>:</h4>
<p><code>++</code> is not <code>list.append</code>, it's <code>has_append.append</code></p>



<a name="266955466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955466">(Jan 05 2022 at 16:19)</a>:</h4>
<p>Still, the <code>is_left_id</code> instance has nothing to do with it being refl</p>



<a name="266955513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955513">(Jan 05 2022 at 16:19)</a>:</h4>
<p>Yes, we're just using the fact that this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_append</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>
</code></pre></div>



<a name="266955525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955525">(Jan 05 2022 at 16:19)</a>:</h4>
<p>The presence or absence of an instance is never the reason a proof is <code>rfl</code>, unless the instance itself _defines_ the statement you're trying to prove.</p>



<a name="266955655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955655">(Jan 05 2022 at 16:20)</a>:</h4>
<p>How would this instance be invoked then? <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="266955667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955667">(Jan 05 2022 at 16:20)</a>:</h4>
<p>What makes it refl is that it's a concrete list.</p>



<a name="266955717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955717">(Jan 05 2022 at 16:20)</a>:</h4>
<p>Here, <code>((++) : list T -&gt; list T) = list.append := rfl</code> because of the <code>has_append</code> instance. Then <code>list.append [] s = s := rfl</code> by the definition of <code>list.append</code> (as long as I got the order of args right).</p>



<a name="266955753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955753">(Jan 05 2022 at 16:21)</a>:</h4>
<p>For an arbitrary list (by which I mean we don't know how it was built), the lemma won't be refl</p>



<a name="266955769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955769">(Jan 05 2022 at 16:21)</a>:</h4>
<p>How about this  then:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">\</span><span class="k">forall</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="bp">\</span><span class="n">N</span><span class="o">),</span> <span class="o">[]</span> <span class="bp">++</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="n">x</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="n">x</span><span class="o">]:=</span><span class="gr">sorry</span><span class="o">,</span>
</code></pre></div>



<a name="266955783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955783">(Jan 05 2022 at 16:21)</a>:</h4>
<p>Lean is using the existence of <code>list.has_append</code> to make sense of the question, but then the question becomes <code>list.append [] [0,1,2] = [0,1,2]</code> which is definitionally true.</p>



<a name="266955939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266955939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266955939">(Jan 05 2022 at 16:22)</a>:</h4>
<p>We still know how <code>[0, 1, x]</code> was built.</p>



<a name="266956014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266956014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266956014">(Jan 05 2022 at 16:23)</a>:</h4>
<p>What's the question?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">[]</span> <span class="bp">++</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="n">x</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="n">x</span><span class="o">]:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">is_left_id.left_id</span> <span class="n">_</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">[]</span> <span class="bp">++</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="n">x</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="n">x</span><span class="o">]:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span>
</code></pre></div>



<a name="266956105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266956105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266956105">(Jan 05 2022 at 16:24)</a>:</h4>
<p>Here's an example where <code>rfl</code> doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">37</span> <span class="bp">=</span> <span class="mi">37</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="266956129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266956129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266956129">(Jan 05 2022 at 16:24)</a>:</h4>
<p>I think one of the issues here is that <code>is_left_id</code> is maybe a bit of a niche typeclass</p>



<a name="266956162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266956162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266956162">(Jan 05 2022 at 16:25)</a>:</h4>
<p>So seeing where its used isn't so easy</p>



<a name="266956163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266956163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266956163">(Jan 05 2022 at 16:25)</a>:</h4>
<p>But <code>list.append</code> is defined by recursion on the left variable so <code>rfl</code> will always work here</p>



<a name="266956185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266956185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266956185">(Jan 05 2022 at 16:25)</a>:</h4>
<p>The most "practical" use case would probably be to construct more complex algebraic type classses based on it?</p>



<a name="266956652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266956652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266956652">(Jan 05 2022 at 16:29)</a>:</h4>
<p>Yes. Just the same way as when you declare a <code>0</code> on a concrete type. When you're dealing with your <code>concrete_type</code> you can always use the spelling <code>concrete_type.zero</code> instead <code>0</code>. But without the <code>has_zero concrete_type</code> instance you can't use general machinery</p>



<a name="266956830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266956830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266956830">(Jan 05 2022 at 16:30)</a>:</h4>
<p>Feels like I'm gonna be learning the basics of Lean for the next 5 years <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="266957091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266957091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266957091">(Jan 05 2022 at 16:33)</a>:</h4>
<p>Here's a different example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">head</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">[]</span>       <span class="o">:=</span> <span class="n">default</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span>
</code></pre></div>
<p>here <code>head</code> is a function that takes a list and produces the first element of the list.</p>
<p>But what if the list was empty? We want a function from list of alphas to alphas, rather than "alpha or nothing", so one way to do this is to pick once and for all a default element of alpha for each alpha.<br>
Of course this isn't always possible, some types are empty and have no elements after all! But when it is we can define an instance of the inhabited typeclass, which is then inferred automatically whenever <code>head</code> is called.<br>
<code>inhabited</code> has type</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">default</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>so we can make an instance using</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">inst1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">default</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">}</span>
</code></pre></div>
<p>but this is a bit verbose, when we just want to say a number, so this is where anonymous constructors, which are just a shorthand come in:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">inst2</span><span class="o">:</span> <span class="n">inhabited</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">2</span><span class="o">⟩</span>
</code></pre></div>
<p>after defining one of these instances we can check it was inferred automatically by </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">a</span> <span class="o">:</span> <span class="n">list.head</span> <span class="o">[]</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>This example also highlights one of the main stumbling blocks with typeclasses, what if we declare more than one of the same type? In this case this is a bad thing, as then the default value of nat will depend on whichever instance lean happens to choose. So in general we have to pay attention to ensure than all instances with the same type are equal.</p>



<a name="266957299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266957299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266957299">(Jan 05 2022 at 16:35)</a>:</h4>
<p>If we want to give the typeclass argument manually by hand we can do that too, by using <code>@</code> to signal that we want to provide all implicit arguments for example</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">@</span><span class="n">list.head</span> <span class="n">ℕ</span> <span class="n">inst1</span> <span class="o">[]</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="266957376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266957376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266957376">(Jan 05 2022 at 16:35)</a>:</h4>
<p>This is the only time when the name of an instance should really matter, as it is a somewhat rare situation that we need to tell lean the instance by hand</p>



<a name="266958284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266958284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266958284">(Jan 05 2022 at 16:41)</a>:</h4>
<p>In LISP (which I admit I haven't used in 30 years) if you take the <code>car</code> of an empty list you get a <code>nil</code> symbol, but I guess in lean you can't even define the <code>head</code> of a list unless you have some kind of default value of the same type as the list entries, is that right?</p>



<a name="266958405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266958405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266958405">(Jan 05 2022 at 16:41)</a>:</h4>
<p>Right -- else you could take <code>[] : list empty</code> and make an element of the empty type which would let you prove anything</p>



<a name="266959152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266959152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266959152">(Jan 05 2022 at 16:48)</a>:</h4>
<p>Yeah there are other functions like <a href="https://leanprover-community.github.io/mathlib_docs/find/list.nth">docs#list.nth</a> that you can use instead if you want that behaviour</p>



<a name="266959440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266959440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266959440">(Jan 05 2022 at 16:50)</a>:</h4>
<p>Maybe this is too vague, but suppose you want to write a Lean function that takes a string that represents a computation in postfix notation, and return the value of the expression. You'd typically use a stack.  I'm trying visualize what this might look like in lean.  Is there something like this out there to look at?</p>



<a name="266959711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266959711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266959711">(Jan 05 2022 at 16:52)</a>:</h4>
<p>On the earlier point: <br>
<span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/anonymous.20instance.3F/near/266959152">said</a>:</p>
<blockquote>
<p>Yeah there are other functions like <a href="https://leanprover-community.github.io/mathlib_docs/find/list.nth">docs#list.nth</a> that you can use instead if you want that behaviour</p>
</blockquote>
<p>So in that case you are extending the type of elements of the list to allow for a <code>none</code> symbol or whatever <code>option \alpha</code> has.</p>



<a name="266959764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266959764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266959764">(Jan 05 2022 at 16:53)</a>:</h4>
<p>You're only extending the type of the output to allow <code>none</code> but yes.</p>



<a name="266967464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266967464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266967464">(Jan 05 2022 at 17:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="462625">Jeremy Teitelbaum</span> <a href="#narrow/stream/113489-new-members/topic/anonymous.20instance.3F/near/266959440">said</a>:</p>
<blockquote>
<p>Maybe this is too vague, but suppose you want to write a Lean function that takes a string that represents a computation in postfix notation, and return the value of the expression. You'd typically use a stack.  I'm trying visualize what this might look like in lean.  Is there something like this out there to look at?</p>
</blockquote>
<p>Fun exercise! Here is how I would code it, note that this looks a bit different to the process of proving mathematical results in lean, but there is a lot of overlap still such as in using the equation compiler to make definitions specifying outputs corresponding to matching inputs, hope it helps!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list.basic</span>
<span class="kn">import</span> <span class="n">data.int.basic</span>

<span class="c1">-- following this outline from: https://www.geeksforgeeks.org/stack-set-4-evaluation-postfix-expression/</span>
<span class="c1">-- 1) Create a stack to store operands (or values).</span>
<span class="c1">-- 2) Scan the given expression and do the following for every scanned element.</span>
<span class="c1">-- …..a) If the element is a number, push it into the stack</span>
<span class="c1">-- …..b) If the element is an operator, pop operands for the operator from the stack. Evaluate the operator and push the result back to the stack</span>
<span class="c1">-- 3) When the expression is ended, the number in the stack is the final answer</span>

<span class="c1">-- this is a language of tokenised terms we will use, we do this because pattern matching on strings</span>
<span class="c1">-- isn't so nice in lean (roughly because strings are list of characters, which are given by nats</span>
<span class="c1">-- representing their ascii numeral)</span>
<span class="kd">inductive</span> <span class="n">postfix_lang</span>
<span class="bp">|</span> <span class="n">add</span> <span class="o">:</span> <span class="n">postfix_lang</span>
<span class="bp">|</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">postfix_lang</span>
<span class="bp">|</span> <span class="n">mul</span> <span class="o">:</span> <span class="n">postfix_lang</span>
<span class="bp">|</span> <span class="n">nat</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">postfix_lang</span>

<span class="kn">open</span> <span class="n">postfix_lang</span>

<span class="c1">-- now we can make elements of this type like so</span>
<span class="k">#check</span> <span class="n">postfix_lang.add</span>
<span class="k">#check</span> <span class="n">postfix_lang.sub</span>
<span class="k">#check</span> <span class="n">postfix_lang.nat</span> <span class="mi">2</span>
<span class="c1">-- every element is either one of these symbols or a natural number</span>

<span class="c1">-- converts a string token, either + - or * into the postfix lang</span>
<span class="kd">def</span> <span class="n">of_string</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">postfix_lang</span>
<span class="bp">|</span> <span class="s2">"+"</span> <span class="o">:=</span> <span class="n">add</span>
<span class="bp">|</span> <span class="s2">"-"</span> <span class="o">:=</span> <span class="n">sub</span>
<span class="bp">|</span> <span class="s2">"*"</span> <span class="o">:=</span> <span class="n">mul</span>
<span class="bp">|</span> <span class="n">s</span>   <span class="o">:=</span> <span class="n">nat</span> <span class="o">(</span><span class="n">string.to_nat</span> <span class="n">s</span><span class="o">)</span> <span class="c1">-- anything that doesn't match the above gets converted to a nat</span>

<span class="c1">-- the core of the algorithm, a recursive function that takes a list of tokens and stack of integers</span>
<span class="c1">-- so far and returns the new stack</span>
<span class="kd">def</span> <span class="n">eval_postfix_aux</span> <span class="o">:</span> <span class="n">list</span> <span class="n">postfix_lang</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℤ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℤ</span>
<span class="c1">-- the next token is an add so we take the first two elements of the stack, add them and put it</span>
<span class="c1">-- back on the rest of the stack, and recurse with the remaining tokens and that stack</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">add</span> <span class="o">::</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eval_postfix_aux</span> <span class="n">r</span> <span class="o">((</span><span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">sub</span> <span class="o">::</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eval_postfix_aux</span> <span class="n">r</span> <span class="o">((</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mul</span> <span class="o">::</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eval_postfix_aux</span> <span class="n">r</span> <span class="o">((</span><span class="n">b</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>
<span class="c1">-- the next token is the natural number `n` so we put `n` on the stack (it is implicitly converted</span>
<span class="c1">-- to an integer)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat</span> <span class="n">n</span> <span class="o">::</span> <span class="n">r</span><span class="o">)</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">eval_postfix_aux</span> <span class="n">r</span> <span class="o">(</span><span class="n">n</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">s</span> <span class="c1">-- if there are no operations left stop recursing and return the stack as is</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="o">[]</span> <span class="c1">-- if we see anything else there is probably a mistake</span>

<span class="c1">-- we can call this directly on a list of postfix_langs like so</span>
<span class="k">#eval</span> <span class="n">eval_postfix_aux</span> <span class="o">[</span><span class="n">nat</span> <span class="mi">2</span><span class="o">,</span> <span class="n">nat</span> <span class="mi">3</span><span class="o">,</span> <span class="n">nat</span> <span class="mi">1</span><span class="o">,</span> <span class="n">mul</span><span class="o">,</span> <span class="n">add</span><span class="o">,</span> <span class="n">nat</span> <span class="mi">9</span><span class="o">,</span> <span class="n">sub</span><span class="o">]</span> <span class="o">[]</span>
<span class="k">#eval</span> <span class="n">eval_postfix_aux</span> <span class="o">[</span><span class="n">nat</span> <span class="mi">2</span><span class="o">,</span> <span class="n">nat</span> <span class="mi">3</span><span class="o">,</span> <span class="n">nat</span> <span class="mi">1</span><span class="o">,</span> <span class="n">mul</span><span class="o">,</span> <span class="n">add</span><span class="o">,</span> <span class="n">nat</span> <span class="mi">9</span><span class="o">,</span> <span class="n">sub</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="c1">-- starting with a nonempty stack</span>
<span class="k">#eval</span> <span class="n">eval_postfix_aux</span> <span class="o">[</span><span class="n">nat</span> <span class="mi">2</span><span class="o">,</span> <span class="n">nat</span> <span class="mi">3</span><span class="o">,</span> <span class="n">nat</span> <span class="mi">1</span><span class="o">,</span> <span class="n">mul</span><span class="o">,</span> <span class="n">add</span><span class="o">,</span> <span class="n">nat</span> <span class="mi">9</span><span class="o">,</span> <span class="n">sub</span><span class="o">,</span> <span class="n">sub</span><span class="o">]</span> <span class="o">[]</span> <span class="c1">-- nonsense case</span>

<span class="c1">-- but you asked for a function from strings to evaluations, we can do this like so:</span>
<span class="c1">-- call the above algorithm on a string by tokenising, running eval_postfix_aux and then taking the</span>
<span class="c1">-- head of the resulting list</span>
<span class="kd">def</span> <span class="n">eval_postfix</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">eval_postfix_aux</span> <span class="o">((</span><span class="n">s.split_on</span> <span class="sc">' '</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">of_string</span><span class="o">)</span> <span class="o">[])</span><span class="bp">.</span><span class="n">head</span>

<span class="k">#eval</span> <span class="n">eval_postfix</span> <span class="s2">"2 3 1 * + 9 -"</span>
<span class="k">#eval</span> <span class="n">eval_postfix</span> <span class="s2">"2 3 1 * + 9 - 7 +"</span>

<span class="c1">-- we get zero if we do nonesense</span>
<span class="k">#eval</span> <span class="n">eval_postfix</span> <span class="s2">"2 3 1 * + 9 - - - -"</span>
</code></pre></div>



<a name="266971583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266971583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266971583">(Jan 05 2022 at 18:27)</a>:</h4>
<p>This is fantastic, thanks!!!! <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span> <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span> <span aria-label="octopus" class="emoji emoji-1f419" role="img" title="octopus">:octopus:</span></p>



<a name="266971764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266971764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266971764">(Jan 05 2022 at 18:28)</a>:</h4>
<p>Regarding <a href="https://leanprover-community.github.io/mathlib_docs/find/is_left_id">docs#is_left_id</a> (and the entire file it resides in), it's part of a major refactor of the algebraic typeclasses that was abandoned long ago. See the github link at the top of the page.</p>



<a name="266971920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266971920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266971920">(Jan 05 2022 at 18:29)</a>:</h4>
<p>So the answer to "what's the instance useful for" is "not much because those typeclasses never replaced things like <code>monoid</code>"</p>



<a name="266972954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266972954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266972954">(Jan 05 2022 at 18:37)</a>:</h4>
<p>So much for reading the middle of source code files.</p>



<a name="266985089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266985089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266985089">(Jan 05 2022 at 20:14)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span>  following up on your parser, what about the following?<br>
In general terms, we have the type of <code>list postfix_lang</code> that you've described.  Then some of these are "well-formed" in the sense<br>
that they evaluate to a number. This gives a predicate on <code>list postfix_lang</code> which is decidable (via your algorithm).  Would such an approach make sense?</p>
<p>I'm not trying to give you homework, so if you think it's reasonable I can try to do it for <em>my</em> homework.</p>



<a name="266987674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266987674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266987674">(Jan 05 2022 at 20:35)</a>:</h4>
<p>You could definitely define that predicate, either by counting number of operations vs number of nats in the list, or just asserting that <code>eval_postfix_aux</code> doesn't return <code>[]</code> I guess, hopefully one can prove they are equivalent. And it should be provable that it is a <a href="https://leanprover-community.github.io/mathlib_docs/find/decidable_pred">docs#decidable_pred</a>.</p>



<a name="266987901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266987901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Teitelbaum <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266987901">(Jan 05 2022 at 20:37)</a>:</h4>
<p>OK, this gives me something concrete to think about, thanks for the help!</p>



<a name="266988914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/anonymous%20instance%3F/near/266988914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/anonymous.20instance.3F.html#266988914">(Jan 05 2022 at 20:47)</a>:</h4>
<p>Hmm I guess "counting" was a bit over-simple, and the condition is something like there are always at least 1 more number than operation in every prefix of the list?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
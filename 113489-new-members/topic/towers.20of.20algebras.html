---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/towers.20of.20algebras.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html">towers of algebras</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="238449402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238449402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238449402">(May 12 2021 at 10:02)</a>:</h4>
<p>I think I could need some guidance of how Lean automatically finds -- or doesn't -- some implicit arguments.<br>
With the following variables</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.integral_closure</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">]</span>
</code></pre></div>
<p>it is true that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>-algebra by combining the intermediate algebra maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi mathvariant="normal">Frac</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">A \to \operatorname{Frac}(A) \to L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">Frac</span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> and I can certainly state this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">my_comp_of_algebras</span><span class="o">:</span> <span class="n">algebra</span> <span class="n">A</span> <span class="n">L</span><span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">ring_hom.to_algebra</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)),</span>
<span class="kd">end</span>
</code></pre></div>
<p>But if I state other results, it doesn't automatically find the instance <code>algebra A L</code> (is 'instance' the correct terminology?):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span><span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>(says <code>failed to synthesize type class instance for algebra A L</code>)</p>
<ul>
<li>attempt 1: I thought the thing labelled as <code>def</code> could be labelled as <code>instance</code> to fix this, but I seem to be misunderstanding instances as this leads to timeout errors.</li>
<li>attempt 2: Then I thought I would have to add <code>{algebra A L}</code> or <code>[algebra A L]</code> to the preamble. From the former I hoped it would create it automatically, which it didn't, the latter works, but I have the feeling it just adds another <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>-algebra structure on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> instead of using the combined structure above, i.e. I can't show then that <code>algebra A L = my_comp_of_algebras</code>. <br>
<code>example [algebra A L]: algebra (integral_closure A (fraction_ring A)) (integral_closure A L) := sorry</code></li>
</ul>
<p><em>Could somebody please give me a hint on what I didn't understand yet and how to do this? Thank you for the help!</em></p>
<p>PS: Ultimately I am trying to get algebra maps (or just a linear map) <code>A → (integral_closure A (fraction_field A)) → (integral_closure A L)</code> and then split them (there's also more conditions, like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> being normal and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> being finite extension of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Frac</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Frac}(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">Frac</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>, but I thought they are irrelevant here).</p>



<a name="238449696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238449696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238449696">(May 12 2021 at 10:05)</a>:</h4>
<p>Good questions! I have had similar struggles before, so let me take a look...</p>



<a name="238449811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238449811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238449811">(May 12 2021 at 10:06)</a>:</h4>
<p>My guess would be that mathlib can infer <code>algebra (fraction_ring A) L</code> from <code>algebra A L</code>but not vice versa (assuming that's something that mathematically is possible)</p>



<a name="238449847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238449847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238449847">(May 12 2021 at 10:06)</a>:</h4>
<p>Typeclass inference is used to build structures on complex objects out of structures on simpler ones</p>



<a name="238449877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238449877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238449877">(May 12 2021 at 10:07)</a>:</h4>
<p>It's not allowed to go in both directions, as it can't handle loops</p>



<a name="238450032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238450032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238450032">(May 12 2021 at 10:08)</a>:</h4>
<blockquote>
<p>But if I state other results, it doesn't automatically find the instance algebra A L (is 'instance' the correct terminology?):</p>
</blockquote>
<p>(<code>instance</code> is indeed the correct word here!) You're getting a missing instance error here because the typeclass system is only aware of declarations marked as instance, as you correctly tried to fix by replacing <code>def</code> with <code>instance</code>.</p>



<a name="238450361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238450361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238450361">(May 12 2021 at 10:11)</a>:</h4>
<p>However, an instance of the form <code>my_comp_of_algebras [algebra (fraction_ring A) L] : algebra A L</code> cannot work automatically. This is because type class inference performs its search as follows:</p>
<ul>
<li>need to find instance <code>algebra A L</code></li>
<li>try to apply <code>my_comp_of_algebras</code><ul>
<li>need to find instance <code>algebra (fraction_ring A) L</code></li>
<li>try to apply <code>my_comp_of_algebras</code><ul>
<li>need to find instance <code>algebra (fraction_ring (fraction_ring A)) L</code></li>
<li>try to apply <code>my_comp_of_algebras</code><ul>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>



<a name="238450783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238450783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238450783">(May 12 2021 at 10:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238449811">said</a>:</p>
<blockquote>
<p>My guess would be that mathlib can infer <code>algebra (fraction_ring A) L</code> from <code>algebra A L</code>but not vice versa (assuming that's something that mathematically is possible)</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238450361">said</a>:</p>
<blockquote>
<p>However, an instance of the form <code>my_comp_of_algebras [algebra (fraction_ring A) L] : algebra A L</code> cannot work automatically. This is because type class inference performs its search as follows:</p>
<ul>
<li>need to find instance <code>algebra A L</code></li>
<li>try to apply <code>my_comp_of_algebras</code><ul>
<li>need to find instance <code>algebra (fraction_ring A) L</code></li>
<li>try to apply <code>my_comp_of_algebras</code><ul>
<li>need to find instance <code>algebra (fraction_ring (fraction_ring A)) L</code></li>
<li>try to apply <code>my_comp_of_algebras</code><ul>
<li>...<br>
Oh I see the looping problem involved here.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>



<a name="238450808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238450808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238450808">(May 12 2021 at 10:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238449811">said</a>:</p>
<blockquote>
<p>My guess would be that mathlib can infer <code>algebra (fraction_ring A) L</code> from <code>algebra A L</code>but not vice versa (assuming that's something that mathematically is possible)</p>
</blockquote>
<p>why is that?</p>



<a name="238450821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238450821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238450821">(May 12 2021 at 10:16)</a>:</h4>
<p>Your solution is also on the right track: we can introduce a new <code>algebra</code> instance parameter, then try to show that this is indeed the correct one. I'm not completely sure whether this is always the case (would it follow from the universal property of <code>fraction_ring</code>?), but we can simply postulate that this holds:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.integral_closure</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>  <span class="o">[</span><span class="n">algebra</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">my_comp_of_algebras</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">A</span> <span class="n">L</span><span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">refine</span> <span class="n">ring_hom.to_algebra</span> <span class="n">_</span><span class="o">,</span>
<span class="n">exact</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)),</span>
<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">A</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="n">A</span> <span class="n">L</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_scalar_tower.algebra_map_eq</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
</code></pre></div>



<a name="238450951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238450951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238450951">(May 12 2021 at 10:18)</a>:</h4>
<p>Eric, there's an algebra map from <code>A</code> to <code>fraction_ring A</code>, not the other way. So mathematically going from <code>algebra (fraction_ring A) L</code> to <code>algebra A L</code> is the correct direction</p>



<a name="238451074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238451074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238451074">(May 12 2021 at 10:19)</a>:</h4>
<p>(Fixed the example, sorry. I should run my code before posting it! :P)</p>



<a name="238451475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238451475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238451475">(May 12 2021 at 10:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238450821">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">A</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">]</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I did use <code>is_scalar_tower</code> at some point before, but hesitated on using too many conditions that seem to follow automatic from a maths perspective. In that case I just throw in a couple of them, thank you!</p>



<a name="238451696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238451696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238451696">(May 12 2021 at 10:25)</a>:</h4>
<p>Can I also ask you about integral closure <span class="user-mention" data-user-id="238446">@Anne Baanen</span> ? I found this <code>[integrally_closed: integral_closure A (fraction_ring A) = ⊥]</code> but I can't really use it. I don't have a MWE ready but essentially I want to say that I get a map <code>integral_closure A (fraction_ring A) →+* A</code> which is a bijection...</p>



<a name="238451859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238451859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238451859">(May 12 2021 at 10:27)</a>:</h4>
<p>I agree with Anne's snippet, the way to set this up is indeed <code> [algebra A L] [algebra (fraction_ring A) L] [is_scalar_tower A (fraction_ring A) L]</code>, as lean already provides <a href="https://leanprover-community.github.io/mathlib_docs/find/fraction_ring.algebra">docs#fraction_ring.algebra</a></p>



<a name="238451903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238451903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238451903">(May 12 2021 at 10:27)</a>:</h4>
<p>thanks!</p>



<a name="238451915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238451915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238451915">(May 12 2021 at 10:27)</a>:</h4>
<p>I think you want something like <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.bot_equiv_of_injective">docs#algebra.bot_equiv_of_injective</a></p>



<a name="238452044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452044">(May 12 2021 at 10:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238451915">said</a>:</p>
<blockquote>
<p>I think you want something like <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.bot_equiv_of_injective">docs#algebra.bot_equiv_of_injective</a></p>
</blockquote>
<p>Looks like it, didn't see that before. Thanks for the help</p>



<a name="238452076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452076">(May 12 2021 at 10:29)</a>:</h4>
<p>I can't find anything that says that there's an equivalence between two equal subalgebras, which would give you your exact statement.</p>



<a name="238452090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452090">(May 12 2021 at 10:29)</a>:</h4>
<p>Let me see if I can build it easily...</p>



<a name="238452132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452132">(May 12 2021 at 10:30)</a>:</h4>
<p>If the subalgebras are equal then that's presumably just something like <code>h \t alg_equiv.id</code>?</p>



<a name="238452219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452219">(May 12 2021 at 10:30)</a>:</h4>
<p><del>Do</del> we have that definition for other structures<del>?</del>: <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_equiv.of_eq">docs#linear_equiv.of_eq</a> <del>maybe</del> exists<del>?</del></p>



<a name="238452635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452635">(May 12 2021 at 10:34)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Two subalgebras that are equal are also equivalent as algebras. -/</span>
<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">equiv_of_eq</span> <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">T</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span> <span class="bp">▸</span> <span class="n">x.2</span><span class="o">⟩,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h.symm</span> <span class="bp">▸</span> <span class="n">x.2</span><span class="o">⟩,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">commutes'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">linear_equiv.of_eq</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">to_submodule</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="238452708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452708">(May 12 2021 at 10:35)</a>:</h4>
<p><code>h \t alg_equiv.refl S</code> doesn't work (looks like because it's not smart enough to see that only one <code>S</code> should become a <code>T</code>)</p>



<a name="238452758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452758">(May 12 2021 at 10:35)</a>:</h4>
<p>What you have is better definitionally anyway</p>



<a name="238452854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452854">(May 12 2021 at 10:36)</a>:</h4>
<p>I'd recommend <code>simps apply</code> and a manual lemma though, to match <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_equiv.of_eq_symm">docs#linear_equiv.of_eq_symm</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">of_eq_symm</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">of_eq</span> <span class="n">p</span> <span class="n">q</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">of_eq</span> <span class="n">q</span> <span class="n">p</span> <span class="n">h.symm</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="238452880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452880">(May 12 2021 at 10:36)</a>:</h4>
<p>Hmm, should it be called <code>subalgebra.equiv_of_eq</code> or <code>alg_equiv.of_eq</code>?</p>



<a name="238452902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238452902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238452902">(May 12 2021 at 10:37)</a>:</h4>
<p>(The latter might not work so well with <code>intermediate_field</code>)</p>



<a name="238453050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238453050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238453050">(May 12 2021 at 10:38)</a>:</h4>
<p>The latter is consistent with linear_equiv.of_eq</p>



<a name="238453058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238453058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238453058">(May 12 2021 at 10:39)</a>:</h4>
<p>We already have duplicate names in this space; <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.set_congr">docs#equiv.set_congr</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.set.of_eq">docs#equiv.set.of_eq</a> are the same definition</p>



<a name="238453351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238453351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238453351">(May 12 2021 at 10:42)</a>:</h4>
<p>I'll go with the former since there's not a lot of consensus, and maybe we want to make the same definition <code>intermediate_field</code> (where the appropriate equiv is still <code>alg_equiv</code>, which would cause name collisions).</p>



<a name="238453510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238453510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238453510">(May 12 2021 at 10:44)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7590">#7590</a></p>



<a name="238453930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238453930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238453930">(May 12 2021 at 10:48)</a>:</h4>
<p>So that means I can just update mathlib in my project once that has been accepted and it'll be in there? That is amazing :D</p>



<a name="238454183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238454183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238454183">(May 12 2021 at 10:51)</a>:</h4>
<p>If everything goes well and the PR gets accepted, yes :) If you are impatient, you should be able to copy-paste the definitions into your own project:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Two subalgebras that are equal are also equivalent as algebras.</span>
<span class="sd">This is the `subalgebra` version of `linear_equiv.of_eq` and `equiv.set.of_eq`. -/</span>
<span class="kd">@[simps apply]</span>
<span class="kd">def</span> <span class="n">equiv_of_eq</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">T</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span> <span class="bp">▸</span> <span class="n">x.2</span><span class="o">⟩,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h.symm</span> <span class="bp">▸</span> <span class="n">x.2</span><span class="o">⟩,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">commutes'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">linear_equiv.of_eq</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">to_submodule</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">equiv_of_eq_symm</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">equiv_of_eq</span> <span class="n">S</span> <span class="n">T</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">equiv_of_eq</span> <span class="n">T</span> <span class="n">S</span> <span class="n">h.symm</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>



<a name="238461897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238461897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238461897">(May 12 2021 at 12:02)</a>:</h4>
<p>Just to note that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>-algebra then even if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> is a field it might not be an algebra for the field of fractions for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, e.g. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mn>37</mn><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z/37\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/37</span><span class="mord mathbb">Z</span></span></span></span> is an algebra for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span> but cannot be given the structure of an algebra for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord mathbb">Q</span></span></span></span>.</p>



<a name="238462257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238462257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238462257">(May 12 2021 at 12:05)</a>:</h4>
<p>is there any conditions that allow it to be such?</p>



<a name="238462760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238462760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238462760">(May 12 2021 at 12:09)</a>:</h4>
<p>Not 100% sure, but I suppose it's exactly when the algebra map from <code>A</code> to <code>L</code> maps every nonzero element of <code>A</code> to a unit in <code>L</code>, by the universal property of the localization.</p>



<a name="238463764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238463764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238463764">(May 12 2021 at 12:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238461897">said</a>:</p>
<blockquote>
<p>Just to note that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>-algebra then even if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> is a field it might not be an algebra for the field of fractions for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, e.g. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mn>37</mn><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z/37\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/37</span><span class="mord mathbb">Z</span></span></span></span> is an algebra for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span> but cannot be given the structure of an algebra for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord mathbb">Q</span></span></span></span>.</p>
</blockquote>
<p>Good point. I realised I don't actually need this map to be an algebra map/linear map, I only need to look at the composite of multiple maps.</p>



<a name="238464448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238464448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238464448">(May 12 2021 at 12:25)</a>:</h4>
<p>Also, everything in my project is in equal characteristics (0,0), i.e. when you have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi><mo>⊂</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathbb{Q} \subset A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord mathbb">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span></p>



<a name="238464665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238464665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238464665">(May 12 2021 at 12:26)</a>:</h4>
<p>that doesn't fix the maths problem, there are char 0 counterexamples, but this is not the point -- the answer to your question is this <code>is_scalar_tower</code> class. It's a bit of an adjustment coming from maths on paper to maths in Lean's type theory, you need to pick up a few basic tricks and this is one.</p>



<a name="238464964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238464964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238464964">(May 12 2021 at 12:29)</a>:</h4>
<p>But it helps realising that certain things are wrong (and you don't even need them), so thanks for the comment! It's so easy to get lost in the code and try to proof things that don't hold</p>



<a name="238474997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238474997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238474997">(May 12 2021 at 13:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238454183">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simps apply]</span>
<span class="kd">def</span> <span class="n">equiv_of_eq</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">T</span> <span class="o">:=</span>
<span class="bp">...</span>
</code></pre></div><br>
</p>
</blockquote>
<p>After putting that in I am left with two small conversion problems, which I unfortunately don't think I can solve with my own understanding.</p>
<p>I want to take an integral element in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>:</mo><mo>=</mo><mi mathvariant="normal">Frac</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K:=\operatorname{Frac}(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">Frac</span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> and say that it is actually in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>. (we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> integrally closed.)</p>
<p><em>(For context that would help me to manually define then a function <code>(integral_closure A L) →ₗ[A] A</code> and manually check the <code>map_add'</code> and <code>map_smul'</code> conditions.)</em></p>
<p>Here are the steps I tried, the two I am stuck on are</p>
<p>1) going from <code>is_integral A x</code> to <code>x:integral_closure A K</code> (where <code>x:K</code>) and <br>
2) going from <code>z:↑⊥</code> to <code>z:A</code> (I think <code>↑⊥</code> is a <code>subalgebra A K</code>).</p>
<p>Moreover, is there better syntax for working on this? I am just treating it as if it was a <code>Prop</code> statement, which works but I think some tactics like <code>library_search</code> or <code>hint</code> don't like constructions like this...</p>
<p>Thank you once more for the help!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.integral_closure</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>  <span class="o">[</span><span class="n">algebra</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">restrict_to_A</span>  <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="o">[</span><span class="n">is_integral</span> <span class="n">A</span> <span class="n">x</span><span class="o">][</span><span class="n">integrally_closed</span><span class="o">:</span> <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">]:</span> <span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">y</span><span class="o">:</span> <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- that should be a straight forward conversion I haven't found yet.</span>
  <span class="n">replace</span> <span class="n">integrally_closed</span> <span class="o">:=</span> <span class="n">equiv_of_eq</span> <span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="bp">⊥</span> <span class="n">integrally_closed</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">integrally_closed.to_fun</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">y'</span><span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- I expect a conversion from elements in `↑⊥: subalgebra A (fraction_field A)` to elements of `A`.</span>
  <span class="n">use</span> <span class="n">y'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="238478485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238478485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238478485">(May 12 2021 at 14:02)</a>:</h4>
<p>Does the following help?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">integral_closure.mk</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span>
</code></pre></div>



<a name="238479350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238479350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238479350">(May 12 2021 at 14:07)</a>:</h4>
<p><span class="user-mention" data-user-id="385895">@Jon Eugster</span> I get an error on <code>equiv_of_eq</code> if I paste your code into VS Code.</p>



<a name="238479639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238479639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238479639">(May 12 2021 at 14:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238479350">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="385895">Jon Eugster</span> I get an error on <code>equiv_of_eq</code> if I paste your code into VS Code.</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simps apply]</span>
<span class="kd">def</span> <span class="n">equiv_of_eq</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">T</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span> <span class="bp">▸</span> <span class="n">x.2</span><span class="o">⟩,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h.symm</span> <span class="bp">▸</span> <span class="n">x.2</span><span class="o">⟩,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">commutes'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">linear_equiv.of_eq</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">subalgebra.to_submodule</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>
<p>There's a <code>subalgebra.to_submodule</code> in the proof that needs to be adjusted from what Anne wrote</p>



<a name="238479754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238479754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238479754">(May 12 2021 at 14:10)</a>:</h4>
<p>Can you post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>? Edit your original post</p>



<a name="238479895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238479895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238479895">(May 12 2021 at 14:10)</a>:</h4>
<p>This is what I have in my file:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.integral_closure</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>  <span class="o">[</span><span class="n">algebra</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">]</span>

<span class="kd">@[simps apply]</span>
<span class="kd">def</span> <span class="n">equiv_of_eq</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">T</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span> <span class="bp">▸</span> <span class="n">x.2</span><span class="o">⟩,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h.symm</span> <span class="bp">▸</span> <span class="n">x.2</span><span class="o">⟩,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">commutes'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">linear_equiv.of_eq</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">subalgebra.to_submodule</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">equiv_of_eq_symm</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">equiv_of_eq</span> <span class="n">S</span> <span class="n">T</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">equiv_of_eq</span> <span class="n">T</span> <span class="n">S</span> <span class="n">h.symm</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="k">#check</span> <span class="o">(</span><span class="bp">⊥</span><span class="o">:</span> <span class="n">subalgebra</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span>
<span class="kd">def</span> <span class="n">restrict_to_A</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="o">[</span><span class="n">is_integral</span> <span class="n">A</span> <span class="n">x</span><span class="o">][</span><span class="n">integrally_closed</span><span class="o">:</span> <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">]:</span> <span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">y</span><span class="o">:</span> <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- that should be a straight forward conversion I haven't found yet.</span>
  <span class="n">replace</span> <span class="n">integrally_closed</span> <span class="o">:=</span> <span class="n">equiv_of_eq</span> <span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="bp">⊥</span> <span class="n">integrally_closed</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">integrally_closed.to_fun</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">y'</span><span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- I expect a conversion from elements in `↑⊥: subalgebra A (fraction_field A)` to elements of `A`.</span>
  <span class="n">use</span> <span class="n">y'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="238480621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238480621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238480621">(May 12 2021 at 14:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238478485">said</a>:</p>
<blockquote>
<p>Does the following help?</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">integral_closure.mk</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Yes, that seems to be the first <code>sorry</code>,  thank you! The <code>⟨  ⟩</code> is still very mysterious to me</p>



<a name="238480847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238480847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238480847">(May 12 2021 at 14:17)</a>:</h4>
<p>If you want to understand <code>⟨  ⟩</code>, replace it with <code>{! !}</code>, click the lightbulb in vscode and "generate structure under consideration" or similar</p>



<a name="238480967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238480967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238480967">(May 12 2021 at 14:18)</a>:</h4>
<p>In your case it will expand to <code>{ val := _, property := _ }</code>.  So on this line, <code>⟨x, hx⟩</code> is just short for <code>{ val := x, property := hx }</code></p>



<a name="238481100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238481100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238481100">(May 12 2021 at 14:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238480847">said</a>:</p>
<blockquote>
<p>If you want to understand <code>⟨  ⟩</code>, replace it with <code>{! !}</code>, click the lightbulb in vscode and "generate structure under consideration" or similar</p>
</blockquote>
<p>oh that's neat!</p>



<a name="238481208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238481208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238481208">(May 12 2021 at 14:19)</a>:</h4>
<p>Another way to think of <code>⟨  ⟩</code> is as it being like a term-mode version of the <code>split</code> or <code>constructor</code> tactic</p>



<a name="238485217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238485217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238485217">(May 12 2021 at 14:42)</a>:</h4>
<p>Updated MWE on what's still left from my original question.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.integral_closure</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>  <span class="o">[</span><span class="n">algebra</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">]</span>

<span class="c1">-- I expect a conversion from elements in `↑⊥: subalgebra A (fraction_field A)` to elements of `A`.</span>
<span class="kd">def</span> <span class="n">my_mk</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span> <span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="bp">⊥</span><span class="o">:</span><span class="n">subalgebra</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))]:</span>
  <span class="n">A</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="238485628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238485628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238485628">(May 12 2021 at 14:44)</a>:</h4>
<p>A comment: <code>[my hypothesis]</code> should be really used only for things that the typeclass search can use, like <code>[group G]</code> <code>[field K]</code> <code>[algebra A L]</code></p>



<a name="238485765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238485765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238485765">(May 12 2021 at 14:44)</a>:</h4>
<p>so <code>(...)</code> for everything else?</p>



<a name="238485796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238485796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238485796">(May 12 2021 at 14:45)</a>:</h4>
<p>And a <code>≃ₐ[A]</code> is not actually a lemma, it is a <code>def</code>, it is a bundled combination of a function and its reverse and all of the proofs saying that it is an equivalence of algebras</p>



<a name="238486677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238486677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238486677">(May 12 2021 at 14:49)</a>:</h4>
<p>I think somehow <code>subalgebra.bot_equiv</code> should help here</p>



<a name="238486740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238486740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238486740">(May 12 2021 at 14:49)</a>:</h4>
<p>Using <code>alg_equiv.trans</code>. Basically, you compose several "canonical isomorphisms"</p>



<a name="238488707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238488707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238488707">(May 12 2021 at 15:01)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> I think I managed to use the two statements you mentioned to get the desired result!</p>



<a name="238488732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238488732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238488732">(May 12 2021 at 15:02)</a>:</h4>
<p>Can you share?</p>



<a name="238490292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238490292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238490292">(May 12 2021 at 15:10)</a>:</h4>
<p>yep, give me a second to clean it up</p>



<a name="238492410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238492410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238492410">(May 12 2021 at 15:23)</a>:</h4>
<p>Still a big mess, but here's roughly how all the help can be combined to get that an integral element in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Frac</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Frac}(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">Frac</span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> actually<br>
lies in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.integral_closure</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>
<span class="kn">import</span> <span class="n">algebra.algebra.subalgebra</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">K</span> <span class="n">L</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span>  <span class="o">[</span><span class="n">algebra</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="n">L</span><span class="o">]</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">integrally_closed</span><span class="o">:</span> <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span>

<span class="c1">-- Anne PRed this into mathlib, can be removed later.</span>
<span class="kd">@[simps apply]</span>
<span class="kd">def</span> <span class="n">equiv_of_eq</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="n">T</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">T</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h</span> <span class="bp">▸</span> <span class="n">x.2</span><span class="o">⟩,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">h.symm</span> <span class="bp">▸</span> <span class="n">x.2</span><span class="o">⟩,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">commutes'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">linear_equiv.of_eq</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">subalgebra.to_submodule</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>


<span class="c1">-- Thx Yakov Perchersky</span>
<span class="kd">def</span> <span class="n">integral_closure.mk</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="c1">--- {!   !} is useful!</span>


<span class="c1">-- assuming `A` is integrally closed in it's fraction field, this</span>
<span class="c1">-- is the corresponding equivalence of algebras</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">canoncial_equiv</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))):</span>
<span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">alg_equiv.trans</span> <span class="o">(</span><span class="n">equiv_of_eq</span> <span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="bp">⊥</span> <span class="n">integrally_closed</span><span class="o">)</span> <span class="o">(</span><span class="n">algebra.bot_equiv_of_injective</span> <span class="n">h</span><span class="o">)</span>


<span class="c1">-- This is how we can get an element in `A` from an integral element in `fraction_ring A`.</span>
<span class="c1">-- Injectivity should be deducable from something, `A: integral_domain`?</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">restriction_to_A</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="o">[</span><span class="n">h</span><span class="o">:</span><span class="n">is_integral</span> <span class="n">A</span> <span class="n">x</span><span class="o">]</span> <span class="o">(</span><span class="n">h'</span><span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)))</span>
<span class="o">(</span><span class="n">integrally_closed</span><span class="o">:</span> <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span>
<span class="o">:</span> <span class="n">A</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">y</span><span class="o">:</span> <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">integral_closure.mk</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">z</span> <span class="o">:=</span> <span class="o">(</span><span class="n">canoncial_equiv</span> <span class="n">integrally_closed</span> <span class="n">h'</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">z</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="238494043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238494043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238494043">(May 12 2021 at 15:32)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Thx Yakov Pechersky -- (only 1 `r`)</span>
<span class="kd">def</span> <span class="n">integral_closure.mk</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="c1">--- {!   !} is useful!</span>


<span class="c1">-- assuming `A` is integrally closed in it's fraction field, this</span>
<span class="c1">-- is the corresponding equivalence of algebras</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">canonical_equiv</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))):</span>
  <span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">equiv_of_eq</span> <span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="bp">⊥</span> <span class="n">integrally_closed</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span>
  <span class="o">(</span><span class="n">algebra.bot_equiv_of_injective</span> <span class="n">h</span><span class="o">)</span>


<span class="c1">-- This is how we can get an element in `A` from an integral element in `fraction_ring A`.</span>
<span class="c1">-- Injectivity should be deducable from something, `A : integral_domain`?</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">restriction_to_A</span> <span class="o">(</span><span class="n">integrally_closed</span> <span class="o">:</span> <span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">canonical_equiv</span> <span class="n">integrally_closed</span> <span class="n">h'</span> <span class="o">(</span><span class="n">integral_closure.mk</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span>
</code></pre></div>



<a name="238494155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238494155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238494155">(May 12 2021 at 15:33)</a>:</h4>
<p>Try not to define <code>def</code> using tactic <code>begin ... end</code> mode</p>



<a name="238494164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238494164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238494164">(May 12 2021 at 15:33)</a>:</h4>
<p>(to first pass)</p>



<a name="238494229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238494229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238494229">(May 12 2021 at 15:33)</a>:</h4>
<p>We can use <code>canonical_equiv</code> or any <code>≃ₐ[A]</code> (or any <code>≃</code>) as a function, no need to use <code>to_fun</code></p>



<a name="238495029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238495029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238495029">(May 12 2021 at 15:38)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span>  What's wrong about this example?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">injective</span>
<span class="kd">end</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">type mismatch at application</span>
<span class="cm">  (algebra_map ?m_6 ?m_7).injective</span>
<span class="cm">term</span>
<span class="cm">  algebra_map ?m_1 ?m_2</span>
<span class="cm">has type</span>
<span class="cm">  @ring_hom ?m_1 ?m_2 (@comm_semiring.to_semiring ?m_1 ?m_3) ?m_4 : Type (max ? ?)</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  @ring_hom ?m_1 ?m_2 (@ring.to_semiring ?m_1 (@division_ring.to_ring ?m_1 ?m_3)) ?m_4 : Type (max ? ?)</span>
<span class="cm">Additional information:</span>
<span class="cm">/home/yakov/code/mathlib/src/test.lean: context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message</span>
<span class="cm">  type mismatch at application</span>
<span class="cm">    (algebra_map ?m_6 ?m_7).injective</span>
<span class="cm">  term</span>
<span class="cm">    algebra_map ?m_1 ?m_2</span>
<span class="cm">  has type</span>
<span class="cm">    @ring_hom ?m_1 ?m_2 (@comm_semiring.to_semiring ?m_1 ?m_3) ?m_4 : Type (max ? ?)</span>
<span class="cm">  but is expected to have type</span>
<span class="cm">    @ring_hom ?m_1 ?m_2 (@ring.to_semiring ?m_1 (@division_ring.to_ring ?m_1 ?m_3)) ?m_4 : Type (max ? ?)</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="238495146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238495146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238495146">(May 12 2021 at 15:38)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ring_hom.injective">docs#ring_hom.injective</a> needs the algebra to be over a <del>field</del> <code>division_ring</code>, not just an <code>integral_domain</code></p>



<a name="238496760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238496760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238496760">(May 12 2021 at 15:46)</a>:</h4>
<p>There should be some lemma that for an integral domain the map into the field of fractions is injective</p>



<a name="238497457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238497457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238497457">(May 12 2021 at 15:49)</a>:</h4>
<p>Perhaps, but <a href="https://leanprover-community.github.io/mathlib_docs/find/fraction_ring.algebra">docs#fraction_ring.algebra</a> is the very last line in the file, so either mathlib doesn't have it, it's in a downstream file somewhere, or it's true more generally and we're looking for the wrong thing</p>



<a name="238497480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238497480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238497480">(May 12 2021 at 15:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/fraction_map.injective">docs#fraction_map.injective</a></p>



<a name="238497723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238497723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238497723">(May 12 2021 at 15:51)</a>:</h4>
<p>Look's to me like we're missing the rfl-lemma that <code>algebra_map A (fraction_ring A) = (fraction_map.of A).to_map</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">algebra_map_eq</span> <span class="o">:</span> <span class="n">algebra_map</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">fraction_ring.of</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">to_map</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>as then we would have found the <code>injective</code> lemma with library_search</p>



<a name="238497956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238497956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238497956">(May 12 2021 at 15:52)</a>:</h4>
<p>But indeed that lemma closes the goal</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">fraction_map.injective</span> <span class="n">_</span>
</code></pre></div>



<a name="238498302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238498302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238498302">(May 12 2021 at 15:54)</a>:</h4>
<p>Great!<br>
Then you have just this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">canonical_equiv</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">equiv_of_eq</span> <span class="o">(</span><span class="n">integral_closure</span> <span class="n">A</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="n">A</span><span class="o">))</span> <span class="bp">⊥</span> <span class="n">integrally_closed</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span>
  <span class="o">(</span><span class="n">algebra.bot_equiv_of_injective</span> <span class="o">(</span><span class="n">fraction_map.injective</span> <span class="n">_</span><span class="o">))</span>
</code></pre></div>



<a name="238498615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238498615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238498615">(May 12 2021 at 15:56)</a>:</h4>
<p>But <span class="user-mention" data-user-id="385895">@Jon Eugster</span>, why do you need to construct an <code>A</code> from something that you know only separately is of type <code>fraction_map A</code> and  holds <code>is_integral A</code>?</p>



<a name="238498679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238498679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238498679">(May 12 2021 at 15:56)</a>:</h4>
<p>Instead of working on such elements, perhaps you just need the right composition of functions/isos</p>



<a name="238548956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238548956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238548956">(May 12 2021 at 21:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238498679">said</a>:</p>
<blockquote>
<p>Instead of working on such elements, perhaps you just need the right composition of functions/isos</p>
</blockquote>
<p>Thanks for work above, I'll go through it tomorrow. Maybe I should explain more of the context. I thought I give it a shot and see how far I'd get formalising the direct summand conjecture; in equal characteristics (0,0) to start with. The proof reads like this<br>
<a href="/user_uploads/3121/nDvIH1gKfHiEnck9WXzeK_we/dsc.png">dsc.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/nDvIH1gKfHiEnck9WXzeK_we/dsc.png" title="dsc.png"><img src="/user_uploads/3121/nDvIH1gKfHiEnck9WXzeK_we/dsc.png"></a></div><p>I did manage to construct the trace as map <code>L →ₗ[K] K</code> and show that it splits <code>algebra_map K L</code>, so know I would like to adapt this to a map <code>(integral_closure A L) →ₗ[A] A</code>. I guess there should be a way to combine this from different maps but the problem I encountered is that although you have a combination of maps <code>(integral_closure A L) → L → K</code> and <code>(integral_closure A K) → A</code> you don't have a map <code>K→(integral_closure A K)</code>, but the composition of everything exists and is a linear map. So I thought as last resource I would give it a go and define this composition explicitly by constructing an element in <code>A</code>.</p>
<p>Another challenge is then the "we can enlarge $B$ to be the integral closure ..." but I haven't started on that yet.</p>
<p>So if you have any tips/tricks or opinions I am very happy to listen and learn :)</p>



<a name="238551227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238551227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238551227">(May 12 2021 at 22:02)</a>:</h4>
<p>This is a great way of learning Lean! There are plenty of people here who know enough to be able to help you out.</p>
<p>The best way to ask a question here is to post fully working lean code including all imports etc and a sorry, and ask how to fill it in. You'll get stuck many times initially, but it will all begin to make sense later on as you learn the tricks.</p>



<a name="238612593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238612593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jon Eugster <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238612593">(May 13 2021 at 12:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/towers.20of.20algebras/near/238494155">said</a>:</p>
<blockquote>
<p>Try not to define <code>def</code> using tactic <code>begin ... end</code> mode</p>
</blockquote>
<p>So far I used <code>begin ... end</code> because it seems more iterative, i.e. you can create stuff step-by-step with <code>have</code>, and then once your done, you can rewrite it as a direct term without tactic mode, is there a better approach to do such constructions?</p>



<a name="238613091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238613091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238613091">(May 13 2021 at 12:12)</a>:</h4>
<p><span class="user-mention" data-user-id="385895">@Jon Eugster</span> You can write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">some_type</span> <span class="o">:=</span>
<span class="n">partial</span> <span class="n">_</span> <span class="n">construction</span> <span class="o">(</span><span class="n">of</span> <span class="n">my</span> <span class="n">_</span> <span class="kd">definition</span><span class="o">)</span>
</code></pre></div>
<p>and if you put your cursor on one of the <code>_</code>, then the goal window will show you the remaining goal.</p>



<a name="238672753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/towers%20of%20algebras/near/238672753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/towers.20of.20algebras.html#238672753">(May 13 2021 at 20:02)</a>:</h4>
<p>Often it's still easier to use tactic mode first as Jon describes though, especially since sometimes it saves you from elaborator quirks</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html">Word metric on group -- a new attempt</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="289961580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/289961580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#289961580">(Jul 18 2022 at 12:58)</a>:</h4>
<p>Hi all, I tried to start from scratch with a definition of the word metric on a group, and I'm stuck at some basics. Here is where I am now: I'm thinking of a basic object which is a group with fixed generating set</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed.group.basic</span>
<span class="kn">import</span> <span class="n">group_theory.free_group</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">function</span> <span class="n">real</span>

<span class="kn">namespace</span> <span class="n">word_metric</span>

<span class="kn">section</span> <span class="n">marked_group</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>

<span class="s2">"""an S-generated group"""</span>
<span class="kd">class</span> <span class="n">marked_group</span> <span class="o">(</span><span class="n">G</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">group</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">marking</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_surjective</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">marking</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">marked_group</span> <span class="n">G</span> <span class="n">S</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">free_group_norm</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">f</span><span class="o">,</span> <span class="o">(</span><span class="n">free_group.to_word</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span>

<span class="kd">lemma</span> <span class="n">marked_group_marking</span> <span class="o">(</span><span class="n">G</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">marked_group</span> <span class="n">G</span> <span class="n">S</span><span class="o">]</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">marked_group.marking</span>

<span class="kd">def</span> <span class="n">group_norm</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">g</span><span class="o">,</span> <span class="n">Inf</span> <span class="o">((</span><span class="n">free_group_norm</span><span class="o">)</span><span class="bp">''</span> <span class="o">((</span><span class="n">marked_group_marking</span> <span class="n">G</span> <span class="n">S</span><span class="o">)</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">g</span><span class="o">}))</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">S</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">group_norm_finite</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">group_norm</span> <span class="n">x</span> <span class="bp">≠</span> <span class="bp">⊤</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="c1">-- say that the Inf argument is non-empty because of marked_group.is_surjective</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">group_norm_one</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">group_norm</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="c1">-- etc.</span>

<span class="kd">end</span> <span class="n">marked_group</span>

<span class="kd">end</span> <span class="n">word_metric</span>
</code></pre></div>
<p>My basic questions, for which I hope I can get help, are:</p>
<ul>
<li>Why do I have to repeat the assumptions <code>[decidable_eq S]</code> in unpredictable ways?</li>
<li>In <code>group_norm_finite</code> there is an error that Lean doesn't know how to synthesize a placeholder at <code>group_norm</code></li>
<li>I intend to define <code>class normed_group extends group G, has_norm G, metric_space G</code> and create an instance of it from a <code>marked_group G S</code>. Does this sound reasonable?</li>
</ul>
<p>Many thanks in advance! Laurent</p>



<a name="289962146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/289962146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#289962146">(Jul 18 2022 at 13:03)</a>:</h4>
<p>The second <code>[decidable_eq S]</code> is needed because you introduced a new <code>S</code> in <code>`def free_group_norm</code>.</p>



<a name="289962272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/289962272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#289962272">(Jul 18 2022 at 13:04)</a>:</h4>
<p>The third one should be useless, but beware that you repeated <code>[group G]</code>, so now you have <em>two</em> group structure on <code>G</code>, and this surely not what you want.</p>



<a name="289962367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/289962367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#289962367">(Jul 18 2022 at 13:05)</a>:</h4>
<p>Also, you may want to use <code>finite S</code> instead of <code>fintype S</code> (and you need this only once).</p>



<a name="289963813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/289963813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#289963813">(Jul 18 2022 at 13:19)</a>:</h4>
<p>OK, thanks! I cleaned up a bit the code with these suggestions, and edited my first message. (sorry if the beginning of the conversation now looks strange).</p>
<p>I forgot another question: I couldn't access the field "marking" in the <code>marked_group G</code> from <code>group_norm</code>, so I resorted to writing the lemma <code>marked_group_marking</code> to access it. What's the correct way of doing this?</p>



<a name="290018835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290018835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290018835">(Jul 18 2022 at 20:29)</a>:</h4>
<p><span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> <span class="user-mention" data-user-id="466727">@Jim Fowler</span> Just making sure you are aware of each others' work here!</p>



<a name="290019444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290019444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290019444">(Jul 18 2022 at 20:34)</a>:</h4>
<p>Yes, I have some code posted at <a href="https://github.com/kisonecat/word-metric/tree/main/src">https://github.com/kisonecat/word-metric/tree/main/src</a></p>



<a name="290019618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290019618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290019618">(Jul 18 2022 at 20:36)</a>:</h4>
<p>I do think 'marked_group' is a better name than 'generated_group'.</p>



<a name="290022622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290022622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290022622">(Jul 18 2022 at 21:04)</a>:</h4>
<p>Let me ping <span class="user-mention" data-user-id="466209">@Georgi Kocharyan</span> here too.</p>



<a name="290037883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290037883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290037883">(Jul 18 2022 at 23:48)</a>:</h4>
<p><span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> </p>
<blockquote>
<p>In group_norm_finite there is an error that Lean doesn't know how to synthesize a placeholder at group_norm</p>
</blockquote>
<p>This is because the statement doesn't mention <code>S</code> at all, so Lean doesn't know what to fill in for the <code>S</code> in <code>group_norm</code>. Making <code>S</code> explicit in <code>group_norm</code> helps; if you don't want to write <code>S</code> all the time you should probably include it as a field in the structure <code>marked_group</code>.</p>
<p>If you don't choose to include <code>S</code> inside the structure, then it seems necessary to define <code>marked_group_marking</code> as you did, because <code>S</code> is implicit in <code>marked_group.marking</code>. If you change the inverse image <code>⁻¹'</code> by an explicit expression as I did above, you can make <code>G</code> implicit in <code>marked_group_marking</code> (btw, it should be a def not a lemma).</p>
<p>Note that <code>⊤</code> still doesn't work since <code>ℕ</code> doesn't <code>has_top</code>. It seems nicer to use <a href="https://leanprover-community.github.io/mathlib_docs/find/well_founded.min">docs#well_founded.min</a> to define <code>group_norm</code> (see below).</p>
<p>Another comment: since your <code>marked_group</code> extends <code>group</code>, you should probably require <code>marking</code> to be a homomorphism.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed.group.basic</span>
<span class="kn">import</span> <span class="n">group_theory.free_group</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">function</span> <span class="n">real</span>

<span class="kn">namespace</span> <span class="n">word_metric</span>

<span class="kn">section</span> <span class="n">marked_group</span>

<span class="c1">-- an S-generated group</span>
<span class="kd">class</span> <span class="n">marked_group</span> <span class="o">(</span><span class="n">G</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">group</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">marking</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_surjective</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">marking</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">marked_group</span> <span class="n">G</span> <span class="n">S</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">marked_group_marking</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">marked_group.marking</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">S</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">S</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">free_group_norm</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">free_group.to_word</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">group_norm</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.lt.is_well_order.wf.min</span>
  <span class="o">(</span><span class="n">free_group_norm</span> <span class="bp">''</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">marked_group_marking</span> <span class="n">S</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span><span class="o">})</span>
  <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">set.nonempty.image</span><span class="o">,</span> <span class="n">exact</span> <span class="n">marked_group.is_surjective</span> <span class="n">g</span> <span class="o">})</span>
<span class="c1">-- Inf (free_group_norm '' {x | marked_group_marking S x = g})</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">group_norm</span> <span class="n">S</span> <span class="n">x</span> <span class="c1">-- now works</span>
</code></pre></div>



<a name="290060300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290060300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Georgi Kocharyan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290060300">(Jul 19 2022 at 06:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt/near/290022622">said</a>:</p>
<blockquote>
<p>Let me ping <span class="user-mention silent" data-user-id="466209">Georgi Kocharyan</span> here too.</p>
</blockquote>
<p>thanks - my current attempt for the word metric and Cayley graphs is at <a href="https://github.com/GregorSamsa42/svarc-milnor/blob/main/src/cayleygraphs.lean">https://github.com/GregorSamsa42/svarc-milnor/blob/main/src/cayleygraphs.lean</a></p>



<a name="290061834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290061834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290061834">(Jul 19 2022 at 07:12)</a>:</h4>
<p><code>marked_group</code> doesn't look like it can safely extend <code>group</code> to me</p>



<a name="290062125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290062125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290062125">(Jul 19 2022 at 07:16)</a>:</h4>
<p>Although maybe it's safe if you change <code>S : Type*</code> to <code>S : out_param Type*</code></p>



<a name="290063712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290063712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290063712">(Jul 19 2022 at 07:38)</a>:</h4>
<p>Thanks to all!<br>
<span class="user-mention" data-user-id="466727">@Jim Fowler</span> , I see you're done a lot, and it will be very inspiring. However, I think that the notion of "marked group" is important enough to be in Lean, not just for the word metric. See e.g. <a href="http://math.univ-lyon1.fr/~altinel/ModelsGroupsArx/benli_gm2015.pdf">http://math.univ-lyon1.fr/~altinel/ModelsGroupsArx/benli_gm2015.pdf</a> for some slides. <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> , it looks like a very nice shortcut to use simple_graph.dist. Are you working with Clara Löh on this? I see her name in a header. The Svarc-Milnor theorem is a great goal, it was on my todo list but I'll cross it out now :)</p>
<p>I would nevertheless like the code to be a bit more general. In particular, separate the notions of marked_group and normed_group; and within normed_group, have word_normed_group in which one specifies a (positive real) length for each generator. That will make induction harder, since we'll have a well-founded set of real lengths to work with.</p>
<p>WRT the first class, my heart goes now more in the direction of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">marked_group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">group</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">decidable</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">S</span><span class="o">)</span>
<span class="o">(</span><span class="n">marking</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span> <span class="bp">→*</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_surjective</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">marking</span><span class="o">)</span>
</code></pre></div>
<p>Comments as always appreciated!</p>



<a name="290064473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290064473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290064473">(Jul 19 2022 at 07:48)</a>:</h4>
<p>If you have real numbers then the minimum may not be achieved, e.g. if G is the additive group of ℚ, S is {1/n | n ∈ ℕ+}, and 1/n is assigned length 1/n^2. But if S is finite then there's only a finite number of elements in free_group S of bounded norm.</p>



<a name="290073461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290073461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290073461">(Jul 19 2022 at 09:26)</a>:</h4>
<p>I'd also perhaps suggest:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">marked_group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">out_param</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">marking</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span> <span class="bp">→*</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_surjective</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">marking</span><span class="o">)</span>
</code></pre></div>
<p>and then you don't need the <code>decidable</code> instance as a field</p>



<a name="290073526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290073526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290073526">(Jul 19 2022 at 09:27)</a>:</h4>
<p>This has the bonus of working for <code>comm_group</code> too, in case that's relevant'; with your spelling, you can't talk about marked commutative groups.</p>



<a name="290077956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290077956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290077956">(Jul 19 2022 at 10:13)</a>:</h4>
<p>If you want to register your group as a metric space (where the distance depends on <code>S</code>), you will need to embrace the type synonym trick. Instead of a class, define a structure <code>marking S G</code> as you did. And then given a group <code>G</code> and a marking <code>m</code>, define a new type <code>marked_group m G := G</code>. On this new type, you can register the same group structure as on <code>G</code>, but you can also register a distance as <code>m</code> is now available to the system when you consider <code>x y : marked_group m G</code>.</p>



<a name="290078064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290078064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290078064">(Jul 19 2022 at 10:14)</a>:</h4>
<p>The <code>out_param</code> idea I don't like so much because often we discuss several generating sets on a given group.</p>



<a name="290078251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290078251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290078251">(Jul 19 2022 at 10:16)</a>:</h4>
<p>OK! <span class="user-mention" data-user-id="310045">@Eric Wieser</span> , I followed your suggestion, so the beginning looks like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">marked_group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">out_param</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">marking</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span> <span class="bp">→*</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_surjective</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">marking</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">S</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">free_group_norm</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">free_group.to_word</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">MG</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">MG</span><span class="o">]</span> <span class="o">[</span><span class="n">marked_group</span> <span class="n">MG</span> <span class="n">S</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">group_norm</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">MG</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">nat.lt.is_well_order.wf.min</span>
  <span class="o">(</span><span class="n">free_group_norm</span> <span class="bp">''</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="n">marked_group.marking</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span><span class="o">})</span>
  <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">set.nonempty.image</span><span class="o">,</span> <span class="n">exact</span> <span class="n">marked_group.is_surjective</span> <span class="n">g</span> <span class="o">})</span>

<span class="kd">lemma</span> <span class="n">group_norm_one</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">MG</span><span class="o">)</span> <span class="o">:</span> <span class="n">group_norm</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>Is this what you had in mind? I don't seem to be able to get away without repeating the assertions <code>[decidable_eq S]</code> everywhere, otherwise Lean doesn't know anything about <code>S</code>.</p>
<p>Extra question: what is the interface for <code>nat.lt.is_well_order.wf.min</code>? All I want is to extract an element representing the minimum, and provide witnesses that upper-bound the minimum.</p>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> , I just saw your message while typing. Do you think it's then best to keep it the way I did it before, with an explicit <code>S</code> field? (and of course your splitting into struct and type</p>



<a name="290078753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290078753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290078753">(Jul 19 2022 at 10:22)</a>:</h4>
<p>IIrc <code>nat.find</code> was a good alternative to <code>….wf.min</code> in the case of naturals?<br>
<a href="https://leanprover-community.github.io/mathlib_docs/init/data/nat/lemmas.html#nat.find">See here</a>.</p>



<a name="290079175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290079175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290079175">(Jul 19 2022 at 10:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="263407">Laurent Bartholdi</span> <a href="#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt/near/290063712">said</a>:</p>
<blockquote>
<p>Are you working with Clara Löh on this? I see her name in a header.</p>
</blockquote>
<p>No, but Georgi is! and I'm casually helping Georgi out.</p>



<a name="290079915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290079915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290079915">(Jul 19 2022 at 10:35)</a>:</h4>
<p>By the way, at the risk of thread-jacking, would it make sense to set up a space to coordinate the progress on formalizing GGT? I admit I haven't made nearly as much progress as expected until now, but would like to get back to it, and would love to have the possibility to work outside of my bubble and discuss formalization strategies and goals in a kind of communal way.</p>



<a name="290080451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290080451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290080451">(Jul 19 2022 at 10:40)</a>:</h4>
<p>I am not quite the person to ask about this, but I strongly suggest you do! The most effective way to do this is to work on a common branch of mathlib (and create a new directory in there to keep the new files close to each other) or to create a new repository with CI (which is arguably much more work) + have either a Discord group chat, a Zulip topic or a Zulip stream.</p>



<a name="290082980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290082980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290082980">(Jul 19 2022 at 11:08)</a>:</h4>
<p>The <code>out_param</code> should mean that lean works out what <code>S</code> is</p>



<a name="290083137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290083137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290083137">(Jul 19 2022 at 11:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt/near/290078064">said</a>:</p>
<blockquote>
<p>The <code>out_param</code> idea I don't like so much because often we discuss several generating sets on a given group.</p>
</blockquote>
<p>If my understanding is correct<code>out_param</code> doesn't really require that the generating set be unique, it just means that you can leave it unspecified and lean will find a default.</p>



<a name="290083673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290083673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290083673">(Jul 19 2022 at 11:15)</a>:</h4>
<p>The rule is that for a given choice of non-instance-implicit non-<code>out_param</code> arguments, you can't have two instances that are not equal. (Instance-implicit parameters are the ones in [square brackets].) Equality of instances means:</p>
<ul>
<li>the fields of the underlying structure are definitionally equal, up to a reducibility somewhere between reducible and semireducible (I believe the correct reducibility depends on the specific situation)</li>
<li>all values for <code>out_param</code> and instance-implicit parameters are similarly definitionally equal</li>
</ul>



<a name="290083754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290083754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290083754">(Jul 19 2022 at 11:16)</a>:</h4>
<p>If you break this rule, you will get diamond errors (unless you are very careful with what you do).</p>



<a name="290086992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290086992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290086992">(Jul 19 2022 at 11:48)</a>:</h4>
<p>Equality doesn't even make sense to state though if the out_params arguments (indices) are different</p>



<a name="290087025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290087025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290087025">(Jul 19 2022 at 11:49)</a>:</h4>
<p><code>out_param</code> stuff should definitely be unique, yes, otherwise you run into diamonds.</p>
<p>A tentative scheme avoiding out_params would be the following:</p>
<ul>
<li>First, work with normed groups, and prove whatever you like here. Possibly adding new typeclass assumptions that say that the distance is proper or hyperbolic or whatever.</li>
<li>Then, to construct instances of such normed groups, do it on type synonyms. For instance, given two types <code>S</code> and <code>G</code> with <code>[group G]</code>, define <code>marking S G</code> as the space of markings of <code>G</code> parameterized by <code>S</code>. Then, given a group <code>G</code> and a marking <code>m</code>, define a type<code>marked_group G S := G</code> as a copy of <code>G</code>, then define on it the group structure coming fro <code>G</code> (with <code>@[derive ...]</code>) and the norm associated to <code>S</code>. Then <code>marked_group G S</code> will be an instance of a normed group.</li>
</ul>



<a name="290087173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290087173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290087173">(Jul 19 2022 at 11:50)</a>:</h4>
<p>If you want to have real distances, this fits perfectly well in this scheme, with another type synonym in which you will register a marking together with the length of each edge for each element of <code>S</code>.</p>



<a name="290087619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290087619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290087619">(Jul 19 2022 at 11:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt/near/290087025">said</a>:</p>
<blockquote>
<p><code>out_param</code> stuff should definitely be unique, yes, otherwise you run into diamonds.</p>
</blockquote>
<p>Do you have an example in mind for what this looks like? Maybe you're right that <code>out_param</code>s aren't the right solution here, but I don't believe that diamonds (at least not in the usual sense) are possible from them</p>



<a name="290088721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290088721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290088721">(Jul 19 2022 at 12:06)</a>:</h4>
<p>Does this count as a diamond?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.basic</span>

<span class="kd">class</span> <span class="n">artificial_example</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">o</span> <span class="o">:</span> <span class="n">out_param</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">o</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">ex0</span> <span class="o">:</span> <span class="n">artificial_example</span> <span class="n">ℕ</span> <span class="mi">1</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">ex0_eq_0</span> <span class="o">:</span> <span class="n">artificial_example.foo</span> <span class="n">ℕ</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="n">ex1</span> <span class="o">:</span> <span class="n">artificial_example</span> <span class="n">ℕ</span> <span class="mi">2</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">ex0_eq_0'</span> <span class="o">:</span> <span class="n">artificial_example.foo</span> <span class="n">ℕ</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">ex0_eq_0</span> <span class="c1">-- Error: type mismatch</span>
</code></pre></div>



<a name="290088949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290088949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290088949">(Jul 19 2022 at 12:09)</a>:</h4>
<p>Of course, this will work once you make <code>o</code> explicit in <code>foo</code>, but at that point you don't need the <code>out_param</code> anymore.</p>



<a name="290089001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290089001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290089001">(Jul 19 2022 at 12:09)</a>:</h4>
<p>Oh I see, the diamond no longer happens in the instance itself (because you can't state that any more), but the operations/projections derived from it. Thanks!</p>



<a name="290089097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290089097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290089097">(Jul 19 2022 at 12:10)</a>:</h4>
<p>That's one way to see it indeed!</p>



<a name="290093635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290093635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290093635">(Jul 19 2022 at 12:51)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> it'd be great to coordinate formalization efforts around GGT!</p>



<a name="290095033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290095033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290095033">(Jul 19 2022 at 13:02)</a>:</h4>
<p>I agree with you <span class="user-mention silent" data-user-id="263407">Laurent Bartholdi</span> that <code>marked_group</code> is the correct notion.</p>



<a name="290095575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290095575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290095575">(Jul 19 2022 at 13:06)</a>:</h4>
<p>OK, I guess the best place to start is by setting up a stream, but it seems you need to be an admin to do that. Am I right, <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> ? OK, started with a topic <a href="#narrow/stream/113488-general/topic/Geometric.20Group.20Theory.20coordination.20.3F/near/290098362">here</a></p>



<a name="290095707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290095707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290095707">(Jul 19 2022 at 13:07)</a>:</h4>
<p>I would suggest creating a stream only if the project starts getting big. There are only 39 public streams.</p>



<a name="290099072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290099072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290099072">(Jul 19 2022 at 13:33)</a>:</h4>
<p>Perhaps create a ggt branch in mathlib, create a subdirectory geometric_group_theory ?</p>



<a name="290104794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290104794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290104794">(Jul 19 2022 at 14:16)</a>:</h4>
<p>Or <code>group_theory.geometry</code>?</p>



<a name="290107018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290107018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290107018">(Jul 19 2022 at 14:30)</a>:</h4>
<blockquote>
<p>Extra question: what is the interface for nat.lt.is_well_order.wf.min? All I want is to extract an element representing the minimum, and provide witnesses that upper-bound the minimum.</p>
</blockquote>
<p>The interface you want is provided by <a href="https://leanprover-community.github.io/mathlib_docs/find/well_founded.min_le">docs#well_founded.min_le</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/well_founded.min_mem">docs#well_founded.min_mem</a>.<br>
But indeed <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.find">docs#nat.find</a> is better. Thanks Rémi Bottinelli!</p>



<a name="290108880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290108880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290108880">(Jul 19 2022 at 14:43)</a>:</h4>
<p>OK, I just created a minuscule file at group_theory/geometric/marked_group.lean in a branch geometric-group-theory. All are welcome to play with it and modify! For now, I'm just testing whether the basic idea is sound. I'll try to incorporate the changes suggested by <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> </p>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> and <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> and <span class="user-mention" data-user-id="466727">@Jim Fowler</span> , perhaps we can put all our ideas together in this subdirectory and sort out which approach works best?</p>
<p>I hope I'm not doing anything untoward. Hopefully everybody has access to this branch and can make coordinated changes.</p>



<a name="290114392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290114392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290114392">(Jul 19 2022 at 15:18)</a>:</h4>
<p>I had some very WIP code on the ends of graphs and also a basic pull request about nets and separated sets in metric spaces <a href="https://github.com/leanprover-community/mathlib/pull/12010/files">here</a>. I'm not sure either belongs to <code>group_theory/geometric</code> though?</p>



<a name="290115927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290115927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290115927">(Jul 19 2022 at 15:28)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> definitely they do!<br>
A very nice result to formalize could be the 0-1-2-infty theorem on ends; and, perhaps even better, the new take by Yves de Cornulier that does not restrict to finitely generated groups. In essence, he considers a group G acting on a space X; the Boolean algebra of X-subsets modulo finite ones; its G-invariant subalgebra; and the Stone dual thereof. This is the space of ends of X_G, and for X=G has 0,1,2 elements or is a Cantor set. See [https://www.normalesup.org/~cornulier/spaends.pdf]<br>
Particularly interesting would be to connect to the classical theory of ends in graph theory when the group is f.g.</p>



<a name="290119742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290119742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290119742">(Jul 19 2022 at 15:52)</a>:</h4>
<p>Hah, I had exactly that thing in mind (see the topic I started on General). I was thinking it might be easier to define both "coarse" and "graphical" notions of ends separately and link them later on. But that really stemmed from my failure at defining a coarse notion for which the 0-1-2-oo theorem is easily shown.<br>
So, it's a good question whether we should directly start with the most general result or not.</p>
<p>By the way, it's not clear from just reading the abstract, but does Cornulier actually prove the "generalized" version of 0-1-2-oo ?</p>



<a name="290123272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290123272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290123272">(Jul 19 2022 at 16:13)</a>:</h4>
<p><span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> thank you for getting this going!</p>



<a name="290124276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290124276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290124276">(Jul 19 2022 at 16:20)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> I think it would be helpful to collect anything related (like ends of <em>graphs</em>) in <code>group_theory/geometric</code>.</p>



<a name="290124407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290124407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290124407">(Jul 19 2022 at 16:21)</a>:</h4>
<p>I recall seeing some QIE definitions by Clara Löh which could also be put in this branch (or maybe quasi-isometry lives somewhere in mathlib already?).</p>



<a name="290127256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290127256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290127256">(Jul 19 2022 at 16:42)</a>:</h4>
<p>As far as I knew, quasi-isometries weren't there yet. This one (I mean, the notion of quasi-isometry) also has lots of different definitions, and I'm not sure which one to start with first. My PR was actually headed in this direction, since some implications need to start with a maximal separated subset.</p>



<a name="290172508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290172508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290172508">(Jul 19 2022 at 23:02)</a>:</h4>
<p>OK, it's 1am and I just managed to prove that |g|=0 iff g=1. If anyone wants to give a look to group_theory/geometric/marked_group.lean and provide golfing / structure suggestions, I'd love it!</p>



<a name="290187650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290187650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290187650">(Jul 20 2022 at 02:34)</a>:</h4>
<p><span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> I moved some things into <code>variable</code>s and implicit arguments.</p>



<a name="290195780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290195780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290195780">(Jul 20 2022 at 05:36)</a>:</h4>
<p>Ah, damn, I'm getting the yellow bar and vscodium crashes wnen trying to work with the <code>geometric-group-theory</code> branch. Should <code>leanproject get-cache --fallback=download-first</code>be the correct command to get the cache?</p>



<a name="290220427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290220427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290220427">(Jul 20 2022 at 11:10)</a>:</h4>
<p>After some more work, I got to the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">to_word_inv_length</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹.</span><span class="n">to_word.length</span> <span class="bp">≤</span> <span class="n">x.to_word.length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
<span class="kd">lemma</span> <span class="n">to_word_mul_length</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">to_word.length</span> <span class="bp">≤</span> <span class="n">x.to_word.length</span> <span class="bp">+</span> <span class="n">y.to_word.length</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">group_norm_comm_le</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">group_norm</span> <span class="n">m</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">≤</span> <span class="n">group_norm</span> <span class="n">m</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">group_norm</span> <span class="n">m</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">group_norms</span> <span class="n">m</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.lt.is_well_order.wf.min_mem</span> <span class="o">(</span><span class="n">group_norms</span> <span class="n">m</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">group_norms_nonempty</span> <span class="n">m</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">rcases</span> <span class="n">set.mem_image_iff_bex.1</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span><span class="n">ytox</span><span class="o">,</span><span class="n">yneqxn</span><span class="o">⟩,</span>

  <span class="k">have</span> <span class="n">yitoxi</span> <span class="o">:</span> <span class="n">m.marking</span> <span class="n">y</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">map_inv</span><span class="o">,</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">inv_inj</span><span class="o">],</span><span class="n">exact</span> <span class="n">ytox</span> <span class="o">},</span>

  <span class="k">have</span> <span class="n">mon</span> <span class="o">:</span> <span class="o">(</span><span class="n">y</span><span class="bp">⁻¹</span><span class="o">)</span><span class="bp">.</span><span class="n">to_word.length</span> <span class="bp">≤</span> <span class="n">y.to_word.length</span><span class="o">,</span> <span class="k">from</span> <span class="n">to_word_inv_length</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">y</span><span class="bp">⁻¹</span><span class="o">)</span><span class="bp">.</span><span class="n">to_word.length</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">group_norms</span> <span class="n">m</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">),</span>
    <span class="k">from</span> <span class="n">set.mem_image_iff_bex.2</span> <span class="o">⟨</span><span class="n">y</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="n">yitoxi</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">well_founded.min_le</span> <span class="n">nat.lt.is_well_order.wf</span> <span class="n">this</span> <span class="o">(</span><span class="n">group_norms_nonempty</span> <span class="n">m</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">)),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">yneqxn</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">mon</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">group_norm_comm</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">group_norm</span> <span class="n">m</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">group_norm</span> <span class="n">m</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">has_le.le.antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">group_norm_comm_le</span> <span class="n">m</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">(</span><span class="n">inv_inv</span> <span class="n">x</span><span class="o">)</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">assumption</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">group_norm_comm_le</span> <span class="n">m</span> <span class="n">x</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">group_norm_ineq</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">group_norm</span> <span class="n">m</span> <span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">group_norm</span> <span class="n">m</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">group_norm</span> <span class="n">m</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="c1">-- extract reps for x, y, use product for x*y</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">group_norm</span> <span class="n">m</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">group_norms</span> <span class="n">m</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.lt.is_well_order.wf.min_mem</span> <span class="o">(</span><span class="n">group_norms</span> <span class="n">m</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">group_norms_nonempty</span> <span class="n">m</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">rcases</span> <span class="n">set.mem_image_iff_bex.1</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">z</span><span class="o">,</span><span class="n">ztox</span><span class="o">,</span><span class="n">zneqxn</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">k</span> <span class="o">:</span> <span class="o">(</span><span class="n">group_norm</span> <span class="n">m</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">group_norms</span> <span class="n">m</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.lt.is_well_order.wf.min_mem</span> <span class="o">(</span><span class="n">group_norms</span> <span class="n">m</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">group_norms_nonempty</span> <span class="n">m</span> <span class="n">y</span><span class="o">),</span>
  <span class="n">rcases</span> <span class="n">set.mem_image_iff_bex.1</span> <span class="n">k</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">w</span><span class="o">,</span><span class="n">wtoy</span><span class="o">,</span><span class="n">wneqyn</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">one</span> <span class="o">:</span> <span class="n">m.marking</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">wtoy</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">two</span> <span class="o">:</span> <span class="n">m.marking</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="k">from</span> <span class="n">ztox</span><span class="o">,</span>

  <span class="k">have</span> <span class="n">zwtoxy</span> <span class="o">:</span> <span class="n">m.marking</span> <span class="o">(</span><span class="n">z</span><span class="bp">*</span><span class="n">w</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">map_mul</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">one</span><span class="o">,</span><span class="n">two</span><span class="o">],},</span>
  <span class="k">have</span> <span class="n">mon</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span><span class="bp">*</span><span class="n">w</span><span class="o">)</span><span class="bp">.</span><span class="n">to_word.length</span> <span class="bp">≤</span> <span class="n">z.to_word.length</span> <span class="bp">+</span> <span class="n">w.to_word.length</span><span class="o">,</span> <span class="k">from</span> <span class="n">to_word_mul_length</span> <span class="n">z</span> <span class="n">w</span><span class="o">,</span>

  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span><span class="bp">*</span><span class="n">w</span><span class="o">)</span><span class="bp">.</span><span class="n">to_word.length</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">group_norms</span> <span class="n">m</span> <span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span><span class="o">)),</span>
    <span class="k">from</span> <span class="n">set.mem_image_iff_bex.2</span> <span class="o">⟨</span><span class="n">z</span><span class="bp">*</span><span class="n">w</span><span class="o">,</span> <span class="n">zwtoxy</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>

  <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">well_founded.min_le</span> <span class="n">nat.lt.is_well_order.wf</span> <span class="n">this</span> <span class="o">(</span><span class="n">group_norms_nonempty</span> <span class="n">m</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">))),</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">zneqxn</span><span class="o">,</span><span class="bp">←</span><span class="n">wneqyn</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">mon</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I'm not sure of the best way to prove the first two lemmas above. Surely they should follow from relatively simple manipulations in the free group: If <code>w</code> is a reduced word for <code>x</code>, then <code>w.reverse.map …</code> is a representative of x⁻¹, hence in the same class as <code>x⁻¹.to_word</code>, hence reduces to it, and by monotonocity we're done… but I can't quite get the correct tools to use for that. By the way, please tell me if I should play with something else while you're working on this file!</p>



<a name="290223129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290223129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290223129">(Jul 20 2022 at 11:38)</a>:</h4>
<p><span class="user-mention" data-user-id="466727">@Jim Fowler</span> great! I looked at your "properties.lean" and added some stuff. Out of curiosity, why did you go to monoid quotients in "residually P"?</p>



<a name="290224371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290224371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290224371">(Jul 20 2022 at 11:51)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> Very nice, of course I'm very happy to see you filled some sorries. Should I paste it into the file, or do you want to commit it yourself?</p>
<p>About <code>to_word_inv_length</code>: the lemmas are definitely there, but I can't put them together: <code>free_group.mk</code> takes a list and uses <code>red</code>, <code>free_group.red.length</code> proves that length decreases under <code>red</code>, and <code>free_group.inv_mk</code> reverses a list, so preserves length. Hope that helps!</p>



<a name="290224723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290224723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290224723">(Jul 20 2022 at 11:54)</a>:</h4>
<p>Feel free to paste if you feel it's going in the direction you were headed at (this way there is fewer chances of commits crossing, etc). I'll think more about how to go forward with it, without much guarantee!</p>



<a name="290229591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290229591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290229591">(Jul 20 2022 at 12:46)</a>:</h4>
<p>I had added some of the inv_rev lemmas to free_group on another branch -- it is in <a href="https://github.com/leanprover-community/mathlib/pull/15503">https://github.com/leanprover-community/mathlib/pull/15503</a></p>



<a name="290229806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290229806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290229806">(Jul 20 2022 at 12:48)</a>:</h4>
<p><span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> the monoid stuff in the def of <code>residually</code> is just there to get it to find the instance of has_one.  I'm not sure how to quantify over groups and get type class inference to pick up the <code>group</code> instance.</p>



<a name="290234146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290234146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290234146">(Jul 20 2022 at 13:28)</a>:</h4>
<p><span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> Your additions to <code>properties.lean</code> are great!</p>



<a name="290235151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290235151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290235151">(Jul 20 2022 at 13:36)</a>:</h4>
<p><span class="user-mention" data-user-id="466727">@Jim Fowler</span> Great, do you have any when your PR will get merged?</p>
<p>In the meantime, I've tried tackling <code>to_word_inv_length</code> below: as far as I know, it works correctly, though the code is far from good.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">to_word_inv_length</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">free_group</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹.</span><span class="n">to_word.length</span> <span class="bp">≤</span> <span class="n">x.to_word.length</span> <span class="o">:=</span>
<span class="kd">begin</span>

  <span class="k">let</span> <span class="n">xi</span> <span class="o">:=</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">xw</span> <span class="o">:=</span> <span class="n">x.to_word</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">xiw</span> <span class="o">:=</span> <span class="n">x</span><span class="bp">⁻¹.</span><span class="n">to_word</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">xwi</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x.to_word.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">),</span> <span class="o">(</span><span class="n">y.fst</span><span class="o">,</span> <span class="bp">!</span><span class="n">y.snd</span><span class="o">)))</span><span class="bp">.</span><span class="n">reverse</span><span class="o">,</span>

  <span class="k">have</span> <span class="n">xi_eq_mk_xwi</span> <span class="o">:</span> <span class="n">xi</span> <span class="bp">=</span> <span class="n">free_group.mk</span> <span class="n">xwi</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">free_group.inv_mk</span><span class="o">,</span> <span class="n">free_group.to_word.mk</span><span class="o">],</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">free_group.reduce</span> <span class="n">xwi</span> <span class="bp">=</span> <span class="o">(</span><span class="n">free_group.mk</span> <span class="n">xwi</span><span class="o">)</span><span class="bp">.</span><span class="n">to_word</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">free_group.reduce</span> <span class="n">xwi</span> <span class="bp">=</span> <span class="n">xiw</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="bp">←</span><span class="n">xi_eq_mk_xwi</span><span class="o">],</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">free_group.red</span> <span class="n">xwi</span> <span class="n">xiw</span> <span class="o">,</span> <span class="k">from</span> <span class="n">this</span> <span class="bp">▸</span> <span class="n">free_group.reduce.red</span><span class="o">,</span>

  <span class="k">have</span> <span class="o">:</span> <span class="n">xwi.length</span> <span class="bp">≥</span> <span class="n">xiw.length</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">rcases</span> <span class="n">free_group.red.length</span> <span class="n">this</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span><span class="n">p</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">le_iff_exists_add.mpr</span> <span class="o">⟨</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">,</span><span class="n">p</span><span class="o">⟩,</span>
  <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">list.length_reverse</span><span class="o">,</span><span class="n">list.length_map</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="290238048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290238048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290238048">(Jul 20 2022 at 13:57)</a>:</h4>
<p>Perhaps it's best to wait till <span class="user-mention" data-user-id="466727">@Jim Fowler</span> 's PR is merged? That will make all the lemmas shorter in marked_groups. I can then do the integration. Or is there a way to temporarily merge your PR without completely messing up git?</p>



<a name="290240276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290240276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290240276">(Jul 20 2022 at 14:12)</a>:</h4>
<p>(deleted)</p>



<a name="290246253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290246253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290246253">(Jul 20 2022 at 14:55)</a>:</h4>
<p><span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> (I've updated my snippet with an impl for <code>to_word_mul_length</code> too)<br>
Whichever way you prefer, though note that <span class="user-mention" data-user-id="466727">@Jim Fowler</span> 's PR is for <code>master</code>, if I'm not mistaken. This means both that it may take some time to get merged, and that our including a patchy version for the time being in <code>geometric-group-theory</code> won't mess up anything with git as far as I'm aware.</p>



<a name="290273921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290273921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290273921">(Jul 20 2022 at 18:04)</a>:</h4>
<p>OK, I've included <span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> 's code in marked_group.lean. In principle, we have all the lemmas to assert the existence of a metric space!</p>
<p>I confess I haven't totally [= not at all] understood how to create a new type such that <code>[marked_group MG]</code> asserts that MG is a group with marking. I have created a tentative growth.lean file to see how the API could develop.</p>
<p>For some practical applications I have in mind, it may be nice to have more general metrics: word metrics with weights, and restrictions of the word metric to a subgroup. There too, I'm not yet sure about how best to create the structures.</p>



<a name="290340083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290340083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290340083">(Jul 21 2022 at 06:59)</a>:</h4>
<p>I've made a few changes to <code>marked_group.lean</code> but it's not pushed to your branch: <a href="https://github.com/bottine/mathlib/blob/geometric-group-theory/src/group_theory/geometric/marked_group.lean">see my repo</a>. I've split the <code>group_norm_one</code> into a sublemma because I needed it later on, and mostly I've started an attempt at showing that two finite generating sets induce equivalent norms. For this I've had to define a few more lemmas on the free group (unproved yet but should be easy enough). I've also added a few natural stubs: e.g. the only elements of norm one are letters.</p>



<a name="290363767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290363767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290363767">(Jul 21 2022 at 11:35)</a>:</h4>
<p>Yes, that's definitely the right direction!<br>
0) if I may ask, why do you prefer working in a fork?<br>
1) my aims are multiple:<br>
1.1) to be able to formalize lots of geometric group theory, which relies on having a metric space instance starting from a finitely generated group; this includes the Svarc-Milnor lemma, ends of groups, hyperbolic, CAT(0) groups, etc.<br>
1.2) to formalize growth of groups; in particular, the Dixmier-Bass-Guivarch result that virtually nilpotent groups have polynomial growth; the Milnor-Wolf result that virtually solvable groups have either polynomial or exponential growth; the Grigorchuk result that there are groups of intermediate growth; and (probably harder) the Gromov result that polynomial-growth groups are virtually nilpotent.<br>
1.3) to formalize, more generally, the "space of marked groups" as a compact topological space; and results about openness / closedness / G_delta genericity of various group properties.<br>
2) here is my idea of a roadmap:<br>
2.1) have a robust class "marked_group" which is a group on which a marking is registered; this will be useful for all the goals in 1)<br>
2.2) different people can then develop independently the different consequences: growth, group properties, space of marked groups, and "pure geometric group theory" i.e. ends and actions on nice spaces (CAT(0), delta-hyperbolic, wall space, median space, ...)<br>
3) in your lemma <code>lemma group_norm_letter</code> on line 120 there's a good reason the proof is <code>sorry</code>, and that the lemma's wrong! indeed nothing prevents an element of S to be mapped to 1:G. The correct one would have "\le 1". For the same reason, <code>lemma group_norm_one_iff_is_letter</code> on line 121 is wrong if G is the trivial group.</p>
<p>Now I must confess I feel a bit bad about writing this roadmap, feeling like an orchestra conductor who can't play a single instrument. It's just my opinion on what would be good, and I'd love a discussion about it.</p>



<a name="290364836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290364836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290364836">(Jul 21 2022 at 11:45)</a>:</h4>
<p>0) I don't prefer working in a fork at all: it's just that I'm not sure my changes were agreeable, and wanted to share them before committing them (my own "fork" is just a way to work without polluting the official repo).<br>
1) Great: I pretty much have the exact same goals. I would very much like to prove Stalling's ends theorem eventually, hence working on ends and Bass-Serre seems like a good start.<br>
2) I know the feeling!<br>
3) Good point, what about adding <code>m.marking (free_group.mk p) ≠ 1</code>? Maybe that's useless as a lemma…</p>



<a name="290365220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290365220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290365220">(Jul 21 2022 at 11:50)</a>:</h4>
<p>Please avoid touching the branch right now! I am implementing the type synonym approach.</p>



<a name="290367422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290367422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290367422">(Jul 21 2022 at 12:14)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> great, I'll keep my hands off the keyboard.<br>
<span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> , I don't think it's a good idea to forbid trivial generators; for example, it's nice to know that if G is a marked group then every quotient of G inherits the marking. Also, you must have the trivial group in the space of marked groups. Also, your lemmas at line 120-121 aren't used. Did you have an application in mind?</p>



<a name="290368077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290368077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290368077">(Jul 21 2022 at 12:22)</a>:</h4>
<p>no use, I just felt they  (or a suitably corrected versions) might come handy later on. <br>
And from the little I learned about mathlib, the rule of thumb looks to be: as few defs as possible, as many lemmas as possible. <br>
But we can drop them, obviously.</p>



<a name="290394101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290394101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290394101">(Jul 21 2022 at 15:51)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> Line 51 is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">free_group.mk.singleton</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">free_group.mk</span> <span class="o">[</span><span class="n">p</span><span class="o">])</span><span class="bp">.</span><span class="n">to_word</span> <span class="bp">=</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>and this isn't in <a href="https://github.com/leanprover-community/mathlib/pull/15503">https://github.com/leanprover-community/mathlib/pull/15503</a> but it could be added.  There's a lot of relevant lemmas for words and the free group...</p>



<a name="290394227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290394227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290394227">(Jul 21 2022 at 15:52)</a>:</h4>
<p>In terms of goals, I think ends of groups would be a great first goal.</p>



<a name="290409596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290409596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290409596">(Jul 21 2022 at 17:45)</a>:</h4>
<p>I am not convinced that the basic object is marked groups. Instead, I'd go for groups with a left-invariant distance: there are many examples where the relevant distance is not a word distance (as a basic example, just think of the case where you don't give length 1 to all generators). Unfortunately, in mathlib currently <code>normed_group</code> is reserved for additive groups, but we could make the case that this should be renamed to <code>normed_add_group</code>.</p>



<a name="290409847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290409847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290409847">(Jul 21 2022 at 17:47)</a>:</h4>
<p>Have you seen the definitions of <code>normed_mul_group</code> and <code>isom_action</code> on <a href="https://github.com/leanprover-community/mathlib/tree/geometric-group-theory">branch#geometric-group-theory</a>?</p>



<a name="290410005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290410005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290410005">(Jul 21 2022 at 17:48)</a>:</h4>
<p>I am currently PRing group seminorms with the hope to turn around the dependency between <code>seminorm</code> and <code>normed_group</code> and eventually move <code>normed_mul_group</code> to mathlib.</p>



<a name="290411059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290411059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290411059">(Jul 21 2022 at 17:57)</a>:</h4>
<p>No, I haven't opened the branch, I'm just writing random thoughts on Zulip :-)</p>
<p>Changing the current <code>normed_group</code> to <code>normed_add_group</code> would make a lot of sense, IMHO.</p>



<a name="290411175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290411175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290411175">(Jul 21 2022 at 17:58)</a>:</h4>
<p>I agree, but I didn't dare to suggest it because it's used in 182 files :P</p>



<a name="290411443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290411443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290411443">(Jul 21 2022 at 18:00)</a>:</h4>
<p><code>normed_add_group</code> seems like a great improvement.  I don't think there is any sort of automated way of renaming identifiers?</p>



<a name="290411588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290411588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290411588">(Jul 21 2022 at 18:01)</a>:</h4>
<p>No but it's not hard to do by hand. If people agree on the rename, I can do that in a few minutes.</p>



<a name="290412003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290412003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290412003">(Jul 21 2022 at 18:05)</a>:</h4>
<p>I would like to better understand current mathlib idioms for attaching a symmetry group to an object.</p>



<a name="290412225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290412225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jim Fowler <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290412225">(Jul 21 2022 at 18:06)</a>:</h4>
<p>It's really great to see all of <span class="user-mention" data-user-id="466209">@Georgi Kocharyan</span> 's work in this branch too.</p>



<a name="290414367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290414367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290414367">(Jul 21 2022 at 18:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> : in fact it was my initial hope to have more general metrics. The worry I had is that the process would never leave the ground if we aim for too general in the beginning: for example, you'll have to make the metric be proper even before mentioning growth functions. In an ideal world, I would see the following:</p>
<ul>
<li>metric spaces with a left action by isometries</li>
<li>as a special case, a homogeneous space G/P with metric induced from a metric on G</li>
<li>as a sub-special case, G/P with a metric induced by weights on a [finite?] generating set of G</li>
<li>as a sub^2-special case, G/P with the word metric from G</li>
<li>as another sub^2-special case, G with a metric induced by weights on a [finite?] generating set of G</li>
<li>as a sub^3 special case, G with the word metric</li>
</ul>
<p>and automatic ways of converting each special case to less special one whenever the more general theorem holds.</p>
<p>I don't think I have enough wizard powers to implement this, though. Do you think it's feasible?</p>



<a name="290419946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290419946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290419946">(Jul 21 2022 at 19:04)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I just looked at your code, it's beautiful!<br>
Though I have a problem with the "normed_mul_group": defining the metric by <code>dist x y =  ∥x/y∥</code> makes is right invariant, while all of lean seems to be built on left actions and left invariance. I tried to change it to <code>dist x y =  ∥x⁻¹*y∥</code> (see the most recent commit), but of course nothing works quite as before. Feel free to revert.</p>



<a name="290420064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290420064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290420064">(Jul 21 2022 at 19:05)</a>:</h4>
<p>Thanks! Glad you like it <span aria-label="smiling face" class="emoji emoji-263a" role="img" title="smiling face">:smiling_face:</span></p>



<a name="290420318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290420318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290420318">(Jul 21 2022 at 19:07)</a>:</h4>
<p>I picked this direction because eventually we will refactor <a href="https://leanprover-community.github.io/mathlib_docs/find/normed_group">docs#normed_group</a> to be the additivized version of <code>normed_mul_group</code>, and it uses <code>dist x y = ∥x - y∥</code>.</p>



<a name="290420435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290420435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290420435">(Jul 21 2022 at 19:08)</a>:</h4>
<p>Note however that <code>normed_group</code> is already assumed to be commutative, so we might be able to work around it, but it will be painful.</p>



<a name="290421971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290421971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290421971">(Jul 21 2022 at 19:21)</a>:</h4>
<p>There's no doubt that mathematically Laurent's definition is the right one. Even in the additive case, it would feel more natural to me to have <code>dist x y = ∥y - x∥</code>, by the way.</p>



<a name="290425955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290425955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290425955">(Jul 21 2022 at 19:56)</a>:</h4>
<p><code>∥y - x∥</code> is still right-invariant, right?</p>



<a name="290426152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290426152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290426152">(Jul 21 2022 at 19:58)</a>:</h4>
<p>On a side note, I had to add lemmas</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_mul_inv_cancel</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹*</span><span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹*</span><span class="n">y</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span><span class="bp">⁻¹*</span><span class="n">z</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">group</span>
<span class="kd">lemma</span> <span class="n">inv_of_inv_mul</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹*</span><span class="n">y</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="n">y</span><span class="bp">⁻¹*</span><span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">group</span>
</code></pre></div>
<p>which I couldn't find in the library -- algebra.group.basic seems to mainly consist of lemmas for commutative (multiplicative and additive) groups, and I found no basic lemmas in group_theory.</p>
<p>Yet another side note: I would like (with the help of a student) to extend group_theory.commutator. I respect the fact that left actions are used by default in Lean; but it would be nice to have a notation for it (it's exponentiation for a right action). Is there some standard one? Otherwise, I would propose ⇀, ⇁ or ⊸, something like <code>infix `⊸`:200 := λ x y,x*y/x </code>. It would also be nice to have iterated commutators; I can use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="bp">`⁅`</span><span class="n">x</span><span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">y</span><span class="bp">`</span><span class="o">,</span><span class="bp">`</span> <span class="n">z</span><span class="bp">`⁆`</span> <span class="o">:=</span> <span class="o">(</span><span class="n">has_bracket.bracket</span> <span class="n">x</span> <span class="o">(</span><span class="n">has_bracket.bracket</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⁅</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">y</span><span class="bp">⁆=</span><span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">group</span>
</code></pre></div>
<p>but it would be nice to have right associativity for the non-infix operation.</p>



<a name="290426635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290426635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290426635">(Jul 21 2022 at 20:01)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> and <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> we want <code>∥-x + y∥</code> if we're ever going to consider non-commutative additive groups :tongue-in-cheek:</p>



<a name="290427207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290427207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290427207">(Jul 21 2022 at 20:06)</a>:</h4>
<p>There is little point in adding all possible lemmas about group operations, when you can get there with one or two existing ones. The first is <code>rw [mul_assoc, mul_inv_cancel_left]</code>, and the second is <code>rw [mul_inv_rev, inv_inv]</code>.</p>



<a name="290427654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290427654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290427654">(Jul 21 2022 at 20:09)</a>:</h4>
<p><a href="https://tqft.net/mathlib/algebra">file#algebra</a>.group.basic is the right file to look at. I do not quite get what you mean about it being mostly for commutative groups, given that there are 99 lemmas in there that apply to the noncommutative setting.</p>



<a name="290432322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290432322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290432322">(Jul 21 2022 at 20:49)</a>:</h4>
<p>Thanks, I golfed the proofs and just pushed them using your suggestion. I also removed a sorry from instance:normed_mul_group</p>



<a name="290462711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290462711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290462711">(Jul 22 2022 at 04:15)</a>:</h4>
<p>Re "the right basic object", the <a href="https://www.normalesup.org/~cornulier/MetricLC.pdf">Proposition 1.A.1 in Cornulier &amp; de la Harpe,p. 10 </a> seemed to me to be exactly what we should aim for (see also the text up until 1.B) but I had the same fear that it might be too general to start with?</p>



<a name="290473738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290473738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Georgi Kocharyan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290473738">(Jul 22 2022 at 07:27)</a>:</h4>
<p>Looking forward to working on this with everyone! Would I be able to have writing rights on the repo? My github is GregorSamsa42 :)</p>



<a name="290475198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290475198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290475198">(Jul 22 2022 at 07:48)</a>:</h4>
<p><span class="user-mention" data-user-id="466209">@Georgi Kocharyan</span>: by the way, if there are places in your code where you'd trust a beginner to fill in some holes, I'd welcome the opportunity.</p>



<a name="290481295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290481295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Georgi Kocharyan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290481295">(Jul 22 2022 at 09:00)</a>:</h4>
<p>As I am also a beginner you are more than welcome !</p>



<a name="290510569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290510569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290510569">(Jul 22 2022 at 14:10)</a>:</h4>
<p>Alright! anything in particular?</p>



<a name="290521841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290521841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Laurent Bartholdi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290521841">(Jul 22 2022 at 15:01)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> I just pushed some definitions from Cornulier&amp;Harpe to your (nice) new file on coarse pseudometric spaces. Hopefully this will connect nicely with the rest of the code</p>



<a name="290523295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Word%20metric%20on%20group%20--%20a%20new%20attempt/near/290523295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt.html#290523295">(Jul 22 2022 at 15:11)</a>:</h4>
<p>Beware, though! After discussing on github (I have a pull request open for this file), i noticed that my definitions are quite (dangerously?) different from the official ones. For density, I'm using the existence of a close point with "≤", instead of Hausdorff distance with "&lt;", and for separation I use "&lt;" instead of "≤". I admit I like my definitions, since they allow a very clean statement in the last theorem, but wonder if they are dangerous as of now…</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
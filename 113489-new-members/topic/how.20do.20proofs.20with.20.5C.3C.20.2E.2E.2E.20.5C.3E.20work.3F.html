---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html">how do proofs with \< ... \> work?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="223603193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223603193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223603193">(Jan 22 2021 at 04:37)</a>:</h4>
<p>Hi, I'm new to Lean.</p>
<p>I saw some examples where<br>
<code>lemma self_mem_coset (a : G) (H : subgroup G) : a ∈ a ⋆ H := ⟨1, H.one_mem, (group.mul_one a).symm⟩</code>.<br>
I'm unsure how to read this proof.</p>
<p>I know that <code>⟨..., ...⟩</code> represents a dependent pair (sigma type) and means that "the type of the second element of the pair, b : β a, depends on the first element of the pair, a : α"<br>
from <a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html</a></p>
<p>What does it translate to in tactics?</p>
<p>Thanks :)</p>



<a name="223603282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223603282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223603282">(Jan 22 2021 at 04:39)</a>:</h4>
<p>Can you say where you found that lemma?</p>



<a name="223603335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223603335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223603335">(Jan 22 2021 at 04:40)</a>:</h4>
<p>Even better, provide a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="223603417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223603417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223603417">(Jan 22 2021 at 04:42)</a>:</h4>
<p>In any case, the point is that to prove that some element  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> of a group is a member of a coset associated to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>, you have to prove that there exists an element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> in the subgroup <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mi>a</mi><mo>⋅</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">g = a \cdot h</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>. In the case <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">g = a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>, you take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h = 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, so that's the first <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> appearing there. The <code>H.one_mem</code> is the proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> is an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> (which is a subgroup of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>), while <code>group.mul_one a</code> is the proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>a</mi><mo>⋅</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a = a \cdot 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, while <code>symm</code> means reverse the equality.</p>



<a name="223603421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223603421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223603421">(Jan 22 2021 at 04:42)</a>:</h4>
<p>A mwe would be helpful, but here's a guess of a tactic proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">use</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">H.one_mem</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">group.mul_one</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="223603581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223603581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223603581">(Jan 22 2021 at 04:46)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span>  I found it here: <a href="https://github.com/ImperialCollegeLondon/group-theory-game/blob/master/src/subgroup/basic.lean#L191">https://github.com/ImperialCollegeLondon/group-theory-game/blob/master/src/subgroup/basic.lean#L191</a></p>



<a name="223603644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223603644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223603644">(Jan 22 2021 at 04:48)</a>:</h4>
<p>but how should I interpret the <code>⟨..., ...⟩</code> more generally? Is it just used to sequence terms one after the other? since each spot in the tuple is dependent on the spot before it? (sorry, I don't know if "spot" is the right word to use here)</p>



<a name="223604054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223604054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223604054">(Jan 22 2021 at 05:00)</a>:</h4>
<p>Its called an anonymous constructor, see <a href="https://leanprover.github.io/reference/declarations.html#structures-and-records">https://leanprover.github.io/reference/declarations.html#structures-and-records</a></p>



<a name="223604241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223604241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223604241">(Jan 22 2021 at 05:03)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="127136">@Alex J. Best</span> ! That's exactly the info I needed. So does this mean that it doesn't correspond to a term of a sigma type?</p>



<a name="223604608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223604608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223604608">(Jan 22 2021 at 05:11)</a>:</h4>
<p>Right, its much more general, you can make terms of sigma types with it like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">t</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">n</span><span class="o">,</span> <span class="n">vector</span> <span class="n">ℤ</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">vector.nil</span><span class="o">⟩</span>
</code></pre></div>
<p>but we can also make a term of type <code>vector ℤ 1</code> with this notation, a vector is a list of a fixed length, so it has one constructor, the list and the proof that it has that length, so this is <code>⟨[1], by simp⟩ : vector ℤ 1</code>. The fun begins when we can combine these:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">t'</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">n</span><span class="o">,</span> <span class="n">vector</span> <span class="n">ℤ</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="o">⟨[</span><span class="mi">1</span><span class="o">],</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩⟩</span>
<span class="c1">-- we can remove the nesting which is what makes this notation so powerful:</span>
<span class="kd">def</span> <span class="n">t''</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="n">n</span><span class="o">,</span> <span class="n">vector</span> <span class="n">ℤ</span> <span class="n">n</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>
</code></pre></div>



<a name="223608879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223608879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223608879">(Jan 22 2021 at 06:52)</a>:</h4>
<p>Another place where they can occur is in the proof of iff statements.  In this case you would have </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">⟨</span><span class="n">proof</span> <span class="n">of</span> <span class="bp">→</span><span class="o">,</span> <span class="n">proof</span> <span class="n">of</span> <span class="bp">←</span><span class="o">⟩</span>
</code></pre></div>



<a name="223609834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223609834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223609834">(Jan 22 2021 at 07:13)</a>:</h4>
<p>Damiano, you were talking about structures recently -- you can make a term of any structure using this pointy bracket notation. The things in the bracket are the inputs for the constructor.</p>



<a name="223610109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223610109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223610109">(Jan 22 2021 at 07:19)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> Note that <code>iff</code> is just a special case of what Alex said! It's also just a structure (-;</p>



<a name="223610625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223610625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223610625">(Jan 22 2021 at 07:29)</a>:</h4>
<p>Ah, thanks for the information: I did not know that these were all special cases of the same construction!</p>



<a name="223657978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223657978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223657978">(Jan 22 2021 at 15:43)</a>:</h4>
<p>In the example shown here <a href="https://leanprover.github.io/reference/declarations.html#structures-and-records">https://leanprover.github.io/reference/declarations.html#structures-and-records</a>,<br>
I'm still a little confused as to why <code>⟨ b₁, b₂, f₁, ..., fₙ ⟩</code> is equivalent to <code>foo.constructor b₁ b₂ f₁ f₁ ... fₙ</code>.<br>
My understanding is that a structure is a pi-type with type former : <code>foo : Π (a : α), Sort u</code><br>
Wouldn't a term of the type formed by the structure need to be of a pi-type?<br>
I thought <code>⟨ ...⟩</code> meant it's a term of a sigma-type.</p>
<p>Thanks again!<br>
(I managed to translate a few of the proofs done with <code>⟨ ...⟩</code> into tactic proofs and am getting a better intuition toward it but I think I haven't yet wrapped my head completely around it)</p>



<a name="223671655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223671655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223671655">(Jan 22 2021 at 17:22)</a>:</h4>
<p>The bracket notation is really for any inductive type with only one constructor, check out these examples for instance:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">foo</span>
<span class="k">#check</span> <span class="o">(⟨⟩</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">bar</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">bar</span> <span class="bp">→</span> <span class="n">bar</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(⟨⟨⟨</span><span class="n">l</span><span class="o">⟩⟩⟩</span> <span class="o">:</span> <span class="n">bar</span><span class="o">)</span>
</code></pre></div>



<a name="223674055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223674055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223674055">(Jan 22 2021 at 17:42)</a>:</h4>
<p>I think the confusion comes from families of types, but the notation works in the same way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">foo</span>
<span class="k">#check</span> <span class="o">(⟨⟩</span> <span class="o">:</span> <span class="n">foo</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div>



<a name="223676329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223676329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223676329">(Jan 22 2021 at 17:59)</a>:</h4>
<p>ok I'm not sure why I was assuming that <code>⟨ ...⟩</code> was only for sigma types.<br>
I just looked at the sigma type definition (<a href="https://github.com/leanprover/lean/blob/72a965986fa5aeae54062e98efb3140b2c4e79fd/library/init/core.lean#L247">https://github.com/leanprover/lean/blob/72a965986fa5aeae54062e98efb3140b2c4e79fd/library/init/core.lean#L247</a>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">sigma</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">fst</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">snd</span> <span class="o">:</span> <span class="n">β</span> <span class="n">fst</span><span class="o">)</span>
</code></pre></div>
<p>and it has only one constructor and if I'm not mistaken a <code>structure</code> is an <code>inductive</code>.<br>
This means we can use the "anonymous constructor" <code>⟨ ...⟩</code> to create a term of type <code>sigma</code>.</p>
<p>So if I understood correctly, <code>⟨ ...⟩</code> is not specific to sigma types but instead is specific to inductive types.</p>



<a name="223676997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223676997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223676997">(Jan 22 2021 at 18:04)</a>:</h4>
<p>*with one constructor</p>



<a name="223677049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223677049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223677049">(Jan 22 2021 at 18:04)</a>:</h4>
<p>You can't use it on <code>or</code>, which has two</p>



<a name="223685681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/how%20do%20proofs%20with%20%5C%3C%20...%20%5C%3E%20work%3F/near/223685681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> François Sunatori <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/how.20do.20proofs.20with.20.5C.3C.20.2E.2E.2E.20.5C.3E.20work.3F.html#223685681">(Jan 22 2021 at 19:16)</a>:</h4>
<p>thanks <span class="user-mention" data-user-id="310045">@Eric Wieser</span> <span class="user-mention" data-user-id="127136">@Alex J. Best</span>   you're explanations really helped me understand this :) and thanks everyone else as well for all your clues to help me untangle this!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Tactics.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html">Tactics</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="195318228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318228">(Apr 26 2020 at 05:19)</a>:</h4>
<p>I'm not fully grasping  what the tactics are doing in this proof. I've written a comment that is how I'm thinking of it on paper but not sure if that's correct.</p>
<div class="codehilite"><pre><span></span>        <span class="kn">theorem</span> <span class="n">even_plus_even2</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span>
            <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_even</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">is_even</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_even</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
                <span class="k">match</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span> <span class="k">with</span>
                    <span class="bp">⟨</span><span class="n">w1</span><span class="o">,</span> <span class="n">hw1</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">w2</span><span class="o">,</span> <span class="n">hw2</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">w1</span> <span class="bp">+</span> <span class="n">w2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hw1</span><span class="o">,</span> <span class="n">hw2</span><span class="o">,</span> <span class="n">mul_add</span><span class="o">]</span><span class="bp">⟩</span>
                <span class="kn">end</span>
        <span class="c">/-</span><span class="cm"></span>
<span class="cm">        ∃ w1, a = 2 * w1</span>
<span class="cm">        w1 : ℕ</span>
<span class="cm">        hw1 : a = 2 * w1</span>
<span class="cm">        ∃ w2, b = 2 * w2</span>
<span class="cm">        w2 : ℕ</span>
<span class="cm">        hw2 : b = 2 * w2</span>
<span class="cm">        w1 = a/2, w2 = b/2</span>
<span class="cm">        w1 + w2 = a/2 + b/2</span>
<span class="cm">        a + b = 2 * (w1 + w2)</span>
<span class="cm">        -/</span>
</pre></div>



<a name="195318664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318664">(Apr 26 2020 at 05:35)</a>:</h4>
<p>This proof looks okay (but you didn't provide a MWE). What error do you get?</p>



<a name="195318727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318727">(Apr 26 2020 at 05:37)</a>:</h4>
<p>Or is the proof correct and you don't understand how it works?</p>



<a name="195318769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318769">(Apr 26 2020 at 05:38)</a>:</h4>
<p>The proof is correct I'm just trying to understand what's going on under the hood</p>



<a name="195318771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318771">(Apr 26 2020 at 05:38)</a>:</h4>
<p>Actually there aren't really any tactics in this proof except <code>rw</code>. The <code>match</code> is pattern matching on <code>h1</code> and <code>h2</code>, which are existential statements once you unfold the definition of <code>is_even</code>, to produce <code>w1</code> and <code>hw1 : a = 2 * w1</code> and similarly for <code>w2</code></p>



<a name="195318779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318779">(Apr 26 2020 at 05:39)</a>:</h4>
<p>yeah I understand match I just dont fully understand the <code>,by rw [hw1, hw2, mul_add]</code></p>



<a name="195318783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318783">(Apr 26 2020 at 05:39)</a>:</h4>
<p>The right hand side is similarly building an existential proof saying <code>w1 + w2</code> suffices, and so the <code>by rw</code> proof needs to prove <code>a + b = 2 * (w1 + w2)</code></p>



<a name="195318828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318828">(Apr 26 2020 at 05:40)</a>:</h4>
<p>Then the rewrites respectively change the goal to <code>2 * w1 + b = 2 * (w1 + w2)</code> and <code>2 * w1 + 2 * w2 = 2 * (w1 + w2)</code>, and the final <code>mul_add</code> rewrites the right hand side to <code>2 * w1 + 2 * w2 = 2 * w1 + 2 * w2</code>. Since this is true by reflexivity it closes the goal</p>



<a name="195318835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318835">(Apr 26 2020 at 05:40)</a>:</h4>
<p>At least, that's what the lean in my head would do, since that's not an MWE I can't test it</p>



<a name="195318882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318882">(Apr 26 2020 at 05:42)</a>:</h4>
<p>Ohhh that makes sense, thanks!</p>



<a name="195318887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318887">(Apr 26 2020 at 05:42)</a>:</h4>
<p>So rewrite is a substitution rule</p>



<a name="195318888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frank Dai <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318888">(Apr 26 2020 at 05:42)</a>:</h4>
<p>you can also expand <code>by rw [a, b, c]</code> into <code>begin rw a, rw b, rw c, end</code> and step through it</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">even_plus_even2</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span>
    <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_even</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">is_even</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_even</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
        <span class="k">match</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span> <span class="k">with</span>
            <span class="bp">⟨</span><span class="n">w1</span><span class="o">,</span> <span class="n">hw1</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">w2</span><span class="o">,</span> <span class="n">hw2</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">w1</span> <span class="bp">+</span> <span class="n">w2</span><span class="o">,</span> <span class="k">begin</span>
              <span class="n">rw</span> <span class="n">hw1</span><span class="o">,</span>
              <span class="n">rw</span> <span class="n">hw2</span><span class="o">,</span>
              <span class="n">rw</span> <span class="n">mul_add</span><span class="o">,</span>
              <span class="kn">end</span><span class="bp">⟩</span>
        <span class="kn">end</span>
 <span class="bp">```</span>
</pre></div>



<a name="195318891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318891">(Apr 26 2020 at 05:43)</a>:</h4>
<p>You should be able to step through it even if it is in <code>rw [a,b,c]</code> form</p>



<a name="195318892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318892">(Apr 26 2020 at 05:43)</a>:</h4>
<p>this is one of the special privileges of the <code>rw</code> tactic</p>



<a name="195318992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195318992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195318992">(Apr 26 2020 at 05:46)</a>:</h4>
<p>How does mul_add know to apply to the right hand side of the equation?</p>



<a name="195319004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319004">(Apr 26 2020 at 05:47)</a>:</h4>
<p>rw is rewriting terms on the LHS but mul_add works on the RHS.</p>



<a name="195319013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319013">(Apr 26 2020 at 05:47)</a>:</h4>
<p><code>⊢ 2 * w1 + 2 * w2 = 2 * (w1 + w2)</code></p>



<a name="195319108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319108">(Apr 26 2020 at 05:50)</a>:</h4>
<p><code>rw</code> will try to find the LHS of the input theorem anywhere in the goal, including on the RHS of the equality if the goal happens to be an equality</p>



<a name="195319119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319119">(Apr 26 2020 at 05:51)</a>:</h4>
<p>If you used mul_add the other way around, that is <code>rw &lt;- mul_add</code>, then it would try to find <code>a * b + a * c</code> somewhere in the goal instead. In this case it would still succeed, rewriting the LHS and resulting in <code>2 * (w1 + w2) = 2 * (w1 + w2)</code> which is also reflexivity</p>



<a name="195319239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319239">(Apr 26 2020 at 05:55)</a>:</h4>
<p>When we use tactics, what exactly is happening? Is it replacing the tactic command with lambda expressions under-the-hood? Doesn't everything ultimately need to be reduced to lambda expressions for type checking?</p>



<a name="195319562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319562">(Apr 26 2020 at 06:06)</a>:</h4>
<p>Did you look at the sources we linked <a href="#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/193395147" title="#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/193395147">here</a> when you asked this previously?</p>



<a name="195319687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319687">(Apr 26 2020 at 06:10)</a>:</h4>
<p>Yes, but I have zero background in functional programming. I know Python and R and Java and C.  So a "proof state" doesn't make sense to me in the first place. I am sort of learning how to prove basic things but I'm frustrated I don't know what's going on at the computer science level.</p>



<a name="195319702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319702">(Apr 26 2020 at 06:10)</a>:</h4>
<p>Behind the scenes Lean is building a term which has holes, metavariables, in it</p>



<a name="195319706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319706">(Apr 26 2020 at 06:11)</a>:</h4>
<p>as you use more tactics these holes get filled with more terms with holes until eventually the holes go away</p>



<a name="195319710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319710">(Apr 26 2020 at 06:11)</a>:</h4>
<p>each hole is marked with the type that is expected at that position, and that's the goal state that you see</p>



<a name="195319748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319748">(Apr 26 2020 at 06:12)</a>:</h4>
<p>It's very much like writing term mode proofs using <code>_</code></p>



<a name="195319758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319758">(Apr 26 2020 at 06:12)</a>:</h4>
<p>So in principle  there is a way to mechanistically translate a proof written using tactics into a term mode proof?</p>



<a name="195319762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319762">(Apr 26 2020 at 06:13)</a>:</h4>
<p>And get one ugly lambda expression at the other end</p>



<a name="195319763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319763">(Apr 26 2020 at 06:13)</a>:</h4>
<p><code>#print</code></p>



<a name="195319805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319805">(Apr 26 2020 at 06:14)</a>:</h4>
<p>See also the thread <a href="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189273625" title="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189273625">here</a></p>



<a name="195319806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319806">(Apr 26 2020 at 06:14)</a>:</h4>
<p>treat tactics as little C++ programs that help you write term mode proofs</p>



<a name="195319815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319815">(Apr 26 2020 at 06:15)</a>:</h4>
<p>Ohh, ok #print is exactly what I wanted to know</p>



<a name="195319819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319819">(Apr 26 2020 at 06:15)</a>:</h4>
<p>the lean kernel only knows term proofs, so tactics have to run to produce a term proof before the theorem can be accepted</p>



<a name="195319859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319859">(Apr 26 2020 at 06:16)</a>:</h4>
<p>these proofs are stored and <code>#print</code> recalls them</p>



<a name="195319863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319863">(Apr 26 2020 at 06:17)</a>:</h4>
<p><code>#print</code> is mentioned early on in the <a href="https://leanprover.github.io/theorem_proving_in_lean/tactics.html" title="https://leanprover.github.io/theorem_proving_in_lean/tactics.html">Tactics chapter of TPiL</a>.</p>



<a name="195319864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319864">(Apr 26 2020 at 06:17)</a>:</h4>
<p>I see - starting to make a lot more sense. I just couldnt understand why there seemed to be two completely different languages in the same language</p>



<a name="195319884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195319884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195319884">(Apr 26 2020 at 06:17)</a>:</h4>
<p>They call it metaprogramming because you are writing a program (tactic) to build a program (term)</p>



<a name="195320062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195320062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195320062">(Apr 26 2020 at 06:22)</a>:</h4>
<p>Ahh, your answer there about filling holes is very lucid, thanks</p>



<a name="195320116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195320116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195320116">(Apr 26 2020 at 06:24)</a>:</h4>
<p>Thanks for bearing with me - I'm actually a medical doctor just trying to learn more math so I have very little background in all of this</p>



<a name="195320243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/195320243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#195320243">(Apr 26 2020 at 06:29)</a>:</h4>
<p>Feel free to keep asking questions! There aren't very many introductory sources so most of us have been learning here.</p>



<a name="275152548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/275152548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Parivash <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#275152548">(Mar 13 2022 at 13:06)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">some_name</span> <span class="o">(</span><span class="n">θ</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">)(</span><span class="n">a</span> <span class="n">b</span> <span class="n">C</span> <span class="n">P</span> <span class="n">q</span> <span class="n">A</span> <span class="n">V₀</span> <span class="n">Vads</span> <span class="n">x</span> <span class="n">qq</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">)</span>
  <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">+</span> <span class="bp">∑'</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="bp">*</span> <span class="o">(</span><span class="n">θ</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">))</span>
  <span class="o">(</span><span class="n">hVads</span> <span class="o">:</span> <span class="n">Vads</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">+</span> <span class="bp">∑'</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="bp">*</span> <span class="o">(</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">^</span> <span class="n">k</span> <span class="bp">*</span> <span class="n">k</span><span class="o">)))(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">Vads</span> <span class="bp">/</span> <span class="n">A</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h4</span><span class="o">:</span> <span class="n">qq</span> <span class="bp">=</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">*</span> <span class="o">(</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">C</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">∑'</span> <span class="o">(</span><span class="n">x_1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">^</span> <span class="n">x_1</span><span class="o">)))</span> <span class="o">:</span>
  <span class="n">q</span> <span class="bp">=</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">∑'</span> <span class="o">(</span><span class="n">x_1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">^</span> <span class="n">x_1</span><span class="o">):=</span>
<span class="kd">begin</span>
  <span class="c">/-</span><span class="cm"> simp only [h1] at hA {single_pass := tt}, -/</span>
  <span class="c">/-</span><span class="cm"> rw pow_zero at hA, -/</span>
  <span class="c">/-</span><span class="cm"> rw one_mul at hA, -/</span>
  <span class="n">rw</span> <span class="n">tsum_mul_left</span> <span class="n">at</span> <span class="n">hA</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">tsum_mul_left</span> <span class="n">at</span> <span class="n">hA</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_assoc</span> <span class="n">at</span> <span class="n">hA</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">zero_mul</span> <span class="n">at</span> <span class="n">hVads</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">zero_add</span> <span class="n">at</span> <span class="n">hVads</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">tsum_mul_left</span> <span class="n">at</span> <span class="n">hVads</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">tsum_mul_left</span> <span class="n">at</span> <span class="n">hVads</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_assoc</span> <span class="n">at</span> <span class="n">hVads</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">left_distrib</span> <span class="n">at</span> <span class="n">h4</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hA</span> <span class="n">at</span> <span class="n">hq</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hVads</span> <span class="n">at</span> <span class="n">hq</span><span class="o">,</span>


<span class="kd">end</span>
</code></pre></div>
<p>Hi, I want to cancel <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mn>0</mn></mrow><annotation encoding="application/x-tex"> \theta 0 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">0</span></span></span></span> at hq. In other words, how can I take it out from numerator and denominator and then cancel it.</p>



<a name="275152724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/275152724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#275152724">(Mar 13 2022 at 13:11)</a>:</h4>
<p>Pasting that into an empty file yields a bunch of errors - can you create a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="275155928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/275155928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Parivash <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#275155928">(Mar 13 2022 at 14:01)</a>:</h4>
<p><span class="user-mention" data-user-id="307953">@Ruben Van de Velde</span> <br>
Not actually, let me provide the whole things that you can run it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"> Background Copy-/</span>
<span class="kn">import</span> <span class="n">analysis.specific_limits</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">algebra.group.defs</span>
<span class="kn">import</span> <span class="n">logic.function.basic</span>
<span class="kn">import</span> <span class="n">topology.algebra.infinite_sum</span>
<span class="kn">import</span> <span class="n">topology.algebra.group_with_zero</span>

<span class="c">/-</span><span class="cm"> left_comm has_mul.mul mul_comm mul_assoc-/</span>

<span class="n">mul_eq_of_eq_div'</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">/</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span> <span class="n">c</span><span class="o">,</span> <span class="n">mul_inv_cancel_left</span><span class="o">]</span> <span class="kd">end</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm"># Topology on `ℝ≥0`</span>
<span class="cm">The natural topology on `ℝ≥0` (the one induced from `ℝ`), and a basic API.</span>
<span class="cm">## Main definitions</span>
<span class="cm">Instances for the following typeclasses are defined:</span>
<span class="cm">* `topological_space ℝ≥0`</span>
<span class="cm">* `topological_semiring ℝ≥0`</span>
<span class="cm">* `second_countable_topology ℝ≥0`</span>
<span class="cm">* `order_topology ℝ≥0`</span>
<span class="cm">* `has_continuous_sub ℝ≥0`</span>
<span class="cm">* `has_continuous_inv' ℝ≥0` (continuity of `x⁻¹` away from `0`)</span>
<span class="cm">Everything is inherited from the corresponding structures on the reals.</span>
<span class="cm">## Main statements</span>
<span class="cm">Various mathematically trivial lemmas are proved about the compatibility</span>
<span class="cm">of limits and sums in `ℝ≥0` and `ℝ`. For example</span>
<span class="cm">* `tendsto_coe {f : filter α} {m : α → ℝ≥0} {x : ℝ≥0} :</span>
<span class="cm">  tendsto (λa, (m a : ℝ)) f (𝓝 (x : ℝ)) ↔ tendsto m f (𝓝 x)`</span>
<span class="cm">says that the limit of a filter along a map to `ℝ≥0` is the same in `ℝ` and `ℝ≥0`, and</span>
<span class="cm">* `coe_tsum {f : α → ℝ≥0} : ((∑'a, f a) : ℝ) = (∑'a, (f a : ℝ))`</span>
<span class="cm">says that says that a sum of elements in `ℝ≥0` is the same in `ℝ` and `ℝ≥0`.</span>
<span class="cm">Similarly, some mathematically trivial lemmas about infinite sums are proved,</span>
<span class="cm">a few of which rely on the fact that subtraction is continuous.</span>
<span class="cm">-/</span>
<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">topological_space</span> <span class="n">metric</span> <span class="n">filter</span>
<span class="n">open_locale</span> <span class="n">topological_space</span>

<span class="kn">namespace</span> <span class="n">nnreal</span>
<span class="n">open_locale</span> <span class="n">nnreal</span> <span class="n">big_operators</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">infer_instance</span> <span class="c1">-- short-circuit type class inference</span>

<span class="kn">section</span> <span class="n">coe</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">α</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">some_name</span> <span class="o">(</span><span class="n">θ</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">)(</span><span class="n">a</span> <span class="n">b</span> <span class="n">C</span> <span class="n">P</span> <span class="n">q</span> <span class="n">A</span> <span class="n">V₀</span> <span class="n">Vads</span> <span class="n">x</span> <span class="n">qq</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">)</span>
  <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">+</span> <span class="bp">∑'</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="bp">*</span> <span class="o">(</span><span class="n">θ</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">))</span>
  <span class="o">(</span><span class="n">hVads</span> <span class="o">:</span> <span class="n">Vads</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">+</span> <span class="bp">∑'</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="bp">*</span> <span class="o">(</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">^</span> <span class="n">k</span> <span class="bp">*</span> <span class="n">k</span><span class="o">)))(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">Vads</span> <span class="bp">/</span> <span class="n">A</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h4</span><span class="o">:</span> <span class="n">qq</span> <span class="bp">=</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">*</span> <span class="o">(</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">C</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">∑'</span> <span class="o">(</span><span class="n">x_1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">^</span> <span class="n">x_1</span><span class="o">)))</span> <span class="o">:</span>
  <span class="n">q</span> <span class="bp">=</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">θ</span> <span class="mi">0</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">∑'</span> <span class="o">(</span><span class="n">x_1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">^</span> <span class="n">x_1</span><span class="o">):=</span>
<span class="kd">begin</span>
  <span class="c">/-</span><span class="cm"> simp only [h1] at hA {single_pass := tt}, -/</span>
  <span class="c">/-</span><span class="cm"> rw pow_zero at hA, -/</span>
  <span class="c">/-</span><span class="cm"> rw one_mul at hA, -/</span>
  <span class="n">rw</span> <span class="n">tsum_mul_left</span> <span class="n">at</span> <span class="n">hA</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">tsum_mul_left</span> <span class="n">at</span> <span class="n">hA</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_assoc</span> <span class="n">at</span> <span class="n">hA</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">zero_mul</span> <span class="n">at</span> <span class="n">hVads</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">zero_add</span> <span class="n">at</span> <span class="n">hVads</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">tsum_mul_left</span> <span class="n">at</span> <span class="n">hVads</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">tsum_mul_left</span> <span class="n">at</span> <span class="n">hVads</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_assoc</span> <span class="n">at</span> <span class="n">hVads</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">left_distrib</span> <span class="n">at</span> <span class="n">h4</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hA</span> <span class="n">at</span> <span class="n">hq</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hVads</span> <span class="n">at</span> <span class="n">hq</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="275539861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/275539861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#275539861">(Mar 16 2022 at 16:38)</a>:</h4>
<p>Your code still doesn't compile for me, but anyway even after you fix this I think the answer will be that you can't cancel <code>θ 0</code> because you don't seem to have assumed anywhere that it is nonzero.</p>



<a name="275540187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Tactics/near/275540187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Tactics.html#275540187">(Mar 16 2022 at 16:40)</a>:</h4>
<p>Note that Lean does not check that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b\not=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> when you write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a/b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal">b</span></span></span></span>, it allows you to write nonsense, and just returns a junk value; you then can't use theorems about division because it is in the theorems where the hypothesis <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b\not=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> is required.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/working.20with.20sets.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html">working with sets</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="191530108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brian Jiang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530108">(Mar 23 2020 at 20:14)</a>:</h4>
<p>If I define a reduced residue class as follows:<br>
<code> def reduced_residue_class (n: nat):={ k : nat | k &lt; n \and k.coprime n } </code></p>



<a name="191530145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brian Jiang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530145">(Mar 23 2020 at 20:15)</a>:</h4>
<p>is there a way to get the size of this set?</p>



<a name="191530184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brian Jiang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530184">(Mar 23 2020 at 20:15)</a>:</h4>
<p>also I would like to get the product of all elements in the set</p>



<a name="191530223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530223">(Mar 23 2020 at 20:15)</a>:</h4>
<p>Well.... Lean doesn't know yet that the set is finite...</p>



<a name="191530276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530276">(Mar 23 2020 at 20:16)</a>:</h4>
<p>Even though it's obvious.</p>



<a name="191530368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530368">(Mar 23 2020 at 20:17)</a>:</h4>
<p>This might be one reason to choose</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">rsc</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">filter</span> <span class="err">$</span> <span class="k">assume</span> <span class="n">k</span><span class="o">,</span> <span class="n">k</span><span class="bp">.</span><span class="n">coprime</span> <span class="n">n</span>
</pre></div>



<a name="191530405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530405">(Mar 23 2020 at 20:17)</a>:</h4>
<p>Then you can talk about <code>finset.card _</code> afterwards</p>



<a name="191530445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brian Jiang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530445">(Mar 23 2020 at 20:17)</a>:</h4>
<p>is there any way around this? maybe by adding an assumption that says its finite?</p>



<a name="191530464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brian Jiang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530464">(Mar 23 2020 at 20:17)</a>:</h4>
<p>is there any way around this? maybe by adding an assumption that says its finite?</p>



<a name="191530577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brian Jiang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530577">(Mar 23 2020 at 20:18)</a>:</h4>
<p>ok thanks</p>



<a name="191530638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brian Jiang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530638">(Mar 23 2020 at 20:18)</a>:</h4>
<p>can I get the product of all elements in this set somehow?</p>



<a name="191530674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530674">(Mar 23 2020 at 20:19)</a>:</h4>
<p>also</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">mem_rsc</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">k</span> <span class="err">\</span><span class="k">in</span> <span class="n">rsc</span> <span class="n">n</span> <span class="err">\</span><span class="n">iff</span> <span class="o">(</span><span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="err">\</span><span class="n">and</span> <span class="n">k</span><span class="bp">.</span><span class="n">coprime</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>



<a name="191530713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530713">(Mar 23 2020 at 20:19)</a>:</h4>
<p>With the finset definition, the product is also easier.</p>



<a name="191530830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191530830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191530830">(Mar 23 2020 at 20:20)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">prod_rsc</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">(</span><span class="n">rsc</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="n">id</span>
</pre></div>



<a name="191531096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191531096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brian Jiang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191531096">(Mar 23 2020 at 20:22)</a>:</h4>
<p>what do I have to import for finset and prod?</p>



<a name="191531189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191531189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191531189">(Mar 23 2020 at 20:23)</a>:</h4>
<p>You can't take the product until you define the multiplication.</p>



<a name="191531429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191531429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191531429">(Mar 23 2020 at 20:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="269735">Brian Jiang</span> <a href="#narrow/stream/113489-new-members/topic/working.20with.20sets/near/191531096" title="#narrow/stream/113489-new-members/topic/working.20with.20sets/near/191531096">said</a>:</p>
<blockquote>
<p>what do I have to import for finset and prod?</p>
</blockquote>
<p><code>algebra.big_operators</code></p>



<a name="191532340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191532340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brian Jiang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191532340">(Mar 23 2020 at 20:33)</a>:</h4>
<p>@Kevin Buzzard : How may I define this multiplication?</p>



<a name="191532499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191532499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brian Jiang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191532499">(Mar 23 2020 at 20:34)</a>:</h4>
<p>also, would it be possible to define another set that has all the values of <code>rsc n </code> scaled by a factor of a?</p>



<a name="191534533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/191534533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#191534533">(Mar 23 2020 at 20:51)</a>:</h4>
<p>Well you can do regular multiplication and then reduce mod n -- but then you have to prove that the result is coprime to n. If you want to roll your own then you will have to do work before you can even start multiplying.</p>
<p>If you want to learn how to prove theorems in Lean than you could try working on the natural number game.</p>



<a name="278654728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278654728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matias Heikkilä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278654728">(Apr 12 2022 at 06:58)</a>:</h4>
<p>I'm trying to build a sort of "syntactic intuition" on lean. At this point I understand that implications (and the universal quantification) can be "peeled" with <code>intro</code> and the existential quantification can be "peeled" with <code>use</code>. Is there a similar pattern that could be used with something like this <a href="/user_uploads/3121/Q40TQPUJ3p_axzUR1hTTp7T5/image.png">image.png</a> ?</p>
<div class="message_inline_image"><a href="/user_uploads/3121/Q40TQPUJ3p_axzUR1hTTp7T5/image.png" title="image.png"><img src="/user_uploads/3121/Q40TQPUJ3p_axzUR1hTTp7T5/image.png"></a></div>



<a name="278654780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278654780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matias Heikkilä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278654780">(Apr 12 2022 at 06:59)</a>:</h4>
<p>I guess I would like to have the right side of the set builder notation as the claim to work with this in the elementary way (?)</p>



<a name="278654793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278654793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278654793">(Apr 12 2022 at 06:59)</a>:</h4>
<p>Try <code>dsimp</code> and you will see that this really is an hidden existential.</p>



<a name="278654928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278654928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matias Heikkilä <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278654928">(Apr 12 2022 at 07:00)</a>:</h4>
<p>thanks for the tip! would you say that<code>dsimp</code> is often useful with set builder notation?</p>



<a name="278655102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278655102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278655102">(Apr 12 2022 at 07:02)</a>:</h4>
<p>At the level of things you are doing now, <code>dsimp</code> only does cosmetic changes. You can delete them from your proof, and most likely everything will still work fine (except maybe <code>rw</code> because it works up to syntactical equality).</p>



<a name="278661155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278661155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278661155">(Apr 12 2022 at 08:18)</a>:</h4>
<p>Note that "set builder notation" is just the function <a href="https://leanprover-community.github.io/mathlib_docs/find/set_of">docs#set_of</a></p>



<a name="278803160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278803160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eleanor McMurtry <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278803160">(Apr 13 2022 at 09:08)</a>:</h4>
<p>so I'm working through this proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">conjugate</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">mysubgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">mysubgroup</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">h</span> <span class="bp">∈</span> <span class="n">H</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">h</span> <span class="bp">*</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">H.one_mem</span><span class="o">]⟩,</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">rintros</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">,</span> <span class="n">H.mul_mem</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="kd">by</span> <span class="n">group</span><span class="o">⟩,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">inv_mem'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="n">x</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">a</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="n">H.inv_mem</span> <span class="n">ha</span><span class="o">,</span> <span class="kd">by</span> <span class="n">group</span><span class="o">⟩</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>
<p>and I am a bit confused with how exactly <code>rfl</code> works in the <code>rintros</code> matching. my understanding is that <code>⟨a, ha⟩</code> binds to <code>∃ (h : G) (H : H ∈ H)</code>, and then I'm left with <code>x = g * h * g⁻¹</code>. what does putting <code>rfl</code> in for the last bit do exactly? does it just declare that <code>x = g * h * g⁻¹</code> is defined to be reflexively true or something?</p>



<a name="278803185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278803185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eleanor McMurtry <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278803185">(Apr 13 2022 at 09:08)</a>:</h4>
<p>like I get that <code>rfl : ∀ a. a = a</code> but I'm not sure what it does in this context</p>



<a name="278803382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278803382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278803382">(Apr 13 2022 at 09:10)</a>:</h4>
<p>This is not the same <code>rfl</code> as in <code>rfl : ∀ a, a = a</code>. This is part of the <code>rintro</code> syntax which automatically substitutes the LHS or RHS of an equality you introduce everywhere in the context, provided it is a single variable (so that substitution can work). So in that case it replaces <code>x</code> with <code>g * h * g⁻¹</code>.</p>



<a name="278803398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278803398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278803398">(Apr 13 2022 at 09:10)</a>:</h4>
<p>It is equivalent to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rintros</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">ha'</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">hb'</span><span class="o">⟩,</span>
<span class="n">subst</span> <span class="n">ha'</span> <span class="n">hb'</span><span class="o">,</span>
</code></pre></div>



<a name="278803576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278803576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eleanor McMurtry <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278803576">(Apr 13 2022 at 09:12)</a>:</h4>
<p>aha so <code>rfl</code> is just special syntax that is a shortcut for this?</p>



<a name="278803638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278803638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eleanor McMurtry <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278803638">(Apr 13 2022 at 09:13)</a>:</h4>
<p>wait that doesn't work Ruben</p>



<a name="278803681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278803681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eleanor McMurtry <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278803681">(Apr 13 2022 at 09:14)</a>:</h4>
<p>ah, <code>subst ha', subst hb',</code> does though</p>



<a name="278803720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278803720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eleanor McMurtry <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278803720">(Apr 13 2022 at 09:14)</a>:</h4>
<p>very good thanks!</p>



<a name="278804341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278804341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278804341">(Apr 13 2022 at 09:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113489-new-members/topic/working.20with.20sets/near/278803382">said</a>:</p>
<blockquote>
<p>This is not the same <code>rfl</code> as in <code>rfl : ∀ a, a = a</code>. This is part of the <code>rintro</code> syntax which automatically substitutes the LHS or RHS of an equality you introduce everywhere in the context, provided it is a single variable (so that substitution can work). So in that case it replaces <code>x</code> with <code>g * h * g⁻¹</code>.</p>
</blockquote>
<p>It is the same <code>rfl</code>, I think (at least modulo internal <code>rintro</code> implementation details)! <code>rintro</code> allows you to pattern match on stuff, and using <code>rfl</code> as a pattern "forces" unification.</p>



<a name="278804948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278804948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eleanor McMurtry <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278804948">(Apr 13 2022 at 09:26)</a>:</h4>
<p>oh! that makes more sense, and is pretty wild</p>



<a name="278805031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278805031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278805031">(Apr 13 2022 at 09:27)</a>:</h4>
<p>I believe not, because the following fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span> <span class="c1">-- does what's expected</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="n">_</span><span class="o">),</span> <span class="c1">-- intro tactic failed, Pi/let expression expected</span>
<span class="kd">end</span>
</code></pre></div>



<a name="278805227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278805227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278805227">(Apr 13 2022 at 09:29)</a>:</h4>
<p>On top, <code>rintro rfl</code> works even if the relevant variables are already in context, which means it does not just do pattern-matching (pattern-matching only restricts variables that it introduces, it does not substitute the ones already in context).</p>



<a name="278805577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278805577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278805577">(Apr 13 2022 at 09:33)</a>:</h4>
<p>Of course, the two <code>rfl</code> are related, but they are not literally the same.</p>



<a name="278806369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278806369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278806369">(Apr 13 2022 at 09:41)</a>:</h4>
<p>Makes sense, thanks for the clarification! I think another point of view is that <code>rintro</code> simulates "in tactic-land" what pattern matching + unification would do "in term-land", and this simulation is not 100% accurate in the sense that it expects a particular keyword (which is not a bad thing, given how it is meant to be used).</p>



<a name="278806739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278806739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278806739">(Apr 13 2022 at 09:45)</a>:</h4>
<p>No, <code>rintro</code> is much more powerful.</p>



<a name="278807022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278807022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278807022">(Apr 13 2022 at 09:48)</a>:</h4>
<p>I meant for the particular case of using <code>rfl</code>. Well, I think I might be just too used to unification in Agda, so I'll just read up more on how Lean does this.</p>



<a name="278812035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278812035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278812035">(Apr 13 2022 at 10:44)</a>:</h4>
<p>Patrick, my understanding was that rintro was a weaker version of the equation compiler; is that not a good mental model?</p>



<a name="278812740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278812740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278812740">(Apr 13 2022 at 10:52)</a>:</h4>
<p>Perhaps related: In Lean 4, this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">rfl</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
</code></pre></div>
<p>After the <code>=&gt;</code>, unification works as I expected (that is, the variable <code>b</code> disappears from context and is replaced by <code>a</code> everywhere). In Lean 3, though, I tried pattern matching on <code>rfl</code> the naïve way and it just gave me a variable named "rfl" without unifying. This might be related to the fact that <code>rfl</code> is just a value and no longer a keyword in Lean 4. Does this mean that <code>rcases</code> could be implemented in Mathlib4 in such a way that <code>rfl</code> is a special case of pattern matching?</p>



<a name="278812817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278812817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278812817">(Apr 13 2022 at 10:53)</a>:</h4>
<p>In lean 3 you have to match on a and b too</p>



<a name="278812848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278812848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278812848">(Apr 13 2022 at 10:53)</a>:</h4>
<p>rfl isn't a keyword in lean 3</p>



<a name="278813035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278813035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278813035">(Apr 13 2022 at 10:55)</a>:</h4>
<p>Ah, good to know it isn't! That makes a lot more sense. I was confused by the <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#rcases">tactic#rcases</a> documentation because I didn't click the <code>rfl</code> link there.</p>



<a name="278848975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278848975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278848975">(Apr 13 2022 at 16:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/working.20with.20sets/near/278812035">said</a>:</p>
<blockquote>
<p>Patrick, my understanding was that rintro was a weaker version of the equation compiler; is that not a good mental model?</p>
</blockquote>
<p>It is similar in general design to the equation compiler, but it is not strictly dominated in either direction. <code>rintro</code> does not allow using term syntax like <code>eq.refl _</code> for pattern matching; you have to use the anonymous constructor syntax <code>⟨⟩</code> instead of constructor names</p>



<a name="278849310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278849310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278849310">(Apr 13 2022 at 16:02)</a>:</h4>
<p>Unlike the equation compiler you can't do recursive definitions using <code>rcases</code>, but the equation compiler doesn't allow patterns like <code>⟨a | b, c | d⟩</code>, and there is no equivalent of the <code>-</code> pattern either</p>



<a name="278849577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20sets/near/278849577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20sets.html#278849577">(Apr 13 2022 at 16:04)</a>:</h4>
<p>Strictly speaking, <code>rfl</code> is a rintro keyword, which means "use <code>subst</code>". You can't use any other term there</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Function.20with.20fewer.20elements.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html">Function with fewer elements</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="306777988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306777988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306777988">(Oct 29 2022 at 02:26)</a>:</h4>
<p>I have a function f between two fintypes, the first of which has cardinality at least 2 smaller the the second. I want to extract 2 (distinct) elements from the 2nd type which are not in the image of f. I could prove it, but I was wondering if there was anything like this in mathlib already, given that it seems like a pretty basic thing. Thanks!</p>



<a name="306778002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306778002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306778002">(Oct 29 2022 at 02:27)</a>:</h4>
<p>I have no idea what to even search to find something like this in the library</p>



<a name="306779255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306779255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306779255">(Oct 29 2022 at 02:46)</a>:</h4>
<p>are there any criteria for these elements other than "not in the image of <code>f</code>"? what should the behavior be if there are more than 2 elements not in the image?</p>



<a name="306779523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306779523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306779523">(Oct 29 2022 at 02:50)</a>:</h4>
<p>I really have no restrictions, I would then by using those 2 elements to find a contradiction (in some sort of pigeonhole-type argument). I just want to show there exists 2 such distinct elements, if there are more I just need 2 of them (and I don't mind if its not computable or such).</p>



<a name="306779659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306779659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306779659">(Oct 29 2022 at 02:53)</a>:</h4>
<p>oh I see what you're getting at... you just want the proof that a function from a fintype of lesser cardinality leaves a number of elements out of the image</p>



<a name="306780142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306780142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Diamond <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306780142">(Oct 29 2022 at 03:01)</a>:</h4>
<p>I don't have an answer off the top of my head, but are you aware of <a href="https://leanprover-community.github.io/mathlib_docs/combinatorics/pigeonhole.html">https://leanprover-community.github.io/mathlib_docs/combinatorics/pigeonhole.html</a>?</p>



<a name="306780485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306780485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306780485">(Oct 29 2022 at 03:05)</a>:</h4>
<p>Yeah, I guess one could for instance apply finset.exists_card_fiber_lt_of_card_lt_mul twice, but seems a bit convoluted for this simple application. My guess is that someone must have a more directly application result.</p>



<a name="306785625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306785625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306785625">(Oct 29 2022 at 04:41)</a>:</h4>
<p>You just want to show the complement of the range has cardinality at least 2 (using  <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_univ_diff">docs#finset.card_univ_diff</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_image_le">docs#finset.card_image_le</a>), then you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.one_lt_card">docs#finset.one_lt_card</a>.</p>



<a name="306805802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306805802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306805802">(Oct 29 2022 at 08:56)</a>:</h4>
<p>You can get the set as <code>fintype.univ.filter (λ a, ∀ b, a ≠ f b)</code></p>



<a name="306805927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306805927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306805927">(Oct 29 2022 at 08:57)</a>:</h4>
<p>You won't actually be able to extract the two elements separately computably, but you can probably turn them into a <code>sym2</code> with a bit of effort.</p>



<a name="306811441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306811441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306811441">(Oct 29 2022 at 09:45)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finset.univ">docs#finset.univ</a> rather</p>



<a name="306862995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306862995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306862995">(Oct 29 2022 at 16:34)</a>:</h4>
<p>Defining a function and proving that it does what you want are distinct things. Since you don't worry about computability, the function can be defined using classical epsilon:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">fn</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">β</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">classical.epsilon</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">β</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">b₁</span> <span class="n">b₂</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span>
<span class="n">b</span> <span class="bp">=</span> <span class="n">some</span> <span class="o">(</span><span class="n">b₁</span><span class="o">,</span> <span class="n">b₂</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">b₁</span> <span class="bp">≠</span> <span class="n">b₂</span> <span class="bp">∧</span> <span class="bp">¬∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b₁</span> <span class="bp">∨</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b₂</span>
</code></pre></div>
<p>To make some use of it, you would need to prove that in the case of <code>[fintype α] [fintype β] (h : fintype.card α + 2 ≤ fintype.card β)</code> it satisfies the condition.</p>



<a name="306911330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306911330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306911330">(Oct 30 2022 at 03:57)</a>:</h4>
<p>Is this what you want roughly?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.linarith</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">α</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">finset.univ.image</span> <span class="n">f</span>  <span class="bp">∧</span> <span class="n">b</span> <span class="bp">∉</span> <span class="n">finset.univ.image</span> <span class="n">f</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">finset.mem_compl</span><span class="o">,</span> <span class="bp">←</span> <span class="n">finset.one_lt_card_iff</span><span class="o">,</span> <span class="n">finset.card_compl</span><span class="o">],</span>
  <span class="n">zify</span> <span class="o">[</span><span class="n">finset.card_le_univ</span><span class="o">],</span>
  <span class="n">linarith</span> <span class="o">[(</span><span class="k">show</span> <span class="o">(</span><span class="n">finset.univ.image</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span><span class="o">,</span> <span class="k">from</span> <span class="n">finset.card_image_le</span><span class="o">)],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="306916136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Function%20with%20fewer%20elements/near/306916136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Function.20with.20fewer.20elements.html#306916136">(Oct 30 2022 at 05:35)</a>:</h4>
<p>Thanks everyone for your comments! I ended up slightly reformulating my lemma but did something quite close to Junyan Xu's suggestion</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
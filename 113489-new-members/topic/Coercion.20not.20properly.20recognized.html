---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html">Coercion not properly recognized</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="205675243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205675243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205675243">(Aug 01 2020 at 10:18)</a>:</h4>
<p>I can't make the following example work with coercions (i.e. by removing <code>to_fun</code>). Does anybody have tips?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">open</span> <span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="n">def</span> <span class="n">transitive_scalar</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">transitive_module</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span> <span class="c">/-</span><span class="cm"> if I remove to_fun it does not work. Why? -/</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">smul_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">smul_zero</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">map_zero&#39;</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">zero_smul</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">map_one&#39;</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">one_smul</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">map_mul&#39;</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">mul_smul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">map_add&#39;</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">add_smul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>



<a name="205675378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205675378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205675378">(Aug 01 2020 at 10:23)</a>:</h4>
<p>perche le versione con <code>'</code> non devono stare usate</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">open</span> <span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="n">def</span> <span class="n">transitive_scalar</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">transitive_module</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span> <span class="c">/-</span><span class="cm"> if I remove to_fun it does not work. Why? -/</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">smul_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">smul_zero</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">map_zero</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">zero_smul</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">map_one</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">one_smul</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">mul_smul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">map_add</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">add_smul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>



<a name="205675380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205675380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205675380">(Aug 01 2020 at 10:23)</a>:</h4>
<p><code>(algebra_map R A).map_one</code> non <code>(algebra_map R A).map_one'</code></p>



<a name="205675428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205675428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205675428">(Aug 01 2020 at 10:24)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="bp">#</span><span class="kn">check</span> <span class="n">ring_hom</span><span class="bp">.</span><span class="n">map_one</span> <span class="c1">-- ring_hom.map_one : ∀ (f : ?M_1 →+* ?M_2), ⇑f 1 = 1</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">ring_hom</span><span class="bp">.</span><span class="n">map_one&#39;</span> <span class="c1">-- ring_hom.map_one&#39; : ∀ (c : ?M_1 →+* ?M_2), c.to_fun 1 = 1</span>
</code></pre></div>



<a name="205675535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205675535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205675535">(Aug 01 2020 at 10:28)</a>:</h4>
<p><span class="user-mention" data-user-id="267205">@Nicolò Cavalleri</span></p>



<a name="205677364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205677364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205677364">(Aug 01 2020 at 11:27)</a>:</h4>
<p>Ok grazie! Moreover I also cannot manage to substitute <code>smul := ...,</code> with <code>..transitive_scalar R A M,</code> you know why?</p>



<a name="205679843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205679843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205679843">(Aug 01 2020 at 12:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span>  <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>

<span class="n">class</span> <span class="n">bar</span> <span class="kn">extends</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bar</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kn">axiom</span> <span class="n">one_eq_zero</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span>

<span class="n">def</span> <span class="n">foo_instance</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">foo</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">bar_instance₁</span> <span class="o">:</span> <span class="n">bar</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">foo</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">bar</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">one_eq_zero</span><span class="o">]</span> <span class="o">}</span> <span class="c1">-- works</span>

<span class="n">def</span> <span class="n">bar_instance₂</span> <span class="o">:</span> <span class="n">bar</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">bar</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">one_eq_zero</span><span class="o">],</span>  <span class="c1">-- ⊢ foo.foo = 0</span>
  <span class="bp">..</span> <span class="n">foo_instance</span> <span class="o">}</span>
</code></pre></div>



<a name="205680130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205680130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205680130">(Aug 01 2020 at 12:50)</a>:</h4>
<p><span class="user-mention" data-user-id="267205">@Nicolò Cavalleri</span> these nested instances can have unpredictable behaviour, so the safest way is to do this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">open</span> <span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="n">def</span> <span class="n">transitive_scalar</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span> <span class="o">}</span>

<span class="kn">open</span> <span class="n">ring_hom</span>
<span class="n">def</span> <span class="n">transitive_module</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">smul_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">smul_zero</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">show</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="mi">0</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">map_zero</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">],</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">show</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="mi">1</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">map_one</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">],</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">x</span><span class="o">,</span> <span class="k">show</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span>
    <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">r</span> <span class="err">•</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">s</span> <span class="err">•</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">],</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">s</span> <span class="n">x</span><span class="o">,</span> <span class="k">show</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span>
    <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">s</span> <span class="err">•</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">map_add</span><span class="o">,</span> <span class="n">add_smul</span><span class="o">],</span>
  <span class="bp">..</span> <span class="n">transitive_scalar</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span> <span class="o">}</span>
</code></pre></div>



<a name="205680136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205680136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205680136">(Aug 01 2020 at 12:50)</a>:</h4>
<p>i.e. use <code>show</code></p>



<a name="205729578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205729578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205729578">(Aug 02 2020 at 14:27)</a>:</h4>
<p>Ok thanks! And does anybody know why lean does not recognize automatically this coercion:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">open</span> <span class="n">algebra</span> <span class="n">ring_hom</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="n">class</span> <span class="n">compatible_semimodule</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compatible</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">derivation</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">compatible_semimodule</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">leibniz&#39;</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">a</span><span class="o">)</span>

<span class="kn">section</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">compatible_semimodule</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">derivation</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">D</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">to_linear_map</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">one_mul_one</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">one_mul</span> <span class="mi">1</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_algebra_map</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">mul_one</span> <span class="n">r</span><span class="o">,</span> <span class="n">monoid_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="n">r</span> <span class="mi">1</span><span class="o">],</span> <span class="c1">-- not recognizing coercion to monoid_hom</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205730250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730250">(Aug 02 2020 at 14:46)</a>:</h4>
<p>Just to be clear, a linear map does not induce a multiplicative monoid morphism. A module is, in particular, a commutative additive monoid. You probably want to use something like mul_smul or something that's named similarly.</p>



<a name="205730417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730417">(Aug 02 2020 at 14:50)</a>:</h4>
<p>What is <code>add_cancel_comm_monoid</code>? This code doesn't compile for me</p>



<a name="205730500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730500">(Aug 02 2020 at 14:53)</a>:</h4>
<p>Sorry I'm confused isn't algebra_map a ring homomorphism? Why linear map?</p>



<a name="205730506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730506">(Aug 02 2020 at 14:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized/near/205730417">said</a>:</p>
<blockquote>
<p>What is <code>add_cancel_comm_monoid</code>? This code doesn't compile for me</p>
</blockquote>
<p>Sorry I got the mwe wrong, that's only on my local branch! It chould be fixed now, let me know if something else is wrong</p>



<a name="205730550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730550">(Aug 02 2020 at 14:54)</a>:</h4>
<p>D is linear</p>



<a name="205730553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730553">(Aug 02 2020 at 14:54)</a>:</h4>
<p>What's the question? The error is clear, a <code>→+*</code> is not a <code>→*</code></p>



<a name="205730572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730572">(Aug 02 2020 at 14:55)</a>:</h4>
<p><code>extends</code> doesn't create a coercion</p>



<a name="205730573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730573">(Aug 02 2020 at 14:55)</a>:</h4>
<p>Oh I see. You can use ring_hom.map_mul, I guess...</p>



<a name="205730576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730576">(Aug 02 2020 at 14:55)</a>:</h4>
<p>or (just guessing from context) <code>(algebra_map R A).map_mul</code>?</p>



<a name="205730578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730578">(Aug 02 2020 at 14:55)</a>:</h4>
<p>( Your code still doesn't compile, you should perhaps cut and paste into a new file before posting. But it's easy to fix -- you need <code>add_comm_monoid</code> )</p>



<a name="205730646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730646">(Aug 02 2020 at 14:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized/near/205730572">said</a>:</p>
<blockquote>
<p><code>extends</code> doesn't create a coercion</p>
</blockquote>
<p>Does it not? I have been convinced all the times it did</p>



<a name="205730682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730682">(Aug 02 2020 at 14:58)</a>:</h4>
<p>It creates a function, but not a coercion</p>



<a name="205730687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730687">(Aug 02 2020 at 14:58)</a>:</h4>
<p>for classes, it also creates an instance</p>



<a name="205730689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730689">(Aug 02 2020 at 14:58)</a>:</h4>
<p>and it affects the working of the <code>.</code> syntax</p>



<a name="205730702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730702">(Aug 02 2020 at 14:58)</a>:</h4>
<p>Oh then that's why I believed it did then because things worked with classes</p>



<a name="205730703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730703">(Aug 02 2020 at 14:58)</a>:</h4>
<p>Mistery solved thanks to all</p>



<a name="205730792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205730792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205730792">(Aug 02 2020 at 15:01)</a>:</h4>
<p>Is it in general a good idea to write a coercion for structures extending other structures? Like for linear map if I make it extend add_monoid_hom?</p>



<a name="205731100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731100">(Aug 02 2020 at 15:08)</a>:</h4>
<p>In general we don't know whether anything is a good idea</p>



<a name="205731110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731110">(Aug 02 2020 at 15:09)</a>:</h4>
<p>If we knew what the good ideas were the first time around, I wouldn't have just spent the last two weeks refactoring subgroups.</p>



<a name="205731256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731256">(Aug 02 2020 at 15:12)</a>:</h4>
<p>Well in any case this:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">priority</span> <span class="mi">1000</span><span class="o">]</span>
<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">rα</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">rβ</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→+*</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→*</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">ring_hom</span><span class="bp">.</span><span class="n">to_monoid_hom</span><span class="bp">⟩</span>
</code></pre></div>


<p>seems to be in mathlib already, so I still wonder why did not things work before...</p>



<a name="205731283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731283">(Aug 02 2020 at 15:13)</a>:</h4>
<p>The rewrite tactic works up to syntactic equality so would not apply the coercion</p>



<a name="205731329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731329">(Aug 02 2020 at 15:14)</a>:</h4>
<p>The structure map of an algebra extends a ring hom, so you can use the ring_hom fields for the structure map of an algebra.</p>



<a name="205731363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731363">(Aug 02 2020 at 15:15)</a>:</h4>
<p>So when you combine this with Kevin's comment above, you get the issue.</p>



<a name="205731568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731568">(Aug 02 2020 at 15:20)</a>:</h4>
<p>Actually I'm probably wrong.</p>



<a name="205731595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731595">(Aug 02 2020 at 15:21)</a>:</h4>
<p>Well what you said works it was just that I still wanted to understand why what I did did not work</p>



<a name="205731742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731742">(Aug 02 2020 at 15:25)</a>:</h4>
<p>Yeah I'm not sure, because (I think) ring hom extends monoid hom.</p>



<a name="205731842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731842">(Aug 02 2020 at 15:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized/near/205731742">said</a>:</p>
<blockquote>
<p>Yeah I'm not sure, because (I think) ring hom extends monoid hom.</p>
</blockquote>
<p>It does and there is a coercion from one to the other</p>



<a name="205731963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731963">(Aug 02 2020 at 15:30)</a>:</h4>
<p>Ok I understand now. <code>algebra</code> is a class, which has a <code>ring_hom</code> as a field, so that's why you can use <code>ring_hom.map_mul</code>.</p>



<a name="205731971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205731971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205731971">(Aug 02 2020 at 15:31)</a>:</h4>
<p>The <code>algebra_map</code> is the ring_hom.</p>



<a name="205732189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205732189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205732189">(Aug 02 2020 at 15:36)</a>:</h4>
<p>BTW: this works:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_algebra_map</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">mul_one</span> <span class="n">r</span><span class="o">,</span> <span class="n">map_mul</span><span class="o">],</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205732898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205732898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205732898">(Aug 02 2020 at 15:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="267205">Nicolò Cavalleri</span> <a href="#narrow/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized/near/205731595">said</a>:</p>
<blockquote>
<p>Well what you said works it was just that I still wanted to understand why what I did did not work</p>
</blockquote>
<p>The rewrite doesn't work because of the error given when the rewrite fails. Is this the answer to your question?</p>



<a name="205732954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205732954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205732954">(Aug 02 2020 at 15:58)</a>:</h4>
<p>Oh OK I do see your point</p>



<a name="205733377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205733377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205733377">(Aug 02 2020 at 16:10)</a>:</h4>
<p>OK so the way to answer this question is to explicitly make Lean do the coercion and see what the problem is:</p>
<div class="codehilite"><pre><span></span><code><span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">mul_one</span> <span class="n">r</span><span class="o">,</span> <span class="n">monoid_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→*</span> <span class="n">A</span><span class="o">)</span> <span class="n">r</span> <span class="mi">1</span><span class="o">],</span>
</code></pre></div>


<p>and now we see the issue: if you make the coercion so that <code>monoid_hom.map_mul</code> works, the error is</p>
<div class="codehilite"><pre><span></span><code>rewrite tactic failed, did not find instance of the pattern in the target expression
  ⇑↑(algebra_map R A) (r * 1)
state:
...
⊢ ⇑D (⇑(algebra_map R A) (r * 1)) = 0
</code></pre></div>



<a name="205733382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205733382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205733382">(Aug 02 2020 at 16:11)</a>:</h4>
<p>and these things aren't syntactically equal so the rewrite fails.</p>



<a name="205736334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205736334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205736334">(Aug 02 2020 at 17:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Didn't read the whole thread, but this behavior is intentional.  You write <code>foo_instance</code>, you get <code>foo_instance.foo</code> (or the type class equivalent here).  In general <code>foo_instance</code> might not be a <code>foo.mk</code>, so it doesn't make sense to extract the arguments.</p>



<a name="205736339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205736339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205736339">(Aug 02 2020 at 17:32)</a>:</h4>
<p>ok thanks</p>



<a name="205737537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205737537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205737537">(Aug 02 2020 at 18:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized/near/205733382">said</a>:</p>
<blockquote>
<p>and these things aren't syntactically equal so the rewrite fails.</p>
</blockquote>
<p>What does <code>⇑↑(algebra_map R A) (r * 1)</code> exactly mean? I mean why two arrows?</p>



<a name="205737580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205737580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205737580">(Aug 02 2020 at 18:08)</a>:</h4>
<p>The first is the coercion from a ring hom to a monoid hom, and the second is a coercion-to-function from the monoid hom to the actual function underlying the monoid hom.</p>



<a name="205737593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205737593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205737593">(Aug 02 2020 at 18:09)</a>:</h4>
<p>It's defeq, but not syntactically equal, to <code>⇑(algebra_map R A)</code></p>



<a name="205737771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205737771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205737771">(Aug 02 2020 at 18:14)</a>:</h4>
<p>You could use <code>change</code> to change the goal into something for which the rewrite works of course -- but you have a ring hom and the theorem <code>ring_hom.map_mul</code> exists so you may as well use that.</p>



<a name="205773026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205773026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205773026">(Aug 03 2020 at 09:05)</a>:</h4>
<p>I'm having a really hard time with coercions haha every single new one does not work for a different reason... What about this one?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="n">class</span> <span class="n">compatible_semimodule</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compatible</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">derivation</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">compatible_semimodule</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">leibniz&#39;</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">a</span><span class="o">)</span>

<span class="kn">section</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">compatible_semimodule</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">derivation</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">D</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">to_linear_map</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="n">has_coe_to_linear_map</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">⟨λ</span> <span class="n">D</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">to_linear_map</span><span class="bp">⟩</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_smul</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="n">r</span> <span class="err">•</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">D</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span> <span class="n">D</span> <span class="n">r</span> <span class="n">a</span> <span class="c">/-</span><span class="cm"> This works... -/</span>

<span class="kn">variables</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_neg</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">D</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_neg</span> <span class="n">D</span> <span class="n">a</span> <span class="c">/-</span><span class="cm"> ...but this does not, and neither</span>
<span class="cm">                                                                   does D.to_linear_map.map_neg a.</span>
<span class="cm">                                                                   Why?? I checked instances a</span>
<span class="cm">                                                                   hundred times! -/</span>

<span class="kn">end</span> <span class="n">derivation</span>

<span class="kn">end</span>
</code></pre></div>



<a name="205776830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205776830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205776830">(Aug 03 2020 at 09:54)</a>:</h4>
<p>With <code>set_option pp.all true</code>, we get the error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="bp">@</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">map_neg</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_1</span> <span class="err">?</span><span class="n">l_2</span> <span class="err">?</span><span class="n">l_3</span><span class="o">}</span> <span class="err">?</span><span class="n">m_4</span> <span class="err">?</span><span class="n">m_5</span> <span class="err">?</span><span class="n">m_6</span> <span class="err">?</span><span class="n">m_7</span> <span class="err">?</span><span class="n">m_8</span> <span class="err">?</span><span class="n">m_9</span> <span class="err">?</span><span class="n">m_10</span> <span class="err">?</span><span class="n">m_11</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">derivation</span><span class="bp">.</span><span class="n">to_linear_map</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">}</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="bp">_</span><span class="n">inst_2</span> <span class="bp">_</span><span class="n">inst_3</span> <span class="n">M</span> <span class="bp">_</span><span class="n">inst_4</span> <span class="bp">_</span><span class="n">inst_5</span> <span class="bp">_</span><span class="n">inst_5</span> <span class="bp">_</span><span class="n">inst_6</span> <span class="bp">_</span><span class="n">inst_7</span> <span class="n">D</span><span class="o">)</span>
<span class="n">term</span>
  <span class="bp">@</span><span class="n">derivation</span><span class="bp">.</span><span class="n">to_linear_map</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">}</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="bp">_</span><span class="n">inst_2</span> <span class="bp">_</span><span class="n">inst_3</span> <span class="n">M</span> <span class="bp">_</span><span class="n">inst_4</span> <span class="bp">_</span><span class="n">inst_5</span> <span class="bp">_</span><span class="n">inst_5</span> <span class="bp">_</span><span class="n">inst_6</span> <span class="bp">_</span><span class="n">inst_7</span> <span class="n">D</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">linear_map</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">}</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring</span><span class="bp">.</span><span class="n">to_semiring</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">semiring</span><span class="bp">.</span><span class="n">to_add_comm_monoid</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">A</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring</span><span class="bp">.</span><span class="n">to_semiring</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">A</span> <span class="bp">_</span><span class="n">inst_2</span><span class="o">))</span>
    <span class="bp">_</span><span class="n">inst_4</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">algebra</span><span class="bp">.</span><span class="n">to_semimodule</span><span class="bp">.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">_</span><span class="n">inst_1</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring</span><span class="bp">.</span><span class="n">to_semiring</span><span class="bp">.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">A</span> <span class="bp">_</span><span class="n">inst_2</span><span class="o">)</span> <span class="bp">_</span><span class="n">inst_3</span><span class="o">)</span>
    <span class="bp">_</span><span class="n">inst_6</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u_2</span> <span class="n">u_3</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">linear_map</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_1</span> <span class="err">?</span><span class="n">l_2</span> <span class="err">?</span><span class="n">l_3</span><span class="o">}</span> <span class="err">?</span><span class="n">m_4</span> <span class="err">?</span><span class="n">m_5</span> <span class="err">?</span><span class="n">m_6</span> <span class="err">?</span><span class="n">m_7</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_group</span><span class="bp">.</span><span class="n">to_add_comm_monoid</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_2</span><span class="o">}</span> <span class="err">?</span><span class="n">m_5</span> <span class="err">?</span><span class="n">m_8</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_group</span><span class="bp">.</span><span class="n">to_add_comm_monoid</span><span class="bp">.</span><span class="o">{</span><span class="err">?</span><span class="n">l_3</span><span class="o">}</span> <span class="err">?</span><span class="n">m_6</span> <span class="err">?</span><span class="n">m_9</span><span class="o">)</span>
    <span class="err">?</span><span class="n">m_10</span>
    <span class="err">?</span><span class="n">m_11</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="err">?</span><span class="n">l_1</span> <span class="err">?</span><span class="n">l_2</span><span class="o">)</span>
</code></pre></div>


<p>So apparently there are still <code>comm_semiring</code> istances floating around for <code>R</code> and <code>A</code> that are being picked up by <code>derivation</code>. If you have a <code>[comm_semiring R]</code> variable and later say <code>[comm_ring R]</code>, then this gives two <em>different</em> ring structures on <code>R</code>, not that the previous instance gets a new <code>-</code> operator.</p>



<a name="205777073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205777073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205777073">(Aug 03 2020 at 09:57)</a>:</h4>
<p>It works if we put all the instances in their own section:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">A</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="n">class</span> <span class="n">compatible_semimodule</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compatible</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">derivation</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">compatible_semimodule</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">leibniz&#39;</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">a</span><span class="o">)</span>

<span class="kn">section</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span><span class="o">}</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">compatible_semimodule</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">derivation</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">D</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">to_linear_map</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="n">has_coe_to_linear_map</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">⟨λ</span> <span class="n">D</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">to_linear_map</span><span class="bp">⟩</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_smul</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="n">r</span> <span class="err">•</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">D</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span> <span class="n">D</span> <span class="n">r</span> <span class="n">a</span> <span class="c">/-</span><span class="cm"> This works... -/</span>

<span class="kn">end</span> <span class="n">derivation</span>

<span class="kn">end</span>

<span class="kn">end</span>

<span class="kn">variables</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">compatible_semimodule</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">map_neg</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">D</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_neg</span> <span class="n">D</span> <span class="n">a</span>
</code></pre></div>



<a name="205777340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Coercion%20not%20properly%20recognized/near/205777340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Coercion.20not.20properly.20recognized.html#205777340">(Aug 03 2020 at 10:00)</a>:</h4>
<p>The above solution is rather ugly, though. When I want to switch between <code>semiring</code> and <code>ring</code> structures, I generally put them on different variables, for instance <code>variables {R₀ R₁ : Type*} [semiring R₀] [ring R₁]</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html">Impossible cases for an inductive type constructor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="223553915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/223553915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#223553915">(Jan 21 2021 at 18:53)</a>:</h4>
<p>Is it possible to prove that a case for a function is impossible?</p>
<p>Suppose you define a map (or dictionary in Python) as a list of key/value pairs (see the definition below).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">map</span>
<span class="bp">|</span> <span class="n">build</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span><span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">map</span><span class="o">):</span> <span class="n">map</span>
</code></pre></div>
<p>I could define a function that, given a key k, returns me the value v that is associated with that key (see definition below). This function would probably use an option type in case the key is not in the map.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mget</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span><span class="o">:</span> <span class="n">α</span><span class="o">):</span> <span class="bp">@</span><span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">map.nil</span>             <span class="o">:=</span> <span class="n">option.none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">k1</span> <span class="n">v1</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">k1</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="n">option.some</span> <span class="n">v1</span> <span class="k">else</span> <span class="n">mget</span> <span class="n">m</span>
</code></pre></div>
<p>But if I know that key k is in the keyset of this map (see the function below that returns the keyset), I know it is impossible that <code>mget</code> returns none.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">keys</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_union</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">map.nil</span> <span class="o">:=</span> <span class="bp">∅</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">k</span> <span class="n">_</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="n">has_insert.insert</span> <span class="n">k</span> <span class="o">(</span><span class="n">keys</span> <span class="n">m</span><span class="o">)</span>
</code></pre></div>
<p>The reason I want to define such a function is that, if I have a prove for  <code>(mget k m).is_some</code> (where k is a key, m is a map). I can use option.get on that proof to return me something (with the type of the values). But don't think I can reason about that value, which is what I need. Right? For this question I do not know whether this last statement is true or not, but my attempts at proving something using mget almost always return in a goal that looks like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">option.get</span> <span class="n">_</span> <span class="bp">\</span><span class="k">in</span> <span class="n">keys</span> <span class="n">m</span>
</code></pre></div>
<p>(where _ is <code>(mget k m).is_some</code>)</p>



<a name="223554723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/223554723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#223554723">(Jan 21 2021 at 18:58)</a>:</h4>
<p>Yes it is possible to prove that cases are impossible, and <code>option.get</code> is an example. You should see how it is implemented - it cases on the option and then proves that the none case yields false</p>



<a name="223554795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/223554795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#223554795">(Jan 21 2021 at 18:59)</a>:</h4>
<p><code>[has_union (finset α)]</code> &lt;-- you don't want this</p>



<a name="223558097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/223558097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#223558097">(Jan 21 2021 at 19:25)</a>:</h4>
<p>Aa, the answer was closer than I thought. I will try that, don't know what the none case for option.get exactly says, but I can figure it out.<br>
thakn you!</p>



<a name="223559642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/223559642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#223559642">(Jan 21 2021 at 19:36)</a>:</h4>
<p>Btw, why wouldn't I want [has_union (finset \a)]? Maybe I am reading it wrong, but this says that you can do somefinset \union otherfinset, which should be fine right?</p>



<a name="223561140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/223561140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#223561140">(Jan 21 2021 at 19:46)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/option.get/src">src#option.get</a></p>



<a name="223561300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/223561300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#223561300">(Jan 21 2021 at 19:48)</a>:</h4>
<p>There is already a definition of <code>has_union (finset A)</code>. By asking for a different one it might not have the right properties, for example it might say that the union of any two finsets is empty, in which case your theorems won't be provable</p>



<a name="223561411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/223561411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#223561411">(Jan 21 2021 at 19:49)</a>:</h4>
<p>if you just delete that typeclass argument you will still be able to use union on finsets</p>



<a name="223561579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/223561579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#223561579">(Jan 21 2021 at 19:50)</a>:</h4>
<p>Also <code>map</code> should take its type arguments explicitly, i.e. <code>inductive map (α β: Type) : Type</code>. They can't be inferred from context which is why you are having to write <code>@map α β</code> all the time</p>



<a name="223561638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/223561638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#223561638">(Jan 21 2021 at 19:50)</a>:</h4>
<p>As for your actual question, could you give a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> with the theorem you want to prove? It's a little vague what the problem is</p>



<a name="224237126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224237126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224237126">(Jan 27 2021 at 19:44)</a>:</h4>
<p>Let me first explain the context of the question before giving the mwe. I am taking a course called Logical Verification (Jasmin Blanchette as the teacher). This is part of the project I am working on for that course. He mentioned that i could ask question here. So, I am trying to ask questions about smaller problems I have (I feel like I should at least mention this, just so it does not look suspicious or anything). I will mention your name if I use anything you post here.</p>



<a name="224237138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224237138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224237138">(Jan 27 2021 at 19:44)</a>:</h4>
<p>MWE coming in a bit</p>



<a name="224238566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224238566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224238566">(Jan 27 2021 at 19:55)</a>:</h4>
<p>Again I want to stress that I do not want a the proof (as that would be cheating), but I was allowed to ask questions regarding smaller problems.</p>
<p>So my MWE is here, it is a bit long though</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.finite</span>
<span class="kn">import</span> <span class="n">data.finset</span>
<span class="kn">open</span> <span class="n">finset</span> <span class="n">multiset</span>
<span class="kn">namespace</span> <span class="n">mapfuncs</span>

<span class="kd">inductive</span> <span class="n">map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">map</span>
<span class="bp">|</span> <span class="n">build</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span><span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">map</span><span class="o">):</span> <span class="n">map</span>

<span class="kd">def</span> <span class="n">values</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">@</span><span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">map.nil</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">a</span> <span class="n">b</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="bp">++</span> <span class="n">values</span> <span class="n">m</span>

<span class="kd">def</span> <span class="n">keys</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_union</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">map.nil</span> <span class="o">:=</span> <span class="bp">∅</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">k</span> <span class="n">_</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="n">has_insert.insert</span> <span class="n">k</span> <span class="o">(</span><span class="n">keys</span> <span class="n">m</span><span class="o">)</span>


<span class="kd">def</span> <span class="n">mget</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span><span class="o">:</span> <span class="n">α</span><span class="o">):</span> <span class="bp">@</span><span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">map.nil</span>             <span class="o">:=</span> <span class="n">option.none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">k1</span> <span class="n">v1</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">k1</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="n">option.some</span> <span class="n">v1</span> <span class="k">else</span> <span class="n">mget</span> <span class="n">m</span>

<span class="kd">def</span> <span class="n">keygetfromvalue</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">@</span><span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">map.nil</span> <span class="o">:=</span> <span class="n">option.none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">k</span> <span class="n">v1</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">v1</span> <span class="bp">=</span> <span class="n">v</span> <span class="k">then</span> <span class="n">option.some</span> <span class="n">k</span> <span class="k">else</span> <span class="n">keygetfromvalue</span> <span class="n">m</span>

<span class="kd">def</span> <span class="n">keygetfromvaluesome</span><span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="bp">@</span><span class="n">map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">option.is_some</span> <span class="o">(</span><span class="n">keygetfromvalue</span> <span class="n">v</span> <span class="n">m</span><span class="o">)):</span> <span class="n">α</span>
<span class="o">:=</span> <span class="n">option.get</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">lemma_to_proof</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="bp">@</span><span class="n">map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">v</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">values</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span><span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">k</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">keys</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">mget</span> <span class="n">k</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">option.some</span> <span class="n">v</span><span class="o">))</span> <span class="o">:=</span>
  <span class="kd">begin</span>
      <span class="n">intro</span> <span class="n">hvinvalm</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">exists.intro</span> <span class="o">(</span><span class="n">keygetfromvaluesome</span> <span class="n">v</span> <span class="n">m</span> <span class="o">(</span><span class="kd">by</span> <span class="gr">sorry</span><span class="o">)),</span> <span class="c1">-- I do have a proof here, but it involves a longer lemma.</span>
      <span class="n">apply</span> <span class="n">and.intro</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">simp</span><span class="o">[</span><span class="n">keygetfromvaluesome</span><span class="o">],</span>
          <span class="c1">-- αβ: Type</span>
          <span class="c1">-- _inst_1: decidable_eq α</span>
          <span class="c1">-- _inst_2: decidable_eq β</span>
          <span class="c1">-- v: β</span>
          <span class="c1">-- m: map</span>
          <span class="c1">-- hvinvalm: v ∈ values m</span>
          <span class="c1">-- ⊢ option.get _ ∈ keys m</span>
        <span class="gr">sorry</span> <span class="c1">-- The problem is the state here. I can't get any info on the key itself.</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">simp</span><span class="o">[</span><span class="n">keygetfromvaluesome</span><span class="o">],</span><span class="c1">-- same problem here</span>
        <span class="gr">sorry</span><span class="o">,</span>
      <span class="o">}</span>
  <span class="kd">end</span>
<span class="kd">end</span> <span class="n">mapfuncs</span>
</code></pre></div>



<a name="224239073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224239073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224239073">(Jan 27 2021 at 20:00)</a>:</h4>
<p>The map inductive type is the same, for completeness sake I have included the definitions of values and keys (but I do not think they matter in this case). I gave a different example here, but the problem is the same.</p>
<p>Now I want to define a function (which I call keygetfromvalue) that, given a value v, gets <em>a</em> key associated with that value. When i use that function in my proof I get the problem that I have a goal that looks like <code>option.get _ \in someset</code> (see the two "sorry"s in the lemma_to_proof). Now I want to define a new function (lets call that valuetokey) that given a value v and a proof that there is a key associated with it, returns me v (so not option.some v).</p>



<a name="224241193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224241193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224241193">(Jan 27 2021 at 20:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="381693">Ömer Şakar</span> <a href="#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224237126">said</a>:</p>
<blockquote>
<p>Let me first explain the context of the question before giving the mwe. I am taking a course called Logical Verification (Jasmin Blanchette as the teacher).</p>
</blockquote>
<p>Now where have I heard that name before? :)</p>



<a name="224241563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224241563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224241563">(Jan 27 2021 at 20:19)</a>:</h4>
<p>My first instinct is that you might be able to use case distinction on <code>m</code>, like in <code>keygetfromvalue</code> to prove that <code>↥((keygetfromvalue v m).is_some)</code> implies that <code>option.get this</code> is in the keys.</p>



<a name="224242183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224242183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224242183">(Jan 27 2021 at 20:25)</a>:</h4>
<p>Yes, but unfortunately the way that <code>map</code> is defined, there is no connection between <code>a</code> and <code>b</code> currently.</p>



<a name="224242190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224242190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224242190">(Jan 27 2021 at 20:25)</a>:</h4>
<p>No lemma showing that</p>



<a name="224242694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224242694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224242694">(Jan 27 2021 at 20:29)</a>:</h4>
<p>Right, it would probably have to be in the form of a new lemma (couple of new lemmas?) proved by pattern matching. Basically what I mean is duplicate <code>keygetfromvalue</code> but return a proof instead of a key.</p>



<a name="224242946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224242946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224242946">(Jan 27 2021 at 20:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lemma_to_proof</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="bp">@</span><span class="n">map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">v</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">values</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span><span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">k</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">keys</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">mget</span> <span class="n">k</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">option.some</span> <span class="n">v</span><span class="o">))</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span> <span class="n">a</span> <span class="n">b</span> <span class="n">m</span> <span class="n">hm</span> <span class="n">generalizing</span> <span class="n">v</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">values</span><span class="o">]</span> <span class="o">},</span> <span class="c1">-- false because we would have `v ∈ values map.nil`</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">values</span><span class="o">,</span> <span class="n">keys</span><span class="o">,</span> <span class="n">mem_insert</span><span class="o">,</span> <span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">list.singleton_append</span><span class="o">],</span>
      <span class="n">rintro</span> <span class="o">(</span><span class="n">rfl</span> <span class="bp">|</span> <span class="n">H</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">mget</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hm</span> <span class="n">_</span> <span class="n">H</span><span class="o">,</span>
        <span class="n">use</span> <span class="n">k</span><span class="o">,</span>
        <span class="n">simp</span> <span class="o">[</span><span class="n">hk</span><span class="o">,</span> <span class="n">hv</span><span class="o">,</span> <span class="n">mget</span><span class="o">],</span>
        <span class="gr">sorry</span> <span class="c1">-- you can't prove this because there is no relationship between `b` and `v`</span>
      <span class="o">},</span>
    <span class="o">}</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="224243196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224243196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224243196">(Jan 27 2021 at 20:33)</a>:</h4>
<p>That is because <code>map.build 0 1 (map.build 0 0 map.nil)</code> has <code>values = [0, 1]</code> but <code>keys = {0}</code>!</p>



<a name="224243622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224243622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224243622">(Jan 27 2021 at 20:36)</a>:</h4>
<p>Here's how I suggest you set this up:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.finite</span>
<span class="kn">import</span> <span class="n">data.finset</span>

<span class="kn">namespace</span> <span class="n">mapfuncs</span>

<span class="kd">inductive</span> <span class="n">map</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">map</span>
<span class="bp">|</span> <span class="n">build</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span><span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="n">map</span><span class="o">):</span> <span class="n">map</span>

<span class="kd">def</span> <span class="n">map.values</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">map.nil</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">a</span> <span class="n">b</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="bp">++</span> <span class="n">m.values</span>

<span class="kd">def</span> <span class="n">map.keys</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">map.nil</span> <span class="o">:=</span> <span class="bp">∅</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">k</span> <span class="n">_</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="n">insert</span> <span class="n">k</span> <span class="n">m.keys</span>

<span class="kd">def</span> <span class="n">map.get</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span><span class="o">:</span> <span class="n">α</span><span class="o">):</span> <span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">map.nil</span>             <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">k1</span> <span class="n">v1</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">k1</span> <span class="bp">=</span> <span class="n">k</span> <span class="k">then</span> <span class="n">some</span> <span class="n">v1</span> <span class="k">else</span> <span class="n">map.get</span> <span class="n">m</span>

<span class="kd">def</span> <span class="n">map.by_value</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">map.nil</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">k</span> <span class="n">v1</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">v1</span> <span class="bp">=</span> <span class="n">v</span> <span class="k">then</span> <span class="n">some</span> <span class="n">k</span> <span class="k">else</span> <span class="n">map.by_value</span> <span class="n">m</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">def map.get_by_value {α β: Type*} [decidable_eq β]</span>
<span class="cm">  (v: β) (m: map α β) (h: option.is_some (map.by_value v m)) : α :=</span>
<span class="cm">option.get h</span>
<span class="cm">-/</span>

<span class="kd">lemma</span> <span class="n">map.mem_by_value</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">k</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">map</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">k</span> <span class="bp">∈</span> <span class="n">m.by_value</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">m.get</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">induction</span> <span class="n">m</span><span class="bp">;</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">map.mem_keys</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">k</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">map</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">k</span> <span class="bp">∈</span> <span class="n">m.keys</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">v</span><span class="o">,</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">m.get</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">induction</span> <span class="n">m</span><span class="bp">;</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">map.mem_values</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">map</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">v</span> <span class="bp">∈</span> <span class="n">m.values</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">m.get</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">induction</span> <span class="n">m</span><span class="bp">;</span> <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">mapfuncs</span>
</code></pre></div>



<a name="224243763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224243763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224243763">(Jan 27 2021 at 20:37)</a>:</h4>
<p>I removed the <code>k ∈ (keys m)</code> conjunct from <code>map.mem_values</code> because it's implied by the second conjunct <code>v ∈ m.get k</code></p>



<a name="224243966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224243966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224243966">(Jan 27 2021 at 20:38)</a>:</h4>
<p>You don't need the <code>keygetfromvaluesome</code> function at all for these proofs, so it's commented out</p>



<a name="224244210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224244210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224244210">(Jan 27 2021 at 20:41)</a>:</h4>
<p>Actually, now that I come to think about it, it's possible to prove <code>map.mem_values</code> directly by induction on <code>m</code>, rather than splitting the forward and reverse directions into two theorems</p>



<a name="224245576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224245576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224245576">(Jan 27 2021 at 20:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224242694">said</a>:</p>
<blockquote>
<p>Right, it would probably have to be in the form of a new lemma (couple of new lemmas?) proved by pattern matching. Basically what I mean is duplicate <code>keygetfromvalue</code> but return a proof instead of a key.</p>
</blockquote>
<p>Hi Anne, long time no see:)</p>



<a name="224245745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224245745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224245745">(Jan 27 2021 at 20:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224242183">said</a>:</p>
<blockquote>
<p>Yes, but unfortunately the way that <code>map</code> is defined, there is no connection between <code>a</code> and <code>b</code> currently.</p>
</blockquote>
<p>Hmm I thought that if they are within the same constructor case, that that would be the association. But I guess not... (I only realize that now).</p>



<a name="224246591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224246591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224246591">(Jan 27 2021 at 21:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224243622">said</a>:</p>
<blockquote>
<p>Here's how I suggest you set this up:<br>
</p>
</blockquote>
<p>Interesting. So if I understand it correctly, is the difference with my approach that I rely on a proof (from which you cannot extract any info) and your approach (besides looking more structured) associates the map.by_value and map.get functions?</p>



<a name="224251500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224251500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224251500">(Jan 27 2021 at 21:39)</a>:</h4>
<p>The main point with these lemmas is to have something that can be proven straightforwardly by induction. Once you have them you can use them to prove theorems about the <code>get_by_value</code> function if you want:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">map.get_by_value_mem_keys</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">map</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.get_by_value</span> <span class="n">v</span> <span class="n">h</span> <span class="bp">∈</span> <span class="n">m.keys</span> <span class="o">:=</span>
<span class="n">map.mem_keys.2</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">map.mem_by_value</span> <span class="o">(</span><span class="n">option.get_mem</span> <span class="n">_</span><span class="o">)⟩</span>
</code></pre></div>



<a name="224252606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224252606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224252606">(Jan 27 2021 at 21:49)</a>:</h4>
<p>Also as pointed out by Yakov, some of these theorems aren't true because there is no constraint on <code>m</code> having unique keys. You might find it easier to work with the relation <code>(k, v) ∈ m.entries</code> in place of <code>v ∈ m.get k</code> in the theorems, where</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">map.entries</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">map</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">map.nil</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">map.build</span> <span class="n">a</span> <span class="n">b</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">::</span> <span class="n">m.entries</span>
</code></pre></div>



<a name="224253929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224253929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224253929">(Jan 27 2021 at 22:00)</a>:</h4>
<p>The reason I did not constraint m on having unique keys is that I wanted to model a map as a list of entries. The keyset has unique keys (because by definition elements in a set a unique).</p>



<a name="224254158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224254158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ömer Şakar <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224254158">(Jan 27 2021 at 22:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224251500">said</a>:</p>
<blockquote>
<p>The main point with these lemmas is to have something that can be proven straightforwardly by induction. Once you have them you can use them to prove theorems about the <code>get_by_value</code> function if you want:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">map.get_by_value_mem_keys</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">map</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">m.get_by_value</span> <span class="n">v</span> <span class="n">h</span> <span class="bp">∈</span> <span class="n">m.keys</span> <span class="o">:=</span>
<span class="n">map.mem_keys.2</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">map.mem_by_value</span> <span class="o">(</span><span class="n">option.get_mem</span> <span class="n">_</span><span class="o">)⟩</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Hmmm, i think i get what you mean, I will try it out. Thank you (Anne and Yakov) a lot!</p>



<a name="224255285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224255285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224255285">(Jan 27 2021 at 22:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="381693">Ömer Şakar</span> <a href="#narrow/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor/near/224253929">said</a>:</p>
<blockquote>
<p>The reason I did not constraint m on having unique keys is that I wanted to model a map as a list of entries. The keyset has unique keys (because by definition elements in a set a unique).</p>
</blockquote>
<p>The keyset as defined by <code>map.keys</code> is unique, but you're still able to construct that <code>keys = {0}, values = [0, 1]</code> map, where, depending on how you define retrieval function, some of those values might be unreachable</p>



<a name="224255947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Impossible%20cases%20for%20an%20inductive%20type%20constructor/near/224255947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Impossible.20cases.20for.20an.20inductive.20type.20constructor.html#224255947">(Jan 27 2021 at 22:13)</a>:</h4>
<p>One way to express that the map has unique keys using the <code>map.keys</code> finset is <code>m.keys.card = m.values.length</code>, although that's not the most convenient. If <code>map.keys</code> was a list then you could say <code>m.keys.nodup</code> to express that there are no duplicate keys (and hence you can upgrade this list to a finset without losing duplicate elements)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
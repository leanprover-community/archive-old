---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html">confused about types and Type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="290035654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290035654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290035654">(Jul 18 2022 at 23:19)</a>:</h4>
<p>I noticed a similarity between:</p>
<p>(in Init/Control/State.lean)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kd">def</span> <span class="n">StateT</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">σ</span> <span class="bp">→</span> <span class="n">m</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">σ</span><span class="o">)</span>
</code></pre></div>
<p>and:</p>
<p>(in Init/Prelude.lean)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="bp">...</span>
<span class="sd">/-- An implementation of [ReaderT](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT) -/</span>
<span class="kd">def</span> <span class="n">ReaderT</span> <span class="o">(</span><span class="n">ρ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">ρ</span> <span class="bp">→</span> <span class="n">m</span> <span class="n">α</span>
</code></pre></div>
<p>Based on <a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html">https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html</a>, I read <code>(α × σ)</code> to be syntax for creating an instance of <code>Prod; however, I can rewrite </code>StateT` slightly differently like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kd">def</span> <span class="n">StateT'</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">σ</span>
  <span class="n">σ</span> <span class="bp">→</span> <span class="n">m</span> <span class="n">p</span>
</code></pre></div>
<p>Can someone explain how this use of product above differs from that in <code>MonadStateOf.modifyGet</code>:</p>
<p>(in Init/Prelude.lean)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">MonadStateOf</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="c">/-</span><span class="cm"> Obtain the top-most State of a Monad stack. -/</span>
  <span class="n">get</span> <span class="o">:</span> <span class="n">m</span> <span class="n">σ</span>
  <span class="c">/-</span><span class="cm"> Set the top-most State of a Monad stack. -/</span>
  <span class="n">set</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→</span> <span class="n">m</span> <span class="n">PUnit</span>
  <span class="c">/-</span><span class="cm"> Map the top-most State of a Monad stack.</span>

<span class="cm">     Note: `modifyGet f` may be preferable to `do s &lt;- get; let (a, s) := f s; put s; pure a`</span>
<span class="cm">     because the latter does not use the State linearly (without sufficient inlining). -/</span>
  <span class="n">modifyGet</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">σ</span> <span class="bp">→</span> <span class="n">Prod</span> <span class="n">α</span> <span class="n">σ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">m</span> <span class="n">α</span>
</code></pre></div>



<a name="290035821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290035821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290035821">(Jul 18 2022 at 23:21)</a>:</h4>
<p>Just to be clear, in the above, my brain fails to comprehend how the typechecker is OK with: <code>let p : Type u := α × σ</code></p>



<a name="290036208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290036208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290036208">(Jul 18 2022 at 23:27)</a>:</h4>
<p>It's ok because <code>α × σ : Type u</code>. Take a look at <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod#doc">docs4#Prod</a>, which says that given <code>α : Type u</code> and <code>β : Type v</code> then <code>α × β : Type (max u v)</code>. For the particular example, there's a rule that <code>Type (max u u)</code> is <code>Type u</code>.</p>



<a name="290036286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290036286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290036286">(Jul 18 2022 at 23:28)</a>:</h4>
<p>If you're wondering about <code>Prod</code> rather than using notation, by the way, it's because notation isn't introduced until <a href="https://github.com/leanprover/lean4/blob/f6b6b36f47909fe8a089c16efdb87372154e7efa/src/Init/Notation.lean#L76">here</a></p>



<a name="290036441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290036441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290036441">(Jul 18 2022 at 23:30)</a>:</h4>
<p>When you say "I read <code>(α × σ)</code> to be syntax for creating an instance of <code>Prod</code>", it's not that it creating <em>a</em> <code>Prod α σ</code>, it's that it <em>is</em> <code>Prod α σ</code>. The notation to create a term of <code>Prod α σ</code> is <code>(x, y)</code>. (The word "instance" isn't precise here.)</p>



<a name="290037483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290037483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Bailey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290037483">(Jul 18 2022 at 23:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="362579">Nicolas Rouquette</span> <a href="#narrow/stream/113489-new-members/topic/confused.20about.20types.20and.20Type/near/290035821">said</a>:</p>
<blockquote>
<p>Just to be clear, in the above, my brain fails to comprehend how the typechecker is OK with: <code>let p : Type u := α × σ</code></p>
</blockquote>
<p>This suggests you had a different type in mind, what were you expecting it to be?</p>



<a name="290038701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290038701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290038701">(Jul 19 2022 at 00:01)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="306601">@Kyle Miller</span> for your cogent explanation.</p>
<p><span class="user-mention silent" data-user-id="228466">Chris Bailey</span> <a href="#narrow/stream/113489-new-members/topic/confused.20about.20types.20and.20Type/near/290037483">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="362579">Nicolas Rouquette</span> <a href="#narrow/stream/113489-new-members/topic/confused.20about.20types.20and.20Type/near/290035821">said</a>:</p>
<blockquote>
<p>Just to be clear, in the above, my brain fails to comprehend how the typechecker is OK with: <code>let p : Type u := α × σ</code></p>
</blockquote>
<p>This suggests you had a different type in mind, what were you expecting it to be?</p>
</blockquote>
<p>Something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">StateT''</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="o">(</span><span class="n">Prod</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">σ</span> <span class="bp">→</span> <span class="n">m</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">σ</span><span class="o">)</span>
</code></pre></div>
<p>This does not compute in Lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">application</span> <span class="n">type</span> <span class="n">mismatch</span>
  <span class="n">m</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">σ</span><span class="o">)</span>
<span class="n">argument</span>
  <span class="n">α</span> <span class="bp">×</span> <span class="n">σ</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="n">u</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">σ</span> <span class="bp">×</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
</code></pre></div>
<p>Although I understand <span class="user-mention" data-user-id="306601">@Kyle Miller</span> 's explanation at a logical level, I have difficulty getting an intuitive understanding about the following:</p>
<ul>
<li>When different expressions that are structurally different yield the same type -- e..g. <code>(α × σ)</code> and <code>α</code> in the above have type <code>Type u</code></li>
<li>When structurally different expressions require a correspondingly specific type -- e.g. <code>MonadStateOf.modifyGet</code> argument must be a function of type <code>σ → Prod α σ</code>; it would be quite a different API if the argument where typed <code>Prod α σ → σ</code>.</li>
</ul>



<a name="290039772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290039772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Bailey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290039772">(Jul 19 2022 at 00:19)</a>:</h4>
<p>Evergreen diagram: <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20Prop.20.3A.3D.20Sort.200.20Motivation/near/252362723">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.E2.9C.94.20Prop.20.3A.3D.20Sort.200.20Motivation/near/252362723</a></p>



<a name="290139955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290139955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290139955">(Jul 19 2022 at 18:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/confused.20about.20types.20and.20Type/near/290036208">said</a>:</p>
<blockquote>
<p>It's ok because <code>α × σ : Type u</code>. Take a look at <a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod#doc">docs4#Prod</a>, which says that given <code>α : Type u</code> and <code>β : Type v</code> then <code>α × β : Type (max u v)</code>. For the particular example, there's a rule that <code>Type (max u u)</code> is <code>Type u</code>.</p>
</blockquote>
<p>Where is this rule?</p>
<p>Inspired by <span class="user-mention" data-user-id="228466">@Chris Bailey</span> 's suggestion, I asked Lean for the type of various terms:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="k">#check</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span>
<span class="c1">-- Type u → Type v : Type (max (u + 1) (v + 1))</span>

<span class="k">#check</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">×</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span>
<span class="c1">-- Type u × Type u → Type v : Type (max (u + 1) (v + 1))</span>
</code></pre></div>
<p>Although I couldn't find this rule; I hope we can use it show that these terms have the same type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Can we prove that these two types are equivalent using the rule that Type (max u u) = Type u?</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">×</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="gr">sorry</span>
</code></pre></div>



<a name="290143276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290143276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290143276">(Jul 19 2022 at 18:45)</a>:</h4>
<p>With <code>max u u</code>, what you need to know is that <code>u</code> stands for a universe level variable, whose value is a natural number (not a Lean <code>nat</code>, but the natural numbers as part of the underlying theory), and like usual <code>max u v</code> is just the max of these two numbers. That's why <code>max u u</code> is <code>u</code>.</p>



<a name="290143527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290143527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Bailey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290143527">(Jul 19 2022 at 18:47)</a>:</h4>
<p>The rule about <code>Type (max u u)</code> is part of the type theory, for which people usually link <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">Mario Carneiro's thesis</a> as a reference. Said rule is on page 6. Definitional equality for elements of <code>Sort</code> is by antisymmetry on their universe level.</p>
<p>Your second example doesn't say what you think it does, it posits that <code>(Type u → Type v) = (Type u × Type u → Type v) </code>, not that their types are equal. What you're asking is basically this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span>
<span class="k">#check</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="c1">-- Type u → Type v : Type (max (u + 1) (v + 1))</span>
<span class="k">#check</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="bp">×</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="c1">-- Type u × Type u → Type v : Type (max (u + 1) (v + 1))</span>
<span class="kd">example</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rfl</span>
</code></pre></div>



<a name="290143532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290143532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290143532">(Jul 19 2022 at 18:47)</a>:</h4>
<p>The statement <code>(Type u → Type v) = (Type u × Type u → Type v)</code> is not provable (so, as good as not being true), but since it typechecks it means the left-hand and right-hand sides have the exact same types.</p>



<a name="290307128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290307128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290307128">(Jul 20 2022 at 22:19)</a>:</h4>
<p>Hum.... let me try to explain the original problem differently.</p>
<p>In programming with Scala, it is very helpful to keep the Curry-Howard correspondence in mind: with reasonably-specified function signatures, one can focus on the types of the arguments and result to get an idea about what it can possibly do.</p>
<p>With Scala, CH might be perhaps simpler than with Lean because Scala has only types and terms whereas Lean4 has sorts, types and terms.</p>
<p>From this perspective, I am interested in understanding a small excerpt of functions defined in Lean's prelude and init library:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">namespace</span> <span class="n">confused</span>

<span class="c1">-- renamed the ρ argument to σ so as to emphasize the similarity with StateT.</span>
<span class="kd">def</span> <span class="n">ReaderT</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">σ</span> <span class="bp">→</span> <span class="n">m</span> <span class="n">α</span>

<span class="kd">def</span> <span class="n">StateT</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">σ</span> <span class="bp">→</span> <span class="n">m</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">σ</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">confused</span>
</code></pre></div>
<p>First, I was really puzzled to see that <code>ReaderT</code> and <code>StateT</code> have the same kind of arguments yet their right-hand side terms are clearly different. Since these functions are defined over sorts, not types, it seems to suggest that it is more appropriate to compare their sort-based signatures.  As <span class="user-mention" data-user-id="306601">@Kyle Miller</span> explained: <code>α × σ : Type u</code> so both <code>m α</code> and <code>m (α × σ)</code> have the same sort <code>Type v</code>.</p>
<p>However, given that </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span>
<span class="c1">-- Type u → Type v : Type (max (u + 1) (v + 1))</span>
</code></pre></div>
<p>I would have expected the result to have type <code>Type (max (u + 1) (v + 1))</code> instead of just <code>Type (max u v)</code>. What am I missing here?</p>
<p>Second, it seems that it is crucial to appreciate the difference between sort and types when comparing <code>α</code> and <code>α × σ</code>.<br>
Same sort: <code>Type u</code>; different types: <code>α</code> and <code>α × σ</code>.</p>
<p>Third, it seems that one can further constrain arguments/results in Lean4 as evidence in the difference between <code>StateT.run</code> and <code>StateT.run'</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">namespace</span> <span class="n">confused</span>

<span class="kd">def</span> <span class="n">StateT</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">σ</span> <span class="bp">→</span> <span class="n">m</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">σ</span><span class="o">)</span>

<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">StateT.run</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">StateT</span> <span class="n">σ</span> <span class="n">m</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">σ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">x</span> <span class="n">s</span>

<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">StateT.run'</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">Functor</span> <span class="n">m</span><span class="o">]</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">StateT</span> <span class="n">σ</span> <span class="n">m</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="o">(</span><span class="bp">·.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">x</span> <span class="n">s</span>

<span class="c1">-- from Init/Control/Lawful.lean</span>
<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">run'_eq</span> <span class="o">[</span><span class="n">Monad</span> <span class="n">m</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">StateT</span> <span class="n">σ</span> <span class="n">m</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">:</span> <span class="n">run'</span> <span class="n">x</span> <span class="n">s</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">·.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">run</span> <span class="n">x</span> <span class="n">s</span> <span class="o">:=</span>
  <span class="n">rfl</span>

<span class="kd">end</span> <span class="n">confused</span>
</code></pre></div>
<p>I am confused why <code>StateT.run</code> and <code>StateT.run'</code> have different types: <code>m (α × σ)</code> vs. <code>m α</code>.</p>
<p>I tried to copy the <code>run'_eq</code> theorem in this confused sandbox but I get errors that only increase my state of confusion:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- about: run' x s</span>
<span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">run'</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m.512</span>

<span class="c1">-- about: (·.1)</span>
<span class="n">invalid</span> <span class="n">field</span> <span class="kd">notation</span><span class="o">,</span> <span class="n">type</span> <span class="n">is</span> <span class="n">not</span> <span class="n">of</span> <span class="n">the</span> <span class="n">form</span> <span class="o">(</span><span class="n">C</span> <span class="bp">...</span><span class="o">)</span> <span class="n">where</span> <span class="n">C</span> <span class="n">is</span> <span class="n">a</span> <span class="kd">constant</span>
  <span class="n">a</span><span class="bp">✝</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m.571</span>

<span class="c1">-- about: run x s</span>
<span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">run</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m.546</span>
</code></pre></div>
<p>Fourth, I managed to rewrite <code>StateT.run'</code> to make the functor explicit:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">StateT.run''</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">F</span><span class="o">:</span> <span class="n">Functor</span> <span class="n">m</span><span class="o">]</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">StateT</span> <span class="n">σ</span> <span class="n">m</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">pair</span> <span class="o">:</span> <span class="n">m</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">σ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span> <span class="n">s</span>
  <span class="n">F.map</span> <span class="n">Prod.fst</span> <span class="n">pair</span>
</code></pre></div>
<p>I would have liked to make a variant of the <code>run'_eq</code> theorem for this but given that the mere copy/paste does not work; I am not sure how to proceed.</p>
<p>Fifth, assuming that <code>StateT.run''</code> is equivalent to <code>StateT.run'</code>, I would like to understand how it is possible that <code>m</code> appears in two different types:</p>
<ul>
<li><code>m α</code></li>
<li><code>m (α × σ)</code></li>
</ul>
<p>Is there a simple example of using <code>StateT.run</code> and <code>StateT.run'</code> that could help shed light on what kind of thing is <code>m</code>?</p>



<a name="290307535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290307535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290307535">(Jul 20 2022 at 22:23)</a>:</h4>
<blockquote>
<p>I would have expected the result to have type Type (max (u + 1) (v + 1)) instead of just Type (max u v). What am I missing here?</p>
</blockquote>
<p>The definition of <code>ReaderT</code> has that <code>σ → m α : Type (max u v)</code>, and your <code>#check</code> says that <code>Type u → Type v : Type (max (u + 1) (v + 1))</code>. There's nothing inconsistent here since in the first case you have the type of functions between types, and in the second you have the type of functions between universes (what you're calling sorts). (Universes are types, too, in Lean, so it makes sense to have functions between them.)</p>



<a name="290307933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290307933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290307933">(Jul 20 2022 at 22:27)</a>:</h4>
<p>The difference between <code>StateT.run</code> and <code>StateT.run'</code> is that <code>StateT.run'</code> does <code>fmap prod.fst (x s)</code> rather than just <code>x s</code> (if I expanded out that notation correctly).</p>



<a name="290308068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290308068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290308068">(Jul 20 2022 at 22:28)</a>:</h4>
<blockquote>
<p>I tried to copy the run'_eq theorem</p>
</blockquote>
<p>This doesn't work because the place you got it from was inside a <code>namespace</code>. Try changing <code>run'</code> and <code>run</code> to <code>StateT.run</code> and <code>StateT.run'</code>, which hopefully is enough.</p>



<a name="290308280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290308280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290308280">(Jul 20 2022 at 22:30)</a>:</h4>
<p>If you're getting really confused about type universes, I suggest that for now you just pretend that <code>Type u</code> is <code>Type</code> everywhere. The algorithm you were looking at earlier should still work under this assumption.</p>



<a name="290308434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/confused%20about%20types%20and%20Type/near/290308434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/confused.20about.20types.20and.20Type.html#290308434">(Jul 20 2022 at 22:32)</a>:</h4>
<p>I believe that if you made your own copy of <code>StateT</code> and the rest with all the type universes replaced with <code>Type</code> it should all still work.</p>
<p>All this universe polymorphism isn't usually important when writing programs, but it's great that it's there when you need it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/.22Deep.22.20cases.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html">"Deep" cases</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206514752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206514752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206514752">(Aug 10 2020 at 21:19)</a>:</h4>
<p>Is there a "deep" version of cases that doesn't look terrible. I find it very unfortunate that the <code>rintro</code> and <code>rcases</code> need four pairs of <code>⟨⟩</code> to fully destruct <code>im</code>. I'd expect <code>example : im → true := by { rintro (⟨⟩ | ⟨⟩); trivial }</code> to suffice.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">im</span>
<span class="bp">|</span> <span class="n">r</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">i</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">im</span> <span class="bp">→</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintro</span> <span class="o">(</span><span class="bp">⟨⟨⟩⟩</span> <span class="bp">|</span> <span class="bp">⟨⟨⟩⟩</span><span class="o">)</span><span class="bp">;</span> <span class="n">trivial</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">im</span> <span class="bp">→</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">a</span> <span class="k">with</span> <span class="bp">⟨⟨⟩⟩</span> <span class="bp">|</span> <span class="bp">⟨⟨⟩⟩;</span> <span class="n">trivial</span>
<span class="kn">end</span>
</code></pre></div>



<a name="206514995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206514995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206514995">(Aug 10 2020 at 21:21)</a>:</h4>
<p>Also, is there a tactic like <code>simp</code> that destructs terms in the environment?</p>



<a name="206515351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206515351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206515351">(Aug 10 2020 at 21:24)</a>:</h4>
<p>There are four values of <code>im</code>, so you should have three <code>|</code>s total. But <code>rcases</code> is very tolerant of the wrong syntax (maybe too tolerant?)</p>



<a name="206515378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206515378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206515378">(Aug 10 2020 at 21:24)</a>:</h4>
<p><code>rcases? a</code> should show the correct pattern</p>



<a name="206516533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206516533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206516533">(Aug 10 2020 at 21:35)</a>:</h4>
<p>Your example is a bit odd, <code>example : im → true := by { rintro (⟨⟩ | ⟨⟩); trivial }</code> will always work because you are just proving true</p>



<a name="206516623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206516623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206516623">(Aug 10 2020 at 21:36)</a>:</h4>
<p>I guess you want to case on the elements of bool, producing four cases?</p>



<a name="206516729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206516729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206516729">(Aug 10 2020 at 21:37)</a>:</h4>
<p>The correct syntax for that is <code>rintro (⟨_|_⟩ | ⟨_|_⟩)</code>.</p>



<a name="206516906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206516906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206516906">(Aug 10 2020 at 21:39)</a>:</h4>
<p>The reason is that matching on an inductive type actually requires the syntax <code>⟨a,b⟩ | ⟨c,d⟩ | ⟨e⟩</code>, involving an alternation of tuples. So if <code>e</code> here was an inductive type with one constructor you would have to write <code>⟨a,b⟩ | ⟨c,d⟩ | ⟨⟨e_inner⟩⟩</code> to destruct it</p>



<a name="206517040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206517040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206517040">(Aug 10 2020 at 21:40)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/3730">#3730</a> is a rewrite of <code>rcases</code>, so if you want to change this behavior now is a good time to interject</p>



<a name="206517363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206517363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206517363">(Aug 10 2020 at 21:44)</a>:</h4>
<p>We could make it so that the tuple brackets are not expected for variants with one argument, i.e. the correct way to pattern match on</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">foo</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="n">two</span> <span class="o">(</span><span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span>
</code></pre></div>


<p>is <code>_ | a | ⟨b,c⟩</code>, where the tuple brackets are not expected in the second case, and then <code>_ | ⟨a_inner⟩ | ⟨b,c⟩</code> would do one further destructuring on <code>a</code>. This is a pretty big breaking change though</p>



<a name="206517840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%22Deep%22%20cases/near/206517840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/.22Deep.22.20cases.html#206517840">(Aug 10 2020 at 21:49)</a>:</h4>
<p>The new version of cases will accept <code>rintro ((_|_) | (_|_))</code> for this example, which I think is a bit better, avoiding the need for the tuple brackets</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
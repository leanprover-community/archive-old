---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Induction.20proofs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html">Induction proofs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="201034035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201034035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Tsynkov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201034035">(Jun 16 2020 at 15:41)</a>:</h4>
<p>My first question. Beware.  What is the best way to do an induction proof if the base case is not 0? For example, prove that <code>sum_{i=1}^n  (2i-1) = n^2</code> by induction on <code>n</code> starting with <code>n=1</code>. In this case one can shift and do <code>sum_{j=0} (2j+1)</code> instead. But I'm interested to see how to deal with the original form if possible. Can one still somehow easily use the <code>induction n</code> tactic like in the natural game? Thank you!</p>



<a name="201034526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201034526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201034526">(Jun 16 2020 at 15:44)</a>:</h4>
<p>i think reparameterizing so that the induction variable starts at 0 is a good approach.</p>



<a name="201034563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201034563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201034563">(Jun 16 2020 at 15:44)</a>:</h4>
<p>do you have example code? (where you managed to make the induction work but you want advice on how to make it cleaner?)</p>



<a name="201035644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201035644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201035644">(Jun 16 2020 at 15:52)</a>:</h4>
<p>I think the base case for that sum question is n=0 anyway ;-) The empty sum is 0. But in general when I'm in this situation, assuming the base case isn't any larger than 2, I do <code>cases n with n'</code> and then I have to deal with the case n=0 separately, and now we're left with the case n=n'+1, and if my base case is 1 I do induction on n' but if it's bigger than 1 I do cases n' again. There might be some induction theorem in the library which saves you having to do this.</p>



<a name="201036032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201036032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201036032">(Jun 16 2020 at 15:55)</a>:</h4>
<p><span class="user-mention" data-user-id="312045">@Victor Tsynkov</span> one thing I find particularly sexy about Lean is that it's possible to rigorously ask your question as a Lean <code>sorry</code> which you want filled in. For example, if you were interested in how to do induction starting from the case n=d you could ask how to fill in the following sorry:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="c1">-- thing you want to prove</span>
  <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="c1">-- base</span>
  <span class="o">(</span><span class="n">hbase</span> <span class="o">:</span> <span class="n">P</span> <span class="n">d</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hstep</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201036390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201036390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201036390">(Jun 16 2020 at 15:57)</a>:</h4>
<p>and another thing which is particularly sexy (especially now, given that it just worked) is that you can search the library and see what you need is in there already. And lo:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="c1">-- base</span>
  <span class="o">(</span><span class="n">hbase</span> <span class="o">:</span> <span class="n">P</span> <span class="n">d</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hstep</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">library_search</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>takes a while to run, but comes up with  <code>exact nat.le_induction hbase hstep n hn,</code></p>



<a name="201036829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201036829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201036829">(Jun 16 2020 at 15:59)</a>:</h4>
<p>So the answer to your question is that you can <code>apply nat.le_induction</code> and what is even cooler is that you learnt that if instead of asking an informal question you can ask a formalised question, then you might be able to use Lean's tactics to find out your own answer :D</p>
<div class="codehilite"><pre><span></span><code><span class="n">nat</span><span class="bp">.</span><span class="n">le_induction</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">P</span> <span class="n">m</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">n</span>
</code></pre></div>



<a name="201038195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201038195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Tsynkov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201038195">(Jun 16 2020 at 16:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <span class="user-mention" data-user-id="252300">@Jalex Stark</span>  Thank you both a lot! I didn't know how to actually write the sum in Lean to post working code, let alone how to search for a general induction framework, but this will help me get going.</p>



<a name="201038652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201038652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201038652">(Jun 16 2020 at 16:12)</a>:</h4>
<p>I didn't write any sum, I just said "let P n be any true/false statement at all".</p>



<a name="201038719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201038719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201038719">(Jun 16 2020 at 16:13)</a>:</h4>
<p>Working in the biggest generality is somehow the right thing to do here</p>



<a name="201066263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201066263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Tsynkov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201066263">(Jun 16 2020 at 19:59)</a>:</h4>
<p>Finally! I think I got to prove this, thanks to the information in this thread:</p>
<p><a href="#narrow/stream/113489-new-members/topic/Computing.20finset.20(range).20sums">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Computing.20finset.20(range).20sums</a></p>
<p>Posting this here in case someone else will be interested. The proof starting at one seems quite a bit longer than the other one though!</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="c1">-- shift terms for a series</span>
<span class="n">def</span> <span class="n">g1</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">-</span> <span class="mi">1</span> <span class="c1">-- for i = 1, 2, ...</span>
<span class="c1">-- change to</span>
<span class="n">def</span> <span class="n">g2</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">j</span> <span class="bp">+</span> <span class="mi">1</span>  <span class="c1">-- now j = 0, 1, 2, ...</span>

<span class="c1">--!!! the best way to do it ???</span>
<span class="kn">lemma</span> <span class="n">ind_start_one</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_induction</span><span class="o">,</span>
    <span class="o">{</span>   <span class="c1">-- base case</span>
        <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_range_succ</span> <span class="n">g1</span> <span class="mi">1</span><span class="o">,</span>
        <span class="n">unfold</span> <span class="n">g1</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="mi">1</span><span class="o">,</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
            <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_range_succ</span> <span class="n">g1</span> <span class="mi">0</span><span class="o">,</span>
            <span class="c1">--simp,</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">add_zero</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_empty</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range_zero</span><span class="o">],</span>
            <span class="n">unfold</span> <span class="n">g1</span><span class="o">,</span> <span class="n">norm_num</span><span class="o">,</span>
        <span class="n">unfold</span> <span class="n">g1</span> <span class="n">at</span> <span class="n">h1</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">h1</span><span class="o">,</span> <span class="n">norm_num</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>   <span class="c1">-- inductive step</span>
        <span class="n">intros</span> <span class="n">n</span> <span class="n">hn</span> <span class="n">hind</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_range_succ</span> <span class="n">g1</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
        <span class="n">rw</span> <span class="n">hind</span><span class="o">,</span>
        <span class="n">unfold</span> <span class="n">g1</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">,</span> <span class="n">ring</span><span class="o">,</span> <span class="c1">-- can&#39;t do it without this step!</span>
        <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">norm_num</span><span class="o">,</span> <span class="n">ring</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">done</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">,</span> <span class="n">g2</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
    <span class="o">{</span>  <span class="c1">-- base case n = 0; nothing to sum</span>
        <span class="n">refl</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span> <span class="c1">-- inductive case</span>
        <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_range_succ</span> <span class="n">g2</span> <span class="n">d</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">d</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_eq_add_one</span> <span class="n">d</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">h2</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h1</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hd</span><span class="o">,</span>
        <span class="n">unfold</span> <span class="n">g2</span><span class="o">,</span> <span class="n">ring</span><span class="o">,</span>
    <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201066303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201066303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Tsynkov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201066303">(Jun 16 2020 at 19:59)</a>:</h4>
<p>But I do have another question.</p>



<a name="201066911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201066911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Tsynkov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201066911">(Jun 16 2020 at 20:04)</a>:</h4>
<p>When trying to use <code>exact</code> instead of <code>apply</code>, these two below seem to be the same. Never mind the <code>sorry</code>, why would <code>exact</code> fail in the second case? It's fed the same terms as far as I can tell.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">def</span> <span class="n">g1</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">i</span> <span class="bp">-</span> <span class="mi">1</span> <span class="c1">-- for i = 1, 2, ...</span>

<span class="c1">-- go forward</span>
<span class="n">def</span> <span class="n">prd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span>
<span class="kn">lemma</span> <span class="n">ind_start_one_forw_1</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">prd</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="c1">-- first show this is true for n = 1</span>
    <span class="k">have</span> <span class="n">hbase</span> <span class="o">:</span> <span class="n">prd</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span>
    <span class="c1">-- then show that ∀ n : ℕ, 1 ≤ n &amp;&amp; true for n → true for (n+1)</span>
    <span class="k">have</span> <span class="n">hstep</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">prd</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">prd</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
    <span class="o">{</span>
        <span class="n">sorry</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_induction</span> <span class="n">hbase</span> <span class="n">hstep</span> <span class="n">n</span><span class="o">,</span> <span class="c1">-- this is fine</span>
<span class="kn">end</span>

<span class="c1">-- some strange behaviour here, not sure what&#39;s going on yet</span>
<span class="c1">-- isn&#39;t this the same as variant _f1 above?</span>
<span class="kn">lemma</span> <span class="n">ind_start_one_forw_2</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="c1">-- first show this is true for n = 1</span>
    <span class="k">have</span> <span class="n">hbase</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="mi">1</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">*</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span>
    <span class="c1">-- then show that ∀ m : ℕ, 1 ≤ m &amp;&amp; true for m → true for (m+1)</span>
    <span class="k">have</span> <span class="n">hstep</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">→</span>
        <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">2</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_induction</span> <span class="n">hbase</span> <span class="n">hstep</span> <span class="n">n</span><span class="o">,</span> <span class="c1">-- why would this fail ???</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201067171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201067171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201067171">(Jun 16 2020 at 20:05)</a>:</h4>
<p>Did you read the error message?</p>



<a name="201067249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201067249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Tsynkov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201067249">(Jun 16 2020 at 20:06)</a>:</h4>
<p>I can't make sense of it.</p>



<a name="201067613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201067613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201067613">(Jun 16 2020 at 20:09)</a>:</h4>
<p>Your base case proof did a lot of unnecessary work</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">ind_start_one</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_induction</span><span class="o">,</span>
    <span class="o">{</span>   <span class="c1">-- base case</span>
        <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_range_succ</span> <span class="n">g1</span> <span class="mi">1</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>   <span class="c1">-- inductive step</span>
        <span class="n">sorry</span>
    <span class="o">},</span>
    <span class="n">done</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201067615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201067615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201067615">(Jun 16 2020 at 20:09)</a>:</h4>
<p>subtraction is poorly behaved on <code>nat</code> so you can expect trouble if you use it, e.g. in the <code>g1</code> case. The base case is true by definition though:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">ind_start_one</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_induction</span><span class="o">,</span>
    <span class="o">{</span>   <span class="c1">-- base case</span>
        <span class="n">refl</span>
    <span class="o">},</span>
    <span class="o">{</span>   <span class="c1">-- inductive step</span>
        <span class="n">intros</span> <span class="n">n</span> <span class="n">hn</span> <span class="n">hind</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_range_succ</span> <span class="n">g1</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
        <span class="n">rw</span> <span class="n">hind</span><span class="o">,</span>
        <span class="n">unfold</span> <span class="n">g1</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">,</span> <span class="n">ring</span><span class="o">,</span> <span class="c1">-- can&#39;t do it without this step!</span>
        <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">norm_num</span><span class="o">,</span> <span class="n">ring</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">done</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201067732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201067732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201067732">(Jun 16 2020 at 20:10)</a>:</h4>
<p>what's the error message that you don't understand?</p>



<a name="201067801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201067801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201067801">(Jun 16 2020 at 20:11)</a>:</h4>
<p>error messages are one of the key ways that Lean teaches you how to use it</p>



<a name="201067916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201067916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201067916">(Jun 16 2020 at 20:12)</a>:</h4>
<p>If you read the error message you'll see that you have not fed the correct variables into the function in order to prove the result.</p>



<a name="201068046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201068046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201068046">(Jun 16 2020 at 20:14)</a>:</h4>
<p>Also, you can start that proof by <code>apply nat.le_induction</code>.</p>



<a name="201068094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201068094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201068094">(Jun 16 2020 at 20:14)</a>:</h4>
<p>(and then <code>refl</code>)</p>



<a name="201074201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201074201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Tsynkov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201074201">(Jun 16 2020 at 21:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Induction.20proofs/near/201067916">said</a>:</p>
<blockquote>
<p>If you read the error message you'll see that you have not fed the correct variables into the function in order to prove the result.</p>
</blockquote>
<p>I thought I fed the same variables in both cases. One worked, the other didn't. I'm still confused. It's just getting really late so no more coffee-:(</p>



<a name="201078761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201078761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201078761">(Jun 16 2020 at 21:50)</a>:</h4>
<p>The error is this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">le_induction</span> <span class="n">hbase</span> <span class="n">hstep</span>
<span class="n">term</span>
  <span class="n">hstep</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span>
    <span class="mi">1</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span>
    <span class="err">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">→</span>
    <span class="err">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span>
    <span class="mi">1</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span>
    <span class="err">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="err">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">g1</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>
</code></pre></div>


<p>so (replacing n by m in the second one) you have a sum being <code>m*m</code> and it expected it to be m, and you have another sum being <code>(m+1)*(m+1)</code> and  Lean expected it to be m+1. This means that either you've made some big error somewhere else, or you've just not fed the right variables in, in the right order.</p>



<a name="201078986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201078986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201078986">(Jun 16 2020 at 21:52)</a>:</h4>
<p>OK so in fact something a bit more subtle is going on.</p>



<a name="201079251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201079251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201079251">(Jun 16 2020 at 21:56)</a>:</h4>
<p><code>nat.le_induction</code> is a function and some of the inputs are explicit, but others are implicit, like <code>P</code>. Lean has to guess <code>P</code> and unfortunately what's happening is that you don't give Lean enough clues, and it's guessing it wrong; it sees <code>hbase</code> and figures that <code>m</code> must be 1 and then incorrectly guesses that all the 1's in <code>hbase</code> are going to be <code>n</code>s in the general case. Can you see that you haven't given Lean enough information to figure out <code>P</code>? There are lots of functions of n such that if you set n=1 they become <code>∑ i in finset.range (1+1), g1 i = 1 * 1</code>. You want three of those 1s to be ns, but not the fourth one; but Lean has no way of guessing this.</p>



<a name="201079325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201079325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201079325">(Jun 16 2020 at 21:56)</a>:</h4>
<p><code>apply nat.le_induction _ hstep</code> works. <code>hstep</code> has got a lot more clues in, and Lean can solve the jigsaw puzzle for <code>P</code> from <code>hstep</code>.</p>



<a name="201079617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201079617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201079617">(Jun 16 2020 at 22:00)</a>:</h4>
<p><code>refine nat.le_induction _ hstep n,</code> also works. Basically <code>hbase</code> is poisoned; it misleads the elaborator.</p>



<a name="201079799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201079799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201079799">(Jun 16 2020 at 22:02)</a>:</h4>
<p><code>    exact @nat.le_induction (λ n, ∑ (i : ℕ) in finset.range (n + 1), g1 i = n * n) _ hbase hstep _,</code> also works. Here we use <code>@</code> to tell Lean that we're going to input P directly; that way <code>hbase</code> can't confuse the elaborator.</p>



<a name="201124731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201124731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Victor Tsynkov <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201124731">(Jun 17 2020 at 10:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Induction.20proofs/near/201078986">said</a>:</p>
<blockquote>
<p>OK so in fact something a bit more subtle is going on.</p>
</blockquote>
<p>This makes sense. I had started to think something like this was going on, but I couldn't figure it all out. Thank you for such detailed explanation <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>



<a name="201124830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201124830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201124830">(Jun 17 2020 at 10:38)</a>:</h4>
<p>Yes, you were right to be confused, I had just assumed you'd fed the variables in in the wrong order but on closer inspection it was unification failing</p>



<a name="201125011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20proofs/near/201125011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20proofs.html#201125011">(Jun 17 2020 at 10:40)</a>:</h4>
<p>This sort of problem is super-hard; Lean has some algorithm which fails in some cases because failure is inevitable in this situation, you can't always guess P. Lean looks at the base case first and makes the wrong guess. If it looked at the step case first it would be OK, but then you'll find examples where looking at the step case gave you the wrong answer</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
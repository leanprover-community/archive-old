---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/field.20of.20fractions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html">field of fractions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="220376819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220376819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220376819">(Dec 18 2020 at 14:21)</a>:</h4>
<p>Before I embark in proving the lemma below, could I ask that it is what I think that it is mathematically?</p>
<p>I want to prove that if <code>f : polynomial ℤ</code> and <code>a b : ℤ</code>, then <code>b ^ f.nat_degree * eval f (a / b)</code> is an integer.  Is this what the code below generalizes?  Is the statement that I want already in Lean?</p>
<p>Thanks! </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">d</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nums_dens</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span>
  <span class="o">(((</span><span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">d.to_map</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220377906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220377906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220377906">(Dec 18 2020 at 14:30)</a>:</h4>
<p>(Also, feel free to suggest any improvements to the statement: I have never used localizations in Lean before.)</p>



<a name="220378937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220378937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220378937">(Dec 18 2020 at 14:39)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> yup, that statement looks right. And I'm sorry that it turns into such a mess.</p>



<a name="220379045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220379045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220379045">(Dec 18 2020 at 14:40)</a>:</h4>
<p>I think we should be able to make this look better... but it will require changes to mathlib</p>



<a name="220379062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220379062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220379062">(Dec 18 2020 at 14:40)</a>:</h4>
<p>Thanks for the confirmation!  Since I had not experience of fields of fractions, I wanted to make sure that I was not complicating my life too much by doing it like this!</p>



<a name="220379205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220379205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220379205">(Dec 18 2020 at 14:41)</a>:</h4>
<p>Should <a href="https://leanprover-community.github.io/mathlib_docs/find/fraction_map">docs#fraction_map</a> have a coe_to_fun equal to to_map?</p>



<a name="220379355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220379355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220379355">(Dec 18 2020 at 14:42)</a>:</h4>
<p>So that I understand Eric's comment: this means I would not need to type <code>d.to_map b</code>, but simply <code>d b</code> would suffice?</p>



<a name="220379408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220379408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220379408">(Dec 18 2020 at 14:43)</a>:</h4>
<p>I think <code>fraction_map</code> (and <code>localization_map</code>) should be predicates on <code>ring_hom</code>.</p>



<a name="220379431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220379431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220379431">(Dec 18 2020 at 14:43)</a>:</h4>
<p>But that requires a bunch of refactoring, for which I currently don't have the time</p>



<a name="220379513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220379513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220379513">(Dec 18 2020 at 14:44)</a>:</h4>
<p>I think the instance may already be there</p>



<a name="220379550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220379550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220379550">(Dec 18 2020 at 14:44)</a>:</h4>
<p>Does it work without to_map?</p>



<a name="220380354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220380354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220380354">(Dec 18 2020 at 14:51)</a>:</h4>
<p>I am waiting for Lean to process the file: it takes a really long time.</p>
<p>Earlier, though, I had to put in the <code>.to_map</code> since at some stage it was not working without.  However, it was also a stage where I did not have a correctly formed term, so I am not sure that the missing <code>.to_map</code> was the issue.</p>



<a name="220381099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220381099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220381099">(Dec 18 2020 at 14:57)</a>:</h4>
<p>It might be that you only need one of the <code>to_map</code>s</p>



<a name="220381272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220381272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220381272">(Dec 18 2020 at 14:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/220379408">said</a>:</p>
<blockquote>
<p>I think <code>fraction_map</code> (and <code>localization_map</code>) should be predicates on <code>ring_hom</code>.</p>
</blockquote>
<p>Perhaps <code>fraction_map R K</code> should even be a class extending <code>algebra R K</code>?</p>



<a name="220381643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220381643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220381643">(Dec 18 2020 at 15:01)</a>:</h4>
<p>Finally I could use Lean!  It seems to require the <code>.to_map</code>.  For instance</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nums_dens</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span>
  <span class="o">(((</span><span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">d</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
 <span class="c1">--function expected at</span>
<span class="c1">--  d</span>
<span class="c1">--term has type</span>
<span class="c1">--  localization_map (non_zero_divisors R) K</span>
</code></pre></div>
<p>whereas </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nums_dens</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span>
  <span class="o">(((</span><span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">d.to_map</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>works.</p>



<a name="220381822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220381822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220381822">(Dec 18 2020 at 15:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/220376819">said</a>:</p>
<blockquote>
<p>Before I embark in proving the lemma below, could I ask that it is what I think that it is mathematically?</p>
<p>I want to prove that if <code>f : polynomial ℤ</code> and <code>a b : ℤ</code>, then <code>b ^ f.nat_degree * eval f (a / b)</code> is an integer.  Is this what the code below generalizes?  Is the statement that I want already in Lean?</p>
<p>Thanks! </p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">d</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nums_dens</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span>
  <span class="o">(((</span><span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">d.to_map</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Equivalent, but nicer, should be to have the conclusion <code>d.is_integer ((((d.to_map b) ^ f.nat_degree * eval₂ d.to_map (d.to_map a / d.to_map b) f))</code> (see <a href="https://leanprover-community.github.io/mathlib_docs/find/localization_map.is_integer">docs#localization_map.is_integer</a>).</p>



<a name="220382032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220382032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220382032">(Dec 18 2020 at 15:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/220379355">said</a>:</p>
<blockquote>
<p>So that I understand Eric's comment: this means I would not need to type <code>d.to_map b</code>, but simply <code>d b</code> would suffice?</p>
</blockquote>
<p>It would be nice, but isn't possible at the moment. So you'll have to write <code>d.to_map b</code> always, unfortunately.</p>



<a name="220382215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220382215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220382215">(Dec 18 2020 at 15:05)</a>:</h4>
<p>Anne, thanks for the suggestion!  I will use <code>.is_integer</code>!  Also, no worries about the <code>.to_map</code>: it had not even occurred to me that it might be possible to not have to type it!</p>



<a name="220383119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220383119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220383119">(Dec 18 2020 at 15:12)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]{</span><span class="n">d</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">fraction_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">localization_map.to_ring_hom</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">nums_dens</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">d.is_integer</span> <span class="o">(</span><span class="n">d</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="bp">↑</span><span class="n">d</span> <span class="o">(</span><span class="n">d</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>If it doesn't cause too much pain, that <code>has_coe </code> instance could be added back to mathlib later.</p>



<a name="220383254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220383254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220383254">(Dec 18 2020 at 15:14)</a>:</h4>
<p>Ah, thanks a lot, Eric!  I am not at all familiar with <code>coe</code>stuff, but I am happy to use what you proposed!</p>
<p>In any case, I will start proving this result in a bit: I first need to set up an inductive argument.</p>



<a name="220383387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220383387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220383387">(Dec 18 2020 at 15:15)</a>:</h4>
<p>I'd probably try to prove the <code>to_map</code> version first, and then see what breaks if you use the <code>has_coe</code> instead one you already have the proof</p>



<a name="220383872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220383872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220383872">(Dec 18 2020 at 15:19)</a>:</h4>
<p>If we later decide to add the <code>has_coe</code>, we should not forget to also add a <code>has_coe_to_fun</code>, as explained in <a href="https://leanprover-community.github.io/mathlib_docs/notes.html#function%20coercion">the function coercion library note</a>.</p>



<a name="220407420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220407420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220407420">(Dec 18 2020 at 18:00)</a>:</h4>
<p>In case anyone is interested, want to golf the proofs or has comments of any form, below is a proof of the initial lemma!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.polynomial.erase_lead</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kn">open</span> <span class="n">polynomial</span> <span class="n">finset</span>

<span class="kd">lemma</span> <span class="n">erase_lead_card_support_eq</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f0</span> <span class="o">:</span> <span class="n">f.support.card</span> <span class="bp">=</span> <span class="n">c.succ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.erase_lead.support.card</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">erase_lead_support</span><span class="o">,</span> <span class="n">card_erase_of_mem</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">nat.pred_eq_of_eq_succ</span> <span class="n">f0</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">nat_degree_eq_support_max'</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">f.support.max'_mem</span> <span class="o">(</span><span class="n">nonempty_support_iff.mpr</span> <span class="n">_</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">support_zero</span><span class="o">,</span> <span class="n">card_empty</span><span class="o">]</span> <span class="n">at</span> <span class="n">f0</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">not_le.mpr</span> <span class="o">(</span><span class="n">nat.succ_pos</span> <span class="n">c</span><span class="o">))</span> <span class="o">(</span><span class="n">eq.ge</span> <span class="n">f0</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">Pind</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">P_0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">P_C_mul_pow</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">r</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">C</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">X</span> <span class="bp">^</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="n">P_C_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">,</span> <span class="n">f.nat_degree</span> <span class="bp">≤</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">g.nat_degree</span> <span class="bp">≤</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">,</span> <span class="n">f.nat_degree</span> <span class="bp">≤</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">f</span> <span class="n">df</span><span class="o">,</span>
  <span class="n">generalize'</span> <span class="n">hd</span> <span class="o">:</span> <span class="n">card</span> <span class="n">f.support</span> <span class="bp">=</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">c</span> <span class="k">with</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">df</span> <span class="n">f0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="o">(</span><span class="n">finsupp.support_eq_empty.mp</span> <span class="o">(</span><span class="n">card_eq_zero.mp</span> <span class="n">f0</span><span class="o">))</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">f</span> <span class="n">df</span> <span class="n">f0</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">erase_lead_add_C_mul_X_pow</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">P_C_add</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">erase_lead_nat_degree_le</span> <span class="n">df</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">nat_degree_C_mul_X_pow_le</span> <span class="o">(</span><span class="n">leading_coeff</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">nat_degree</span> <span class="n">f</span><span class="o">))</span> <span class="n">df</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">hc</span> <span class="n">_</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">erase_lead_nat_degree_le</span> <span class="n">df</span><span class="o">)</span> <span class="o">(</span><span class="n">erase_lead_card_support_eq</span> <span class="n">f0</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">P_C_mul_pow</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">df</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ne.def</span><span class="o">,</span> <span class="n">leading_coeff_eq_zero</span><span class="o">],</span>
      <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">not_le.mpr</span> <span class="o">(</span><span class="n">nat.succ_pos</span> <span class="n">c</span><span class="o">))</span> <span class="o">(</span><span class="n">eq.ge</span> <span class="n">f0</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">d</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">P_0</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">d.is_integer</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">N</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">eval₂_zero</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">],</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">d.to_map.map_zero</span><span class="o">⟩,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">P_C_mul_pow</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">),</span> <span class="n">r</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">N</span> <span class="bp">→</span>
    <span class="n">d.is_integer</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">N</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">X</span> <span class="bp">^</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">r</span> <span class="n">r0</span> <span class="n">nN</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">^</span> <span class="o">(</span><span class="n">N</span> <span class="bp">-</span> <span class="n">n</span><span class="o">),</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">C</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">X</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">nat_degree</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">C_mul_X_pow_eq_monomial</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat_degree_monomial</span> <span class="n">_</span> <span class="n">_</span> <span class="n">r0</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval₂_X_pow</span><span class="o">,</span> <span class="n">div_pow</span><span class="o">,</span> <span class="n">eval₂_C</span><span class="o">,</span> <span class="n">eval₂_mul</span><span class="o">,</span> <span class="n">ring_hom.map_pow</span><span class="o">,</span> <span class="n">ring_hom.map_mul</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="n">_</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">r</span><span class="o">),</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_eq_mul_left_iff</span><span class="o">],</span>
  <span class="n">left</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mul_div_assoc</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_div_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">mul_div_comm</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_eq_mul_left_iff</span><span class="o">],</span>
  <span class="n">left</span><span class="o">,</span>
  <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">div_eq_iff</span><span class="o">,</span> <span class="bp">←</span> <span class="n">pow_add</span><span class="o">,</span> <span class="n">nat.sub_add_cancel</span> <span class="n">nN</span><span class="o">],</span>
  <span class="n">intro</span> <span class="n">l0</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">b0</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">pow_eq_zero</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">localization_map.injective</span> <span class="n">d</span> <span class="n">le_rfl</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">ring_hom.map_pow</span><span class="o">,</span> <span class="n">ring_hom.map_zero</span><span class="o">,</span> <span class="n">localization_map.injective</span> <span class="n">d</span> <span class="n">le_rfl</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">P_C_add</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">),</span> <span class="n">f.nat_degree</span> <span class="bp">≤</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">g.nat_degree</span> <span class="bp">≤</span> <span class="n">N</span> <span class="bp">→</span>
    <span class="n">d.is_integer</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">N</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">→</span>
    <span class="n">d.is_integer</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">N</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">g</span><span class="o">)</span> <span class="bp">→</span>
    <span class="n">d.is_integer</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">N</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="n">f</span> <span class="n">g</span> <span class="n">fN</span> <span class="n">gN</span> <span class="o">⟨</span><span class="n">f1</span><span class="o">,</span> <span class="n">hf</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">g1</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">f1</span> <span class="bp">+</span> <span class="n">g1</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">eval₂_add</span><span class="o">,</span> <span class="n">hf</span><span class="o">,</span> <span class="n">hg</span><span class="o">,</span> <span class="n">ring_hom.map_add</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_integer_N</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">),</span> <span class="n">f.nat_degree</span> <span class="bp">≤</span> <span class="n">N</span> <span class="bp">→</span>
<span class="n">d.is_integer</span> <span class="o">(((</span><span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">N</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">Pind</span> <span class="n">N</span> <span class="o">(</span><span class="n">P_0</span> <span class="n">N</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b0</span><span class="o">)</span> <span class="o">(</span><span class="n">P_C_mul_pow</span> <span class="n">N</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b0</span><span class="o">)</span> <span class="o">(</span><span class="n">P_C_add</span> <span class="n">N</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b0</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">nums_dens</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">d.is_integer</span> <span class="o">(((</span><span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">is_integer_N</span> <span class="o">(</span><span class="n">nat_degree</span> <span class="n">f</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b0</span> <span class="n">f</span> <span class="n">le_rfl</span>
</code></pre></div>



<a name="220453588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220453588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220453588">(Dec 19 2020 at 04:42)</a>:</h4>
<p>A follow up question: is the definition below already in mathlib?  Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">zq</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">ℤ</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">z</span><span class="o">),</span>
  <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_units'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">surj'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">eq_iff_exists'</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>



<a name="220453815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220453815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220453815">(Dec 19 2020 at 04:51)</a>:</h4>
<p>Found it!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The cast from `int` to `rat` as a `fraction_map`. -/</span>
<span class="kd">def</span> <span class="n">int.fraction_map</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">ℤ</span> <span class="n">ℚ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">coe</span><span class="o">,</span>
  <span class="n">map_units'</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">submonoid.mem_carrier</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_unit_iff_ne_zero</span><span class="o">,</span> <span class="n">int.cast_eq_zero</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">]</span> <span class="n">using</span> <span class="n">hx</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">surj'</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">hd</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">d</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩⟩,</span> <span class="n">rat.mul_denom_eq_num</span><span class="o">⟩,</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="n">submonoid.mem_carrier</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero</span><span class="o">,</span> <span class="n">int.coe_nat_ne_zero_iff_pos</span><span class="o">]</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">eq_iff_exists'</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">int.cast_inj</span><span class="o">],</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">use</span> <span class="mi">1</span> <span class="o">},</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">⟩,</span> <span class="n">h</span><span class="o">⟩,</span>
    <span class="n">apply</span> <span class="n">int.eq_of_mul_eq_mul_right</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="n">submonoid.mem_carrier</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">hc</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">int.cast_ring_hom</span> <span class="n">ℚ</span> <span class="o">}</span>
</code></pre></div>



<a name="220454191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220454191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220454191">(Dec 19 2020 at 05:03)</a>:</h4>
<p>You can search <code>fraction_map ℤ ℚ</code> in VSCode</p>



<a name="220454618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220454618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220454618">(Dec 19 2020 at 05:16)</a>:</h4>
<p>Ah, thanks for the pointer!  I still had not realized that there was a search tool across all the repository!  I had created my own using <code>grep</code> on the command line!</p>



<a name="220455654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220455654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220455654">(Dec 19 2020 at 05:50)</a>:</h4>
<p>Once more, how can I prove this fact?  I cannot get the coercion to more from the submonoid to the element.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.non_zero_divisors</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">Z</span><span class="o">]</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="o">(</span><span class="n">non_zero_divisors</span> <span class="n">Z</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">↑</span><span class="n">c</span> <span class="bp">∈</span> <span class="n">non_zero_divisors</span> <span class="n">Z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220455726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220455726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220455726">(Dec 19 2020 at 05:53)</a>:</h4>
<p><code>exact c.2</code></p>



<a name="220455730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220455730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220455730">(Dec 19 2020 at 05:53)</a>:</h4>
<p>Seriously!  It works, thanks a lot!!</p>



<a name="220459587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220459587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220459587">(Dec 19 2020 at 08:05)</a>:</h4>
<p>Is there a way of finding out such proofs automatically?  Library_search does not seem to try the components of assumptions.</p>



<a name="220459832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220459832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220459832">(Dec 19 2020 at 08:12)</a>:</h4>
<p>Which is weird, because this is just shorthand for <code>subtype.property c</code></p>



<a name="220459958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220459958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220459958">(Dec 19 2020 at 08:17)</a>:</h4>
<p>Is there a tactic that tries out <code>exact h.i</code> where <code>h</code> is a hypothesis and <code>i</code> an index?</p>



<a name="220460008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220460008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220460008">(Dec 19 2020 at 08:18)</a>:</h4>
<p>Something like <code>assumption</code>, except... <code>subassumption</code>?</p>



<a name="220460064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220460064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220460064">(Dec 19 2020 at 08:20)</a>:</h4>
<p>A tactic like library_search is to find proofs when you don't know where they are. Here it's clear where the proof is, all you need to learn is the simple technique for getting it out.</p>



<a name="220460203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220460203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220460203">(Dec 19 2020 at 08:25)</a>:</h4>
<p>Re subassumption -- if you've spent some time playing with pp.all true you will discover how absolutely gigantic some terms are!</p>



<a name="220460254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220460254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220460254">(Dec 19 2020 at 08:26)</a>:</h4>
<p>That, together with the fact that figuring out if two terms have the same type is noncomputable, indicates that it might be better off just learning the trick</p>



<a name="220460409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220460409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220460409">(Dec 19 2020 at 08:31)</a>:</h4>
<p>Ok, in this case, I had no idea that <code>c.2</code> was my assumption, but I take your points!</p>



<a name="220460645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220460645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220460645">(Dec 19 2020 at 08:39)</a>:</h4>
<p>If you don't understand what c is or how to work with it, you should right click on <code>non_zero_divisors</code> and jump to definition, where you will see how it's defined and examples of how to use it plus the basic API (the lemmas proved just after the definition).</p>



<a name="220460691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220460691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220460691">(Dec 19 2020 at 08:40)</a>:</h4>
<p>Inside a tactic proof you can also do <code>cases c</code> if you want to see what it's hiding</p>



<a name="220460808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220460808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220460808">(Dec 19 2020 at 08:45)</a>:</h4>
<p>But in this case clicking on <code>non_zero_divisors</code> wouldn't help. It's the <code>coe_to_sort</code> that was hiding something</p>



<a name="220463166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220463166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220463166">(Dec 19 2020 at 10:04)</a>:</h4>
<p>Thank you both!  I had looked at non_zero_divisors and I tried to exact it a lot, but did not think of it having fields.  A rookie mistake!</p>



<a name="220463298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220463298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220463298">(Dec 19 2020 at 10:08)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> <code>non_zero_divisors</code> is a set. But sets can be coerced into types (using <code>coe_to_sort</code>). This coercion sends a set <code>s</code> to <code>subtype s = {x // x \in s}</code>.</p>



<a name="220463305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220463305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220463305">(Dec 19 2020 at 10:08)</a>:</h4>
<p>If <code>s : set X</code>, then <code>subtype s</code> is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span> <span class="n">val</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span>
  <span class="n">property</span> <span class="o">:</span> <span class="n">val</span> <span class="bp">\</span><span class="k">in</span> <span class="n">s</span> <span class="o">}</span>
</code></pre></div>



<a name="220463325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220463325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220463325">(Dec 19 2020 at 10:10)</a>:</h4>
<p>So if you have a term <code>c : non_zero_divisors</code>, then <code>c.val</code> is the raw element, and <code>c.property</code> is the proof witness that <code>c.val</code> is in fact a nonzero divisor.</p>



<a name="220463365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220463365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220463365">(Dec 19 2020 at 10:10)</a>:</h4>
<p><code>c.2</code> is just shorthand for <code>c.property</code>.</p>



<a name="220463372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220463372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220463372">(Dec 19 2020 at 10:10)</a>:</h4>
<p>But my main point is that <code>.val</code> and <code>.property</code> have nothing to do with <code>non_zero_divisor</code>. They come from <code>subtype</code>.</p>



<a name="220463385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220463385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220463385">(Dec 19 2020 at 10:11)</a>:</h4>
<p>And the <code>subtype</code> showed up by some hidden Lean trick, because <code>non_zero_divisor</code> was being treated as a <em>Type</em> instead of as a <em>set</em>.</p>



<a name="220463519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220463519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220463519">(Dec 19 2020 at 10:14)</a>:</h4>
<p>Thank you very much for the explanation!  I am now just competent enough to understand what you are saying!</p>



<a name="220463522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220463522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220463522">(Dec 19 2020 at 10:14)</a>:</h4>
<p>And it clarifies a lot!</p>



<a name="220494422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220494422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220494422">(Dec 20 2020 at 00:15)</a>:</h4>
<p>I bet <code>suggest</code> would give you the proof right away</p>



<a name="220495084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220495084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220495084">(Dec 20 2020 at 00:36)</a>:</h4>
<p><code>hint</code> suggests <code>cases c</code> and then <code>hint</code> again suggests <code>tauto</code> which works :-)</p>



<a name="220495339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220495339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220495339">(Dec 20 2020 at 00:44)</a>:</h4>
<p>Ah. That's too bad! Is there any way to add <code>subtype.property</code> to the <code>suggest</code> list?</p>



<a name="220503813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220503813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220503813">(Dec 20 2020 at 05:16)</a>:</h4>
<p>Thanks for the suggestion of using <code>cases</code>!  I do not use cases enough, I think.  Once that step made its way in its final form, it is included in the line</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">exact</span> <span class="n">false.rec</span> <span class="n">_</span> <span class="o">(</span><span class="n">not_not.mpr</span> <span class="n">ze</span> <span class="o">(</span><span class="n">mem_non_zero_divisors_iff_ne_zero.mp</span> <span class="n">c.property</span><span class="o">))</span>
</code></pre></div>



<a name="220504357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220504357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220504357">(Dec 20 2020 at 05:33)</a>:</h4>
<p>Below is a proof that you can obtain a <code>fraction_map</code> out of an <code>injective</code> ring homomorphism such that every element of the target is the ratio of two elements of the source.  This is not much longer than the proof of <code>int.fraction_map</code> and you can recover <code>int.fraction_map</code> from this in 4 lines.</p>
<ol>
<li>Is the lemma below already in mathlib?  I could not find it.</li>
<li>Does it seem like a valuable addition?</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">fraction_map_of_inj_frac</span> <span class="o">{</span><span class="n">Z</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">Z</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">Q</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">Z</span> <span class="bp">→+*</span> <span class="n">Q</span><span class="o">)</span>
  <span class="o">(</span><span class="n">inj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">i</span><span class="o">)</span>
  <span class="o">(</span><span class="n">gen</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">q</span> <span class="o">:</span> <span class="n">Q</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Z</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">*</span> <span class="n">i</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">i</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fraction_map</span> <span class="n">Z</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">i</span> <span class="n">z</span><span class="o">),</span>
  <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">ring_hom.map_one</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">ring_hom.map_mul</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">ring_hom.map_zero</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">ring_hom.map_add</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">map_units'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">submonoid.mem_carrier</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨{</span><span class="n">val</span> <span class="o">:=</span> <span class="n">i</span> <span class="n">y</span><span class="o">,</span> <span class="n">inv</span> <span class="o">:=</span> <span class="o">(</span><span class="n">i</span> <span class="n">y</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="n">val_inv</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">inv_val</span> <span class="o">:=</span> <span class="n">_</span><span class="o">},</span> <span class="n">rfl</span><span class="o">⟩</span><span class="bp">;</span>
    <span class="o">{</span> <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">mul_inv_cancel</span> <span class="o">},</span>
      <span class="n">try</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">inv_mul_cancel</span> <span class="o">},</span>
      <span class="n">rw</span> <span class="bp">←</span> <span class="n">ring_hom.map_zero</span> <span class="n">i</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">function.injective.ne</span> <span class="n">inj</span> <span class="n">z</span> <span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">surj'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">b0</span><span class="o">,</span> <span class="n">H</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">gen</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class="n">b0</span><span class="o">⟩⟩,</span> <span class="n">H</span><span class="o">⟩,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">eq_iff_exists'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">function.injective.eq_iff</span> <span class="n">inj</span><span class="o">,</span> <span class="n">mul_eq_mul_right_iff</span><span class="o">],</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">or.inl</span> <span class="n">h</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">ze</span><span class="o">⟩,</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">false.rec</span> <span class="n">_</span> <span class="o">(</span><span class="n">not_not.mpr</span> <span class="n">ze</span> <span class="o">(</span><span class="n">mem_non_zero_divisors_iff_ne_zero.mp</span> <span class="n">c.property</span><span class="o">))</span> <span class="o">},</span>
 <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="220504477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/220504477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#220504477">(Dec 20 2020 at 05:36)</a>:</h4>
<p>And below is the proof of <code>int.fraction_map</code>, given the lemma above.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">ZQ_alg</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">ℤ</span> <span class="n">ℚ</span> <span class="o">:=</span>
<span class="n">fraction_map_of_inj_frac</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">ℤ</span> <span class="n">ℚ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="bp">@</span><span class="n">int.cast_inj</span> <span class="n">ℚ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rwa</span> <span class="n">ring_hom.eq_int_cast</span> <span class="n">at</span> <span class="n">h</span><span class="o">)))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">q</span><span class="o">,</span> <span class="o">⟨</span><span class="n">q.1</span><span class="o">,</span> <span class="n">q.2</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">norm_cast</span><span class="o">,</span> <span class="n">exact</span> <span class="n">rat.denom_ne_zero</span> <span class="n">q</span> <span class="o">},</span>
    <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ring_hom.eq_int_cast</span><span class="o">,</span> <span class="n">ring_hom.eq_int_cast</span><span class="o">,</span> <span class="n">int.cast_coe_nat</span><span class="o">,</span> <span class="n">rat.mul_denom_eq_num</span><span class="o">]</span> <span class="o">)⟩)</span>
</code></pre></div>
<p>together with a proof that it coincides with the earlier definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">ZQ_alg</span> <span class="bp">=</span> <span class="n">fraction_map.int.fraction_map</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ring_hom.eq_int_cast</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="221219330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221219330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221219330">(Dec 30 2020 at 15:15)</a>:</h4>
<p>Dear All,</p>
<p>in the process of cleaning up, I now have two almost identical proofs of essentially the same statement.  One assumes that you start with a <code>semiring/comm_ring</code> pair, the other with an <code>integral_domain/field</code> pair.  I would like to obtain the <code>integral_domain/field</code> result as an application of the <code>semiring/comm_ring</code> one.  However, I seem to be steering Lean to proving something that is not true.  Can anyone help me with the second <code>sorry</code> below, please?  Thank you very much!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.localization</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kn">section</span> <span class="n">semiring</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">bi</span> <span class="o">:</span> <span class="n">K</span><span class="o">}</span> <span class="o">{</span><span class="n">bu</span> <span class="o">:</span> <span class="n">bi</span> <span class="bp">*</span> <span class="n">i</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nums_dens</span>  <span class="c1">-- this is the lemma that I can prove</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">bi</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">bu</span> <span class="o">:</span> <span class="n">bi</span> <span class="bp">*</span> <span class="n">i</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">D</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">i</span> <span class="n">D</span> <span class="bp">=</span> <span class="o">(</span><span class="n">i</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">polynomial.map</span> <span class="n">i</span> <span class="n">f</span><span class="o">)))</span> <span class="o">:=</span>
<span class="gr">sorry</span>  <span class="c1">-- I have a full proof of this fact</span>

<span class="kd">end</span> <span class="n">semiring</span>

<span class="kn">section</span> <span class="n">fractions_map</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">d</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">}</span>

<span class="c1">-- this is the "special case" of the previous one that I can only prove by reproving it along</span>
<span class="c1">-- the same lines as the lemma above</span>
<span class="kd">lemma</span> <span class="n">nums_dens_2</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">d.is_integer</span> <span class="o">(((</span><span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">nums_dens</span> <span class="n">d.to_map</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">eval</span><span class="o">,</span> <span class="c1">-- here you can see that Lean is following different paths that seem to diverge</span>
  <span class="gr">sorry</span><span class="o">,</span> <span class="c1">-- I can see that Lean went to try to prove something that is not necessarily true</span>
  <span class="c1">-- but how can I get it to prove what actually is true?</span>
  <span class="n">apply</span> <span class="n">one_div_mul_cancel</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="o">(</span><span class="n">localization_map.to_map</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">map_zero</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">function.injective.ne</span> <span class="o">(</span><span class="n">fraction_map.injective</span> <span class="n">d</span><span class="o">)</span> <span class="n">b0</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">fractions_map</span>
</code></pre></div>



<a name="221220019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221220019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221220019">(Dec 30 2020 at 15:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.localization</span>
<span class="kn">import</span> <span class="n">tactic.field_simp</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kn">section</span> <span class="n">semiring</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">bi</span> <span class="o">:</span> <span class="n">K</span><span class="o">}</span> <span class="o">{</span><span class="n">bu</span> <span class="o">:</span> <span class="n">bi</span> <span class="bp">*</span> <span class="n">i</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nums_dens</span>  <span class="c1">-- this is the lemma that I can prove</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">bi</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">bu</span> <span class="o">:</span> <span class="n">bi</span> <span class="bp">*</span> <span class="n">i</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">D</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">i</span> <span class="n">D</span> <span class="bp">=</span> <span class="o">(</span><span class="n">i</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">i</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">bi</span><span class="o">)</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="gr">sorry</span>  <span class="c1">-- I have a full proof of this fact</span>

<span class="kd">end</span> <span class="n">semiring</span>

<span class="kn">section</span> <span class="n">fractions_map</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">d</span> <span class="o">:</span> <span class="n">fraction_map</span> <span class="n">R</span> <span class="n">K</span><span class="o">}</span>

<span class="c1">-- this is the "special case" of the previous one that I can only prove by reproving it along</span>
<span class="c1">-- the same lines as the lemma above</span>
<span class="kd">lemma</span> <span class="n">nums_dens_2</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">d.is_integer</span> <span class="o">(((</span><span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">nums_dens</span> <span class="n">d.to_map</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">field_simp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">one_div_mul_cancel</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="o">(</span><span class="n">localization_map.to_map</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">map_zero</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">function.injective.ne</span> <span class="o">(</span><span class="n">fraction_map.injective</span> <span class="n">d</span><span class="o">)</span> <span class="n">b0</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">fractions_map</span>
</code></pre></div>
<p>Note that I changed <code>eval</code> to <code>eval\_2</code> in the first lemma.</p>



<a name="221220152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221220152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221220152">(Dec 30 2020 at 15:26)</a>:</h4>
<p>I don't know how important it is for you to have <code>eval</code> as opposed to <code>eval_2</code>.</p>



<a name="221221142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221221142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221221142">(Dec 30 2020 at 15:42)</a>:</h4>
<p>Ah, thank you!  I will try to see how it plays out: to be honest, I do not know what the difference between<code>eval</code> and <code>eval2</code> is.</p>



<a name="221221251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221221251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221221251">(Dec 30 2020 at 15:44)</a>:</h4>
<p>As I understand it, <code>eval_2</code> takes a polynomial over <code>R</code> and a morphism <code>R -&gt; S</code> and evaluates the polynomial in <code>S</code>.</p>



<a name="221221261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221221261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221221261">(Dec 30 2020 at 15:44)</a>:</h4>
<p>So it looks like that's exactly what you're trying to do in <code>nums_dens</code>.</p>



<a name="221221311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221221311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221221311">(Dec 30 2020 at 15:45)</a>:</h4>
<p>If you insist on using <code>eval</code>, I suggest using <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.eval₂_eq_eval_map">docs#polynomial.eval₂_eq_eval_map</a></p>



<a name="221221456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221221456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221221456">(Dec 30 2020 at 15:47)</a>:</h4>
<p>Thanks for the conversion between eval and eval2: it seems that everything might be a simple <code>rw</code> away!</p>



<a name="221221711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221221711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221221711">(Dec 30 2020 at 15:50)</a>:</h4>
<p>Indeed: below is a proof of the literal statements that I wrote before!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">nums_dens_2</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">b0</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">d.is_integer</span> <span class="o">(((</span><span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">d.to_map</span> <span class="o">(</span><span class="n">d.to_map</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">wfs.nums_dens</span> <span class="n">d.to_map</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="n">d.to_map</span> <span class="n">b</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">eval₂_eq_eval_map</span><span class="o">,</span> <span class="n">mul_one_div</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">one_div_mul_cancel</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="o">(</span><span class="n">localization_map.to_map</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">map_zero</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">function.injective.ne</span> <span class="o">(</span><span class="n">fraction_map.injective</span> <span class="n">d</span><span class="o">)</span> <span class="n">b0</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Thank you very much!</p>



<a name="221221720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221221720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221221720">(Dec 30 2020 at 15:50)</a>:</h4>
<p>Right, there are 3 ways of evaluating polynomials. If you have <code>f : polynomial R</code>, then you can use</p>
<ul>
<li><code>eval</code> to evaluate <code>f</code> on elements of <code>R</code>,</li>
<li><code>eval2</code> to evaluate <code>f</code> on elements of <code>S</code>, but you have to provide a ring hom <code>R -&gt; S</code></li>
<li><code>aeval</code> to evaluate <code>f</code> on elements of <code>A</code>, if there is an instance <code>[algebra R A]</code> available.</li>
</ul>



<a name="221221818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221221818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221221818">(Dec 30 2020 at 15:51)</a>:</h4>
<p>(and some of this will assume various rings are commutative)</p>



<a name="221221820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221221820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221221820">(Dec 30 2020 at 15:51)</a>:</h4>
<p>Thank you both!</p>
<p>I personally prefer the initial version <code>nums_dens</code>.  However, it does not use the <code>localization</code> theory.  I would like to PR either one/both of these to mathlib: is there any preference?</p>



<a name="221222007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222007">(Dec 30 2020 at 15:54)</a>:</h4>
<p>probably both, because the proof of <code>nums_dens_2</code> is not a 1-liner.</p>



<a name="221222019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222019">(Dec 30 2020 at 15:54)</a>:</h4>
<p>You can also formulate <code>nums_dens</code> with <code>is_unit (i b)</code>.</p>



<a name="221222046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222046">(Dec 30 2020 at 15:55)</a>:</h4>
<p>Which I suppose is closer to the localization api.</p>



<a name="221222062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222062">(Dec 30 2020 at 15:55)</a>:</h4>
<p>(I meant, PR these with a full proof!  My preference would be to prove <code>nums_dens</code> and maybe or maybe not include also the proof above of <code>nums_dens_2</code>.  Since I do not have much experience with <code>localizations</code> in mathlib, I had worked with the initial version.  I do use the freedom of having a target field that is <em>larger</em> than the field of fractions.  In my intended application, the rings in question are ℤ and ℝ, rather than ℚ.)</p>



<a name="221222159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222159">(Dec 30 2020 at 15:56)</a>:</h4>
<p>That's another argument for <code>nums_dens</code>. It is a lot more flexible.</p>



<a name="221222174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222174">(Dec 30 2020 at 15:56)</a>:</h4>
<p>Ok, so I will PR the statement without <code>localizations</code> and merge it in some file.  Then, once this one is in, I will add the proof of <code>nums_dens_2</code> in the localization file.  Of course, the names will have to be better!</p>



<a name="221222201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222201">(Dec 30 2020 at 15:56)</a>:</h4>
<p>Don't we have something in mathlib which says "This morphism of rings <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> factors through <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A \to S^{-1}A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span></span></span></span>."?</p>



<a name="221222233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222233">(Dec 30 2020 at 15:57)</a>:</h4>
<p>I.e. <code>\forall s, is_unit (f s)</code></p>



<a name="221222240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222240">(Dec 30 2020 at 15:57)</a>:</h4>
<p>Hmm, maybe just PR only <code>nums_dens</code>. We'll see if <code>nums_dens_2</code> is useful in the end. Maybe if we refactor <code>localization</code> to make <code>localization_map</code> a predicate, then the proof of <code>nums_dens_2</code> will be a 1-liner.</p>



<a name="221222252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222252">(Dec 30 2020 at 15:57)</a>:</h4>
<p>If nobody gets to it before me, I hope to do this refactor 2nd half of Feb</p>



<a name="221222317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222317">(Dec 30 2020 at 15:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/221222201">said</a>:</p>
<blockquote>
<p>Don't we have something in mathlib which says "This morphism of rings <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> factors through <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A \to S^{-1}A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span></span></span></span>."?</p>
</blockquote>
<p>Probably <code>localization_map.lift</code> or something like that. I'm sure it's there.</p>



<a name="221222326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222326">(Dec 30 2020 at 15:58)</a>:</h4>
<p>Ok, I will do so!  As an idea, I like the <code>localization</code> idea, however, the possibility of working with a "possibly larger than the localization" target ring can be useful.</p>



<a name="221222364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222364">(Dec 30 2020 at 15:59)</a>:</h4>
<p>Yeah, I agree. That's why I suggested the <code>is_unit</code> thing, because I assumed the api for localization used it... I'm looking in mathlib now...</p>



<a name="221222373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222373">(Dec 30 2020 at 15:59)</a>:</h4>
<p>(I still do not have a good application in mind for the <code>semiring</code> stuff, so, although it is true with these very limited hypotheses, it is not this that sells it to me!)</p>



<a name="221222386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222386">(Dec 30 2020 at 15:59)</a>:</h4>
<p>Right <a href="https://leanprover-community.github.io/mathlib_docs/find/localization_map.lift">docs#localization_map.lift</a></p>



<a name="221222479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222479">(Dec 30 2020 at 16:00)</a>:</h4>
<p>So, I think if you can phrase your <code>nums_dens</code> using <code>is_unit</code>, it should be easy to relate it to localization via the universal property using <code>localization_map.lift</code>.</p>



<a name="221222959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221222959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221222959">(Dec 30 2020 at 16:06)</a>:</h4>
<p>Just to emphasize what you have all been saying: I had no use for this in this context, however, I would also find it useful to have the freedom in <code>localization</code> to work with the localization of a quotient.  If I understand correctly, this is where the <code>localization_map.lift</code> comes in.</p>



<a name="221223649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221223649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221223649">(Dec 30 2020 at 16:12)</a>:</h4>
<p>Well, what I'm saying is that the condition <code>is_unit (i b)</code> is equivalent to the assertion that the moprhism <code>i</code> factors through the localization at the element <code>b</code>. And the part of the localization api which lets you obtain the map from the localization at <code>b</code> is coming from <code>localization_map.lift</code>, where the assumption is <code>\forall s, is_unit (i s)</code> (or something similar...).</p>



<a name="221223655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221223655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221223655">(Dec 30 2020 at 16:12)</a>:</h4>
<p>So essentially, yes :)</p>



<a name="221223974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221223974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221223974">(Dec 30 2020 at 16:17)</a>:</h4>
<p>Here's a skeleton :)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.localization</span>
<span class="kn">import</span> <span class="n">algebra.group.units</span>
<span class="kn">import</span> <span class="n">tactic.field_simp</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kn">section</span> <span class="n">semiring</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">nums_dens</span>  <span class="c1">-- this is the lemma that I can prove</span>
  <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">i</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">D</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">i</span> <span class="n">D</span> <span class="bp">=</span> <span class="o">(</span><span class="n">i</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">f.nat_degree</span> <span class="bp">*</span> <span class="n">eval₂</span> <span class="n">i</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">hb.unit.inv</span><span class="o">)</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="gr">sorry</span>  <span class="c1">-- I have a full proof of this fact</span>

<span class="kd">end</span> <span class="n">semiring</span>
</code></pre></div>



<a name="221224096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221224096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221224096">(Dec 30 2020 at 16:19)</a>:</h4>
<p>Thanks!  I was trying to see how to extract the inverse from <code>is_unit</code>!</p>



<a name="221226541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221226541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221226541">(Dec 30 2020 at 16:56)</a>:</h4>
<p>I am failing to make progress: how do I access the fact that <code>is_unit</code> implies that there is an inverse?  Below is a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> that I am not able to solve.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.units</span>
<span class="kn">import</span> <span class="n">algebra.ring.basic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">K</span><span class="o">]</span>
  <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">iub</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">i</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">iub.unit.inv</span> <span class="bp">*</span> <span class="n">i</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">admit</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221226838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221226838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221226838">(Dec 30 2020 at 17:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/221221720">said</a>:</p>
<blockquote>
<p>Right, there are 3 ways of evaluating polynomials. If you have <code>f : polynomial R</code>, then you can use</p>
<ul>
<li><code>eval</code> to evaluate <code>f</code> on elements of <code>R</code>,</li>
<li><code>eval2</code> to evaluate <code>f</code> on elements of <code>S</code>, but you have to provide a ring hom <code>R -&gt; S</code></li>
<li><code>aeval</code> to evaluate <code>f</code> on elements of <code>A</code>, if there is an instance <code>[algebra R A]</code> available.</li>
</ul>
</blockquote>
<p>Is this in a module docstring somewhere? If not then it should be added.</p>



<a name="221229197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221229197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221229197">(Dec 30 2020 at 17:19)</a>:</h4>
<p>Are the three ways to do arbitrary unions, each with their own specific notation, documented somewhere?</p>



<a name="221239189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221239189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221239189">(Dec 30 2020 at 19:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113489-new-members/topic/field.20of.20fractions/near/221226541">said</a>:</p>
<blockquote>
<p>I am failing to make progress: how do I access the fact that <code>is_unit</code> implies that there is an inverse?  Below is a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> that I am not able to solve.</p>
</blockquote>
<p>Here's a proof (that can probably be golfed a bit):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.units</span>
<span class="kn">import</span> <span class="n">algebra.ring.basic</span>

<span class="c1">-- This should really be a simp lemma for `is_unit` itself...</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">K</span><span class="o">]</span>
  <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">iub</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">i</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">iub.unit.inv</span> <span class="bp">*</span> <span class="n">i</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">iub.unit.inv_val</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">_</span> <span class="bp">=</span> <span class="bp">↑</span><span class="o">(</span><span class="n">iub.unit</span><span class="o">),</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">iub.unit_spec</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="221239579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221239579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221239579">(Dec 30 2020 at 19:29)</a>:</h4>
<p>Thank you very much!</p>



<a name="221239661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221239661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221239661">(Dec 30 2020 at 19:30)</a>:</h4>
<p>It really looks like mathlib is missing some simp lemmas here...</p>



<a name="221239672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221239672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221239672">(Dec 30 2020 at 19:30)</a>:</h4>
<p>This proof should have been <code>by simp</code>.</p>



<a name="221239921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221239921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221239921">(Dec 30 2020 at 19:33)</a>:</h4>
<p>Yes, even with your solution, I am finding it very difficult to navigate with the <code>is_unit</code> command...</p>



<a name="221240010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221240010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221240010">(Dec 30 2020 at 19:34)</a>:</h4>
<p>In fact, maybe this example should be a <code>simp</code> lemma</p>



<a name="221240180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221240180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221240180">(Dec 30 2020 at 19:36)</a>:</h4>
<p>This is a bit better:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.units</span>
<span class="kn">import</span> <span class="n">algebra.ring.basic</span>

<span class="c1">-- rename this...</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">unit_val_eq_coe</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">units</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">u.val</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">u</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">-- rename this too...</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">is_unit_mul</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">hx.unit.inv</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">hx.unit.inv_val</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hx.unit_spec</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">K</span><span class="o">]</span>
  <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">K</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">iub</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">i</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">iub.unit.inv</span> <span class="bp">*</span> <span class="n">i</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span>
</code></pre></div>



<a name="221240667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221240667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221240667">(Dec 30 2020 at 19:43)</a>:</h4>
<p>I am off for the day, but will take a look at this soon!  I have PR <a href="https://github.com/leanprover-community/mathlib/issues/5529">#5529</a> with a single lemma waiting to be approved, before I will make a PR with the stuff about denominators!</p>



<a name="221241060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221241060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221241060">(Dec 30 2020 at 19:48)</a>:</h4>
<p>I left a review (-;</p>



<a name="221286776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221286776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221286776">(Dec 31 2020 at 12:24)</a>:</h4>
<p>A golf of <span class="user-mention" data-user-id="243562">@Adam Topaz</span>'s second lemma,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">is_unit.inv_mul</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">hx.unit.inv</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">units.inv_mul_of_eq</span> <span class="n">hx.unit_spec</span>
</code></pre></div>
<p>or possible more simp-normal,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">is_unit.inv_mul</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">is_unit</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">↑</span><span class="o">(</span><span class="n">hx.unit</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">units.inv_mul_of_eq</span> <span class="n">hx.unit_spec</span>
</code></pre></div>
<p>which parallels the theorem statement of <a href="https://leanprover-community.github.io/mathlib_docs/find/unit.inv_mul">docs#unit.inv_mul</a></p>



<a name="221443746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/field%20of%20fractions/near/221443746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/field.20of.20fractions.html#221443746">(Jan 03 2021 at 10:03)</a>:</h4>
<p>I created PR <a href="https://github.com/leanprover-community/mathlib/issues/5587">#5587</a> including the stuff about clearing denominators.  I still did not include the <code>is_unit</code> stuff, though.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
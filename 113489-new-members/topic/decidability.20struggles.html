---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/decidability.20struggles.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html">decidability struggles</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="234885593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234885593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234885593">(Apr 16 2021 at 16:41)</a>:</h4>
<p>I was trying to prove decidability of some predicates (about inhabited lists), and I got to a point where <code>#eval</code> on <code>to_bool</code> works the way I would expect but <code>#reduce</code> timeouts when using mathlib (and it works fine without it), and the <code>dec_trivial</code> tactic fails. What am I doing wrong? My experiment is attached:<br>
<a href="/user_uploads/3121/aed9iCvYAFjZiCO8S4OEyRqH/decibility_experiment.lean">decibility_experiment.lean</a></p>



<a name="234886272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234886272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234886272">(Apr 16 2021 at 16:46)</a>:</h4>
<p>Since the file is short, I've pasted it here:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">--import data.list -- import some mathlib, or not</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">forall2_inh_bool</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">P</span> <span class="o">(</span><span class="n">default</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">default</span> <span class="n">β</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">P</span> <span class="n">h1</span> <span class="o">(</span><span class="n">default</span> <span class="n">β</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">forall2_inh_bool</span> <span class="n">t1</span> <span class="o">[])</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">P</span> <span class="o">(</span><span class="n">default</span> <span class="n">α</span><span class="o">)</span> <span class="n">h2</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">forall2_inh_bool</span> <span class="o">[]</span> <span class="n">t2</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">P</span> <span class="n">h1</span> <span class="n">h2</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">forall2_inh_bool</span> <span class="n">t1</span> <span class="n">t2</span><span class="o">)</span>

<span class="k">#reduce</span> <span class="n">forall2_inh_bool</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">))</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
<span class="c1">-- tt without mathlib</span>
<span class="c1">-- timeout with mathlib</span>

<span class="kd">def</span> <span class="n">my_get</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">l.head</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">my_get</span> <span class="n">n</span> <span class="n">l.tail</span>

<span class="kd">lemma</span> <span class="n">my_get_nil</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">my_get</span> <span class="n">n</span> <span class="n">list.nil</span> <span class="bp">=</span> <span class="n">default</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">my_get_nil</span> <span class="n">n</span>

<span class="kd">lemma</span> <span class="n">forall2_inh_bool.correct</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">Hdec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">P</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]</span>
<span class="o">:</span> <span class="bp">∀</span> <span class="n">l1</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l2</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">,</span>
<span class="n">forall2_inh_bool</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">P</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="n">l1</span> <span class="n">l2</span> <span class="bp">=</span> <span class="n">tt</span>
<span class="bp">↔</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">my_get</span> <span class="n">n</span> <span class="n">l1</span><span class="o">)</span> <span class="o">(</span><span class="n">my_get</span> <span class="n">n</span> <span class="n">l2</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">[]</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">my_get_nil</span><span class="o">,</span> <span class="n">forall2_inh_bool</span><span class="o">],</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">H</span> <span class="n">n</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">H</span> <span class="mi">0</span><span class="o">⟩</span> <span class="c1">-- comment this line when using mathlib</span>
<span class="kd">end</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">[]</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">forall2_inh_bool</span><span class="o">,</span> <span class="n">forall2_inh_bool.correct</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">n</span><span class="o">,</span> <span class="n">cases</span> <span class="n">n</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H.1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H.2</span> <span class="n">n</span> <span class="o">},</span>
  <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">H</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">H</span> <span class="n">n.succ</span><span class="o">⟩</span>
<span class="kd">end</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">forall2_inh_bool</span><span class="o">,</span> <span class="n">forall2_inh_bool.correct</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">n</span><span class="o">,</span> <span class="n">cases</span> <span class="n">n</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H.1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H.2</span> <span class="n">n</span> <span class="o">},</span>
  <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">H</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">H</span> <span class="n">n.succ</span><span class="o">⟩</span>
<span class="kd">end</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">forall2_inh_bool</span><span class="o">,</span> <span class="n">forall2_inh_bool.correct</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">H</span> <span class="n">n</span><span class="o">,</span> <span class="n">cases</span> <span class="n">n</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H.1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H.2</span> <span class="n">n</span> <span class="o">},</span>
  <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">H</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">H</span> <span class="n">n.succ</span><span class="o">⟩</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">forall2_inh_dec</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">Hdec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">P</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]</span>
<span class="o">(</span><span class="n">l1</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l2</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span>
<span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">my_get</span> <span class="n">n</span> <span class="n">l1</span><span class="o">)</span> <span class="o">(</span><span class="n">my_get</span> <span class="n">n</span> <span class="n">l2</span><span class="o">))</span>
<span class="o">:=</span>
<span class="k">if</span> <span class="n">C</span> <span class="o">:</span> <span class="n">forall2_inh_bool</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">P</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="n">l1</span> <span class="n">l2</span> <span class="bp">=</span> <span class="n">tt</span> <span class="k">then</span>
  <span class="n">is_true</span> <span class="o">((</span><span class="n">forall2_inh_bool.correct</span> <span class="n">P</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">C</span><span class="o">)</span>
<span class="k">else</span> <span class="n">is_false</span> <span class="o">(</span><span class="n">mt</span> <span class="o">(</span><span class="n">forall2_inh_bool.correct</span> <span class="n">P</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">C</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">my_equiv</span> <span class="o">(</span><span class="n">l1</span> <span class="n">l2</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">my_get</span> <span class="n">n</span> <span class="n">l1</span> <span class="bp">=</span> <span class="n">my_get</span> <span class="n">n</span> <span class="n">l2</span>

<span class="kd">instance</span> <span class="n">equiv_decidable</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">decidable_rel</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="n">my_equiv</span>
<span class="o">:=</span> <span class="n">forall2_inh_dec</span> <span class="n">eq</span>

<span class="k">#eval</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">my_equiv</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">])</span>
<span class="c1">-- tt</span>

<span class="k">#reduce</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">my_equiv</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">])</span>
<span class="c1">-- tt without mathlib</span>
<span class="c1">-- timeout with mathlib</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">my_equiv</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">dec_trivial</span>
<span class="c1">-- fails</span>
</code></pre></div>
</div></div>



<a name="234886390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234886390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234886390">(Apr 16 2021 at 16:47)</a>:</h4>
<p>iirc, <code>&amp;&amp;</code> does not short circuit in Lean, correct?</p>



<a name="234931647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234931647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234931647">(Apr 16 2021 at 22:40)</a>:</h4>
<p>What does "shortening circuit" mean? It is defined as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">bor</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="n">_</span>  <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">band</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="n">_</span>  <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">notation</span> <span class="n">x</span> <span class="bp">||</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">bor</span> <span class="n">x</span> <span class="n">y</span>
<span class="kd">notation</span> <span class="n">x</span> <span class="bp">&amp;&amp;</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">band</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>



<a name="234932071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234932071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234932071">(Apr 16 2021 at 22:45)</a>:</h4>
<p>in normal programming languages, something like <code>f(x) &amp;&amp; y(x)</code> will be executed as the following: it first checks <code>f(x)</code>. If it's false, then it won't even bother checking <code>y(x)</code>, as the and of them is false. Similarly for <code>f(x) || y(x)</code> when <code>f(x)=tt</code>. This is short circuiting</p>



<a name="234932265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234932265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234932265">(Apr 16 2021 at 22:47)</a>:</h4>
<p>Ah, I see, then as far as I understand, it does by the definition. However, it shouldn't make a difference anyway when I tested in on 5 simple checks...</p>



<a name="234932326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234932326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234932326">(Apr 16 2021 at 22:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">tt</span> <span class="bp">&amp;&amp;</span> <span class="n">to_bool</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">∈</span> <span class="n">list.range</span> <span class="mi">10000000</span><span class="o">)</span>
</code></pre></div>



<a name="234932348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234932348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234932348">(Apr 16 2021 at 22:48)</a>:</h4>
<p>then add another 0</p>



<a name="234933916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234933916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234933916">(Apr 16 2021 at 23:07)</a>:</h4>
<p>After a bit of more experimenting, any reason why the following code times out with mathlib (and succeeds with <code>tt</code> when I replace the third line with <code>ff</code>)?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">test</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">test</span> <span class="n">t1</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">test</span> <span class="o">[]</span> <span class="n">t2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="k">#reduce</span> <span class="n">test</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">[]</span>
</code></pre></div>
<p>But I don't even know whether this is important, I primarily wanted to make the <code>dec_trivial</code> work in the original question (and similar cases)...</p>



<a name="234937992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234937992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234937992">(Apr 17 2021 at 00:04)</a>:</h4>
<p>OK, so after making the function <code>forall2_inh_bool</code> recursive only in one argument (which required defining another helper function), the problem is solved, and my takeover from this is that recursion on multiple arguments is somehow evil.</p>



<a name="234949221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234949221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234949221">(Apr 17 2021 at 01:38)</a>:</h4>
<p>I'm not sure what you mean by "with mathlib" here. I am not having any trouble evaluating that expression, but the general recommendation on <code>#reduce</code> is "don't use it, it doesn't work beyond toy examples"</p>



<a name="234971088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234971088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234971088">(Apr 17 2021 at 08:09)</a>:</h4>
<p>I mean, when I prepend the code of <code>test</code> (I believe should be a toy example) with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.list</span>
</code></pre></div>
<p>Then the <code>#reduce</code> times out. By the way, I am using lean version, leanprover-community/lean:3.28.0</p>
<p>And I was trying to use <code>#reduce</code> just to figure out what the problem could be. The original issue was that <code>dec_trivial</code> was not working in the original question.</p>



<a name="234973375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234973375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234973375">(Apr 17 2021 at 08:54)</a>:</h4>
<p>This is a minimal working example, I believe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">test</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">test</span> <span class="n">t1</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">test</span> <span class="o">[]</span> <span class="n">t2</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="kd">def</span> <span class="n">test2</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">test2</span> <span class="n">t1</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="k">#eval</span> <span class="n">test</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">[]</span>
<span class="c1">-- tt</span>
<span class="k">#eval</span> <span class="n">test2</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">[]</span>
<span class="c1">-- tt</span>
<span class="c1">--#reduce test [0] [] -- times out</span>
<span class="k">#reduce</span> <span class="n">test2</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">[]</span>
<span class="c1">-- tt</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">test</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">dec_trivial</span>
<span class="c1">-- fails</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">test2</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">dec_trivial</span>
<span class="c1">-- succeeds</span>
</code></pre></div>



<a name="234973826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234973826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234973826">(Apr 17 2021 at 09:03)</a>:</h4>
<p>Oh interesting. <code>test</code> is apparently compiled using well founded recursion, which is going to cause problems with <code>#reduce</code> for sure, but importantly the default well founded recursion tactic uses <code>simp</code>, so importing mathlib can change the proof that is discovered, from one that computes to one that uses axioms. There is a recent "fix" to lean 3 that should be arriving in the next version, which will make this fail rather than unfold the proof</p>



<a name="234974033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234974033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234974033">(Apr 17 2021 at 09:06)</a>:</h4>
<p>If you want to avoid well founded recursion, you can rewrite it to make it more obviously structural recursive:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">test1</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">test1</span> <span class="n">t2</span>

<span class="kd">def</span> <span class="n">test2</span> <span class="o">(</span><span class="n">IH</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">IH</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h2</span><span class="o">::</span><span class="n">t2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="kd">def</span> <span class="n">test</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">test1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h1</span><span class="o">::</span><span class="n">t1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">test2</span> <span class="o">(</span><span class="n">test</span> <span class="n">t1</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">test</span> <span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">[]</span>
</code></pre></div>



<a name="234974586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/234974586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#234974586">(Apr 17 2021 at 09:17)</a>:</h4>
<p>OK, I did it this way in the end. Originally, I found it convenient that lean (contrary to say coq) can handle recursion on multiple parameters on its own but it is apparently not for free.</p>



<a name="235013827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/235013827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#235013827">(Apr 17 2021 at 20:08)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">tt</span> <span class="bp">&amp;&amp;</span> <span class="n">to_bool</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">∈</span> <span class="n">list.range</span> <span class="mi">10000000</span><span class="o">)</span>
</code></pre></div>
<blockquote>
<p>then add another 0</p>
</blockquote>
<p>(a bit offtopic)<br>
I was still a bit puzzled by this. First, let's just clarify that it is not an example of not shortening circuit for <code>&amp;&amp;</code> since <code>tt &amp;&amp;</code> must continue with the evaluation. If we replace it with <code>tt ||</code> or <code>ff &amp;&amp;</code>, lean handles it without problem. But still, I thought that <code>1</code> should be at the beginning of  the <code>range</code>, so it should be possible to find it quickly. So I looked up the definition of <code>list.range</code>, and it turned out that by lean's definition, it counts down to zero until it starts making the list. So I wrote my own <code>range</code> definition, however, even that one didn't turn out working fast. Why it is the case seems to be a technical detail of how lean do / doesn't do lazy evaluation which is beyond my understanding.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">list.my_range</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">n0</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">n0</span> <span class="o">(</span><span class="n">l</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n0</span><span class="o">::(</span><span class="n">list.my_range</span> <span class="o">(</span><span class="n">n0</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span>

<span class="k">#eval</span> <span class="o">(</span><span class="mi">0</span><span class="o">::(</span><span class="n">list.my_range</span> <span class="mi">1</span> <span class="mi">9999999</span><span class="o">))</span><span class="bp">.</span><span class="n">head</span>
<span class="c1">-- fast</span>
<span class="k">#eval</span> <span class="o">((</span><span class="n">list.my_range</span> <span class="mi">0</span> <span class="mi">10000000</span><span class="o">))</span><span class="bp">.</span><span class="n">head</span>
<span class="c1">-- slow</span>
</code></pre></div>



<a name="235030370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/235030370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#235030370">(Apr 18 2021 at 00:33)</a>:</h4>
<p>Lean is an eager, or call-by-value language, like ML and unlike Haskell. That means that it won't evaluate <code>list.mem</code> until it has fully evaluated the <code>list.range 10000000</code> into a list with 10000000 elements. If you used lazy lists (which lean has btw, as <code>lazy_list A</code>) then it would only evaluate as many elements as needed and leave the rest as thunks, so the operation would evaluate quickly.</p>



<a name="235057412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/235057412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#235057412">(Apr 18 2021 at 09:03)</a>:</h4>
<p>Well, but not exactly, when I run the following code in OCaml,</p>
<div class="codehilite" data-code-language="OCaml"><pre><span></span><code><span class="k">let</span> <span class="k">rec</span> <span class="n">range</span> <span class="n">n0</span> <span class="o">=</span> <span class="k">function</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="bp">[]</span> <span class="o">|</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">n0</span><span class="o">::(</span><span class="n">range</span> <span class="o">(</span><span class="n">n0</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">));;</span>
<span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="o">(</span><span class="mi">0</span><span class="o">::(</span><span class="n">range</span> <span class="mi">0</span> <span class="mi">1000000</span><span class="o">));;</span>
</code></pre></div>
<p>I get an error. On the other hand, lean can handle</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">(</span><span class="mi">0</span><span class="o">::(</span><span class="n">list.range</span> <span class="mi">1000000000</span><span class="o">))</span><span class="bp">.</span><span class="n">head</span>
</code></pre></div>



<a name="235058362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/235058362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#235058362">(Apr 18 2021 at 09:23)</a>:</h4>
<p>I guess, it is not so important, just that it surprised me a bit.</p>



<a name="235059902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/235059902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#235059902">(Apr 18 2021 at 09:50)</a>:</h4>
<p>Heh, that's because lean cheats:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.compiler.optimize_bytecode</span> <span class="n">true</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">0</span><span class="o">::(</span><span class="n">list.range</span> <span class="mi">1000000000</span><span class="o">))</span><span class="bp">.</span><span class="n">head</span>

<span class="c1">-- [compiler.optimize_bytecode]  foo 0</span>
<span class="c1">-- 0: scnstr #0</span>
<span class="c1">-- 1: ret</span>
</code></pre></div>



<a name="235059921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/235059921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#235059921">(Apr 18 2021 at 09:51)</a>:</h4>
<p>Using the magic of pure functional programming it was able to prove that the thing evaluates to 0 without having to work out the tail of the list</p>



<a name="235060098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/235060098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#235060098">(Apr 18 2021 at 09:54)</a>:</h4>
<p>It doesn't need laziness to justify this transformation because all functions are total</p>



<a name="291572658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/291572658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ben Selfridge <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#291572658">(Aug 01 2022 at 13:12)</a>:</h4>
<p>Hello! My name is Ben Selfridge. I work at Galois, Inc. in Portland and am learning Lean in my spare time, both for joy and professional development. I've been learning the proofs of Gödel's incompleteness theorems at a deeper level than I've ever had time to lately, and I partly decided to learn Lean to see if I could formalize them as a fun challenge. I initially started with Lean4, but gave up as soon as I realized that most of the relevant mathlib work had not been ported yet, so now I'm on Lean3.</p>
<p>I have a newbie question. I have a prop definition</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">divides</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span>
</code></pre></div>
<p>I want to show that the following function <code>dividesF</code> decides this proposition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">dividesF_aux</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="k">if</span> <span class="n">a.succ</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span>
  <span class="k">then</span> <span class="n">tt</span>
  <span class="k">else</span> <span class="n">dividesF_aux</span> <span class="n">a</span> <span class="n">m</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">dividesF</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">dividesF_aux</span> <span class="n">n</span> <span class="n">m</span> <span class="n">n</span>
</code></pre></div>
<p>In proving the following lemma, I got stuck:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">divides_of_dividesF_aux</span> <span class="o">{</span><span class="n">a</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">dividesF_aux</span> <span class="n">a</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">divides</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">a</span> <span class="k">with</span> <span class="n">pa</span><span class="o">,</span>
  <span class="c1">-- a = 0</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">dividesF_aux</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">divides</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">exists.intro</span> <span class="n">nat.zero</span><span class="o">,</span>
    <span class="c1">-- How do I get to_bool (n = 0) to turn into n = 0?</span>
    <span class="gr">admit</span><span class="o">,</span>
  <span class="c1">-- a = pa.succ</span>
    <span class="gr">admit</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>As indicated in the comment, I have <code>to_bool(n = 0)</code> as my hypothesis, and I'd like it to resolve to <code>n = 0</code>. In Lean4, <code>simp</code> did the trick, but not here.</p>
<p>Any suggestions? Also, any pointers for code quality are welcome.</p>



<a name="291574729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/291574729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#291574729">(Aug 01 2022 at 13:24)</a>:</h4>
<p>Should <code>h</code> be of type <code>dividesF_aux a m n = tt</code>?</p>



<a name="291575453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/291575453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#291575453">(Aug 01 2022 at 13:29)</a>:</h4>
<p><code>simp</code> should do this reduction, but you need the file containing the simp lemma to be imported. In this case I would guess it's <a href="https://leanprover-community.github.io/mathlib_docs/data/bool/basic.html"><code>data.bool.basic</code></a></p>



<a name="291597693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/291597693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ben Selfridge <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#291597693">(Aug 01 2022 at 16:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="325367">Mauricio Collares</span> <a href="#narrow/stream/113489-new-members/topic/decidability.20struggles/near/291574729">said</a>:</p>
<blockquote>
<p>Should <code>h</code> be of type <code>dividesF_aux a m n = tt</code>?</p>
</blockquote>
<p>Yes, it should! That fixed the problem. Do you know if Lean4 automatically figures out that's what I meant? Because I've tried it both ways in Lean4 and it didn't seem to affect anything.</p>



<a name="291598081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/decidability%20struggles/near/291598081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ben Selfridge <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/decidability.20struggles.html#291598081">(Aug 01 2022 at 16:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/decidability.20struggles/near/291575453">said</a>:</p>
<blockquote>
<p><code>simp</code> should do this reduction, but you need the file containing the simp lemma to be imported. In this case I would guess it's <a href="https://leanprover-community.github.io/mathlib_docs/data/bool/basic.html"><code>data.bool.basic</code></a></p>
</blockquote>
<p>Thank you -- this also worked!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
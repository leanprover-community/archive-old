---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Understanding.20Alist.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html">Understanding Alist</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="180661410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180661410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180661410">(Nov 13 2019 at 19:18)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/c28497fa056ae52b93aa9aca2fd20155d57fa016/src/data/list/alist.lean#L16" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/c28497fa056ae52b93aa9aca2fd20155d57fa016/src/data/list/alist.lean#L16">https://github.com/leanprover-community/mathlib/blob/c28497fa056ae52b93aa9aca2fd20155d57fa016/src/data/list/alist.lean#L16</a> says that alist should have unique keys, but it in not clear to me how this is enforced. The alist.nodupkeys descructor is austensibly a proof that the keys are duplicated, but would this proof make more sense as a constuctor?</p>



<a name="180661873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180661873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180661873">(Nov 13 2019 at 19:23)</a>:</h4>
<p>For example, <code> #reduce alist.keys (list.to_alist [{2,3}, {4,2}, {2,4}])</code> gives <code>list.map sigma.fst (list.erase_dupkeys._match_1 {2, 3} (list.erase_dupkeys._match_1 {4, 2} (list.erase_dupkeys._match_1 {2, 4} list.nil))) </code>,  and <code>#reduce (list.to_alist [{2,3}, {4,2}, {2,4}]).nodupkeys</code> triggers a memory consumption error (emacs).</p>



<a name="180661967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180661967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180661967">(Nov 13 2019 at 19:24)</a>:</h4>
<p>in order to create an alist you need to provide an element of entries.nodupkeys, which is a proof that there are no duplicate keys</p>



<a name="180662042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180662042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180662042">(Nov 13 2019 at 19:25)</a>:</h4>
<p>to_alist ensures this by calling erase_dupkeys, which removes all duplicates from the input</p>



<a name="180662113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180662113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180662113">(Nov 13 2019 at 19:26)</a>:</h4>
<p>The <code>structure</code> syntax is a helper for defining inductive types with a single constructor (<a href="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#declaring-structures" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#declaring-structures">TPiL section</a>). As Marc says, to construct an <code>alist</code>, you must supply both <code>entries</code> and <code>nodupkeys</code>.</p>



<a name="180662158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180662158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180662158">(Nov 13 2019 at 19:26)</a>:</h4>
<p>By the way, unless you know what you're doing, you probably want to use <code>#eval</code> instead of <code>#reduce</code> for this kind of experimenting.</p>



<a name="180662576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180662576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180662576">(Nov 13 2019 at 19:31)</a>:</h4>
<blockquote>
<p>By the way, unless you know what you're doing, you probably want to use <code>#eval</code> instead of <code>#reduce</code> for this kind of experimenting.</p>
</blockquote>
<p>Ok, I'll use <code>#eval</code></p>



<a name="180662894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180662894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180662894">(Nov 13 2019 at 19:34)</a>:</h4>
<p>So suppose I were to omit using nodupkeys_erase_dupkeys in list.to_alist.<br>
Then why does <code>#check (alist.mk [{2,3}, {4,2}, {2,4}] _).nodupkeys</code> typecheck?</p>



<a name="180663052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180663052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180663052">(Nov 13 2019 at 19:36)</a>:</h4>
<p>My understanding is that by using <code>_</code> I am inferring a proof, which in this case should not exist.<br>
Maybe the distinction is that running eval on this expressions produces <code>don't know how to synthesize placeholder</code>.</p>



<a name="180663320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180663320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180663320">(Nov 13 2019 at 19:39)</a>:</h4>
<blockquote>
<p>The <code>structure</code> syntax is a helper for defining inductive types with a single constructor (<a href="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#declaring-structures" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html#declaring-structures">TPiL section</a>). As Marc says, to construct an <code>alist</code>, you must supply both <code>entries</code> and <code>nodupkeys</code>.</p>
</blockquote>
<p>My bad, <code>nodupkeys</code> is in fact a constructor here, thanks.</p>



<a name="180664368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180664368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180664368">(Nov 13 2019 at 19:49)</a>:</h4>
<blockquote>
<p>So suppose I were to omit using nodupkeys_erase_dupkeys in list.to_alist.<br>
Then why does <code>#check (alist.mk [{2,3}, {4,2}, {2,4}] _).nodupkeys</code> typecheck?</p>
</blockquote>
<p>If you look at the output of <code>#check</code> you'll see a metavariable (<code>?M_1</code> or something). <code>#check</code> is displaying what the type would be, assuming you were to fill in all the placeholders that couldn't be filled in automatically.</p>



<a name="180664789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180664789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180664789">(Nov 13 2019 at 19:53)</a>:</h4>
<p>if you do this in regular code, you'll get <code>don't know how to synthesize placeholder</code>.<br>
e.g.</p>
<div class="codehilite"><pre><span></span>abbreviation f : ℕ → Type := λ n, ℕ
def xs : list (sigma f) := [⟨2,3⟩, ⟨4,2⟩, ⟨2,4⟩]
def foo : alist f := alist.mk xs _
</pre></div>



<a name="180665154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180665154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180665154">(Nov 13 2019 at 19:56)</a>:</h4>
<blockquote>
<p>So suppose I were to omit using nodupkeys_erase_dupkeys in list.to_alist.<br>
Then why does <code>#check (alist.mk [{2,3}, {4,2}, {2,4}] _).nodupkeys</code> typecheck?</p>
</blockquote>
<p><code>#check _ : 0 = 1</code> typechecks.</p>



<a name="180666259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180666259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180666259">(Nov 13 2019 at 20:08)</a>:</h4>
<blockquote>
<p>My bad, <code>nodupkeys</code> is in fact a constructor here, thanks.</p>
</blockquote>
<p>structures only have a single constructor <code>mk</code>. a value/proof of <code>entries.nodupkeys</code> is a parameter to that constructor, not a constructor of <code>alist</code> itself. one might also call it a projection ;)</p>



<a name="180677074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180677074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180677074">(Nov 13 2019 at 21:53)</a>:</h4>
<p>This all makes sense. When I actually go to fill in the proof in the first place, I get the following error:</p>
<div class="codehilite"><pre><span></span>example : list.nodupkeys [sigma.mk 1 3, sigma.mk 2 4] :=
begin
  simp, exact eq.mp (ne.def 1 2) (nat.succ_ne_self 1).symm
end
</pre></div>


<div class="codehilite"><pre><span></span>tactic failed, result contains meta-variables
state: no goals
</pre></div>



<a name="180677243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180677243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180677243">(Nov 13 2019 at 21:56)</a>:</h4>
<p>I think I read somewhere that simp should only be used in a finishing position but it seems that my alternative is a to use a long string of rewrites. Is this preferable?</p>



<a name="180678351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180678351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180678351">(Nov 13 2019 at 22:08)</a>:</h4>
<p>The problem here is that Lean isn't inferring the type of <code>sigma.mk 1 3</code>. It's of type <code>sigma f</code> where <code>f : nat -&gt; Type</code> where <code>f 1 = nat</code> and <code>f 2 = nat</code>, but that's not enough to know <code>f</code> is the constant function.</p>



<a name="180678390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180678390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180678390">(Nov 13 2019 at 22:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nodupkeys</span> <span class="o">[(</span><span class="n">sigma</span><span class="bp">.</span><span class="n">mk</span> <span class="mi">1</span> <span class="mi">3</span> <span class="o">:</span> <span class="n">sigma</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">ℕ</span><span class="o">)),</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">mk</span> <span class="mi">2</span> <span class="mi">4</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">eq</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">ne</span><span class="bp">.</span><span class="n">def</span> <span class="mi">1</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ_ne_self</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="kn">end</span>
</pre></div>



<a name="180679233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180679233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180679233">(Nov 13 2019 at 22:18)</a>:</h4>
<p>Great, I now have a working toy example:</p>
<div class="codehilite"><pre><span></span>#eval alist.keys (alist.mk [(sigma.mk 1 3 : sigma (λ _, ℕ)), sigma.mk 2 4]
                           (by {simp; exact eq.mp (ne.def 1 2) (nat.succ_ne_self 1).symm}))
</pre></div>


<p>produces [1,2]</p>



<a name="180680226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180680226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180680226">(Nov 13 2019 at 22:28)</a>:</h4>
<p>The following also works </p>
<div class="codehilite"><pre><span></span>#eval (alist.keys (alist.mk [(sigma.mk 1 [1] : sigma (λ _, list ℕ)), sigma.mk 2 [4,5]]
                            (by {simp; exact eq.mp (ne.def 1 2) (nat.succ_ne_self 1).symm})))
</pre></div>


<p>So now my question is the following: <br>
I plan on using assoc lists with natural numbers in the sigma.fst spot.<br>
Is there a tactic that I can use that will take care of disequality proofs between nats when I first define an alist?</p>



<a name="180682082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180682082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180682082">(Nov 13 2019 at 22:49)</a>:</h4>
<p>You can try <code>dec_trivial</code></p>



<a name="180683998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180683998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180683998">(Nov 13 2019 at 23:16)</a>:</h4>
<p>For proving specific disequalities like <code>1 ≠ 2</code> you can use <code>norm_num</code>.</p>



<a name="180684088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180684088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180684088">(Nov 13 2019 at 23:18)</a>:</h4>
<p><code> failed to synthesize type class instance for |- decidable (list.nodupkeys [&lt;1,3&gt;,&lt;2,4&gt;]) </code><br>
I think this means that I need to provide information that checking if for key duplicates is a decidable proposition.<br>
dec_trivial points to of_as_true, which implicitly asks for a decidable proposition. Should I somehow provide <code>decidable_eq nat</code> to <code>@of_as_true</code>?</p>



<a name="180684414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180684414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180684414">(Nov 13 2019 at 23:23)</a>:</h4>
<blockquote>
<p>For proving specific disequalities like <code>1 ≠ 2</code> you can use <code>norm_num</code>.</p>
</blockquote>
<p>#eval (alist.keys (<a href="http://alist.mk" target="_blank" title="http://alist.mk">alist.mk</a> [(<a href="http://sigma.mk" target="_blank" title="http://sigma.mk">sigma.mk</a> 1 [3] : sigma (λ _,list ℕ)), <a href="http://sigma.mk" target="_blank" title="http://sigma.mk">sigma.mk</a> 2 [4]] (by norm_num)))<br>
Woohoo!</p>



<a name="180684693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180684693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180684693">(Nov 13 2019 at 23:27)</a>:</h4>
<p>But somehow not in this form??:</p>
<div class="codehilite"><pre><span></span>def a : list (sigma (λ _, list ℕ)) := [sigma.mk 1 [3], sigma.mk 2 [4]]
#eval (alist.keys (alist.mk a (by norm_num)))
</pre></div>


<p>What kind of witchcraft is this?</p>



<a name="180685004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180685004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180685004">(Nov 13 2019 at 23:32)</a>:</h4>
<blockquote>
<p>But somehow not in this form??:</p>
</blockquote>
<p>def a : list (sigma (λ _, list ℕ)) := [sigma.mk 1 [3], <a href="http://sigma.mk" target="_blank" title="http://sigma.mk">sigma.mk</a> 2 [4]]<br>
#eval (alist.keys (<a href="http://alist.mk" target="_blank" title="http://alist.mk">alist.mk</a> a (by norm_num)))</p>
<div class="codehilite"><pre><span></span>What kind of witchcraft is this?
</pre></div>


<p>Nevermind, this works:</p>
<div class="codehilite"><pre><span></span>def a : list (sigma (λ _, list ℕ)) := [sigma.mk 1 [3], sigma.mk 2 [4]]
#eval (alist.keys (alist.mk a (by rw a; norm_num)))
</pre></div>



<a name="180685287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180685287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180685287">(Nov 13 2019 at 23:37)</a>:</h4>
<blockquote>
<p><code>failed to synthesize type class instance for |- decidable (list.nodupkeys [&lt;1,3&gt;,&lt;2,4&gt;])</code><br>
I think this means that I need to provide information that checking if for key duplicates is a decidable proposition.</p>
</blockquote>
<p>That should be in mathlib, I guess it was missed. I'm sure <code>list.nodup</code> already has a decidable instance, and <code>alist.nodupkeys</code> is just a wrapper around that, so the proof should be easy</p>



<a name="180685300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180685300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180685300">(Nov 13 2019 at 23:37)</a>:</h4>
<p>alternatively:</p>
<div class="codehilite"><pre><span></span>abbreviation a : list (sigma (λ _, list ℕ)) := [sigma.mk 1 [3], sigma.mk 2 [4]]
#eval (alist.keys (alist.mk a (by norm_num)))
</pre></div>


<p>defs are semi-reducible (see <a href="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html?highlight=semi%20reducible#elaboration-hints" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html?highlight=semi%20reducible#elaboration-hints">https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html?highlight=semi%20reducible#elaboration-hints</a>)</p>



<a name="180685358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180685358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180685358">(Nov 13 2019 at 23:38)</a>:</h4>
<p>I would suggest <code>norm_num [a]</code> instead of making it an abbreviation</p>



<a name="180685686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180685686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180685686">(Nov 13 2019 at 23:43)</a>:</h4>
<p>also </p>
<div class="codehilite"><pre><span></span>#eval (let a : list (sigma (λ _, list ℕ)) := [sigma.mk 1 [3], sigma.mk 2 [4]] in
          (alist.keys (alist.mk a (by norm_num)))
</pre></div>


<p>works</p>



<a name="180686179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180686179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180686179">(Nov 13 2019 at 23:50)</a>:</h4>
<blockquote>
<p>alternatively:</p>
</blockquote>
<p>abbreviation a : list (sigma (λ _, list ℕ)) := [sigma.mk 1 [3], <a href="http://sigma.mk" target="_blank" title="http://sigma.mk">sigma.mk</a> 2 [4]]<br>
#eval (alist.keys (<a href="http://alist.mk" target="_blank" title="http://alist.mk">alist.mk</a> a (by norm_num)))</p>
<div class="codehilite"><pre><span></span>defs are semi-reducible (see https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html?highlight=semi%20reducible#elaboration-hints)
</pre></div>


<p>I read this section, but it does not mention the abbreviation keyword. Where is this documented?</p>



<a name="180686211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180686211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180686211">(Nov 13 2019 at 23:51)</a>:</h4>
<blockquote>
<p>I would suggest <code>norm_num [a]</code> instead of making it an abbreviation</p>
</blockquote>
<p>Can I put a list of lemmas/definitions to rewrite with after any tactic?</p>



<a name="180686325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180686325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180686325">(Nov 13 2019 at 23:53)</a>:</h4>
<blockquote>
<p>I read this section, but it does not mention the abbreviation keyword. Where is this documented?</p>
</blockquote>
<p>no idea, sebastian told me about it some day. you can also just tag the def as reducible instead</p>



<a name="180686451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180686451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180686451">(Nov 13 2019 at 23:55)</a>:</h4>
<p>looks like it used to be in an old version of TPIL: <a href="https://leanprover.github.io/tutorial/tutorial.pdf" target="_blank" title="https://leanprover.github.io/tutorial/tutorial.pdf">https://leanprover.github.io/tutorial/tutorial.pdf</a></p>



<a name="180763360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180763360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180763360">(Nov 14 2019 at 19:13)</a>:</h4>
<p>Consider the following alists:</p>
<div class="codehilite"><pre><span></span>def a : alist (λ (_:ℕ), ℕ) :=
  alist.mk [sigma.mk 1 2, sigma.mk 2 3, sigma.mk 3 4] (by norm_num)

def b : alist (λ (_:ℕ), list ℕ) :=
  alist.mk [sigma.mk 1 [2], sigma.mk 2 [], sigma.mk 3 [1,2]] (by norm_num)

#reduce (alist.replace 1 3 a)
#reduce (alist.replace 1 [3] b)
</pre></div>


<p>Only the last line generates an error, saying that it failed to synthesize type class instance for decidable_eq or has_one. Looking at alist.replace and kreplace, I do not see any mention of decidability. Where is this coming from and how do I fix it?</p>



<a name="180764010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180764010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180764010">(Nov 14 2019 at 19:19)</a>:</h4>
<p>What do you mean by <code>alist.replace 1 [3] b</code>? Lean is trying to interpret this, and the errors are what it gets. What do you want it to mean?</p>



<a name="180764274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180764274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180764274">(Nov 14 2019 at 19:21)</a>:</h4>
<p>You know about the implicit inputs to the function, right? If you hover over <code>alist.replace</code> in VS Code you will see <code>Π {α : Type u} {β : α → Type v} [_inst_1 : decidable_eq α]</code>. Lean is trying to figure out what alpha and beta are -- what do you think they are?</p>



<a name="180764438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180764438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180764438">(Nov 14 2019 at 19:23)</a>:</h4>
<p>When I look for alist.replace I see the following:</p>
<div class="codehilite"><pre><span></span>def replace (a : α) (b : β a) (s : alist β) : alist β :=
⟨kreplace a b s.entries, (kreplace_nodupkeys a b).2 s.nodupkeys⟩
</pre></div>



<a name="180764468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180764468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180764468">(Nov 14 2019 at 19:23)</a>:</h4>
<p>In mathlib/src/data/list/alist.lean</p>



<a name="180764516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180764516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180764516">(Nov 14 2019 at 19:23)</a>:</h4>
<p>But if you read the mathlib code then you don't see the variables. If you hover over the function then you'll see all the stuff I posted.</p>



<a name="180764602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180764602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180764602">(Nov 14 2019 at 19:24)</a>:</h4>
<p>Alternatively try <code>#check @alist.replace</code></p>



<a name="180764649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180764649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180764649">(Nov 14 2019 at 19:25)</a>:</h4>
<p>The @ means "tell me all the details of all the inputs to this function, including the stuff which Lean is going to figure out by itself"</p>



<a name="180764712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180764712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180764712">(Nov 14 2019 at 19:25)</a>:</h4>
<div class="codehilite"><pre><span></span>alist.replace :
  Π {α : Type u_1} {β : α → Type u_2} [_inst_1 : decidable_eq α] (a : α), β a → alist β → alist β
</pre></div>


<p>Lean says "ok I'll guess alpha, I'll guess beta, typeclass inference will guess _inst_1, now it's your turn"</p>



<a name="180765127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180765127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180765127">(Nov 14 2019 at 19:29)</a>:</h4>
<p>You wrote <code>alist.replace 1 [3] b</code>. Lean thinks "OK, so a is supposed to be 1, so alpha is some type which has a 1, gosh, there are lots of possibilities". Lean then gets [3] and thinks "Ok so beta 1 is supposed to be [3], I'll bear that in mind". Lean then gets b and thinks "OK so b must have type alist beta, but b <em>definitely</em> has type <code>alist (λ (_:ℕ), list ℕ)</code> so beta <em>must</em> be <code> (λ (_:ℕ), list ℕ)</code>. Hey this looks like it should work. I am now intrigued.</p>



<a name="180765464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180765464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180765464">(Nov 14 2019 at 19:32)</a>:</h4>
<p>I can get a more helpful error message if I put</p>
<div class="codehilite"><pre><span></span>#check (alist.replace (1:ℕ) ([1]:list ℕ) b)
</pre></div>



<a name="180765552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180765552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180765552">(Nov 14 2019 at 19:33)</a>:</h4>
<div class="codehilite"><pre><span></span>type mismatch at application
  alist.replace 1 [1]
term
  [1]
has type
  list var : Type
but is expected to have type
  ?m_1 1 : Type ?
</pre></div>



<a name="180765773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180765773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180765773">(Nov 14 2019 at 19:35)</a>:</h4>
<p>You should comment out those <code>#reduce</code>s, they really slow things down. So here's how I would start debugging:</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">alist</span><span class="bp">.</span><span class="n">replace</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="mi">1</span> <span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="n">b</span>
</pre></div>



<a name="180765853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180765853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180765853">(Nov 14 2019 at 19:35)</a>:</h4>
<p>OK so indeed if we tell Lean what beta is, it works fine:</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">alist</span><span class="bp">.</span><span class="n">replace</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">),</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">_</span> <span class="mi">1</span> <span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="n">b</span>
</pre></div>



<a name="180765862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180765862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180765862">(Nov 14 2019 at 19:36)</a>:</h4>
<p>So the problem is that Lean is failing to guess beta.</p>



<a name="180765948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180765948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180765948">(Nov 14 2019 at 19:36)</a>:</h4>
<p>This is some issue with the elaborator and it's beyond my pay grade to solve it. I would just fix it with the @ trick and move on.</p>



<a name="180766317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180766317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180766317">(Nov 14 2019 at 19:39)</a>:</h4>
<p>Great. +1 for showing how you would debug</p>



<a name="180767602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Understanding%20Alist/near/180767602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Viteri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Understanding.20Alist.html#180767602">(Nov 14 2019 at 19:52)</a>:</h4>
<p>FYI, same problem and solution for alist.insert</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
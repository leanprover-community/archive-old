---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html">Induction on a submonoid</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="216369226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216369226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216369226">(Nov 11 2020 at 16:42)</a>:</h4>
<p>I'm having trouble inducting over elements of a submonoid, and assume I must be doing something wrong. The mwe is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">my_fun</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">sorry</span>  <span class="c1">-- not relevant</span>

<span class="kd">def</span> <span class="n">my_monoid</span> <span class="o">:=</span> <span class="n">submonoid.closure</span> <span class="bp">$</span> <span class="n">set.range</span> <span class="o">(</span><span class="n">my_fun</span> <span class="n">M</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">my_fun_mem</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_fun</span> <span class="n">M</span> <span class="n">A</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">submonoid.subset_closure</span> <span class="bp">$</span> <span class="n">set.mem_range_self</span> <span class="n">m</span>

<span class="kd">lemma</span> <span class="n">induction</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h_one</span> <span class="o">:</span> <span class="n">C</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">submonoid.one_mem</span> <span class="o">(</span><span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">)⟩)</span>
  <span class="o">(</span><span class="n">h_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">my_fun</span> <span class="n">M</span> <span class="n">A</span> <span class="n">m</span><span class="o">,</span> <span class="n">my_fun_mem</span> <span class="n">M</span> <span class="n">A</span> <span class="n">m</span><span class="o">⟩)</span>
  <span class="o">(</span><span class="n">h_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span>
  <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">subtype.coe_eta</span> <span class="n">v</span> <span class="n">v.prop</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">submonoid.closure_induction</span> <span class="n">v.prop</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">set.mem_range.mpr</span> <span class="n">hx</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">h_fun</span> <span class="n">a</span><span class="o">,</span> <span class="n">apply</span> <span class="n">subtype.eq</span><span class="o">,</span> <span class="n">refl</span> <span class="o">})</span>
    <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">h_one</span><span class="o">,</span> <span class="n">apply</span> <span class="n">subtype.eq</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ring_hom.map_one</span><span class="o">]})</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
      <span class="n">sorry</span><span class="o">,</span>
    <span class="o">})</span>
<span class="kd">end</span>
</code></pre></div>
<p>Alarmingly, this gives a type error at the word <code>lemma</code>, rather than telling me which of my tactics failed.</p>
<p>What am I missing here?</p>



<a name="216370820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216370820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216370820">(Nov 11 2020 at 16:55)</a>:</h4>
<p>I think Lean's error reporting might have difficulty with this ~5-tuply interleaved term/tactic mode proof</p>



<a name="216370940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216370940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216370940">(Nov 11 2020 at 16:56)</a>:</h4>
<p>but anyways, I think the real issue is that you can't apply <code>submonoid.closure_induction</code> directly because its motive <code>C</code> isn't allowed to depend on the proof of membership</p>



<a name="216371134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216371134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216371134">(Nov 11 2020 at 16:57)</a>:</h4>
<p>I tried various levels of unweaving, and none seemed to help with the error message</p>



<a name="216371330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216371330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216371330">(Nov 11 2020 at 16:58)</a>:</h4>
<p>Presumably I need to use <a href="https://leanprover-community.github.io/mathlib_docs/find/submonoid.dense_induction">docs#submonoid.dense_induction</a>, and show that under the subtype <code>my_monoid </code>, the closure of <code>set.range (my_fun M A)</code> after coercion is <code>\top</code></p>



<a name="216371488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216371488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216371488">(Nov 11 2020 at 17:00)</a>:</h4>
<p>Well for example, if you replace the whole <code>exact</code> tactic with <code>apply submonoid.closure_induction v.prop</code>, then you get an error message on <code>apply</code>.</p>



<a name="216371792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216371792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216371792">(Nov 11 2020 at 17:02)</a>:</h4>
<p>Ah, that's good to know</p>



<a name="216372130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216372130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216372130">(Nov 11 2020 at 17:04)</a>:</h4>
<p>I think I need to start by proving</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">submonoid.closure</span> <span class="o">(</span><span class="n">coe</span> <span class="bp">⁻¹'</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">submonoid.closure</span> <span class="n">s</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>so that I have the first argument to <code>dense_induction</code></p>



<a name="216377200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216377200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216377200">(Nov 11 2020 at 17:50)</a>:</h4>
<p>This is proving difficult:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">submonoid.closure</span> <span class="o">(</span><span class="n">coe</span> <span class="bp">⁻¹'</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">submonoid.closure</span> <span class="n">s</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">subtype.rec_on</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">xprop</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">submonoid.closure_induction</span> <span class="n">xprop</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">simp_rw</span> <span class="bp">←</span><span class="n">submonoid.mem_coe</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">submonoid.subset_closure</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">set.mem_preimage</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">subtype.coe_mk</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span><span class="n">this</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">hy</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">{</span> <span class="n">convert</span> <span class="n">submonoid.one_mem</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- ↑⟨1, xprop⟩ = ↑1</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">convert</span> <span class="n">submonoid.mul_mem</span> <span class="n">_</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- ⟨a * b, xprop⟩ = ⟨a, xprop⟩ * ⟨b, xprop⟩</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>Both the remaining goals are something I'd hope to close with <code>refl</code>, but I can't and I don't know what to do next</p>



<a name="216377370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216377370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216377370">(Nov 11 2020 at 17:52)</a>:</h4>
<p><del>If I add <code>ext</code> before the last sorry, then I get a type error at the word <code>example</code> again</del></p>
<p>Nevermind, the type error was there anyway and I missed it</p>



<a name="216378000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216378000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216378000">(Nov 11 2020 at 17:58)</a>:</h4>
<p><code>unfold_coes, simp</code> does the first one</p>



<a name="216378038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216378038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216378038">(Nov 11 2020 at 17:58)</a>:</h4>
<p>as does <code>unfold_coes, refl</code></p>



<a name="216378150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216378150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216378150">(Nov 11 2020 at 17:59)</a>:</h4>
<p>and <code>ext, unfold_coes, refl</code> does the second one</p>



<a name="216378160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216378160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216378160">(Nov 11 2020 at 17:59)</a>:</h4>
<p>Turns out it's irrelevant, the tactic state was telling me to keep going even though a type error had already appeared</p>



<a name="216378515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216378515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216378515">(Nov 11 2020 at 18:02)</a>:</h4>
<p>But thanks, that does indeed close the goals! (despite not fixing the type error)</p>



<a name="216379241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216379241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216379241">(Nov 11 2020 at 18:08)</a>:</h4>
<p>In fact, I seem to run into exactly the same problem I had before</p>



<a name="216379501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216379501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216379501">(Nov 11 2020 at 18:10)</a>:</h4>
<p>What do you think about this approach:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">induction</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h_one</span> <span class="o">:</span> <span class="n">C</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">submonoid.one_mem</span> <span class="o">(</span><span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">)⟩)</span>
  <span class="o">(</span><span class="n">h_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">my_fun</span> <span class="n">M</span> <span class="n">A</span> <span class="n">m</span><span class="o">,</span> <span class="n">my_fun_mem</span> <span class="n">M</span> <span class="n">A</span> <span class="n">m</span><span class="o">⟩)</span>
  <span class="o">(</span><span class="n">h_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span>
  <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">C'</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="k">if</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span> <span class="k">then</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="k">else</span> <span class="n">true</span> <span class="k">with</span> <span class="n">hC'</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">C'</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">hC'</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">split_ifs</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">apply</span> <span class="n">submonoid.closure_induction</span><span class="o">,</span>
<span class="bp">...</span>
</code></pre></div>



<a name="216379726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216379726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216379726">(Nov 11 2020 at 18:13)</a>:</h4>
<p><code>  apply submonoid.closure_induction hv,</code> might be an even better last line</p>



<a name="216379733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216379733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216379733">(Nov 11 2020 at 18:13)</a>:</h4>
<p>Rather than <code>if then else</code>, you can probably use <code>forall</code></p>



<a name="216380108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380108">(Nov 11 2020 at 18:16)</a>:</h4>
<p>I get stuck trying to unfold <code>C'</code> in the goal there, from</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">this</span><span class="o">:</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">my_fun</span> <span class="n">M</span> <span class="n">A</span> <span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span>
<span class="bp">⊢</span> <span class="n">C'</span> <span class="o">(</span><span class="n">my_fun</span> <span class="n">M</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="216380171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380171">(Nov 11 2020 at 18:16)</a>:</h4>
<p>That's why I used <code>set</code> not <code>let</code> -- you can <code>rw hC'</code></p>



<a name="216380335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380335">(Nov 11 2020 at 18:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">apply</span> <span class="n">submonoid.closure_induction</span> <span class="n">hv</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">hC'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hx</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">h_fun</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">},</span>
</code></pre></div>
<p>There's the first one</p>



<a name="216380346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380346">(Nov 11 2020 at 18:18)</a>:</h4>
<p>I don't understand Reid's comment</p>



<a name="216380348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380348">(Nov 11 2020 at 18:18)</a>:</h4>
<p>Yep, I can finish up from there</p>



<a name="216380358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380358">(Nov 11 2020 at 18:18)</a>:</h4>
<p>Me neither</p>



<a name="216380383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380383">(Nov 11 2020 at 18:18)</a>:</h4>
<p>Oh, probably "for all proofs that it's in your submonoid..."</p>



<a name="216380405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380405">(Nov 11 2020 at 18:18)</a>:</h4>
<p><code>set C' : A → Prop := λ a, \all ha : a ∈ my_monoid M A, C ⟨a, ha⟩</code></p>



<a name="216380441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380441">(Nov 11 2020 at 18:19)</a>:</h4>
<p>that's nicer because you'll have those to hand and won't need the split_ifs</p>



<a name="216380452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380452">(Nov 11 2020 at 18:19)</a>:</h4>
<p>Does this belong in mathlib somewhere? <code>submonoid.closure_induction'</code>?</p>



<a name="216380909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380909">(Nov 11 2020 at 18:23)</a>:</h4>
<p>This has something to do with your two submonoids and you want to quotient out one by the other, right? My instinct when I look at your lemma is "why not use Reid's trick to define your C and have things like a and b in <code>h_mul</code> quantify over all of A rather than just the submonoid", but perhaps this is not convenient for you in your situation?</p>



<a name="216380940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216380940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216380940">(Nov 11 2020 at 18:23)</a>:</h4>
<p>Quantify over proofs everywhere.</p>



<a name="216381045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381045">(Nov 11 2020 at 18:24)</a>:</h4>
<p>I don't think I can finish off the last part of the proof with reid's trick</p>



<a name="216381134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381134">(Nov 11 2020 at 18:25)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">induction</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h_one</span> <span class="o">:</span> <span class="n">C</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">submonoid.one_mem</span> <span class="o">(</span><span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">)⟩)</span>
  <span class="o">(</span><span class="n">h_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">my_fun</span> <span class="n">M</span> <span class="n">A</span> <span class="n">m</span><span class="o">,</span> <span class="n">my_fun_mem</span> <span class="n">M</span> <span class="n">A</span> <span class="n">m</span><span class="o">⟩)</span>
  <span class="o">(</span><span class="n">h_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span>
  <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">C'</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">,</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="k">with</span> <span class="n">hC'</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">C'</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">hC'</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">this</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">apply</span> <span class="n">submonoid.closure_induction</span> <span class="n">hv</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hC'</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">set.mem_range.mpr</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h_fun</span> <span class="n">a</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">hC'</span><span class="o">,</span> <span class="n">intro</span> <span class="n">ha</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h_one</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hC'</span><span class="o">,</span> <span class="n">intros</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hC'</span> <span class="n">at</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216381303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381303">(Nov 11 2020 at 18:27)</a>:</h4>
<p>oops</p>



<a name="216381330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381330">(Nov 11 2020 at 18:27)</a>:</h4>
<p>Maybe my idea doesn't work.</p>



<a name="216381334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381334">(Nov 11 2020 at 18:27)</a>:</h4>
<p>maybe <code>\exists</code> is better then?</p>



<a name="216381478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381478">(Nov 11 2020 at 18:29)</a>:</h4>
<p>Are we missing some important lemma? It seems like there should be something that says "within a <code>submonoid.closure s</code>, the elements of <code>s</code> when embedded in the subtype are the generators of the entire subtype"</p>



<a name="216381587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381587">(Nov 11 2020 at 18:30)</a>:</h4>
<p>Isn't that what we're proving?</p>



<a name="216381629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381629">(Nov 11 2020 at 18:30)</a>:</h4>
<p>I mean basically yes, it is</p>



<a name="216381695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381695">(Nov 11 2020 at 18:31)</a>:</h4>
<p>That's what my <code>submonoid.closure (coe ⁻¹' s : set (submonoid.closure s)) = ⊤</code> statement above was attempting to be - my hope was that eliminating the <code>my_fun</code> stuff would make it simpler to prove</p>



<a name="216381736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381736">(Nov 11 2020 at 18:31)</a>:</h4>
<p>You're using the wrong induction procedure</p>



<a name="216381744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381744">(Nov 11 2020 at 18:31)</a>:</h4>
<p>(deleted)</p>



<a name="216381834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216381834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216381834">(Nov 11 2020 at 18:32)</a>:</h4>
<p>It would be great if lemmas could be tagged with "this is an induction procedure" to help me find the right one</p>



<a name="216382089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216382089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216382089">(Nov 11 2020 at 18:34)</a>:</h4>
<p>I think my C' approach is doomed to failure.</p>



<a name="216382123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216382123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216382123">(Nov 11 2020 at 18:34)</a>:</h4>
<p>It was a nice idea</p>



<a name="216382188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216382188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216382188">(Nov 11 2020 at 18:35)</a>:</h4>
<p>I think you should try with <code>\exists</code> instead</p>



<a name="216382208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216382208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216382208">(Nov 11 2020 at 18:35)</a>:</h4>
<p>that way you're proving membership and <code>C</code> at the same time</p>



<a name="216382651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216382651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216382651">(Nov 11 2020 at 18:39)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">C'</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">,</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="k">with</span> <span class="n">hC'</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">C'</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">hm</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">submonoid.closure_induction</span> <span class="n">hv</span><span class="o">,</span>
<span class="bp">...</span>
</code></pre></div>



<a name="216382814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216382814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216382814">(Nov 11 2020 at 18:40)</a>:</h4>
<p>I think Reid's right. This won't have the problems which mul had with my original C'</p>



<a name="216382839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216382839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216382839">(Nov 11 2020 at 18:40)</a>:</h4>
<p>Will try that</p>



<a name="216382864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216382864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216382864">(Nov 11 2020 at 18:40)</a>:</h4>
<p>I think my original C' was logically equivalent to Reid's forall C', but this is different. Mul works, for starters</p>



<a name="216383063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216383063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216383063">(Nov 11 2020 at 18:42)</a>:</h4>
<p>Yep</p>



<a name="216383067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216383067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216383067">(Nov 11 2020 at 18:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">induction</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h_one</span> <span class="o">:</span> <span class="n">C</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">submonoid.one_mem</span> <span class="o">(</span><span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">)⟩)</span>
  <span class="o">(</span><span class="n">h_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">my_fun</span> <span class="n">M</span> <span class="n">A</span> <span class="n">m</span><span class="o">,</span> <span class="n">my_fun_mem</span> <span class="n">M</span> <span class="n">A</span> <span class="n">m</span><span class="o">⟩)</span>
  <span class="o">(</span><span class="n">h_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span>
  <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">C'</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">my_monoid</span> <span class="n">M</span> <span class="n">A</span><span class="o">,</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="k">with</span> <span class="n">hC'</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">C'</span> <span class="n">v</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">apply</span> <span class="n">submonoid.closure_induction</span> <span class="n">hv</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">submonoid.subset_closure</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">set.mem_range.mpr</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h_fun</span> <span class="n">a</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">hC'</span><span class="o">,</span> <span class="n">use</span> <span class="n">submonoid.one_mem</span> <span class="n">_</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h_one</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">hx'</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">hy'</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="n">submonoid.mul_mem</span> <span class="n">_</span> <span class="n">hx'</span> <span class="n">hy'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h_mul</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216384778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216384778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216384778">(Nov 11 2020 at 18:56)</a>:</h4>
<p>I'll try to distil to something more generally applicable tomorrow</p>



<a name="216441798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216441798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216441798">(Nov 12 2020 at 08:51)</a>:</h4>
<p>Golfed to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">induction'</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">submonoid.closure</span> <span class="n">s</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h_one</span> <span class="o">:</span> <span class="n">C</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="n">submonoid.closure</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">one_mem</span><span class="o">⟩)</span>
  <span class="o">(</span><span class="n">h_closure</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">submonoid.subset_closure</span> <span class="n">h</span><span class="o">⟩)</span>
  <span class="o">(</span><span class="n">h_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span>
  <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">submonoid.closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">C</span> <span class="n">v</span> <span class="o">:=</span>
<span class="n">subtype.rec_on</span> <span class="n">v</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">exists.elim</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">submonoid.closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">C</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩),</span> <span class="n">hc</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">submonoid.closure_induction</span> <span class="n">hv</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="o">⟨</span><span class="n">submonoid.subset_closure</span> <span class="n">hx</span><span class="o">,</span> <span class="n">h_closure</span> <span class="n">x</span> <span class="n">hx</span><span class="o">⟩)</span>
    <span class="o">⟨</span><span class="n">submonoid.one_mem</span> <span class="n">_</span><span class="o">,</span> <span class="n">h_one</span><span class="o">⟩</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span> <span class="n">exists.elim</span> <span class="n">hx</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">hx'</span> <span class="n">hx</span><span class="o">,</span> <span class="n">exists.elim</span> <span class="n">hy</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">hy'</span> <span class="n">hy</span><span class="o">,</span>
      <span class="o">⟨</span><span class="n">submonoid.mul_mem</span> <span class="n">_</span> <span class="n">hx'</span> <span class="n">hy'</span><span class="o">,</span> <span class="n">h_mul</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">⟩),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216443576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216443576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216443576">(Nov 12 2020 at 09:12)</a>:</h4>
<p>And the other lemma,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">closure_coe_preimage_eq_top</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">submonoid.closure</span> <span class="o">(</span><span class="n">coe</span> <span class="bp">⁻¹'</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">submonoid.closure</span> <span class="n">s</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">⊤</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">iff_true</span><span class="o">,</span> <span class="n">submonoid.mem_top</span><span class="o">],</span>
  <span class="n">cases</span> <span class="n">v</span> <span class="k">with</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">submonoid.closure</span> <span class="n">s</span><span class="o">,</span> <span class="o">(⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">submonoid.closure</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">submonoid.closure</span> <span class="o">(</span><span class="n">coe</span> <span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">submonoid.closure_induction</span> <span class="n">hv</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="o">⟨</span><span class="n">submonoid.subset_closure</span> <span class="n">hx</span><span class="o">,</span> <span class="n">submonoid.subset_closure</span> <span class="bp">$</span> <span class="n">set.mem_preimage.mpr</span> <span class="n">hx</span><span class="o">⟩)</span>
    <span class="o">⟨</span><span class="n">submonoid.one_mem</span> <span class="n">_</span><span class="o">,</span> <span class="n">submonoid.one_mem</span> <span class="n">_</span><span class="o">⟩</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span> <span class="n">exists.elim</span> <span class="n">hx</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">hx'</span> <span class="n">hx</span><span class="o">,</span> <span class="n">exists.elim</span> <span class="n">hy</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">hy'</span> <span class="n">hy</span><span class="o">,</span>
      <span class="o">⟨</span><span class="n">submonoid.mul_mem</span> <span class="n">_</span> <span class="n">hx'</span> <span class="n">hy'</span><span class="o">,</span> <span class="n">submonoid.mul_mem</span> <span class="n">_</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">⟩),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="216445568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction%20on%20a%20submonoid/near/216445568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Induction.20on.20a.20submonoid.html#216445568">(Nov 12 2020 at 09:34)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/4984">#4984</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
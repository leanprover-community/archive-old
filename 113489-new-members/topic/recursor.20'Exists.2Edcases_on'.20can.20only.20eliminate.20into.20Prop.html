---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/recursor.20'Exists.2Edcases_on'.20can.20only.20eliminate.20into.20Prop.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursor.20'Exists.2Edcases_on'.20can.20only.20eliminate.20into.20Prop.html">recursor 'Exists.dcases_on' can only eliminate into Prop</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="301905782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursor%20%27Exists.dcases_on%27%20can%20only%20eliminate%20into%20Prop/near/301905782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursor.20'Exists.2Edcases_on'.20can.20only.20eliminate.20into.20Prop.html#301905782">(Oct 02 2022 at 08:31)</a>:</h4>
<p>I already got this error in the past and I do not understand what causes it and how to fix it. Here is a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.complex.module</span>
<span class="kn">import</span> <span class="n">algebra.algebra.tower</span>

<span class="n">open_locale</span> <span class="n">complex_conjugate</span>

<span class="kd">lemma</span> <span class="n">exist_i</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">ℝ</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">S</span> <span class="n">ℂ</span><span class="o">]</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">ℝ</span> <span class="n">S</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">conj</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">S</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">≠</span> <span class="n">algebra_map</span> <span class="n">S</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">S</span> <span class="n">ℂ</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">complex.I</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">iso_sc</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">ℝ</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">S</span> <span class="n">ℂ</span><span class="o">]</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">ℝ</span> <span class="n">S</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">conj</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">S</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">≠</span> <span class="n">algebra_map</span> <span class="n">S</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">S</span> <span class="bp">≃+*</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">exist_i</span> <span class="n">h</span> <span class="n">hc</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="301908649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursor%20%27Exists.dcases_on%27%20can%20only%20eliminate%20into%20Prop/near/301908649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursor.20'Exists.2Edcases_on'.20can.20only.20eliminate.20into.20Prop.html#301908649">(Oct 02 2022 at 09:07)</a>:</h4>
<p>The short and inaccurate explanation is that there could be multiple <code>s</code> with <code>(algebra_map S ℂ) s = complex.I</code>, and then which one do you want to pick in the definition of <code>iso_sc</code>?</p>



<a name="301909758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursor%20%27Exists.dcases_on%27%20can%20only%20eliminate%20into%20Prop/near/301909758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursor.20'Exists.2Edcases_on'.20can.20only.20eliminate.20into.20Prop.html#301909758">(Oct 02 2022 at 09:21)</a>:</h4>
<p>Your goal is not a Prop so some tactics don't work properly (you shouldn't be in tactic mode at all really). Use <code>exists.some</code> instead.</p>



<a name="301915445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/recursor%20%27Exists.dcases_on%27%20can%20only%20eliminate%20into%20Prop/near/301915445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/recursor.20'Exists.2Edcases_on'.20can.20only.20eliminate.20into.20Prop.html#301915445">(Oct 02 2022 at 10:20)</a>:</h4>
<p>essentially this is because all terms of a <code>Prop</code> are defeq to each other; for example, for  <code>∃ n : nat, true</code>, both 0 and 1 work, so what should Lean choose? Even with a unique existence, this isn't enough for Lean to find out, as in certain cases it couldn't compute what it is! (For example, consider  <code>∃! o : real, is_champernownes_constant o</code>...)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/lean4.20induction.20with.20multiple.20base.20cases.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20induction.20with.20multiple.20base.20cases.html">lean4 induction with multiple base cases</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="286002585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20induction%20with%20multiple%20base%20cases/near/286002585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Augustin d'Oultremont <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20induction.20with.20multiple.20base.20cases.html#286002585">(Jun 13 2022 at 23:30)</a>:</h4>
<p>Hi ! </p>
<p>For context, for my master's thesis I'm working on a proof of concept for a translation system that would translate natural language proofs to lean4, hence I try to get the structure of my lean4 proofs as close to what I need to parse from natural language. I'm posting in <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a>, but this question might be better suited for <a class="stream" data-stream-id="270676" href="/#narrow/stream/270676-lean4">#lean4</a> ? </p>
<h1>Problem</h1>
<p>The part where I am currently stuck is trying to add support for induction, I try to implement it based on a proof for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>&gt;</mo><msup><mi>k</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> 2^k &gt; k^2 - 1 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8882em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>. The idea is the following :</p>
<ul>
<li>base cases for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>, </li>
<li>prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>&gt;</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> 2^{k+1} &gt; (k+1)^2 - 1 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8882em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> based on<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>&gt;</mo><msup><mi>k</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> 2^{k} &gt; k^2 - 1 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8882em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="application/x-tex"> k \geq 3 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></li>
</ul>
</li>
</ul>
<h1>Questions :</h1>
<ul>
<li>Is it possible to make the <code>induction</code> tactic work with multiple base cases ? (and how)</li>
<li>For the generalisation, <code>induction</code> gives access to the first hypothesis I need (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>&gt;</mo><msup><mi>k</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> 2^{k} &gt; k^2 - 1 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8882em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>), but how can I access the second (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="application/x-tex"> k \geq 3 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>) ?</li>
<li>Is there a similar tactic to <code>ring</code> that could work for inequalities ? (e.g. proving <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mn>2</mn></msup><mo>≥</mo><mn>3</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">k ^ 2 \geq 3k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> using the hypothesis that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k \geq 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>)</li>
</ul>
<h1>Current progress :</h1>
<p>The closest I could get in terms of clean and readable structure is using <code>match</code>, but this does not give access to the hypotheses I need. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">two_exp_n</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span> <span class="bp">&gt;</span> <span class="n">n</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="mi">2</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="n">k</span> <span class="bp">=&gt;</span> <span class="gr">admit</span> <span class="c1">-- needs access to the 2 hypotheses</span>
</code></pre></div>
<p>My best bet to have access to the hypotheses is using  multiple <code>induction</code>s chained, or maybe using an induction in the last case of the match ? None of these seem really straight forward (and I did not manage to make these work... I read <a href="#narrow/stream/270676-lean4/topic/Custom.20induction.20hypothesis">custom induction on hypothesis</a>, there seems to be a way to create a custom inductions, but I would ideally want it to be generalised to any number of base cases and had a hard time understanding  the thread... </p>
<p>Thanks for your help ! I hope my question is clear, but do not hesitate to ask me to specify anything !</p>



<a name="286003722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20induction%20with%20multiple%20base%20cases/near/286003722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Bailey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20induction.20with.20multiple.20base.20cases.html#286003722">(Jun 13 2022 at 23:48)</a>:</h4>
<p><span class="user-mention" data-user-id="492793">@Augustin d'Oultremont</span> </p>
<p>If I understood your question, here's one way to do the custom induction deal. The <code>match h : x with</code> pattern is how you preserve stuff in later arms.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">threeBase</span>
  <span class="o">{</span><span class="n">motive</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">minor0</span> <span class="o">:</span> <span class="n">motive</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">minor1</span> <span class="o">:</span> <span class="n">motive</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">minor2</span> <span class="o">:</span> <span class="n">motive</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">(</span><span class="n">minor3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&gt;=</span> <span class="mi">3</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">motive</span> <span class="n">m</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">minor0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">minor1</span>
  <span class="bp">|</span> <span class="mi">2</span> <span class="bp">=&gt;</span> <span class="n">minor2</span>
  <span class="bp">|</span> <span class="n">x</span><span class="bp">+</span><span class="mi">3</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">hGe</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">&gt;=</span> <span class="mi">3</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp_arith</span>
    <span class="n">minor3</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="n">hGe</span>

<span class="kd">theorem</span> <span class="n">two_exp_n</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span> <span class="bp">&gt;</span> <span class="n">n</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="n">using</span> <span class="n">threeBase</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">minor0</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="n">minor1</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="n">minor2</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="n">minor3</span> <span class="n">x</span> <span class="bp">=&gt;</span>
    <span class="n">trace_state</span>
    <span class="gr">sorry</span>
</code></pre></div>



<a name="286003775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20induction%20with%20multiple%20base%20cases/near/286003775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Bailey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20induction.20with.20multiple.20base.20cases.html#286003775">(Jun 13 2022 at 23:49)</a>:</h4>
<p>But in this case you can just use a match and forego the custom induction I think.</p>



<a name="286077448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20induction%20with%20multiple%20base%20cases/near/286077448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Augustin d'Oultremont <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20induction.20with.20multiple.20base.20cases.html#286077448">(Jun 14 2022 at 14:10)</a>:</h4>
<p>Thanks for your answer ! </p>
<p>Using your code, I don't seem to have access to the first hypothesis I need (to prove <code>P x</code> in <code>minor 3</code>, I need <code>P (x-1)</code> and <code>x ≥ 3</code>), I am looking into the custom induction to see how I can do that ;)</p>
<p>Also, is it possible to make a "modular" version of the <code>induction n using threeBase</code> that would not require knowing in advance how many cases we'll use ? There's probably no way to do that, but we never know...</p>



<a name="286084594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20induction%20with%20multiple%20base%20cases/near/286084594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Bailey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20induction.20with.20multiple.20base.20cases.html#286084594">(Jun 14 2022 at 14:56)</a>:</h4>
<p>My bad,  you should be able to use structural recursion for the other hypothesis.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">threeBase</span>
  <span class="o">{</span><span class="n">motive</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">minor0</span> <span class="o">:</span> <span class="n">motive</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">minor1</span> <span class="o">:</span> <span class="n">motive</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">minor2</span> <span class="o">:</span> <span class="n">motive</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">(</span><span class="n">minor3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&gt;=</span> <span class="mi">3</span> <span class="bp">→</span> <span class="n">motive</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">motive</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">motive</span> <span class="n">m</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">minor0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">minor1</span>
  <span class="bp">|</span> <span class="mi">2</span> <span class="bp">=&gt;</span> <span class="n">minor2</span>
  <span class="bp">|</span> <span class="n">x</span><span class="bp">+</span><span class="mi">3</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">hGe</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">&gt;=</span> <span class="mi">3</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp_arith</span>
    <span class="k">have</span> <span class="n">ih</span> <span class="o">:=</span> <span class="n">threeBase</span> <span class="n">minor0</span> <span class="n">minor1</span> <span class="n">minor2</span> <span class="n">minor3</span> <span class="o">((</span><span class="n">x</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">minor3</span> <span class="n">_</span> <span class="n">hGe</span> <span class="n">ih</span>
</code></pre></div>
<p>But I think the answer to your second question is to use <code>match</code>/the equation compiler:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">two_exp_n</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span> <span class="bp">&gt;</span> <span class="n">n</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="mi">2</span> <span class="bp">=&gt;</span> <span class="n">simp</span>
  <span class="bp">|</span> <span class="n">x</span><span class="bp">+</span><span class="mi">3</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="n">hGe</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">&gt;=</span> <span class="mi">3</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp_arith</span>
    <span class="k">have</span> <span class="n">ih</span> <span class="o">:=</span> <span class="n">two_exp_n</span> <span class="o">((</span><span class="n">x</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="gr">sorry</span>
</code></pre></div>



<a name="286109225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20induction%20with%20multiple%20base%20cases/near/286109225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Augustin d'Oultremont <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20induction.20with.20multiple.20base.20cases.html#286109225">(Jun 14 2022 at 17:49)</a>:</h4>
<p>I think the 2nd way to do it is the one I was looking for ! Thanks a lot ! I still have a few problems with some operations : </p>
<p>Here, should ring work ? it does not, but I guess that it is due to it not being fully implemented yet ?<br>
(using mathlib4's <a href="https://github.com/leanprover-community/mathlib4/tree/4f6c829ae8455e8d3f01322dd4cfe753e68393ed">latest chore bumb</a>)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">^</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="gr">admit</span>
</code></pre></div>
<p>gives me </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ring</span> <span class="n">failed</span><span class="o">,</span> <span class="n">ring</span> <span class="n">expressions</span> <span class="n">not</span> <span class="n">equal</span><span class="o">:</span>
<span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">^</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">0</span>
  <span class="bp">!=</span>
<span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span><span class="bp">^</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">0</span>
</code></pre></div>
<p>And for this one, is there a tactic that would be able to derive this ? (ring, simp, rw seem to only work with equalities)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&gt;</span> <span class="n">n</span><span class="o">):</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">&gt;</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="gr">admit</span>
</code></pre></div>



<a name="286129215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/lean4%20induction%20with%20multiple%20base%20cases/near/286129215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Bailey <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/lean4.20induction.20with.20multiple.20base.20cases.html#286129215">(Jun 14 2022 at 20:36)</a>:</h4>
<p>Ring solves it in lean3, mathlib4 is still just experiments I think. The second one can be solved with <code>linarith</code>, which doesn't exist in lean4 yet.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
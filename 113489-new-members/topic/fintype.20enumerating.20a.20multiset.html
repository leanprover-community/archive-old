---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html">fintype enumerating a multiset</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="286769806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286769806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286769806">(Jun 20 2022 at 09:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="488648">Xavier Roblot</span> has marked this topic as unresolved.</p>



<a name="286773724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286773724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286773724">(Jun 20 2022 at 10:07)</a>:</h4>
<p>I am following up on this question since I have a hard time proving that <code>multiset.card P.roots  = fintype.card σ</code> when I define <code>σ  =  {x // x ∈ P.roots}</code>. That is the following result:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.splitting_field</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">polynomial</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">):</span>
  <span class="n">multiset.card</span> <span class="n">P.roots</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">P.roots</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="286773927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286773927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286773927">(Jun 20 2022 at 10:09)</a>:</h4>
<p>Oh, sorry, I misunderstood what you were asking initially and gave you a type that enumerates the unique elements of the multiset (without duplicates).</p>



<a name="286774439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286774439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286774439">(Jun 20 2022 at 10:15)</a>:</h4>
<p>Oh, that explained why I had a hard time proving it <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="286775654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286775654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286775654">(Jun 20 2022 at 10:28)</a>:</h4>
<p>Still, I would be very grateful if somebody could help me with my original question...</p>



<a name="286819701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286819701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286819701">(Jun 20 2022 at 17:01)</a>:</h4>
<p><span class="user-mention" data-user-id="488648">@Xavier Roblot</span> It seems like there's not a way to turn a multiset into a Type with the same number of elements already. Here's a go at it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">algebra.big_operators</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="o">(</span><span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">m.to_finset</span><span class="o">),</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m.count</span> <span class="n">x</span><span class="o">)⟩</span>

<span class="c1">-- Just to check that this instance works:</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">infer_instance</span>

<span class="kd">lemma</span> <span class="n">multiset.card_coe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fintype.card</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m.card</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold_coes</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">transitivity</span> <span class="bp">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">m.to_finset</span><span class="o">,</span> <span class="n">multiset.count</span> <span class="n">x</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">finset.sum_coe_sort</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">m.count</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="286819827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286819827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286819827">(Jun 20 2022 at 17:02)</a>:</h4>
<p>This adds a coercion from multiset to Type where elements are ordered pairs (x, i), with i indexing which x this is in the multiset.</p>



<a name="286820083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286820083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286820083">(Jun 20 2022 at 17:05)</a>:</h4>
<p>Thanks! That’s great. Maybe it should be in mathlib?</p>



<a name="286826672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286826672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286826672">(Jun 20 2022 at 18:25)</a>:</h4>
<p><span class="user-mention" data-user-id="488648">@Xavier Roblot</span> This might be better to define first:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.card</span>
<span class="kn">import</span> <span class="n">algebra.big_operators</span>

<span class="sd">/-- Construct a finset whose elements enumerate the elements of the multiset `m`. -/</span>
<span class="kd">def</span> <span class="n">multiset.to_enum_finset</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">m.to_finset.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">finset.range</span> <span class="o">(</span><span class="n">m.count</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="o">⟨</span><span class="n">prod.mk</span> <span class="n">x</span><span class="o">,</span> <span class="n">prod.mk.inj_left</span> <span class="n">x</span><span class="o">⟩)</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">multiset.mem_to_enum_finset</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p</span> <span class="bp">∈</span> <span class="n">m.to_enum_finset</span> <span class="bp">↔</span> <span class="n">p.1</span> <span class="bp">∈</span> <span class="n">m</span> <span class="bp">∧</span> <span class="n">p.2</span> <span class="bp">&lt;</span> <span class="n">m.count</span> <span class="n">p.1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multiset.to_enum_finset</span><span class="o">,</span> <span class="n">finset.mem_bUnion</span><span class="o">,</span> <span class="n">multiset.mem_to_finset</span><span class="o">,</span>
    <span class="n">finset.mem_map</span><span class="o">,</span> <span class="n">finset.mem_range</span><span class="o">,</span> <span class="n">function.embedding.coe_fn_mk</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">hx</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">p.1</span><span class="o">,</span> <span class="n">h1</span><span class="o">,</span> <span class="n">p.2</span><span class="o">,</span> <span class="n">h2</span><span class="o">,</span> <span class="n">prod.mk.eta</span><span class="o">⟩</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">multiset.coe_to_enum_finset</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">m.to_enum_finset</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">))</span> <span class="bp">=</span> <span class="o">{</span><span class="n">p</span> <span class="bp">|</span> <span class="n">p.1</span> <span class="bp">∈</span> <span class="n">m</span> <span class="bp">∧</span> <span class="n">p.2</span> <span class="bp">&lt;</span> <span class="n">m.count</span> <span class="n">p.1</span><span class="o">}</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">@[mono]</span>
<span class="kd">lemma</span> <span class="n">multiset.to_enum_finset_mono</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m₁</span> <span class="bp">≤</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">m₁.to_enum_finset</span> <span class="bp">⊆</span> <span class="n">m₂.to_enum_finset</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">i</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multiset.mem_to_enum_finset</span><span class="o">,</span> <span class="n">and_imp</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">hx</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">multiset.mem_of_le</span> <span class="n">h</span> <span class="n">hx</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="k">calc</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">multiset.count</span> <span class="n">x</span> <span class="n">m₁</span> <span class="o">:</span> <span class="n">hi</span>
     <span class="bp">...</span> <span class="bp">≤</span> <span class="n">multiset.count</span> <span class="n">x</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">multiset.le_iff_count.mp</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">multiset.card_to_enum_finset</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">m.to_enum_finset.card</span> <span class="bp">=</span> <span class="n">m.card</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">multiset.to_enum_finset</span><span class="o">,</span> <span class="n">finset.card_bUnion</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multiset.mem_to_finset</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">],</span>
    <span class="n">rintros</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">hxy</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset.inf_eq_inter</span><span class="o">,</span> <span class="n">finset.mem_inter</span><span class="o">,</span> <span class="n">finset.mem_map</span><span class="o">,</span> <span class="n">finset.mem_range</span><span class="o">,</span>
      <span class="n">function.embedding.coe_fn_mk</span><span class="o">,</span> <span class="n">prod.mk.inj_iff</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">exists_eq_right_right</span><span class="o">,</span>
      <span class="n">finset.bot_eq_empty</span><span class="o">,</span> <span class="n">finset.not_mem_empty</span><span class="o">,</span> <span class="n">and_imp</span><span class="o">],</span>
    <span class="n">rintros</span> <span class="bp">-</span> <span class="n">rfl</span> <span class="bp">-</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">contradiction</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="286826760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286826760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286826760">(Jun 20 2022 at 18:26)</a>:</h4>
<p>That way we have <code>finset</code>s that satisfy some order properties (like the <code>to_enum_finset_mono</code> lemma), and there are fewer dependent types.</p>



<a name="286826901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286826901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286826901">(Jun 20 2022 at 18:28)</a>:</h4>
<p>I'm not sure what the right name for this is. <code>multiset.to_enum_finset</code> makes it seem like it's enumerating all the elements in some order, but it's only enumerating repeats (so for example the multiset with 1,2,2,3 would give the finset {(1,0), (2,0), (2,1), (3,0)}).</p>



<a name="286861879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286861879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286861879">(Jun 21 2022 at 03:43)</a>:</h4>
<p>from collections import Counter <span aria-label="snake" class="emoji emoji-1f40d" role="img" title="snake">:snake:</span></p>



<a name="286861989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286861989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286861989">(Jun 21 2022 at 03:45)</a>:</h4>
<p>Probably defined via a list fold then into the quotient with a proof that the fold commutes, no longer N^2 construction</p>



<a name="286862051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286862051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286862051">(Jun 21 2022 at 03:46)</a>:</h4>
<p>Unless my fold is hiding N^2 due to the cons</p>



<a name="286877149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286877149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286877149">(Jun 21 2022 at 07:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset/near/286826901">said</a>:</p>
<blockquote>
<p>I'm not sure what the right name for this is. <code>multiset.to_enum_finset</code> makes it seem like it's enumerating all the elements in some order, but it's only enumerating repeats (so for example the multiset with 1,2,2,3 would give the finset {(1,0), (2,0), (2,1), (3,0)}).</p>
</blockquote>
<p>Yes, basically, you are making a <code>finset</code> from a <code>multiset</code> without deleting duplicates.  Something <code>multiset.to_finset_with_dup</code> could work maybe</p>



<a name="286882212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286882212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286882212">(Jun 21 2022 at 08:37)</a>:</h4>
<p>Is there an XY problem here where using <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.prod">docs#multiset.prod</a> instead of <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.prod">docs#finset.prod</a> would avoid the problem?</p>



<a name="286884640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286884640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286884640">(Jun 21 2022 at 08:58)</a>:</h4>
<p>Well, I guess I could change the statement of <a href="https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.prod_X_add_C_coeff">docs#mv_polynomial.prod_X_add_C_coeff</a>  and other results in <code>vieta</code> to use <code>multiset</code> instead of <code>finset</code>...</p>



<a name="286885581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286885581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286885581">(Jun 21 2022 at 09:06)</a>:</h4>
<p>You might want to make a <code>def</code> for the n-th symmetric polynomial of the roots of a polynomial, and give expressions in terms of <code>finset.prod</code> and <code>multiset.prod</code></p>



<a name="286885591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286885591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286885591">(Jun 21 2022 at 09:07)</a>:</h4>
<p>(if I understand the problem correctly)</p>



<a name="286885666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286885666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286885666">(Jun 21 2022 at 09:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="488648">Xavier Roblot</span> <a href="#narrow/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset/near/286884640">said</a>:</p>
<blockquote>
<p>Well, I guess I could change the statement of <a href="https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.prod_X_add_C_coeff">docs#mv_polynomial.prod_X_add_C_coeff</a>  and other results in <code>vieta</code> to use <code>multiset</code> instead of <code>finset</code>...</p>
</blockquote>
<p>I think this is the way to go. It's a lot easier to derive finset results from multiset results than it is to go the other way around</p>



<a name="286885849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286885849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286885849">(Jun 21 2022 at 09:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset/near/286885581">said</a>:</p>
<blockquote>
<p>You might want to make a <code>def</code> for the n-th symmetric polynomial of the roots of a polynomial, and give expressions in terms of <code>finset.prod</code> and <code>multiset.prod</code></p>
</blockquote>
<p>These results exist already more or less in <code>ring_theory.polynomial.vieta</code> but there are not used anywhere else...</p>
<p>Oh, I see. I think I misunderstood what you meant...</p>



<a name="286886040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286886040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286886040">(Jun 21 2022 at 09:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset/near/286885666">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="488648">Xavier Roblot</span> <a href="#narrow/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset/near/286884640">said</a>:</p>
<blockquote>
<p>Well, I guess I could change the statement of <a href="https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.prod_X_add_C_coeff">docs#mv_polynomial.prod_X_add_C_coeff</a>  and other results in <code>vieta</code> to use <code>multiset</code> instead of <code>finset</code>...</p>
</blockquote>
<p>I think this is the way to go. It's a lot easier to derive finset results from multiset results than it is to go the other way around</p>
</blockquote>
<p>Ok. I'll PR that. I still think that the code of Kyle might be useful at some point in the future.</p>



<a name="286912084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286912084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286912084">(Jun 21 2022 at 13:22)</a>:</h4>
<p>Ok, after spending some time thinking about it and trying several options, I do not think that replacing <code>fintype</code> with <code>multiset</code> in <code>ring_theory.polynomial.vieta</code> and, for consistency,<code>ring_theory.polynomial.symmetric</code> is the way go. I mean it is certainly possible, although probably quite messy, but even from a mathematical point of view I do not think it makes sense: in this file, we work with polynomials whose coefficients are in some ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mi>i</mi></msub><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo>∈</mo><mi>σ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R[X_i]_{i \in \sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span></span></span></span> with the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>'s some indeterminates indexed by a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>. It does make sense here to have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> being a multiset. </p>
<p>It is only when we want to evaluate the indeterminates <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> to some value <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">r_i \in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, that it makes sense to have the possibility to repeat values. At the moment, this evaluation is done by providing a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\sigma \to R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> where <code>σ</code> is a <code>fintype</code>. So the missing link is a way to construct such a function when we want its image be a <code>multiset</code>. I don't know how to that. Kyle is providing a solution above by creating a <code>fintype</code> that enumerates the elements of a <code>multiset</code>, but there might be other solutions.</p>



<a name="286924389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286924389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286924389">(Jun 21 2022 at 14:47)</a>:</h4>
<p>(I had a look too, and did some cleanup in <a href="https://github.com/leanprover-community/mathlib/pull/14866">#14866</a>)</p>



<a name="286937106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/286937106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#286937106">(Jun 21 2022 at 16:06)</a>:</h4>
<p>Ok, I have found a short solution. I'll still have to see if I can make it work all the way: I lift the <code>multiset s</code> to a <code>list L</code> and then enumerate the elements of <code>L</code> using <code>finset.range L.length</code>. The result is not very pretty...</p>



<a name="287009785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/287009785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#287009785">(Jun 22 2022 at 06:21)</a>:</h4>
<p>Here is a way of using <code>fin s.card</code> as the indexing type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.multiset.basic</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">multiset.of_fin_card</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">s.card</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">s.to_list.nth_le</span> <span class="n">n.1</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">n.2</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.coe_card</span><span class="o">,</span> <span class="n">multiset.coe_to_list</span><span class="o">]</span> <span class="o">})</span>
</code></pre></div>
<p>Not sure if it's simpler or more complicated than your short solution.</p>



<a name="287013015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/287013015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#287013015">(Jun 22 2022 at 07:05)</a>:</h4>
<p>By the way, if your goal is <a href="https://github.com/leanprover-community/mathlib/pull/11523">#11523</a>, I don't think you need to invoke mathlib's Vieta theorem. <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span>'s post says:</p>
<blockquote>
<p>Let <code>R</code> be an integrally closed domain with fraction field <code>K</code> and let <code>f : polynomial R</code> be monic. If <code>f = g * h</code> over <code>K</code>, then <code>g</code> and <code>h</code> have coefficients in <code>R</code>. Indeed, we can assume that <code>g</code> and <code>h</code> are monic (by factoring out the leading coefficients). If <code>L</code> is a splitting field of <code>f</code>, then writing <code>f</code> as a product of linear factors over <code>L</code> we see that both <code>g</code> and <code>h</code> are product of factors of the form <code>X - a</code>, where <code>a</code> ranges over a subset of the roos of <code>f</code>, that are algebraic over <code>R</code> by assumption. By Vieta, the coefficients of <code>g</code> and <code>h</code> are also algebraic over <code>R</code>, but lie <code>K</code> and so they are in <code>R</code>.</p>
</blockquote>
<p>But in fact you just need that <code>g.map (K -&gt; L)</code> is <code>g'.map (integral_closure of R in L -&gt; L)</code> for some <code>g'</code>, and this <code>g'</code> can be defined to be the multiset product of <code>X - C a</code> over roots <code>a</code> of <code>g.map (K -&gt; L)</code>. Although <code>(g.map (K -&gt; L)).roots : multiset L</code>, the roots of <code>g.map (K -&gt; L)</code> are also roots of <code>f.map (R -&gt; L)</code> so they lie in the integral closure, and you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.attach">docs#multiset.attach</a> combined with <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.map">docs#multiset.map</a> to get the desired <code>multiset (integral closure)</code> of roots. <code>g'</code> is then a polynomial over the integral closure and automatically has coefficients in the integral closure.</p>



<a name="287017701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/287017701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#287017701">(Jun 22 2022 at 07:58)</a>:</h4>
<p>Thanks for your answer. So far, things seem nicer with your <code>def</code> than with what I had so far. My end goal here is a formula to bound the coefficients of a polynomial in terms of bounds on its roots. This is needed for the <code>FLT regular</code> project to prove Kronecker's theorem : an algebraic integer whose conjugates are all of absolute value 1 is a root of unity. Now, I know I can get this result with what's already in <code>ring_theory.polynomial.vieta</code> but I thought it would be nice to prove along the way the classical formula between the roots and coefficients of a polynomial. In fact, Alex J. Best already had a proof of that result that we use to prove Kronecker's theorem in the <code>FLT regular</code> project, but it is done from scratch and is quite intricate.  Since we want to PR Kronecker's theorem in <code>mathlib</code>, I wanted to redo the proof using what's already in <code>ring_theory.polynomial.vieta</code>.</p>



<a name="287023674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/287023674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#287023674">(Jun 22 2022 at 08:56)</a>:</h4>
<p>Yes, any polynomial will do the trick, it is unrelated to being symmetric or whatever</p>



<a name="287141796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/287141796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#287141796">(Jun 23 2022 at 04:07)</a>:</h4>
<p>The multiset version of the theorem <a href="https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.prod_X_add_C_coeff">docs#mv_polynomial.prod_X_add_C_coeff</a> in the original post is the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">multiset_prod_X_add_C_coeff</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">s.card</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">polynomial.C</span> <span class="n">r</span> <span class="bp">+</span> <span class="n">polynomial.X</span><span class="o">))</span><span class="bp">.</span><span class="n">prod.coeff</span> <span class="n">k</span> <span class="bp">=</span>
  <span class="o">((</span><span class="n">s.powerset_len</span> <span class="o">(</span><span class="n">card</span> <span class="n">σ</span> <span class="bp">-</span> <span class="n">k</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="n">multiset.prod</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">:=</span>
</code></pre></div>
<p>which should follow from that theorem using the indexing function<code>multiset.of_fin_card</code> and some lemmas that should exist in mathlib. I'm currently taking a look. Have you been able to prove it? Once it's proved, it's easy to deduce the formula between roots and coefficients, by taking <code>s</code> to be <code>p.roots.map neg</code>.</p>



<a name="287146465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/287146465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#287146465">(Jun 23 2022 at 05:37)</a>:</h4>
<p><span class="user-mention" data-user-id="488648">@Xavier Roblot</span> I have been able to prove the multiset version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.multiset.basic</span>
<span class="kn">import</span> <span class="n">ring_theory.polynomial.vieta</span>

<span class="kd">lemma</span> <span class="n">fin_range_eq_univ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset.fin_range</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">finset.univ</span> <span class="o">:=</span>
<span class="n">finset.eq_univ_of_forall</span> <span class="n">finset.mem_fin_range</span>

<span class="kd">lemma</span> <span class="n">multiset.length_to_list</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">s.to_list.length</span> <span class="bp">=</span> <span class="n">s.card</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">multiset.coe_card</span><span class="o">,</span> <span class="n">s.coe_to_list</span><span class="o">]</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">multiset.of_fin_card</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">s.card</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">s.to_list.nth_le</span> <span class="n">n</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">s.length_to_list</span><span class="o">,</span> <span class="n">exact</span> <span class="n">n.2</span> <span class="o">})</span>

<span class="kd">lemma</span> <span class="n">list.map_nth_le</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l</span> <span class="bp">=</span> <span class="o">(</span><span class="n">list.fin_range</span> <span class="n">l.length</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">l.nth_le</span> <span class="n">n</span> <span class="n">n.2</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">list.ext_le</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list.length_map</span><span class="o">,</span> <span class="n">list.length_fin_range</span><span class="o">])</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">list.nth_le_map_rev</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">list.nth_le_fin_range</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">list.length_fin_range</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">multiset.exists_fin_map_eq</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">n</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="bp">@</span><span class="n">finset.univ</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">val.map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">s.card</span><span class="o">,</span> <span class="n">s.of_fin_card</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="n">conv_rhs</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">s.coe_to_list</span> <span class="o">},</span>
  <span class="n">convert</span> <span class="n">multiset.coe_map</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">convert</span> <span class="bp">←</span> <span class="n">s.to_list.map_nth_le</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">s.length_to_list</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">fin.heq_fun_iff</span> <span class="n">s.length_to_list</span><span class="o">,</span> <span class="n">intro</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">s.length_to_list</span> <span class="o">},</span>
<span class="kd">end</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">lemma</span> <span class="n">multiset_prod_X_add_C_coeff</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">s.card</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">s.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">polynomial.C</span> <span class="n">r</span> <span class="bp">+</span> <span class="n">polynomial.X</span><span class="o">))</span><span class="bp">.</span><span class="n">prod.coeff</span> <span class="n">k</span> <span class="bp">=</span>
  <span class="o">((</span><span class="n">s.powerset_len</span> <span class="o">(</span><span class="n">s.card</span> <span class="bp">-</span> <span class="n">k</span><span class="o">))</span><span class="bp">.</span><span class="n">map</span> <span class="n">multiset.prod</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">s.exists_fin_map_eq</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">multiset.map_map</span><span class="o">,</span> <span class="bp">←</span> <span class="n">finset.prod_eq_multiset_prod</span><span class="o">,</span> <span class="n">mv_polynomial.prod_X_add_C_coeff</span><span class="o">],</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">h</span><span class="o">,</span> <span class="n">rw</span> <span class="n">multiset.card_map</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">multiset.powerset_len_map</span><span class="o">,</span> <span class="bp">←</span> <span class="n">finset.map_val_val_powerset_len</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.sum_eq_multiset_sum</span><span class="o">,</span> <span class="n">multiset.map_map</span><span class="o">,</span> <span class="n">multiset.map_map</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span> <span class="n">rw</span> <span class="n">multiset.card_map</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="287148837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/287148837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Xavier Roblot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#287148837">(Jun 23 2022 at 06:24)</a>:</h4>
<p>Hey, that’s great! I spent a couple of hours yesterday trying to make it work without going anywhere. I guess there is still a lot I need to learn about Lean and mathlib. Can you PR this into mathlib? It would be a great addition and allow me to PR Kronecker theorem. As you said, getting the result I need from your result is straightforward.</p>



<a name="287150153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/287150153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#287150153">(Jun 23 2022 at 06:42)</a>:</h4>
<p>Sure, I'll PR it later. It's still a bit nontrivial to deal with the negations (to extract a power of -1 as a factor), so I should probably include a version with <code>X - C r</code> in vieta.lean; then you can directly plug it into <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.C_leading_coeff_mul_prod_multiset_X_sub_C">docs#polynomial.C_leading_coeff_mul_prod_multiset_X_sub_C</a>.</p>



<a name="287168555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fintype%20enumerating%20a%20multiset/near/287168555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fintype.20enumerating.20a.20multiset.html#287168555">(Jun 23 2022 at 10:10)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/14908">#14908</a><br>
will add PR description later</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
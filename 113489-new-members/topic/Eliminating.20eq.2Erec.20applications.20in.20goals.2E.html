---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html">Eliminating eq.rec applications in goals.</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="295615127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295615127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295615127">(Aug 27 2022 at 16:08)</a>:</h4>
<p>I'm trying to re-implement fixed length vector type <code>vec α n</code> as an exercise and wanted to know if I'm I approaching this correctly? <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<p>I start of with the following inductive definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">inductive</span> <span class="n">vec</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">nil</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>I've defined a <code>concat</code> function that concatenates two fixed length vectors in the obvious way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">concat</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span>
 <span class="bp">|</span> <span class="n">_</span> <span class="mi">0</span> <span class="n">m</span> <span class="n">nil</span> <span class="n">v₂</span> <span class="o">:=</span>
    <span class="kd">begin</span>
      <span class="n">rw</span> <span class="n">nat.zero_add</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">v₂</span><span class="o">,</span>
    <span class="kd">end</span>
 <span class="bp">|</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">e</span> <span class="n">v₁</span><span class="o">)</span> <span class="n">v₂</span> <span class="o">:=</span>
    <span class="kd">begin</span>
      <span class="n">rw</span> <span class="n">add_assoc</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">add_comm</span> <span class="mi">1</span> <span class="n">_x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span><span class="n">add_assoc</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">cons</span> <span class="n">e</span> <span class="o">(</span><span class="n">concat</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">)),</span>
    <span class="kd">end</span>
</code></pre></div>
<p>as well as a function to convert a fixed length vector into a list:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">v2l</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">list</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">_</span> <span class="mi">0</span> <span class="n">nil</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">e</span> <span class="n">vs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e</span> <span class="o">::</span> <span class="o">(</span><span class="n">v2l</span> <span class="n">vs</span><span class="o">)</span>
</code></pre></div>
<p>I'm not trying to show that the <code>concat</code> operation on fixed length vectors is equivalent to the <code>++</code> operator on lists:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">vec_concat_equiv</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">v₁</span> <span class="n">v₂</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span><span class="o">},</span>
    <span class="n">v2l</span> <span class="o">(</span><span class="n">concat</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">v2l</span> <span class="n">v₁</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">v2l</span> <span class="n">v₂</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">α</span> <span class="n">n</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">v₁</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span> <span class="n">v2l</span>
       <span class="o">,</span> <span class="bp">←</span><span class="n">list.append_eq_has_append</span>
       <span class="o">,</span> <span class="n">list.append</span>
       <span class="o">,</span> <span class="n">concat</span>
    <span class="o">],</span>
    <span class="n">refl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">concat</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">v2l</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>
<p>In the base case of this proof, the application of <code>eq.mpr</code>, introduced by the use of the <code>rw</code> tactic in the definition of concat, can be "eliminated" by the use of the <code>refl</code> tactic, however,  I cannot find a way of eliminating them in subterms of my goals as is required in the inductive case.</p>



<a name="295617385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295617385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295617385">(Aug 27 2022 at 16:32)</a>:</h4>
<p>You definition of <code>concat</code> is awkward because it goes against definitional equality: <code>m</code> is defeq to <code>m+0</code> but not to <code>0+m</code>, and <code>(n+m)+1</code> is defeq to <code>n+(m+1)</code> but not to <code>(n+1)+m</code>. So if you define <code>concat</code> by induction on the <code>vec α m</code> argument, you wouldn't need any rewrite. But in order to do so, you also need to switch the order of the two arguments of the constructor <code>vec.cons</code>, and the following works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">inductive</span> <span class="n">vec</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">vec</span>
<span class="kd">def</span> <span class="n">concat</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">n</span> <span class="mi">0</span> <span class="n">v₁</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">v₁</span>
<span class="bp">|</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v₁</span> <span class="o">(</span><span class="n">cons</span> <span class="n">v₂</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cons</span> <span class="o">(</span><span class="n">concat</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">)</span> <span class="n">e</span>
</code></pre></div>



<a name="295617714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295617714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295617714">(Aug 27 2022 at 16:35)</a>:</h4>
<p>Usually the answer (and this is still something that is being discussed and researched and argued about) is that if you see <code>eq.rec</code> in goals, the design is "wrong" in some way and you should see how you can work around that (e.g. by making more things defeq, or by passing a proof obligation; e.g. a <code>concat</code> of typr <code>vec a n -&gt; vec a m -&gt; \forall k, k = n + m -&gt; vec a k</code>)</p>



<a name="295620469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295620469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Sutherland <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295620469">(Aug 27 2022 at 17:03)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> Thank you very much for your help, flipping the order of addition of <code>n</code> and <code>m</code> in the type of <code>concat</code> yields a much simpler definition by exploiting definitional equality:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">concat</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span>
 <span class="bp">|</span> <span class="n">_</span> <span class="mi">0</span> <span class="n">m</span> <span class="n">nil</span> <span class="n">v₂</span> <span class="o">:=</span> <span class="n">v₂</span>
 <span class="bp">|</span> <span class="n">α</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">e</span> <span class="n">v₁</span><span class="o">)</span> <span class="n">v₂</span> <span class="o">:=</span> <span class="n">cons</span> <span class="n">e</span> <span class="o">(</span><span class="n">concat</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">)</span>
</code></pre></div>
<p>In turn, this definition allows for a simple proof of a (slight variation) of the statement above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">vec_concat_equiv</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">v₁</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">v₂</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">m</span><span class="o">},</span>
    <span class="n">v2l</span> <span class="o">(</span><span class="n">concat</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">v2l</span> <span class="n">v₁</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">v2l</span> <span class="n">v₂</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">α</span> <span class="n">n</span> <span class="n">m</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">v₁</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span> <span class="n">v2l</span>
       <span class="o">,</span> <span class="bp">←</span><span class="n">list.append_eq_has_append</span>
       <span class="o">,</span> <span class="n">list.append</span>
       <span class="o">,</span> <span class="n">concat</span>
    <span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">concat</span><span class="o">,</span> <span class="n">v2l</span><span class="o">,</span> <span class="n">v2l</span><span class="o">,</span> <span class="n">v₁_ih</span><span class="o">],</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>
<p>Note that above I had accidentally bound the vector lengths to be the same, which was impeding the induction on <code>v₁</code>.</p>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> Thank you for your advice, I'll strive to apply this rule in future :)</p>



<a name="295621749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295621749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295621749">(Aug 27 2022 at 17:17)</a>:</h4>
<p>I think a subtype like <a href="https://leanprover-community.github.io/mathlib_docs/find/vector">docs#vector</a> is much more robust to defeq issues than an inductive definition like yours, and that's probably why mathlib doesn't use your definition, and why <a href="https://leanprover-community.github.io/mathlib_docs/find/fin">docs#fin</a> has much more API than <a href="https://leanprover-community.github.io/mathlib_docs/find/fin2">docs#fin2</a> ...</p>



<a name="295626682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295626682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295626682">(Aug 27 2022 at 18:14)</a>:</h4>
<p><span class="user-mention" data-user-id="453259">@Julian Sutherland</span> By the way, it would be helpful having a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> for this since there are some missing commands to get it working (you can put it in a <code>spoiler</code> block at the end of a post if you want to keep the flow).</p>
<p>Here's a way to get your original setup to work (with the generalization of <code>vec_concat_equiv</code>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">inductive</span> <span class="n">vec</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">nil</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">vec</span>

<span class="kd">def</span> <span class="n">concat</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span>
 <span class="bp">|</span> <span class="n">_</span> <span class="mi">0</span> <span class="n">m</span> <span class="n">nil</span> <span class="n">v₂</span> <span class="o">:=</span>
    <span class="kd">begin</span>
      <span class="n">rw</span> <span class="n">nat.zero_add</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">v₂</span><span class="o">,</span>
    <span class="kd">end</span>
 <span class="bp">|</span> <span class="n">α</span> <span class="n">_</span> <span class="n">m</span> <span class="o">(</span><span class="bp">@</span><span class="n">cons</span> <span class="n">_</span> <span class="n">n</span> <span class="n">e</span> <span class="n">v₁</span><span class="o">)</span> <span class="n">v₂</span> <span class="o">:=</span>
    <span class="kd">begin</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_comm</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">←</span> <span class="n">add_assoc</span><span class="o">],</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">cons</span> <span class="n">e</span> <span class="o">(</span><span class="n">concat</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">)),</span>
    <span class="kd">end</span>

<span class="kd">def</span> <span class="n">v2l</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">list</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">_</span> <span class="mi">0</span> <span class="n">nil</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">e</span> <span class="n">vs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e</span> <span class="o">::</span> <span class="o">(</span><span class="n">v2l</span> <span class="n">vs</span><span class="o">)</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">v2l_cast</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">v2l</span> <span class="o">(</span><span class="n">cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">h</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">m</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v2l</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">vec_concat_equiv</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">v₁</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">v₂</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">m</span><span class="o">},</span>
    <span class="n">v2l</span> <span class="o">(</span><span class="n">concat</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">v2l</span> <span class="n">v₁</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">v2l</span> <span class="n">v₂</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">α</span> <span class="n">n</span> <span class="n">m</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">v₁</span> <span class="n">generalizing</span> <span class="n">m</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">v2l</span><span class="o">,</span> <span class="bp">←</span><span class="n">list.append_eq_has_append</span><span class="o">,</span> <span class="n">list.append</span><span class="o">,</span> <span class="n">concat</span><span class="o">],</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">v2l_cast</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">concat</span><span class="o">,</span> <span class="n">v2l</span><span class="o">],</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eq_mpr_eq_cast</span><span class="o">,</span> <span class="n">cast_eq</span><span class="o">,</span> <span class="n">cast_cast</span><span class="o">,</span> <span class="n">list.cons_append</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">v2l_cast</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">v2l</span><span class="o">,</span> <span class="n">v₁_ih</span><span class="o">],</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_comm</span> <span class="mi">1</span><span class="o">,</span> <span class="bp">←</span> <span class="n">add_assoc</span><span class="o">],</span> <span class="o">},</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="295626762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295626762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295626762">(Aug 27 2022 at 18:15)</a>:</h4>
<p>The key tool is <code>v2l_cast</code>, which shows <code>v2l</code> is invariant under a certain kind of <a href="https://leanprover-community.github.io/mathlib_docs/find/cast">docs#cast</a>. I'm using <code>cast</code> rather than <code>eq.mpr</code> since <a href="https://leanprover-community.github.io/mathlib_docs/find/eq_mpr_eq_cast">docs#eq_mpr_eq_cast</a> is a simp lemma.</p>



<a name="295627019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295627019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295627019">(Aug 27 2022 at 18:18)</a>:</h4>
<p>Generally speaking, the way you deal with <code>eq.rec</code>, <code>eq.mpr</code>, and <code>cast</code> is that you find some way to turn the <code>eq</code> into a definitional equality (i.e., rewrite things until you have <code>a = b</code> such that <code>(rfl : a = b)</code>). The <code>v2l_cast</code> lemma is doing this by using <code>subst</code> so that the <code>cast</code> reduces away.</p>



<a name="295627837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295627837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295627837">(Aug 27 2022 at 18:26)</a>:</h4>
<p>Here's another way to do it, which is to create your own <code>cast</code> function (maybe more often named <code>copy</code>?) that is specialized to rewriting the indices of a type.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">inductive</span> <span class="n">vec</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">nil</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">vec</span>

<span class="kd">def</span> <span class="n">vec.cast</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">eq.rec</span> <span class="n">v</span> <span class="n">h</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">vec.cast_cast</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n₁</span> <span class="n">n₂</span> <span class="n">n₃</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n₁</span> <span class="bp">=</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h'</span> <span class="o">:</span> <span class="n">n₂</span> <span class="bp">=</span> <span class="n">n₃</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">v.cast</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">cast</span> <span class="n">h'</span> <span class="bp">=</span> <span class="n">v.cast</span> <span class="o">(</span><span class="n">h.trans</span> <span class="n">h'</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">subst_vars</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">vec.cast_rfl</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">v.cast</span> <span class="n">rfl</span> <span class="bp">=</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">concat</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">vec</span> <span class="n">α</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span>
 <span class="bp">|</span> <span class="n">_</span> <span class="mi">0</span> <span class="n">m</span> <span class="n">nil</span> <span class="n">v₂</span> <span class="o">:=</span> <span class="n">v₂.cast</span> <span class="o">(</span><span class="n">nat.zero_add</span> <span class="n">m</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
 <span class="bp">|</span> <span class="n">α</span> <span class="n">_</span> <span class="n">m</span> <span class="o">(</span><span class="n">cons</span> <span class="n">e</span> <span class="n">v₁</span><span class="o">)</span> <span class="n">v₂</span> <span class="o">:=</span> <span class="o">(</span><span class="n">cons</span> <span class="n">e</span> <span class="o">(</span><span class="n">concat</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">))</span><span class="bp">.</span><span class="n">cast</span>
    <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_comm</span> <span class="n">m</span><span class="o">,</span> <span class="bp">←</span> <span class="n">add_assoc</span><span class="o">])</span>

<span class="kd">def</span> <span class="n">v2l</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">list</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">_</span> <span class="mi">0</span> <span class="n">nil</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">e</span> <span class="n">vs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e</span> <span class="o">::</span> <span class="n">v2l</span> <span class="n">vs</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">v2l_cast</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">v2l</span> <span class="o">(</span><span class="n">v.cast</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v2l</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">vec_concat_equiv</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">v₁</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">v₂</span> <span class="o">:</span> <span class="n">vec</span> <span class="n">α</span> <span class="n">m</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">v2l</span> <span class="o">(</span><span class="n">concat</span> <span class="n">v₁</span> <span class="n">v₂</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v2l</span> <span class="n">v₁</span> <span class="bp">++</span> <span class="n">v2l</span> <span class="n">v₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">v₁</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">v2l</span><span class="o">,</span> <span class="n">concat</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">v2l</span><span class="o">,</span> <span class="n">concat</span><span class="o">,</span> <span class="n">v₁_ih</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="295628042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295628042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295628042">(Aug 27 2022 at 18:28)</a>:</h4>
<p>I like how these <code>cast</code>/<code>copy</code> functions tend to work out, since they lead to proofs that are mostly just <code>simp</code>. The key to its operation is that it syntactically gives you a proof that the indices are equal right in the <code>vec.cast</code> expression, which is what proofs about <code>vec.cast</code> can then make use of by a simple <code>subst</code> many times.</p>



<a name="295628308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Eliminating%20eq.rec%20applications%20in%20goals./near/295628308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Eliminating.20eq.2Erec.20applications.20in.20goals.2E.html#295628308">(Aug 27 2022 at 18:31)</a>:</h4>
<p>If you write your simp lemmas to "bubble up" the casts to the top level of the expression, then you have a good shot at eliminating them completely. For example, <code>v2l</code> is able to consume them via <code>v2l_cast</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
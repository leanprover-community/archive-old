---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/supremum.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html">supremum</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="167930813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/167930813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#167930813">(Jun 12 2019 at 09:49)</a>:</h4>
<p>Is there a <code>has_Sup</code> instance for <code>enat</code>? If not, why not?</p>



<a name="167931018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/167931018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#167931018">(Jun 12 2019 at 09:52)</a>:</h4>
<p>No. Because nobody got round to writing one yet.</p>



<a name="167931071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/167931071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#167931071">(Jun 12 2019 at 09:53)</a>:</h4>
<p>Thanks!</p>



<a name="167931181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/167931181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keeley Hoek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#167931181">(Jun 12 2019 at 09:55)</a>:</h4>
<p>Is there any machinery which already handles given some finite upper bound of nats finding a minimal witness? (something to do with lattices? Sorry, I don't know anything about them)</p>



<a name="167931298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/167931298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#167931298">(Jun 12 2019 at 09:56)</a>:</h4>
<p><code>nat.find</code> and <code>nat.find_greatest</code> will help. You should write a <code>complete_linear_order</code> instance.</p>



<a name="167931466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/167931466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#167931466">(Jun 12 2019 at 09:59)</a>:</h4>
<p>You could prove that <code>nat</code> is a <code>conditionally_complete_linear_order_bot</code> first</p>



<a name="167932386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/167932386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#167932386">(Jun 12 2019 at 10:12)</a>:</h4>
<p>You should write a <code>transfer</code> tactic which just transports everything on nat to enat ;-)</p>



<a name="167932424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/167932424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#167932424">(Jun 12 2019 at 10:12)</a>:</h4>
<p>Is there a galois insertion thing you can do here?</p>



<a name="211248110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211248110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211248110">(Sep 25 2020 at 11:57)</a>:</h4>
<p>Why is supremum defined as such in mathlib?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>

<p>is there a quirk with lean that means that this would still work for a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S = (0, 1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>x</mi><mo>&lt;</mo><mn>2</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex"> S = \{ x : x &lt; 2 \} </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">}</span></span></span></span>? I'm a tad confused why this works.</p>
<p>Probably I should explain I'm trying to define supremum and infimum standalone as part of a project to formalise the Exeter Analysis course.</p>



<a name="211248394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211248394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211248394">(Sep 25 2020 at 12:00)</a>:</h4>
<p>That is just the true-false statement that S has a top element. I don't really understand what the question is but suspect it might be a misunderstanding on your part rather than a quirk in Lean</p>



<a name="211248413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211248413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211248413">(Sep 25 2020 at 12:01)</a>:</h4>
<p>Maybe post more code?</p>



<a name="211248456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211248456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211248456">(Sep 25 2020 at 12:01)</a>:</h4>
<p>I stole that bit of code from this, which is part of data.real.basic</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">Sup_def</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Sup</span> <span class="n">S</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span>
    <span class="k">then</span> <span class="n">classical.some</span> <span class="o">(</span><span class="n">exists_sup</span> <span class="n">S</span> <span class="n">h.1</span> <span class="n">h.2</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="211249457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211249457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211249457">(Sep 25 2020 at 12:11)</a>:</h4>
<p>What I can't get my head around is that I'd define supremum as this: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">anal.sup</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Although, it's a bit of a mess and doesn't compile, it feels closer to what we are given in our notes. </p>
<p>"Similarly, if there exists an a ∈ R such that a ≤ x x ∈ S, then S is bounded below and a is a lower bound of S. If α is a lower bound of S, but no number is greater than α is, then α is called the infimum of S"</p>



<a name="211249551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211249551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211249551">(Sep 25 2020 at 12:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="304228">James Arthur</span> <a href="#narrow/stream/113489-new-members/topic/supremum/near/211248110">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>

</blockquote>
<p>This is not the definition of the sup. It's the condition under which a subset of the reals has a sup (nonempty and bounded above).</p>



<a name="211249586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211249586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211249586">(Sep 25 2020 at 12:13)</a>:</h4>
<p>Aah, you didn't even quote it correctly! x doesn't have to be in S in the second clause</p>



<a name="211249707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211249707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211249707">(Sep 25 2020 at 12:14)</a>:</h4>
<p>James I still don't understand the question. The lemma says that if S is any set at all, then <em>if</em> S is non-empty and bounded then the Lean function <code>Sup</code> will indeed return the supremum of S, and if it isn't then it will return a junk value.</p>



<a name="211249710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211249710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211249710">(Sep 25 2020 at 12:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/supremum/near/211249551">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="304228">James Arthur</span> <a href="#narrow/stream/113489-new-members/topic/supremum/near/211248110">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>

</blockquote>
<p>This is not the definition of the sup. It's the condition under which a subset of the reals has a sup (nonempty and bounded above).</p>
</blockquote>
<p>Ah, that makes a lot more sense.</p>



<a name="211249736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211249736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211249736">(Sep 25 2020 at 12:14)</a>:</h4>
<p>There is a more general notion <code>is_lub</code> defined in <code>order.bounds</code>.</p>



<a name="211249790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211249790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211249790">(Sep 25 2020 at 12:15)</a>:</h4>
<p>Note also that <code>Sup</code> is a total function, like division, so 1/0 = junk value (=0) and Sup(all the reals) = junk value too.</p>



<a name="211249914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211249914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211249914">(Sep 25 2020 at 12:16)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">anal.sup</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Does this compile? The second clause looks wrong.</p>



<a name="211249967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211249967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211249967">(Sep 25 2020 at 12:17)</a>:</h4>
<p>I want to define the supremum of a set of real numbers. There's problems with junk values, but I should be able to deal with them if I define the extended reals. My question was basically how do I define supremum because my version doesn't compile. I thought if I could work out how mathlib did it, I could rejig it into my code.</p>



<a name="211249989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211249989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211249989">(Sep 25 2020 at 12:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/supremum/near/211249914">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">anal.sup</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">t</span> <span class="bp">∈</span> <span class="n">ℝ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Does this compile? The second clause looks wrong.</p>
</blockquote>
<p>It is wrong and doesn't compile</p>



<a name="211250135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211250135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211250135">(Sep 25 2020 at 12:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="304228">James Arthur</span> <a href="#narrow/stream/113489-new-members/topic/supremum/near/211249967">said</a>:</p>
<blockquote>
<p>I want to define the supremum of a set of real numbers. There's problems with junk values, but I should be able to deal with them if I define the extended reals. My question was basically how do I define supremum because my version doesn't compile. I thought if I could work out how mathlib did it, I could rejig it into my code.</p>
</blockquote>
<p>You need to think hard about exactly the type of the term you want to define. Currently Lean has <code>Sup</code> which returns the sup of a set of reals if this sup exists, and returns 0 otherwise. You don't necessarily need to look at mathlib to see its internal design decisions, if you can write the maths then you can write it in Lean (perhaps after asking for hints first).</p>



<a name="211250209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211250209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211250209">(Sep 25 2020 at 12:19)</a>:</h4>
<p>But things like "I should be able to deal with them if I use extended reals" indicate to me that you still haven't actually decided what the source and target of the function you want to define is. So you should decide that first -- by which I mean make a precise decision which you understand can't be changed later --  this is a design decision which you will have to make as the designer.</p>



<a name="211251403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211251403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211251403">(Sep 25 2020 at 12:31)</a>:</h4>
<p>I know I want the code to be easy to read, preferably by my coursemates with help from lots of comments. I don't quite know how to define sup and inf, but I wanted it to be one definition for each, just with the two conditions that are given in the notes, while importing the reals from mathlib. We proved that the rationals aren't complete using it, which would be nice to prove using my sup and inf.</p>



<a name="211252513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211252513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211252513">(Sep 25 2020 at 12:43)</a>:</h4>
<p>I'm sure that we'll be able to get you some easy-to-read code, you don't need to use the inbuilt Sup, you will be able to use the inbuilt theorem that if you have a non-empty bounded set of reals then it has a real Sup and if I'd had more time to work on the real number game over the summer then perhaps I would have been able to show you how we did it there. But right now you are going to have to define what the source and target of your <code>Sup</code> function are going to be, and this is your own decision. One you've decided, I'm sure we can help you make it. </p>
<p>I once made a square root function (before mathlib had square roots) and I decided that I wanted the input to be a non-negative real, so I asked for two inputs -- a real, and a proof that it was non-negative. This worked fine, however it was sometimes a pain to use because I got sick of supplying proofs that e.g. 37 was non-negative. This is why mathlib has this <code>Sup</code> function, which does not always return the sup (in fact it fails to return the sup precisely when the sup doesn't exist) but it is easier to use.</p>



<a name="211252869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211252869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211252869">(Sep 25 2020 at 12:46)</a>:</h4>
<p>So I need to decide what goes into my sup and what comes out? Is that what you mean by source and target?</p>



<a name="211252891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211252891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211252891">(Sep 25 2020 at 12:47)</a>:</h4>
<p>Yeah exactly. Let's establish that first.</p>



<a name="211252923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211252923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211252923">(Sep 25 2020 at 12:47)</a>:</h4>
<p>Here are some half-baked thoughts about formalising Imperial's analysis course by the way: <a href="https://github.com/ImperialCollegeLondon/M1P1-lean/tree/master/src">https://github.com/ImperialCollegeLondon/M1P1-lean/tree/master/src</a> . You might find them useful</p>



<a name="211253717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211253717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211253717">(Sep 25 2020 at 12:55)</a>:</h4>
<p>Thankyou. </p>
<p>I'd be happy if it had an input of a set of reals and outputted the supremum, if it exists, or zero.</p>



<a name="211263263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211263263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211263263">(Sep 25 2020 at 14:14)</a>:</h4>
<p>So this is exactly what Sup does. Why don't you write the predicate first? That's a good way to start I guess. Write a function which takes a set S of reals and a real number x, and outputs the statement that x is a sup of S. That could be called <code>is_Sup</code> or something. Note that it will almost certainly be in lean already but you might want to write your own anyway, especially if this is for teaching purposes</p>



<a name="211263564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211263564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211263564">(Sep 25 2020 at 14:17)</a>:</h4>
<p>In fact it seems to me that you could probably go a long way with just <code>has_Sup</code> and <code>is_Sup</code></p>



<a name="211263623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211263623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211263623">(Sep 25 2020 at 14:17)</a>:</h4>
<p>Isn't this all you need in a basic analysis course?</p>



<a name="211266153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211266153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211266153">(Sep 25 2020 at 14:38)</a>:</h4>
<p>I probably just need <code>has_Sup</code> and <code>is_Sup</code>.</p>



<a name="211266683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211266683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211266683">(Sep 25 2020 at 14:43)</a>:</h4>
<p>So then you don't need to get involved in weird functions which return 0 if a set doesn't have a sup.</p>



<a name="211267256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/supremum/near/211267256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Arthur <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/supremum.html#211267256">(Sep 25 2020 at 14:47)</a>:</h4>
<p>Amazing. Thats useful.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
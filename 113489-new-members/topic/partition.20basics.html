---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/partition.20basics.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html">partition basics</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="205959166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205959166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205959166">(Aug 04 2020 at 20:52)</a>:</h4>
<p>I want to do a few exercises with partitions, such as to show that <code>{{a}, {b}, {c}} &lt;= {{a, b}, {c}}</code>. I think first step is to show that each of those are partitions, which means first showing they're setoids. I can do that manually but maybe there's another way?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">lattice</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">setoid</span><span class="bp">.</span><span class="n">partition</span>
<span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">filter</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">inductive</span> <span class="n">thing</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="n">thing</span>


<span class="kn">open</span> <span class="n">thing</span>


<span class="n">def</span> <span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">thing</span> <span class="o">:=</span>
<span class="n">setoid</span><span class="bp">.</span><span class="n">mk_classes</span> <span class="o">{{</span><span class="n">a</span><span class="o">},</span> <span class="o">{</span><span class="n">b</span><span class="o">},</span> <span class="o">{</span><span class="n">c</span><span class="o">}}</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">don&#39;t know how to synthesize placeholder</span>
<span class="cm">context:</span>
<span class="cm">⊢ ∀ (a : thing), ∃! (b : set thing) (H : b ∈ {{a}, {b}, {c}}), a ∈ b -/</span>
</code></pre></div>



<a name="205961488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205961488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205961488">(Aug 04 2020 at 21:12)</a>:</h4>
<p>Actually I don't know how to do that manually.</p>



<a name="205963603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205963603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205963603">(Aug 04 2020 at 21:33)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">thing</span> <span class="o">:=</span>
<span class="n">setoid</span><span class="bp">.</span><span class="n">mk_classes</span> <span class="o">{{</span><span class="n">a</span><span class="o">},</span> <span class="o">{</span><span class="n">b</span><span class="o">},</span> <span class="o">{</span><span class="n">c</span><span class="o">}}</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
<span class="n">use</span> <span class="o">{</span><span class="n">b</span><span class="o">},</span>
<span class="c1">-- x : thing</span>
<span class="c1">-- ⊢ (λ (b : set thing), ∃! (H : b ∈ {{a}, {b}, {c}}), x ∈ b) {b} ∧ ∀ (y : set thing), (λ (b : set thing), ∃! (H : b ∈ {{a}, {b}, {c}}), x ∈ b) y → y = {b}</span>
<span class="kn">end</span>
</code></pre></div>


<p>That can't be right</p>



<a name="205964030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205964030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205964030">(Aug 04 2020 at 21:37)</a>:</h4>
<p>Why would you expect {b} to work for any x? Why not use {x}?</p>



<a name="205964163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205964163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205964163">(Aug 04 2020 at 21:38)</a>:</h4>
<p>Yeah fair enough</p>



<a name="205964234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205964234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205964234">(Aug 04 2020 at 21:38)</a>:</h4>
<p>but the state after that is <code>⊢ (λ (b : set thing), ∃! (H : b ∈ {{a}, {b}, {c}}), x ∈ b) {x} ∧ ∀ (y : set thing), (λ (b : set thing), ∃! (H : b ∈ {{a}, {b}, {c}}), x ∈ b) y → y = {x}</code> which I can barely even parse</p>



<a name="205964842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205964842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205964842">(Aug 04 2020 at 21:45)</a>:</h4>
<p>Well it's what you've got to prove. Try <code>simp</code>.</p>



<a name="205966606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205966606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205966606">(Aug 04 2020 at 22:04)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">thing</span> <span class="o">:=</span>
<span class="n">setoid</span><span class="bp">.</span><span class="n">mk_classes</span> <span class="o">{{</span><span class="n">a</span><span class="o">},</span> <span class="o">{</span><span class="n">b</span><span class="o">},</span> <span class="o">{</span><span class="n">c</span><span class="o">}}</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
<span class="n">use</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span>
<span class="n">simp</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="o">{</span>
    <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">},</span>
<span class="o">},</span>
<span class="n">intro</span> <span class="n">s</span><span class="o">,</span>
<span class="o">{</span>
    <span class="n">intros</span> <span class="n">h</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="k">have</span> <span class="n">hxa</span><span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span> <span class="o">{</span> <span class="n">finish</span> <span class="o">},</span>
        <span class="n">exact</span> <span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">singleton</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hxa</span><span class="o">)),</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
        <span class="o">{</span>
            <span class="k">have</span> <span class="n">hxb</span><span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span> <span class="o">{</span> <span class="n">finish</span> <span class="o">},</span>
            <span class="n">exact</span> <span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">singleton</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hxb</span><span class="o">)),</span>
        <span class="o">},</span>
        <span class="o">{</span>
            <span class="k">have</span> <span class="n">hxc</span><span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">c</span><span class="o">,</span> <span class="o">{</span> <span class="n">finish</span> <span class="o">},</span>
            <span class="n">exact</span> <span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">singleton</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hxc</span><span class="o">)),</span>
        <span class="o">},</span>
    <span class="o">},</span>
<span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205967026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205967026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205967026">(Aug 04 2020 at 22:08)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">setoid</span><span class="bp">.</span><span class="n">partition</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">inductive</span> <span class="n">thing</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="n">thing</span>


<span class="kn">open</span> <span class="n">thing</span>


<span class="n">def</span> <span class="n">s</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">thing</span> <span class="o">:=</span>
<span class="n">setoid</span><span class="bp">.</span><span class="n">mk_classes</span> <span class="o">{{</span><span class="n">a</span><span class="o">},</span> <span class="o">{</span><span class="n">b</span><span class="o">},</span> <span class="o">{</span><span class="n">c</span><span class="o">}}</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span>
  <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span>
  <span class="n">finish</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205967254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205967254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205967254">(Aug 04 2020 at 22:11)</a>:</h4>
<p>ha</p>



<a name="205969457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205969457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205969457">(Aug 04 2020 at 22:38)</a>:</h4>
<p>This works, what would make it more stylish?</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">set_partition</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">t</span><span class="o">)</span> <span class="bp">|</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">s</span><span class="o">}</span>


<span class="n">def</span> <span class="n">ab_connected</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="n">set_partition</span> <span class="n">thing</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">thing</span><span class="bp">.</span><span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">thing</span><span class="bp">.</span><span class="n">b</span> <span class="err">∈</span> <span class="n">s</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="n">p&#39;</span> <span class="o">:</span> <span class="n">set_partition</span> <span class="n">thing</span><span class="o">,</span>  <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span> <span class="bp">∧</span>  <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">val</span> <span class="bp">∧</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">val</span> <span class="bp">→</span>
<span class="o">(</span><span class="n">ab_connected</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">ab_connected</span> <span class="n">p&#39;</span><span class="o">):=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">p</span> <span class="n">p&#39;</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">h</span> <span class="n">pab</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hp</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hp&#39;</span> <span class="n">h</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">ab_connected</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">pab</span> <span class="k">with</span> <span class="n">s</span> <span class="n">pab</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">pab</span> <span class="k">with</span> <span class="n">hs</span> <span class="n">pab</span><span class="o">,</span>
<span class="n">tauto</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205969845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205969845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205969845">(Aug 04 2020 at 22:43)</a>:</h4>
<p>For example, I don't yet have a feel for when I want <code>\forall</code> vs left-of-colon, or when to use <code>\and</code> vs <code>\to</code>.</p>



<a name="205970171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205970171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205970171">(Aug 04 2020 at 22:46)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="n">p&#39;</span> <span class="o">:</span> <span class="n">set_partition</span> <span class="n">thing</span><span class="o">,</span>  <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span> <span class="bp">∧</span>  <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">val</span> <span class="bp">∧</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">val</span> <span class="bp">→</span>
<span class="o">(</span><span class="n">ab_connected</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">ab_connected</span> <span class="n">p&#39;</span><span class="o">):=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">p</span> <span class="n">p&#39;</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">h</span> <span class="n">pab</span><span class="o">,</span>
<span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span> <span class="n">hp</span> <span class="o">,</span> <span class="n">hp&#39;</span><span class="o">,</span> <span class="n">h</span> <span class="bp">⟩</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">ab_connected</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">tauto</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205970188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205970188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205970188">(Aug 04 2020 at 22:46)</a>:</h4>
<p>The argument for putting as much as you can left-of-colon is that it doesn't make theorem statements any longer, but it makes proofs shorter because you don't need to write <code>intro</code> as much. The <code>\and</code> v <code>\to</code> thing is not the same though -- they mean different things. It's a bit confusing because (P and Q) -&gt; R is the same as P -&gt; (Q -&gt; R) so here they're playing a similar role (and in this situation you should use -&gt; not and, because functional programming is easier that way). However in general and and to just mean different things so you should use the one which is logically correct</p>



<a name="205970468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205970468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205970468">(Aug 04 2020 at 22:50)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span>
<span class="o">(</span><span class="n">p</span> <span class="n">p&#39;</span> <span class="o">:</span> <span class="n">set_partition</span> <span class="n">thing</span><span class="o">)</span>
<span class="o">(</span><span class="n">hp</span><span class="o">:</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>
<span class="o">(</span><span class="n">hp&#39;</span><span class="o">:</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span> <span class="bp">≤</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span>
<span class="o">(</span><span class="n">pab</span><span class="o">:</span> <span class="n">ab_connected</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
<span class="n">ab_connected</span> <span class="n">p&#39;</span><span class="o">:=</span>
<span class="k">begin</span>
<span class="n">unfold</span> <span class="n">ab_connected</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">tauto</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205978995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205978995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205978995">(Aug 05 2020 at 01:10)</a>:</h4>
<p>Trying to do it more generically using <code>is_monotone</code>. How can I use <code>h</code> to fill the <code>sorry</code>s? I can't even figure out how to do the equivalent of <code>unfold has_le at h</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">lattice</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">setoid</span><span class="bp">.</span><span class="n">partition</span>
<span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">filter</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>


<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kn">inductive</span> <span class="n">thing</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="n">thing</span>


<span class="kn">open</span> <span class="n">thing</span>


<span class="n">def</span> <span class="n">set_partition</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">t</span><span class="o">)</span> <span class="bp">|</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">s</span><span class="o">}</span>


<span class="n">def</span> <span class="n">ab_connected</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="n">set_partition</span> <span class="n">thing</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">thing</span><span class="bp">.</span><span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">thing</span><span class="bp">.</span><span class="n">b</span> <span class="err">∈</span> <span class="n">s</span>


<span class="n">def</span> <span class="n">is_monotone</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
 <span class="bp">∀</span> <span class="n">x1</span> <span class="n">x2</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">x1</span> <span class="bp">≤</span> <span class="n">x2</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">x1</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">x2</span>


<span class="kn">example</span> <span class="o">[</span><span class="n">preorder</span> <span class="o">(</span><span class="n">set_partition</span> <span class="n">thing</span><span class="o">)</span> <span class="o">]:</span> <span class="n">is_monotone</span> <span class="n">ab_connected</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">p</span> <span class="n">p&#39;</span> <span class="n">h</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">ab_connected</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">h&#39;</span><span class="o">,</span>
<span class="n">rcases</span> <span class="n">h&#39;</span> <span class="k">with</span>  <span class="bp">⟨</span><span class="n">s</span> <span class="o">,</span> <span class="n">hsp</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span> <span class="bp">⟩</span><span class="o">,</span>
<span class="k">have</span><span class="o">:</span> <span class="bp">∃</span> <span class="n">s&#39;</span> <span class="err">∈</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s&#39;</span><span class="o">,</span>
<span class="o">{</span>

<span class="c1">-- _inst_1 : preorder (set_partition thing)</span>
<span class="c1">-- pp&#39; : set_partition thing</span>
<span class="c1">-- h : p ≤ p&#39;</span>
<span class="c1">-- s : set thing</span>
<span class="c1">-- hsp : s ∈ ↑p</span>
<span class="c1">-- ha : a ∈ s</span>
<span class="c1">-- hb : b ∈ s</span>
<span class="c1">-- ⊢ ∃ (s&#39; : set thing) (H : s&#39; ∈ p&#39;.val), a ∈ s&#39;</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="o">},</span>
<span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">s&#39;</span> <span class="n">hs&#39;</span><span class="o">,</span>
<span class="n">use</span> <span class="n">s&#39;</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="o">{</span> <span class="n">finish</span> <span class="o">},</span>
<span class="o">{</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">finish</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">cases</span> <span class="n">hs&#39;</span> <span class="k">with</span> <span class="n">hs&#39;</span> <span class="n">as&#39;</span><span class="o">,</span>
<span class="c1">--         _inst_1 : preorder (set_partition thing)</span>
<span class="c1">-- pp&#39; : set_partition thing</span>
<span class="c1">-- h : p ≤ p&#39;</span>
<span class="c1">-- s : set thing</span>
<span class="c1">-- hsp : s ∈ ↑p</span>
<span class="c1">-- ha : a ∈ s</span>
<span class="c1">-- hb : b ∈ s</span>
<span class="c1">-- s&#39; : set thing</span>
<span class="c1">-- hs&#39; : s&#39; ∈ p&#39;.val</span>
<span class="c1">-- as&#39; : a ∈ s&#39;</span>
<span class="c1">-- ⊢ b ∈ s&#39;</span>
        <span class="n">sorry</span><span class="o">,</span>
    <span class="o">},</span>
<span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205979376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205979376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205979376">(Aug 05 2020 at 01:20)</a>:</h4>
<p>I don't think this is provable without adding some more assumptions on the preorder on <code>set_partition thing</code>. For example, just because <code>p ≤ p'</code> in your arbitrary preorder, that doesn't necessarily give you any way to prove <code>s' ∈ p'.val</code> from <code>s ∈ ↑p</code>.</p>



<a name="205980562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205980562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205980562">(Aug 05 2020 at 01:51)</a>:</h4>
<p>How do I express the same assumptions as in the prior version above?</p>



<a name="205981019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205981019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205981019">(Aug 05 2020 at 02:02)</a>:</h4>
<p>I'm guessing you didn't prove what you thought you were proving</p>



<a name="205981093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205981093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205981093">(Aug 05 2020 at 02:04)</a>:</h4>
<p>Sounds plausible, what do you have in mind?</p>



<a name="205981123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205981123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205981123">(Aug 05 2020 at 02:04)</a>:</h4>
<p>before, you wrote <code>p.val ≤ p'.val</code> where <code>p.val : set (set thing)</code></p>



<a name="205981237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205981237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205981237">(Aug 05 2020 at 02:07)</a>:</h4>
<p>you're right :-/</p>



<a name="205996457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205996457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205996457">(Aug 05 2020 at 07:50)</a>:</h4>
<p>The order relation that I want is "finer is lesser". Is that the one that's <a href="https://github.com/leanprover-community/mathlib/blob/d9a6e478571a4f12a18960cc10f72412a4dcdd0c/src/data/setoid/partition.lean#L161">built into partition</a>? How do I get <code>set_partition thing</code> to inherit that ordering?</p>



<a name="205997418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205997418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205997418">(Aug 05 2020 at 08:05)</a>:</h4>
<p>You can use partial_order.lift</p>



<a name="205999242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205999242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205999242">(Aug 05 2020 at 08:31)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">lattice</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">setoid</span><span class="bp">.</span><span class="n">partition</span>
<span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">filter</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kn">inductive</span> <span class="n">thing</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="n">thing</span>

<span class="kn">open</span> <span class="n">thing</span>

<span class="n">def</span> <span class="n">set_partition</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">//</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">s</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">set_partition</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">set_partition</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">setoid</span><span class="bp">.</span><span class="n">partition</span><span class="bp">.</span><span class="n">partial_order</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="o">(</span><span class="n">set_partition</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">setoid</span><span class="bp">.</span><span class="n">partition</span><span class="bp">.</span><span class="n">complete_lattice</span>

<span class="n">def</span> <span class="n">ab_connected</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">set_partition</span> <span class="n">thing</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">thing</span><span class="bp">.</span><span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">thing</span><span class="bp">.</span><span class="n">b</span> <span class="err">∈</span> <span class="n">s</span>

<span class="kn">lemma</span> <span class="n">ab_connected_of_le</span> <span class="o">(</span><span class="n">p</span> <span class="n">p&#39;</span> <span class="o">:</span> <span class="n">set_partition</span> <span class="n">thing</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">p&#39;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">ab_connected</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">ab_connected</span> <span class="n">p&#39;</span><span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">set_partition</span>
</code></pre></div>



<a name="205999614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205999614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205999614">(Aug 05 2020 at 08:35)</a>:</h4>
<p>What does <code>//</code> do vs <code>|</code>?</p>



<a name="205999736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205999736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205999736">(Aug 05 2020 at 08:37)</a>:</h4>
<p>Makes a type not a term</p>



<a name="205999777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205999777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205999777">(Aug 05 2020 at 08:38)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">set_partition</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">t</span><span class="o">)</span> <span class="bp">|</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">s</span><span class="o">}</span>
</code></pre></div>


<p>doesn't make a type?</p>



<a name="205999823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205999823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205999823">(Aug 05 2020 at 08:38)</a>:</h4>
<p>well, function for generating types</p>



<a name="205999856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205999856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205999856">(Aug 05 2020 at 08:38)</a>:</h4>
<p>well it makes a set, which Lean knows how to coerce to type</p>



<a name="205999861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205999861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205999861">(Aug 05 2020 at 08:38)</a>:</h4>
<p>the results are defeq</p>



<a name="205999973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205999973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205999973">(Aug 05 2020 at 08:40)</a>:</h4>
<p>I have to say, the API of partition in the file is very incomplete</p>



<a name="205999984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/205999984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#205999984">(Aug 05 2020 at 08:40)</a>:</h4>
<p>but we pick <code>//</code> for clarity I guess</p>



<a name="206000040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206000040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206000040">(Aug 05 2020 at 08:41)</a>:</h4>
<p>if I understood you right, using <code>|</code> would have the same result in this case</p>



<a name="206000625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206000625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206000625">(Aug 05 2020 at 08:49)</a>:</h4>
<p>yes</p>



<a name="206001143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206001143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206001143">(Aug 05 2020 at 08:57)</a>:</h4>
<p>Except you'd get little arrows everywhere</p>



<a name="206002623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206002623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206002623">(Aug 05 2020 at 09:18)</a>:</h4>
<p>Can I unfold that <code>h</code> so I can see what I'm actually working with?</p>



<a name="206002636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206002636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206002636">(Aug 05 2020 at 09:18)</a>:</h4>
<p>there's the <code>have := @h</code> trick</p>



<a name="206002645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206002645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206002645">(Aug 05 2020 at 09:19)</a>:</h4>
<p>to make its arguments explicit</p>



<a name="206002667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206002667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206002667">(Aug 05 2020 at 09:19)</a>:</h4>
<p>doesn't help</p>



<a name="206003076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206003076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206003076">(Aug 05 2020 at 09:25)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="k">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="206003082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206003082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206003082">(Aug 05 2020 at 09:25)</a>:</h4>
<p>?</p>



<a name="206003173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206003173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206003173">(Aug 05 2020 at 09:26)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">pp&#39;</span> <span class="o">:</span> <span class="n">set_partition</span> <span class="n">thing</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">p&#39;</span>
<span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="n">ab_connected</span>
<span class="n">this</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">p&#39;</span>
<span class="err">⊢</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">ab_connected</span>
</code></pre></div>



<a name="206003236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206003236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206003236">(Aug 05 2020 at 09:28)</a>:</h4>
<p>oh well</p>



<a name="206003282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206003282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206003282">(Aug 05 2020 at 09:28)</a>:</h4>
<p>also been wondering why is there no space between p and p'</p>



<a name="206003289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206003289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206003289">(Aug 05 2020 at 09:28)</a>:</h4>
<p>how about <code>have := @h _</code></p>



<a name="206003299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206003299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206003299">(Aug 05 2020 at 09:28)</a>:</h4>
<p>oh I think that's a bug</p>



<a name="206003319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206003319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206003319">(Aug 05 2020 at 09:28)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">this</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">y</span> <span class="o">:</span> <span class="n">thing</span><span class="o">⦄,</span> <span class="o">(</span><span class="n">setoid</span><span class="bp">.</span><span class="n">mk_classes</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">rel</span> <span class="err">?</span><span class="n">m_1</span> <span class="n">y</span> <span class="bp">→</span> <span class="o">(</span><span class="n">setoid</span><span class="bp">.</span><span class="n">mk_classes</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">val</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">rel</span> <span class="err">?</span><span class="n">m_1</span> <span class="n">y</span>
</code></pre></div>



<a name="206070833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206070833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206070833">(Aug 05 2020 at 19:59)</a>:</h4>
<p>I think I need to use <code>h</code> here but I can't figure out how to apply it.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">lattice</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">setoid</span><span class="bp">.</span><span class="n">partition</span>
<span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">filter</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kn">inductive</span> <span class="n">thing</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">thing</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="n">thing</span>

<span class="kn">open</span> <span class="n">thing</span>

<span class="n">def</span> <span class="n">set_partition</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">//</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">s</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">set_partition</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">set_partition</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">setoid</span><span class="bp">.</span><span class="n">partition</span><span class="bp">.</span><span class="n">partial_order</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="o">(</span><span class="n">set_partition</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">setoid</span><span class="bp">.</span><span class="n">partition</span><span class="bp">.</span><span class="n">complete_lattice</span>

<span class="n">def</span> <span class="n">ab_connected</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">set_partition</span> <span class="n">thing</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">p</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">thing</span><span class="bp">.</span><span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">thing</span><span class="bp">.</span><span class="n">b</span> <span class="err">∈</span> <span class="n">s</span>

<span class="kn">lemma</span> <span class="n">ab_connected_of_le</span> <span class="o">(</span><span class="n">p</span> <span class="n">p&#39;</span> <span class="o">:</span> <span class="n">set_partition</span> <span class="n">thing</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">p&#39;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">ab_connected</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">ab_connected</span> <span class="n">p&#39;</span><span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rcases</span> <span class="n">hp</span> <span class="k">with</span> <span class="bp">⟨</span> <span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="bp">⟩</span> <span class="bp">⟩</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">ab_connected</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hs&#39;</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">s&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">thing</span><span class="o">,</span> <span class="n">s&#39;</span> <span class="err">∈</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">val</span> <span class="bp">∧</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s&#39;</span><span class="o">,</span>
<span class="o">{</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">is_partition</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">this</span> <span class="k">with</span> <span class="n">hne</span> <span class="n">hpart&#39;</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">hpart&#39;</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hpart&#39;</span> <span class="k">with</span> <span class="n">s&#39;</span> <span class="n">hs&#39;</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">hs&#39;</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">s&#39;</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hs&#39;</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
<span class="o">},</span>
<span class="o">{</span>
    <span class="n">cases</span> <span class="n">hs&#39;</span> <span class="k">with</span> <span class="n">s&#39;</span> <span class="n">hs&#39;</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">s&#39;</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span>  <span class="n">apply</span> <span class="n">hs&#39;</span><span class="bp">.</span><span class="mi">1</span>  <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">split</span><span class="o">,</span>
        <span class="o">{</span>  <span class="n">apply</span> <span class="n">hs&#39;</span><span class="bp">.</span><span class="mi">2</span> <span class="o">},</span>
        <span class="o">{</span>
            <span class="k">show</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">s&#39;</span><span class="o">,</span>
            <span class="c1">-- pp&#39; : set_partition thing</span>
            <span class="c1">-- h : p ≤ p&#39;</span>
            <span class="c1">-- s : set thing</span>
            <span class="c1">-- hs : s ∈ p.val</span>
            <span class="c1">-- ha : a ∈ s</span>
            <span class="c1">-- hb : b ∈ s</span>
            <span class="c1">-- s&#39; : set thing</span>
            <span class="c1">-- hs&#39; : s&#39; ∈ p&#39;.val ∧ a ∈ s&#39;</span>
            <span class="c1">-- ⊢ b ∈ s&#39;</span>
            <span class="n">sorry</span><span class="o">,</span>
        <span class="o">},</span>
    <span class="o">},</span>
<span class="o">},</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">set_partition</span>
</code></pre></div>



<a name="206085414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206085414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206085414">(Aug 05 2020 at 22:25)</a>:</h4>
<p><code>h</code> means <code>p &lt;= p'</code> which means p is finer than p', which means whenever a and b are in the same part of p, then a and b are in the same part of p'. That's exactly the thing I need, but I can' t see how to actually <em>use</em> <code>h</code>, aka <code>this</code>.</p>



<a name="206086377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206086377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206086377">(Aug 05 2020 at 22:36)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">apply</span> <span class="n">h</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">hs&#39;</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hs&#39;</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
</code></pre></div>


<p>?</p>



<a name="206086491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206086491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Iocta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206086491">(Aug 05 2020 at 22:37)</a>:</h4>
<p>that does something, I'll fiddle with it</p>



<a name="206116653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/206116653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#206116653">(Aug 06 2020 at 08:43)</a>:</h4>
<p>as I said, the API for partition is really lacking</p>



<a name="261388983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/261388983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#261388983">(Nov 14 2021 at 00:39)</a>:</h4>
<p>It only excludes <code>S</code> from containing the empty set -- it still allows <code>S</code> itself to be empty.</p>



<a name="261389053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/261389053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#261389053">(Nov 14 2021 at 00:40)</a>:</h4>
<p>Hmm, do you think it could have some issue with non-used colors?</p>



<a name="261389140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/261389140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#261389140">(Nov 14 2021 at 00:42)</a>:</h4>
<p>(when mapping colorings to partitions and vice-versa)</p>



<a name="261389374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/261389374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#261389374">(Nov 14 2021 at 00:48)</a>:</h4>
<p>My use case for <code>is_antichain</code> was <a href="https://github.com/leanprover-community/mathlib/tree/combinatorics">branch#combinatorics</a>, but yes I definitely had independent sets in mind.</p>



<a name="261389569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/261389569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#261389569">(Nov 14 2021 at 00:53)</a>:</h4>
<p>The definition of partition is precisely to make "equivalence relations on X = partitions of X" true.</p>



<a name="261389747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/partition%20basics/near/261389747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/partition.20basics.html#261389747">(Nov 14 2021 at 00:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20variable.20declaration/near/261389053">said</a>:</p>
<blockquote>
<p>Hmm, do you think it could have some issue with non-used colors?</p>
</blockquote>
<p>This is ok if we use the coloring function to partition the vertices, since empty sets won't turn up.  I think it's <code>(setoid.ker C).classes</code>.  Then there's <a href="https://leanprover-community.github.io/mathlib_docs/find/setoid.is_partition_classes">docs#setoid.is_partition_classes</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/band.2C.20bor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html">band, bor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209938277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209938277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209938277">(Sep 13 2020 at 16:18)</a>:</h4>
<p>Why in gods name is band and bor matching on the 2nd argument??? The library definition is:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="kn">inline</span><span class="o">]</span> <span class="n">def</span> <span class="n">bor</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="bp">_</span>  <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">inline</span><span class="o">]</span> <span class="n">def</span> <span class="n">band</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="bp">_</span>  <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">tt</span>
</code></pre></div>


<p>and my definitions are:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">my_band</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="n">def</span> <span class="n">my_bor</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>
</code></pre></div>


<p>which makes proving anything more difficult because you have to use extra cases.</p>



<a name="209947927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209947927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209947927">(Sep 13 2020 at 20:16)</a>:</h4>
<p>Proving anything about booleans is <code>dec_trivial</code></p>



<a name="209947942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209947942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209947942">(Sep 13 2020 at 20:17)</a>:</h4>
<p>(That said I agree with your assessment of these definitions, they could be simplified)</p>



<a name="209953414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209953414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209953414">(Sep 13 2020 at 22:54)</a>:</h4>
<p><span class="user-mention" data-user-id="271218">@Thorsten Altenkirch</span> </p>
<p><a href="https://github.com/leanprover-community/lean/pull/466">https://github.com/leanprover-community/lean/pull/466</a></p>



<a name="209953459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209953459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209953459">(Sep 13 2020 at 22:56)</a>:</h4>
<p>Curiously, no changes are needed, in core or mathlib, to cope with this change.</p>



<a name="209953471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209953471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209953471">(Sep 13 2020 at 22:56)</a>:</h4>
<p>FWIW lean4 matches on the first.<br>
<a href="https://github.com/leanprover/lean4/blob/master/src/Init/Core.lean#L562">https://github.com/leanprover/lean4/blob/master/src/Init/Core.lean#L562</a></p>



<a name="209955188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209955188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209955188">(Sep 13 2020 at 23:54)</a>:</h4>
<p>Do you get the definitional equalities Thorsten expects though? I've seen lean do funny things in this situation</p>



<a name="209955206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209955206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209955206">(Sep 13 2020 at 23:56)</a>:</h4>
<p>When you match on more than one thing lean sometimes ends up making four equations and you still have to case split on the missing variable to get a definitional equality</p>



<a name="209957328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209957328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209957328">(Sep 14 2020 at 00:53)</a>:</h4>
<p>Yeah. The 'match on lhs' ones produce the equational lemmas</p>
<div class="codehilite"><pre><span></span><code><span class="n">Bor</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">),</span> <span class="n">Bor</span> <span class="n">ff</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span>
<span class="n">Band</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">),</span> <span class="n">Band</span> <span class="n">tt</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span>
</code></pre></div>


<p>whereas the 'match on rhs' ones split those into :</p>
<div class="codehilite"><pre><span></span><code><span class="n">bor</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_1</span> <span class="o">:</span> <span class="n">ff</span> <span class="bp">||</span> <span class="n">ff</span> <span class="bp">=</span> <span class="n">ff</span>
<span class="n">bor</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_2</span> <span class="o">:</span> <span class="n">ff</span> <span class="bp">||</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">tt</span>

<span class="n">band</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_2</span> <span class="o">:</span> <span class="n">tt</span> <span class="bp">&amp;&amp;</span> <span class="n">ff</span> <span class="bp">=</span> <span class="n">ff</span>
<span class="n">band</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_3</span> <span class="o">:</span> <span class="n">tt</span> <span class="bp">&amp;&amp;</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">tt</span>
</code></pre></div>


<p>meaning you get:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bor</span> <span class="n">ff</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">bor</span> <span class="n">ff</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">Band</span> <span class="n">tt</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">band</span> <span class="n">tt</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--fails</span>
</code></pre></div>



<a name="209970067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209970067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209970067">(Sep 14 2020 at 06:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/band.2C.20bor/near/209953459">said</a>:</p>
<blockquote>
<p><a href="https://github.com/leanprover-community/lean/pull/466">https://github.com/leanprover-community/lean/pull/466</a></p>
<p>Curiously, no changes are needed, in core or mathlib, to cope with this change.</p>
</blockquote>
<p>That's doubly interesting. Not only this definition discussion turns out to be irrelevant, but we also learn that one can open a PR to try to help instead of simply insulting people writing "brain damaged" definitions.</p>



<a name="209982385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209982385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209982385">(Sep 14 2020 at 09:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> yes but I am teaching beginners so I don't want them to use automatisation yet.</p>



<a name="209982530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209982530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209982530">(Sep 14 2020 at 09:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> what do you mean? We can change the definition from brain damaged to non brain damaged and nothing will fail. So why don't we do that?<br>
And who feels insulted? Leonardo is the author of this file. I don't think he needs anybody to speak for him.</p>



<a name="209983160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209983160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209983160">(Sep 14 2020 at 09:45)</a>:</h4>
<p>I think Patrick is suggesting that it's not conducive to a collegial environment when people describe others contributions as "brain damaged". I agree, for what it's worth, but also don't want to make a big deal of it. I've spent non-trivial time trying to work out how to calm down unnecessarily aggressive arguments on zulip and github, and I'd prefer if every tries to avoid using loaded terms (both "brain damaged" and "insulting people") when possible.</p>



<a name="209983547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209983547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209983547">(Sep 14 2020 at 09:49)</a>:</h4>
<p>mathlib has, for the most part, a really excellent community that is super welcoming, and puts in enormous time to help newcomers get up to speed. I think it's one of the nicest things about Lean! But it also takes some effort from everyone to keep it in place. Patrick has put in lots of great work on infrastructure, but as it's one of the first problems people run into, he cops unnecessary flak about it, and reasonably gets ticked off when this happens. I don't think Patrick has any attachment to the <code>band</code> and <code>bor</code> definitions --- in fact I think everyone wants to change them now that we've noticed.  But a polite suggestion that it should be changed --- and better yet just a PR! --- works better than using terms that could reasonably be construed as insulting (and, as I think everyone is aware, the "target" of an insult is often in the eye of the beholder).</p>



<a name="209986201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986201">(Sep 14 2020 at 10:21)</a>:</h4>
<p>I didn't want to insult anybody but this is how I talk. Apologies if anybody felt insulted but I meant the definitions not the person who wrote it.</p>



<a name="209986344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986344">(Sep 14 2020 at 10:23)</a>:</h4>
<p>Good to hear. As you can see there's a fix in place already. I did find it interesting that nothing in core or mathlib relied on the particular form of the definition. I think this is actually something intentional about the Lean style --- rather unlike Agda --- where we try to set up enough API (including simp lemmas) so that we're less often relying on definitional reduction.</p>



<a name="209986357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986357">(Sep 14 2020 at 10:23)</a>:</h4>
<p>Or rather, when we do rely a lot on definitional reduction we think of it as a code smell. :-)</p>



<a name="209986424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986424">(Sep 14 2020 at 10:24)</a>:</h4>
<p>I've known about this for years but simply didn't care. I think that in practice these basic things you're talking about like definition of addition on naturals etc simply make no difference to "end users" like me.</p>



<a name="209986435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986435">(Sep 14 2020 at 10:24)</a>:</h4>
<p>(That said, could I suggest trying to avoid using terms like "brain damaged"  --- in my reading it refers directly to people not things, and it's not constructive.)</p>



<a name="209986470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986470">(Sep 14 2020 at 10:25)</a>:</h4>
<p>I agree but as I said when teaching I want to avoid using automatisation at least in the beginning. Maybe I should reconsider this in the future.</p>



<a name="209986522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986522">(Sep 14 2020 at 10:25)</a>:</h4>
<p>That's interesting. Mathematicians are far better at understanding <code>ring</code> than <code>rw</code>, and are far better at understanding <code>rw</code> than the dreaded <code>lam</code></p>



<a name="209986523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986523">(Sep 14 2020 at 10:25)</a>:</h4>
<p>It depends... if you care a lot about foundations, I can understand that you want to "tie the students hands"</p>



<a name="209986568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986568">(Sep 14 2020 at 10:26)</a>:</h4>
<p>Yes -- it's a strange state of affairs that in Lean (or any type theory based prover?) you really need to learn well how definitional reduction works at the beginning, and then later you aspire more and more to avoid having to know about it. :-)</p>



<a name="209986574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986574">(Sep 14 2020 at 10:26)</a>:</h4>
<p>Yes I will avoid potentially insulting terms to avoid lengthy and unproductive discussions like this. Can I still say "destructive logic" for non-constructive, i.e. classical logic or is this insulting too? Maybe Hilbert is unhappy?</p>



<a name="209986607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986607">(Sep 14 2020 at 10:26)</a>:</h4>
<p>I think "destructive logic" is fine. :-) We're mostly a bunch of die-hard classicists here, as I'm sure you've seen.</p>



<a name="209986625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986625">(Sep 14 2020 at 10:27)</a>:</h4>
<p>Given that 99% of the mathematicians don't know what "constructive logic" is... I think it's hard to insult them by using "destructive logic".</p>



<a name="209986640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986640">(Sep 14 2020 at 10:27)</a>:</h4>
<p>That's my way of teaching them!</p>



<a name="209986641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986641">(Sep 14 2020 at 10:27)</a>:</h4>
<p>(I know that it working non-constructively is wrong, and when we get to meet alien mathematicians they are not going to be impressed, but mostly I talk to human mathematicians so have got used to it.)</p>



<a name="209986647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986647">(Sep 14 2020 at 10:27)</a>:</h4>
<p>Thorsten did you ever play the natural number game? One key thing about that game is that I never use the concept of definitional equality. I make stuff defeq but tell the players to type <code>rw add_zero</code> and <code>rw zero_add</code>; I just tell them that one of these things is an axiom which needs to be applied, and the other is a theorem which needs to be proved.</p>



<a name="209986676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986676">(Sep 14 2020 at 10:27)</a>:</h4>
<p>To use either one they have to rewrite. I literally shield from the players the concept that one of these things is definitional.</p>



<a name="209986725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986725">(Sep 14 2020 at 10:28)</a>:</h4>
<p>I had a look at it and I thought this was super cool. One of the reasons why I am using lean now. Thanks a lot, Kevin.</p>



<a name="209986748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986748">(Sep 14 2020 at 10:28)</a>:</h4>
<p>Lean's <code>rw</code> tactic applied <code>refl</code> at the end of it and this really confused test users at Imperial</p>



<a name="209986763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986763">(Sep 14 2020 at 10:28)</a>:</h4>
<p>Exactly!</p>



<a name="209986789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986789">(Sep 14 2020 at 10:29)</a>:</h4>
<p>so I had to modify Lean's rewrite tactic so that it would not try the powerful (in my opinion) <code>refl</code> tactic after each step</p>



<a name="209986904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209986904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209986904">(Sep 14 2020 at 10:30)</a>:</h4>
<p>And so because I think of stuff like this, via the interface, I just use much higher-level stuff. We essentailly never used this <code>bool</code> type in the perfectoid project, or nat.add. We're just always working with either rings, or topological spaces, or topological rings, or ordered groups-with-zero.</p>



<a name="209987063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209987063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209987063">(Sep 14 2020 at 10:32)</a>:</h4>
<p>and we just train our simp lemmas to apply <code>zero_add</code> and <code>add_zero</code> whenever they show up, we don't care which one is definitional, I'm not even sure if that makes sense if R is an arbitrary Noetherian commutative ring. Noetherian commutative rings are commutative rings with a fundamental finiteness predicate applied and there is a very deep theory where nothing is defeq.</p>



<a name="209987122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209987122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209987122">(Sep 14 2020 at 10:33)</a>:</h4>
<p>One of my regrets about the natural number game is that I didn't train the user to train the simplifier (because I didn't understand it myself when I wrote that game).</p>



<a name="209987227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209987227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209987227">(Sep 14 2020 at 10:34)</a>:</h4>
<p>Yes, I completely agree. Overemphasis of definitional equality s one of the major downsides of current type theory implementations.</p>



<a name="209987278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209987278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209987278">(Sep 14 2020 at 10:35)</a>:</h4>
<p>but this is exactly what you are complaining about with <code>band</code> and <code>nat.add</code> right?</p>



<a name="209987563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209987563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209987563">(Sep 14 2020 at 10:38)</a>:</h4>
<p>I discovered this bool stupidity very early on when I was learning the basics of inductive types. I try to shield my users from inductive definitions other than structures. The perfectoid project is just full of structures, and theorems about structures, and I'm sure that many of the other people working here on mathematics are doing the same thing. People aren't trying to compute -- we are theory builders, and there are some constructions we're really proud of :-) This seems to be the culture which has developed here, which is I think what makes it different. It's just a joke that there is still no system which can even understand all of the <em>statements</em> of the questions on Paper 1 of my finals at Cambridge. But we're nearly there.</p>



<a name="209988598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209988598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209988598">(Sep 14 2020 at 10:49)</a>:</h4>
<p>Yes, because of the way I am teaching formal reasoning which may be different to the way you do it. I am teaching the way I know but I recognise that over reliance on definitional equality is bad for reusability of code. But I personally haven't yet mastered a good way avoiding it. I am happy to learn.</p>



<a name="209989543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/209989543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#209989543">(Sep 14 2020 at 11:01)</a>:</h4>
<p>I'm really looking forward to the new feature in Lean 4 I've heard about, which lets you completely "seal" the actual definition behind some declaration. (Hopefully someone more knowledgeable can describe this in detail if someone is interested!)</p>



<a name="210011014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210011014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210011014">(Sep 14 2020 at 14:17)</a>:</h4>
<p>You can achieve this quite easily in lean 3, using a constant + axioms. The constant will have no definitional equalities. Lean 4 is just making this practice a bit more safe against accidental inconsistency since you don't have to introduce new axioms all the time</p>



<a name="210011758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210011758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210011758">(Sep 14 2020 at 14:21)</a>:</h4>
<p>(By the way I don't think "destructive logic" is very helpful either, as it throws shade on the practice without reasons to back it up. It sounds like something only appropriate for a space where you are already among like minded individuals. If you want to defend constructive logic or critique nonconstructive logic, use actual arguments instead of emotive language.)</p>



<a name="210037612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210037612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210037612">(Sep 14 2020 at 17:32)</a>:</h4>
<p>I do have arguments but this was a <strong>joke</strong>.</p>



<a name="210037938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210037938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210037938">(Sep 14 2020 at 17:35)</a>:</h4>
<p>I thought about it. If I prove propositions about programs then the actual definition of the program matters. I don't always have an abstract theory I can use to reason about my program without looking at its definition. Maybe I can establish such a thing but then to do this I have to use its definition.</p>



<a name="210039562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210039562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210039562">(Sep 14 2020 at 17:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271218">Thorsten Altenkirch</span> <a href="#narrow/stream/113489-new-members/topic/band.2C.20bor/near/210037612">said</a>:</p>
<blockquote>
<p>I do have arguments but this was a <strong>joke</strong>.</p>
</blockquote>
<p>Exercise for your students; formalize "formalize Poe's law in Lean". (\s)</p>



<a name="210045900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210045900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210045900">(Sep 14 2020 at 18:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271218">Thorsten Altenkirch</span> <a href="#narrow/stream/113489-new-members/topic/band.2C.20bor/near/210037938">said</a>:</p>
<blockquote>
<p>I thought about it. If I prove propositions about programs then the actual definition of the program matters. I don't always have an abstract theory I can use to reason about my program without looking at its definition. Maybe I can establish such a thing but then to do this I have to use its definition.</p>
</blockquote>
<p>In lean we make a fairly sharp distinction between proofs and programs, corresponding to the difference between <code>Prop</code> and <code>Type</code>. When you write computable or noncomputable definitions, they get marked with <code>noncomputable</code> as required, and programs that are computable have code generated for them. For me this is a much more concrete and practically useful notion of computability than intuitionistic mathematics. Of course when you define a program the actual definition of the program matters, and lean reflects this. But proofs are not programs and so lean is happy to identify proofs of the same proposition.</p>



<a name="210046373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210046373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210046373">(Sep 14 2020 at 18:42)</a>:</h4>
<p>Note that even for programs defeq is not the relevant quantity when it comes to evaluation. Kernel reduction can actually get stuck on a definition that is not <code>noncomputable</code>, while the VM will happily evaluate it to completion</p>



<a name="210046905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210046905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210046905">(Sep 14 2020 at 18:47)</a>:</h4>
<p>In short, for mathematics and proofs (including proofs about programs), we care about (propositional) equality; for programs we care about non-<code>noncomputable</code> and (efficient) code generation. Defeq is a vestigial remnant of our DTT forbears, convenient occasionally as the engine behind the powerful <code>refl</code> tactic but not an essential tool</p>



<a name="210613613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210613613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210613613">(Sep 19 2020 at 12:51)</a>:</h4>
<p>If you're going to make up a joke-but-accurate name for classical logic, I think calling it <em>omniscient</em> logic is a better one. Coinductive logic is better deserving of the name destructive logic... <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="210756981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210756981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210756981">(Sep 21 2020 at 15:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  I don't see how this is related to propositions as types. If I want to prove something about my program I need to know how it is defined and the proof may not work for another program that extensionally behaves the same way.</p>



<a name="210757613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210757613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210757613">(Sep 21 2020 at 15:27)</a>:</h4>
<p>You need to know how programs are defined, not how proofs are constructed</p>



<a name="210757679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210757679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210757679">(Sep 21 2020 at 15:27)</a>:</h4>
<p>Also, I would argue that a program that extensionally behaves the same way <em>does</em> satisfy all the same properties</p>



<a name="210757894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210757894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210757894">(Sep 21 2020 at 15:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  It satisfies all the same properties but not with the same proofs. A proof is an intensional thing.</p>



<a name="210758075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210758075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210758075">(Sep 21 2020 at 15:30)</a>:</h4>
<p>Ideally, everything about the definition would be hidden behind an API barrier, and you could change the definition to something extensionally equivalent as long as you can re-establish the API theorems</p>



<a name="210758172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210758172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210758172">(Sep 21 2020 at 15:31)</a>:</h4>
<p>the API theorems themselves depend on the particular form of the definition but everything above that is insensitive to intensional details</p>



<a name="210758360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210758360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210758360">(Sep 21 2020 at 15:32)</a>:</h4>
<p>This is the default behavior in theorem provers based on FOL or HOL. In DTT you have to do some work to get isolation</p>



<a name="210760283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210760283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210760283">(Sep 21 2020 at 15:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/band.2C.20bor/near/210758075">said</a>:</p>
<blockquote>
<p>Ideally, everything about the definition would be hidden behind an API barrier, and you could change the definition to something extensionally equivalent as long as you can re-establish the API theorems</p>
</blockquote>
<p>When you prove properties of programs there usually is no API available. Also in any case you first of all need to establish your API.</p>
<p>But I agree that wherever possible it is a good strategy to establish an API and then prove everything using this.</p>



<a name="210763875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210763875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210763875">(Sep 21 2020 at 16:12)</a>:</h4>
<blockquote>
<p>When you prove properties of programs there usually is no API available.</p>
</blockquote>
<p>For all the core types available in lean there is an extensive API available</p>



<a name="210763900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210763900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210763900">(Sep 21 2020 at 16:12)</a>:</h4>
<p>like band and bor and lists and such</p>



<a name="210763945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210763945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210763945">(Sep 21 2020 at 16:13)</a>:</h4>
<p>Plus lean will prove a basic API for every new definition, creating "equation lemmas"</p>



<a name="210763996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210763996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210763996">(Sep 21 2020 at 16:13)</a>:</h4>
<p>In fact these equation lemmas may not always be definitional, particularly in the case of definitions by well founded recursion</p>



<a name="210764029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210764029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210764029">(Sep 21 2020 at 16:13)</a>:</h4>
<p>so really lean isn't as far from the FOL/HOL style of definition as you might think</p>



<a name="210764508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210764508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210764508">(Sep 21 2020 at 16:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/band.2C.20bor/near/210763875">said</a>:</p>
<blockquote>
<blockquote>
<p>When you prove properties of programs there usually is no API available.</p>
</blockquote>
<p>For all the core types available in lean there is an extensive API available</p>
</blockquote>
<p>Yes, but if I implement program X, let's say X is  space invaders and I want to prove some property about space invaders (eg it is possible to win) then I won't be able to use an API for space invaders. I do agree that a good strategy to prove stuff about space invaders is to structure the program around some API and abstract with each step as much as possible.</p>



<a name="210765282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/band%2C%20bor/near/210765282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/band.2C.20bor.html#210765282">(Sep 21 2020 at 16:23)</a>:</h4>
<p>If you are really serious about space invaders, then of course you build the entire API around it... <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span> <span aria-label="rocket" class="emoji emoji-1f680" role="img" title="rocket">:rocket:</span> <span aria-label="boom" class="emoji emoji-1f4a5" role="img" title="boom">:boom:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
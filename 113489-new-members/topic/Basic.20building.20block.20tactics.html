---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Basic.20building.20block.20tactics.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html">Basic building block tactics</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="189082400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189082400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189082400">(Feb 26 2020 at 03:02)</a>:</h4>
<p>I'm interested in learning about the basic building blocks of proofs in Lean. To this end I've read section 2 of Mario's masters thesis, but I don't have a CS background and didn't understand everything. From what I did understand the tactics, <code>intro</code>, <code>apply</code>, <code>induction</code>, and <code>rw</code>, relate to typing judgements, the basic building blocks of proofs.</p>
<p>Is there a list of tactics for which it's theoretically possible to prove any statement in Lean using only tactics on the list? Or is there a tactic for each typing judgement? And if so, what's the list? Or where can I learn more?</p>
<p>Thanks.</p>



<a name="189083657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189083657">(Feb 26 2020 at 03:38)</a>:</h4>
<p><code>exact</code> does everything by itself</p>



<a name="189083662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189083662">(Feb 26 2020 at 03:38)</a>:</h4>
<p>or <code>refine</code></p>



<a name="189083675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189083675">(Feb 26 2020 at 03:39)</a>:</h4>
<p>You can probably get away with <code>intro</code> and <code>apply</code>, since that covers application and lambda</p>



<a name="189083718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189083718">(Feb 26 2020 at 03:40)</a>:</h4>
<p><code>change</code> is important for triggering definitional conversion</p>



<a name="189083723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189083723">(Feb 26 2020 at 03:40)</a>:</h4>
<p>but <code>induction</code> and <code>rw</code> are just fancy ways to apply functions</p>



<a name="189091945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189091945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189091945">(Feb 26 2020 at 07:41)</a>:</h4>
<p>I guess it's theoretically possible to prove any statement in lean without using any tactics at all, because you can just use term mode. I think Agda might look like this?</p>



<a name="189178089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189178089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189178089">(Feb 27 2020 at 01:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189083718" title="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189083718">said</a>:</p>
<blockquote>
<p>You can probably get away with <code>intro</code> and <code>apply</code>, since that covers application and lambda</p>
<p><code>change</code> is important for triggering definitional conversion</p>
</blockquote>
<p>I see, thanks.</p>
<p>If <code>solve_by_elim</code> was extended so that it could also do <code>intro</code> and <code>change</code>, would it then be a proof search? I.e. if <code>max_reps := n</code>would it always find a proof of length less than or equal to <code>n</code> if one exists?</p>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189091945" title="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189091945">said</a>:</p>
<blockquote>
<p>I guess it's theoretically possible to prove any statement in lean without using any tactics at all, because you can just use term mode. I think Agda might look like this?</p>
</blockquote>
<p>I guess this is why <code>exact</code> does everything. But that's no fun. :)</p>



<a name="189178281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189178281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189178281">(Feb 27 2020 at 01:08)</a>:</h4>
<p>No. Remember <code>solve_by_elim</code> only applies local hypotheses.</p>



<a name="189178367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189178367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189178367">(Feb 27 2020 at 01:10)</a>:</h4>
<p>Also, <code>change</code> requires an explicit user provided argument, so I don't know what you're hoping it would do for you automatically.</p>



<a name="189180117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189180117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189180117">(Feb 27 2020 at 01:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189178281" title="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189178281">said</a>:</p>
<blockquote>
<p>No. Remember <code>solve_by_elim</code> only applies local hypotheses.</p>
</blockquote>
<p>Right, but I thought if something can be proved then it can be proved only using local hypotheses, you just take the proof of lemma or theorem you'd normally use and insert in into the correct spot in your proof. Is that wrong? </p>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189178367" title="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189178367">said</a>:</p>
<blockquote>
<p>Also, <code>change</code> requires an explicit user provided argument, so I don't know what you're hoping it would do for you automatically.</p>
</blockquote>
<p>I have no experience with <code>change</code>, and it's not in <code>tactics.md</code>. I'm going to spend a bit of time seeing what I can find out.</p>



<a name="189191827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189191827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189191827">(Feb 27 2020 at 07:13)</a>:</h4>
<p>Change = show</p>



<a name="189196387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189196387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jasmin Blanchette <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189196387">(Feb 27 2020 at 08:59)</a>:</h4>
<p>If one is interested in minimalism, one can easily avoid the "change" (or "show") tactic. Say the goal is <code>⊢ half_empty</code> and I wish it were <code>⊢ half_full</code>. I can write</p>
<div class="codehilite"><pre><span></span>    <span class="n">apply</span> <span class="o">(</span><span class="k">begin</span> <span class="bp">...</span> <span class="kn">end</span> <span class="o">:</span> <span class="n">half_full</span><span class="o">)</span>
</pre></div>


<p>If you allow yourself <code>have</code>, you can write</p>
<div class="codehilite"><pre><span></span>    <span class="k">have</span> <span class="n">hhf</span> <span class="o">:</span> <span class="n">half_full</span> <span class="o">:=</span> <span class="bp">...</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hhf</span>
</pre></div>



<a name="189271847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189271847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189271847">(Feb 28 2020 at 00:16)</a>:</h4>
<p>I'm interested in learning about the fundamental building blocks of proofs in Lean. In order to do this do I need to learn some CS stuff to the point I completely understand section 2 of Mario's thesis, or is it possible to understand what the basic building blocks are from existing tactics? I.e. are there tactics that emulate the various typing judgements, such as <code>intro</code> for example? Or am I way off base about how Lean works?</p>



<a name="189273625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189273625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189273625">(Feb 28 2020 at 00:46)</a>:</h4>
<p>I think a good place to start is by understanding term proofs, and how tactics are just mechanisms for building particular terms (which you can see with <code>#print</code>)</p>



<a name="189273729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189273729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189273729">(Feb 28 2020 at 00:48)</a>:</h4>
<p>In a tactic proof, each goal corresponds to an <code>_</code> (a hole to be filled) in the corresponding term proof, and each tactic replaces that hole with a term, usually containing more holes inside it. For example, <code>intro x</code> will replace the hole with <code>\lam x, _</code>.</p>



<a name="189273778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189273778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189273778">(Feb 28 2020 at 00:49)</a>:</h4>
<p>and <code>apply f</code> replaces the hole with <code>f _ _ _</code> (depending on how many arguments <code>f</code> has)</p>



<a name="189273873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189273873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189273873">(Feb 28 2020 at 00:50)</a>:</h4>
<p>It also might help to look at the definition of the <code>expr</code> type in lean, which shows all the kind of things that can appear in a term</p>



<a name="189274813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189274813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189274813">(Feb 28 2020 at 01:07)</a>:</h4>
<p>Ok, I think I'm pretty comfortable with the idea of metavariables, but I'm might go through theorem proving in Lean again to pick up some of the things I missed the first time as well as understand what specifically different tactics are doing to the terms.</p>
<p>I'm not so comfortable with <code>expr</code>s, however, but I'll put some time into learning.</p>
<p>I'd still like to understand how a proof search tactic might work. Maybe I'll ask again after I've learned these things.</p>
<p>Thanks.</p>



<a name="189275113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275113">(Feb 28 2020 at 01:13)</a>:</h4>
<p>A quick overview:</p>
<ul>
<li><code>intro x</code> replaces the goal with <code>\lam x, _</code></li>
<li><code>apply f</code> replaces the goal with <code>f _ _ _</code></li>
<li><code>refine e1 (e2 _) (e3 _)</code> replaces the goal with <code>e1 (e2 _) (e3 _)</code> (which should make it clear why I say sometimes that <code>refine</code> is the "universal" tactic, capable of playing the role of all others)</li>
<li><code>exact e</code> replaces the goal with <code>e</code></li>
<li><code>change foo</code> replaces the goal with <code>(_ : foo)</code></li>
<li><code>rw foo</code> replaces the goal with <code>eq.rec_on foo _</code></li>
<li><code>induction foo</code> replaces the goal with <code>T.rec_on foo _ _</code> where <code>T</code> is the type of <code>foo</code></li>
<li><code>cases foo</code>  replaces the goal with <code>T.cases_on foo _ _</code> where <code>T</code> is the type of <code>foo</code></li>
<li><code>split</code> replaces the goal with <code>and.intro _ _</code></li>
<li><code>have x := t</code> replaces the goal with <code>(\lam x, _) t</code></li>
<li><code>let x := t</code> replaces the goal with <code>let x := t in _</code></li>
<li><code>revert x</code> replaces the goal with <code>_ x</code></li>
</ul>



<a name="189275577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275577">(Feb 28 2020 at 01:22)</a>:</h4>
<p><code>simp</code>, <code>norm_num</code>, <code>ring</code>, <code>omega</code>, <code>library_search</code>, <code>tidy</code>, <code>rcases</code>, <code>rintro</code> do more complicated or iterative things to the goal, but fundamentally they all have the same form as the above tactics: they look at the current type of the target hole and use that to determine some term, possibly with more holes in it, to fill the target</p>



<a name="189275675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275675">(Feb 28 2020 at 01:24)</a>:</h4>
<p>Awesome!</p>



<a name="189275768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275768">(Feb 28 2020 at 01:26)</a>:</h4>
<p>Can <code>induction</code> be used instead of <code>rw</code>? For example, given <code>h : a = b</code>, can we always use <code>induction h</code> instead of <code>rw h</code>? Or are there some cases where funny things happen with <code>expr</code>s?</p>



<a name="189275771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275771">(Feb 28 2020 at 01:26)</a>:</h4>
<p>Yep!</p>



<a name="189275798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275798">(Feb 28 2020 at 01:27)</a>:</h4>
<p>However it usually won't be able to calculate the "motive", a hidden extra argument to <code>eq.rec_on</code>, correctly if you use <code>induction h</code></p>



<a name="189275811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275811">(Feb 28 2020 at 01:27)</a>:</h4>
<p>However if one side of the equality is a variable, <code>induction h</code>, <code>cases h</code>, and <code>subst h</code> all act more or less the same way</p>



<a name="189275859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275859">(Feb 28 2020 at 01:28)</a>:</h4>
<p>Also, are there situations where <code>cases</code> works, but induction doesn't? This might be covered in theorem proving in Lean.</p>



<a name="189275903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275903">(Feb 28 2020 at 01:29)</a>:</h4>
<p>Yes. The reason is that unlike <code>induction</code>, <code>cases</code> is able to make use of the equality between the input and the values in the cases to eliminate some of the constructors. (If you were to do this in <code>induction</code>, the inductive hypothesis would end up being useless in most cases)</p>



<a name="189275940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275940">(Feb 28 2020 at 01:30)</a>:</h4>
<p>Internally, <code>cases</code> actually first reverts the input variable and adds an equality</p>



<a name="189275966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275966">(Feb 28 2020 at 01:30)</a>:</h4>
<p>Oh, so <code>eq.rec_on</code> is different somehow to other <code>rec_on</code>'s for inductive types?</p>



<a name="189275983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189275983">(Feb 28 2020 at 01:30)</a>:</h4>
<p>No, it is just that <code>rw</code> uses an algorithm which is different from the generic one that is more useful for equalities</p>



<a name="189276066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189276066">(Feb 28 2020 at 01:32)</a>:</h4>
<p>Right, because <code>induction</code> rewrites everything it can everywhere.</p>



<a name="189276075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189276075">(Feb 28 2020 at 01:32)</a>:</h4>
<p>You can always specify the motive yourself, but it's a pain. <code>eq.rec_on</code> says that from <code>a = b</code> and <code>C a</code> derive <code>C b</code>, so if you are faced with a goal that has <code>b</code>'s in it you want to reverse engineer what <code>C</code> should be so that <code>C b</code> evaluates to the goal and <code>C a</code> evaluates to something more useful</p>



<a name="189276240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189276240">(Feb 28 2020 at 01:36)</a>:</h4>
<p>Ok, so <code>rewrite</code> is a convenience thing, built for humans.</p>



<a name="189276248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189276248">(Feb 28 2020 at 01:36)</a>:</h4>
<p>yep, most tactics are like that</p>



<a name="189276267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189276267">(Feb 28 2020 at 01:36)</a>:</h4>
<p>Yeah, what about <code>Ext</code>? can that be broken down into simpler tactics?</p>



<a name="189276268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189276268">(Feb 28 2020 at 01:36)</a>:</h4>
<p>you <em>could</em> write the term if you wanted to, but you don't want to</p>



<a name="189276282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189276282">(Feb 28 2020 at 01:37)</a>:</h4>
<p><code>ext</code> is just <code>try {apply f}</code> for every <code>f</code> that has been marked <code>@[ext]</code></p>



<a name="189276290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189276290">(Feb 28 2020 at 01:37)</a>:</h4>
<p>in practice, these lemmas tend to be about extensionality</p>



<a name="189276297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189276297">(Feb 28 2020 at 01:37)</a>:</h4>
<p>Yeah, makes sense.</p>



<a name="189276432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189276432">(Feb 28 2020 at 01:41)</a>:</h4>
<p>I have a bit to think about now. Thanks.</p>



<a name="189277748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189277748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189277748">(Feb 28 2020 at 02:06)</a>:</h4>
<p>Is <code>unfold</code> just another version of <code>change</code>? I looked at the code and <code>unfold</code> uses the simplifier, which is complex and confusing.</p>



<a name="189277755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189277755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189277755">(Feb 28 2020 at 02:07)</a>:</h4>
<p>Does <code>simp</code> use <code>change</code>?</p>



<a name="189278478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189278478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189278478">(Feb 28 2020 at 02:26)</a>:</h4>
<p><code>dsimp</code> and <code>dunfold</code> act like <code>change</code>, which is to say, they don't add anything to the term but rather just assert a new type for the term and let the kernel figure it out. (Actually that's a lie. In order to keep up performance in the kernel, the goal is actually replaced with <code>@id foo _</code> instead so that the kernel also gets the same definitional reduction hint as the elaborator. If you have <code>@id foo (@id bar x)</code>, lean's kernel is forced to prove that <code>foo</code> and <code>bar</code> are definitionally equal so that the term is well typed.)</p>



<a name="189278546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189278546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189278546">(Feb 28 2020 at 02:28)</a>:</h4>
<p><code>simp</code> and <code>unfold</code> actually insert equality theorems. It's kind of like <code>rw</code> but instead of using a single <code>eq.rec</code> term with a complicated motive, it is a <code>cast</code> applied to a bunch of congruence lemmas with types like <code>x = y -&gt; z = w -&gt; x + z = y + w</code>.</p>



<a name="189278571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189278571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189278571">(Feb 28 2020 at 02:29)</a>:</h4>
<p>This approach allows you to do extra things in the course of those lemmas, like for example ignoring equalities of arguments that are known to be in subsingleton types, as well as generally using equality proofs that are not definitional</p>



<a name="189365151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189365151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189365151">(Feb 29 2020 at 00:22)</a>:</h4>
<p>I see, Thanks. I had a look at <code>dunfold</code> but it's just a meta constant, so I guess it's more fundamental than <code>unfold</code>. <code>tactic.change</code> is a meta constant as well. </p>
<p>I've been rereading chapter 2 of theorem proving in Lean, and decided to have a go at reducing the proof term for <code>succ_add</code>.</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="n">reduce</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">brec_on</span> <span class="n">m</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="n">m</span><span class="o">),</span>
          <span class="n">nat</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">m</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="mi">0</span><span class="o">),</span>
               <span class="n">id_rhs</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span> <span class="n">rfl</span><span class="o">)</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)),</span>
               <span class="n">id_rhs</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)))</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">succ</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span><span class="bp">.</span><span class="n">fst</span><span class="bp">.</span><span class="n">fst</span> <span class="n">n</span><span class="o">)))</span>
            <span class="bp">_</span><span class="n">F</span><span class="o">)</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">_</span><span class="n">F</span><span class="o">)</span> <span class="n">n</span>
</pre></div>


<p>It gives me <code>λ (n m : ℕ), ⁇</code> and red sqiggle under <code>nat.brec_on</code> with the error message "invalid 'nat.brec_on' application, elaborator has special support for this kind of application (it is handled as an "eliminator"), but the expected type must be known."</p>
<p>Does it want know the type of <code>succ_add</code>? And is there some way to reduce a proof term to the type it's proving?</p>



<a name="189367615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189367615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189367615">(Feb 29 2020 at 01:07)</a>:</h4>
<p>The term displayed by Lean might not contain enough information to reconstruct the original term, as implicit arguments (here the motive for <code>nat.brec_on</code>) may not be inferable, or at least not by the algorithm Lean uses. Here maybe it would help to add a type ascription <code>(... : succ n + m = succ (n + m))</code> or whatever the correct type is to the body of the lambda.</p>



<a name="189367685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189367685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189367685">(Feb 29 2020 at 01:08)</a>:</h4>
<p>But in this case, you might as well just write <code>#reduce nat.succ_add</code>.</p>



<a name="189367702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189367702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189367702">(Feb 29 2020 at 01:09)</a>:</h4>
<p>(I'm assuming you did something like <code>#print succ_add</code>, and then copy and pasted the result into <code>#reduce</code>.)</p>



<a name="189368260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189368260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189368260">(Feb 29 2020 at 01:22)</a>:</h4>
<p>I couldn't get the type ascription to work.</p>
<p>I had a go at turn implicit arguments off and reducing the larger proof term, but now I get a "type mismatch at application" under <code>@nat.rec</code>.</p>
<p>But the red squiggle under <code>@nat.brec_on</code> is gone.</p>



<a name="189368270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189368270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189368270">(Feb 29 2020 at 01:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189367702" title="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189367702">said</a>:</p>
<blockquote>
<p>(I'm assuming you did something like <code>#print succ_add</code>, and then copy and pasted the result into <code>#reduce</code>.)</p>
</blockquote>
<p>Yes, exactly. :)</p>



<a name="189371151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189371151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189371151">(Feb 29 2020 at 02:30)</a>:</h4>
<p>Using <code>pp.all</code> would increase the chances of this working, but it would be better not to do this at all and just use <code>#reduce succ_add</code> directly</p>



<a name="189381787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189381787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189381787">(Feb 29 2020 at 08:16)</a>:</h4>
<p>I never understand why these terms have <code>brec_on</code> and <code>below</code> in. When we prove this in the natural number game we just use an easy induction on m so I would just expect a much simpler term with <code>rec</code></p>



<a name="189381792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189381792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189381792">(Feb 29 2020 at 08:16)</a>:</h4>
<p>Is this the fault of the equation compiler or something?</p>



<a name="189382745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189382745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189382745">(Feb 29 2020 at 08:54)</a>:</h4>
<p>It is a rather unfortunate limitation of the current equation compiler that it cannot handle structural recursion, that is, creating definitions using <code>rec_on</code> directly. It always compiles everything using "bounded recursion", which is needed to handle more complex structural recursions like:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fib</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</pre></div>


<p>(Actually, the bounded recursion technique is not necessary here because you don't need to tuple up the entire history of the function, only the last two values. To take full advantage of the bounded recursion technique you would need to have references out some arbitrary amount, like <code>f n</code> depending on <code>f(n/2)</code>, but in fact this is exactly the case where the equation compiler can't use this method and falls back on well founded recursion.)</p>
<p>While the use of structural recursion in place of bounded recursion is a "mere optimization", allowing functions like</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">add</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>
</pre></div>


<p>to be compiled to the obvious <code>nat.rec_on</code> term instead of the current monstrosity, in some cases it is actually the only available method because bounded recursion method is blocked, and in those cases you will get an error if you try to use the equation compiler even though it should be able to compile in principle.</p>



<a name="189382869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189382869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189382869">(Feb 29 2020 at 08:59)</a>:</h4>
<p>Here's an example of a structural recursive definition that is rejected because the equation compiler can't handle it. (The error message you get is because the failure of bounded recursion falls over to well founded recursion, which fails at some obscure step.)</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">foo</span> <span class="n">n</span>

<span class="n">def</span> <span class="n">no_foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">foo</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">foo</span><span class="bp">.</span><span class="n">mk</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span> <span class="n">no_foo</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">h</span>
<span class="c1">-- failed to prove recursive application is decreasing</span>
<span class="c1">-- |- 0 &lt; 0</span>
</pre></div>



<a name="189382926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189382926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189382926">(Feb 29 2020 at 09:00)</a>:</h4>
<p>Here's the obvious structural recursion proof:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">no_foo&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">foo</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">foo</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">h</span> <span class="n">ih</span><span class="o">,</span> <span class="n">ih</span><span class="o">)</span>
</pre></div>



<a name="189392143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189392143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189392143">(Feb 29 2020 at 14:24)</a>:</h4>
<p>Would it be feasible to add an option to the equation compiler to disable this <code>brec</code> stuff? While it managed to cause fewer problems than it seems like it ought to, it's also virtually never the case that I actually want it</p>



<a name="189394282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189394282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189394282">(Feb 29 2020 at 15:33)</a>:</h4>
<p>The problem is that the <code>rec</code> stuff is <em>not implemented</em></p>



<a name="189394285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189394285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189394285">(Feb 29 2020 at 15:33)</a>:</h4>
<p>so it's <code>brec</code> or nothing</p>



<a name="189394294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189394294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189394294">(Feb 29 2020 at 15:33)</a>:</h4>
<p>(well, well founded recursion, but that's much worse of an option)</p>



<a name="189394341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189394341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189394341">(Feb 29 2020 at 15:34)</a>:</h4>
<p>It's ironic because it's the most basic primitive so you would expect it to be supported, but no, the fancy <code>brec</code> is there but not the humble <code>rec</code></p>



<a name="189397016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189397016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189397016">(Feb 29 2020 at 16:59)</a>:</h4>
<p>Oh huh I never realized that. So even when I use complicated inductive types with extra indices, constructors of infinite arity etc it always translates into <code>brec</code>?</p>



<a name="189397022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189397022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189397022">(Feb 29 2020 at 16:59)</a>:</h4>
<p>Yep. The <code>brec</code> method works as long as the inductive type is not a <code>Prop</code></p>



<a name="189458448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189458448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189458448">(Mar 02 2020 at 02:23)</a>:</h4>
<p>Is there some function in Lean that eats a proof term and gives the proposition proved by the input?</p>
<p>For example, is there a function <code>F</code>, say, such that <code>F (λ hp : p, λ hq : q, hp)</code> gives <code>p → q → p</code>?</p>
<p>And if not, is such a function possible?</p>



<a name="189458544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189458544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189458544">(Mar 02 2020 at 02:26)</a>:</h4>
<p><code>infer_type</code> is a tactic that will do that. But it doesn't make any sense for a lean function to do that, as it would be one of the inputs to the function. That is:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">get_type</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">A</span>
</pre></div>



<a name="189458600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189458600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189458600">(Mar 02 2020 at 02:28)</a>:</h4>
<p>Oh right, of course.</p>



<a name="189458866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189458866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Lucas Allen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20building.20block.20tactics.html#189458866">(Mar 02 2020 at 02:36)</a>:</h4>
<p>I got it working, I'm very happy. :)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/bicategory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html">bicategory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265897077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/265897077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#265897077">(Dec 23 2021 at 09:13)</a>:</h4>
<p>In these days I write a formalization of bicategories. I have finished writing a proof that the collection of pseudofunctors between bicategories have a bicategory structure, so I would like to PR it to mathlib. </p>
<p>When writing basic lemmas on bicategories, almost all  lines are copied from <code>category_theory/monoidal/category.lean</code>. I added 0-morphisms and replaced tensors with left and right whiskerings.</p>
<p>Currently, I use the following notations</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">infixr</span> <span class="bp">`◃`</span><span class="o">:</span> <span class="mi">70</span><span class="o">:</span> <span class="bp">=</span> <span class="n">bicategory.whisker_left</span>
<span class="kd">infixr</span> <span class="bp">`▹`</span><span class="o">:</span> <span class="mi">70</span><span class="o">:</span> <span class="bp">=</span> <span class="n">bicategory.whisker_right</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">α_</span><span class="bp">`</span><span class="o">:</span> <span class="bp">=</span> <span class="n">bicategory.associator</span>
<span class="kd">notation</span> <span class="bp">`λ</span><span class="n">_</span><span class="bp">`</span><span class="o">:</span> <span class="bp">=</span> <span class="n">bicategory.left_unitor</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">ρ_</span><span class="bp">`</span><span class="o">:</span> <span class="bp">=</span> <span class="n">bicategory.right_unitor</span>
</code></pre></div>
<p>that are used in the nlab (<a href="https://ncatlab.org/nlab/show/bicategory">https://ncatlab.org/nlab/show/bicategory</a>), but I'm not sure if this is good or not.</p>



<a name="265897225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/265897225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#265897225">(Dec 23 2021 at 09:15)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>, who also formalized bicategories</p>



<a name="266573274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266573274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266573274">(Jan 01 2022 at 20:14)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="438192">@Yuma Mizuno</span>, I just noticed your <a href="https://github.com/leanprover-community/mathlib/compare/bicategory-functor">bicategory-functor</a> branch by accident and want you know about my ongoing work at <a href="https://github.com/leanprover-community/mathlib/compare/lax_grothendieck?expand=1#diff-779e8ece193ac9cfb8b3ab087590457d8f57c59a774bd663d70eaa8e6a160ecd">lax_grothendieck</a>, where I defined <a href="https://github.com/leanprover-community/mathlib/compare/lax_grothendieck?expand=1#diff-fcba77084af1e1dafef32f2c3674793f357a0495bad381534804a4c025ce28de">lax functors</a> from a 1-category to the 2-category of categories <code>Cat</code>, and use it to make the Grothendieck construction of fibration of categories. I see a few issues that would prevent my branch from using your development, and I hope you have these in mind during your development:</p>
<p>(1) you only defined pseudofunctors and not general lax functors, i.e. you require map_id and map_comp to be <code>iso</code>s, but I think the more general lax functors are preferable, and shouldn't take much more effort; my earlier idea is to make the structure <code>pseudofunctor</code> by extending <code>lax_functor</code> by the <code>is_iso</code> conditions, but now I think we don't need to define <code>pseudofunctor</code> separately, and can just rely on the type class mechanism to infer the <code>is_iso</code> instances for <code>map_id</code> and <code>map_comp</code>. In fact in my construction of colimits in Grothendicek categories, only <code>map_comp</code> is required to be iso.</p>
<p>(2) The direction of your <code>map_id</code> and <code>map_comp</code> are in the opposite direction to mine. Your direction agrees with nLab, but mine is the natural direction to make the Grothendieck construction in the current form. (I am refactoring the existing Grothendieck construction that only applied to strict functors, and the old setup forces me to adopt this direction.)</p>
<p>Thanks for your work and your consideration!</p>



<a name="266579376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266579376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266579376">(Jan 01 2022 at 22:28)</a>:</h4>
<p>Thank you for the comments and letting me know about your ongoing work <span class="user-mention" data-user-id="224323">@Junyan Xu</span> !  I was a little hesitant to use <code>is_iso</code> because it doesn't have the inverse as data, but I'll try to use it.  My choice of the directions of <code>map_id</code> and <code>map_comp</code> was completely random, and I have no idea which direction should be chosen for pseudofunctors. (A similar choice appears in the definition of pseudonatural transformations.)</p>



<a name="266579505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266579505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266579505">(Jan 01 2022 at 22:31)</a>:</h4>
<p>I think the Yoneda lemma for bicategories needs <code>pseudofunctor</code> as a structure.</p>



<a name="266579687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266579687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266579687">(Jan 01 2022 at 22:35)</a>:</h4>
<p>I think it might be worthwhile to define pseudofunctors with isos instead of is_iso for exactly the reason that sometimes it may be useful to have the inverse as data. Besides, if we have lax pseudofunctors, we would presumably also want oplax pseudofunctors, so choosing one direction doesn't make much sense.</p>



<a name="266579940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266579940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266579940">(Jan 01 2022 at 22:40)</a>:</h4>
<p>I don't think we need oplax functors for the same reason we don't need contravariant functors; it makes no sense to duplicate the functor API. Oplax can be obtained from lax by taking opposites of the same categories (the fiber categories in the Grothendieck construction case).</p>



<a name="266579961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266579961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266579961">(Jan 01 2022 at 22:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="438192">Yuma Mizuno</span> <a href="#narrow/stream/113489-new-members/topic/bicategory/near/266579505">said</a>:</p>
<blockquote>
<p>I think the Yoneda lemma for bicategories needs <code>pseudofunctor</code> as a structure.</p>
</blockquote>
<p>If that's the case then indeed that would be a reason to introduce the structure. Literature suggests that we also need pseudofunctor to show the projection functor from the Grothendieck construction is a Grothendieck fibration of categories, which I plan to do after the colimit work.</p>



<a name="266580054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266580054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266580054">(Jan 01 2022 at 22:44)</a>:</h4>
<p>And by the way, I did come up with an example of lax natural transformation in my colimit work: <a href="https://github.com/leanprover-community/mathlib/compare/lax_grothendieck?expand=1#diff-779e8ece193ac9cfb8b3ab087590457d8f57c59a774bd663d70eaa8e6a160ecdR242">https://github.com/leanprover-community/mathlib/compare/lax_grothendieck?expand=1#diff-779e8ece193ac9cfb8b3ab087590457d8f57c59a774bd663d70eaa8e6a160ecdR242</a></p>



<a name="266580369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266580369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266580369">(Jan 01 2022 at 22:50)</a>:</h4>
<p>My direction of arrows is natural in the sense that if we have colimits in the base and fiber categories, then we get colimits in the total (Grothendieck) category, and it also agrees with the old Grothendieck construction. <span class="user-mention" data-user-id="438192">@Yuma Mizuno</span> 's direction would lead straightforwardly to PresheafedSpace and alike, but there we need colimits in the base category and limits in the fiber categories to get colimits in the total category (e.g. PresheafedSpace).</p>



<a name="266581545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266581545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266581545">(Jan 01 2022 at 23:18)</a>:</h4>
<p>Also, the <code>inv</code> in an <code>iso</code> here isn't actually data, as it's uniquely determined by the <code>hom</code>. In general I think it's OK to replace sugsingletons with Props, except maybe for the purpose of defeq. e.g. <code>is_limit</code> could be made a Prop (in fact <a href="https://leanprover-community.github.io/mathlib_docs/find/Top.presheaf.is_sheaf">docs#Top.presheaf.is_sheaf</a> is defined as <code>nonempty is_limit</code>), but <code>is_left_adjoint</code> is actually data. When I get to work on Grothendieck fibrations, I'd probably make <code>is_fibration</code> carry the data of a cleavage.</p>



<a name="266582196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266582196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266582196">(Jan 01 2022 at 23:29)</a>:</h4>
<p>There are times where it's very useful to be able to actually use the definition of an inverse. There is a reason why we have both <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.iso">docs#category_theory.iso</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso">docs#category_theory.is_iso</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.equivalence">docs#category_theory.equivalence</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_equivalence">docs#category_theory.is_equivalence</a> (edit: this is not a great example, since the inverse is part of this structure), and even why <code>has_inv</code> is required for a group structure.</p>



<a name="266582211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266582211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266582211">(Jan 01 2022 at 23:29)</a>:</h4>
<p>We have <code>equiv</code> and <code>function.bijective</code></p>



<a name="266582981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266582981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266582981">(Jan 01 2022 at 23:52)</a>:</h4>
<p>category.equivalence is not a good example also because the inverse is only unique up to isomorphism. Maybe you can come up with examples where the inverse of map_id or map_comp are useful? In all examples I have in mind they're either eq_to_hom or eq_to_hom transferred across adjunction in an abstract way, and only one direction is needed to define the category structure on the Grothendieck construction. If you want to use the definition of the inverse, you could show <code>exists.some</code> is equal to the definition and rewrite, barring defeq issues.</p>



<a name="266628422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266628422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266628422">(Jan 02 2022 at 19:09)</a>:</h4>
<p>I updated <a href="https://github.com/leanprover-community/mathlib/compare/bicategory-functor">bicategory-functor</a> and changed <code>iso</code> to <code>hom</code> in the definition.  I think it is not a bad idea to start with <code>hom</code> instead of <code>iso</code> as a first step, whether or not we really need pseudofunctors. I also reversed the directions of <code>hom</code> s in the definition, in the hope that it will fit well <span class="user-mention" data-user-id="224323">@Junyan Xu</span> 's ongoing work.</p>



<a name="266628842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266628842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266628842">(Jan 02 2022 at 19:20)</a>:</h4>
<p>By the way, 2-categories have two types of opposites. I don't have a good idea for implementation of these concepts. My naive idea is to duplicate the contents in <a href="https://leanprover-community.github.io/mathlib_docs/data/opposite.html">data/oppoiste</a>.</p>



<a name="266651584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266651584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266651584">(Jan 03 2022 at 04:52)</a>:</h4>
<p>Currently if a type C carries a category instance, then C^op carries the opposite category instance. I think in order to make four types to carry the four possible opposite bicategory instances, we would need to introduce another ^op operation that yields a new type given an old type, possibly called ^hop for "hom op" (I think that name isn't taken yet), which only reverses arrows in the hom categories. But we would face the problem that (C^op)^hop is not the same as (C^hop)^op, which is similar to the problem that +1 and -1 don't commute definitionally when people attempted to define chain complexes. But I think it's not too bad as we can show they are equivalent, like the equivalence between C and (C^op)^op already in mathlib.</p>



<a name="266651922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266651922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266651922">(Jan 03 2022 at 05:00)</a>:</h4>
<p>I think would occasionally be hard to rewrite because of dependent type issues.<br>
Would it be possible for a pseudofunctor to accept a field of a nat_iso and a proof that the two are equal?<br>
The same thing could probably also be tried on the monoidal category library.</p>



<a name="266652018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266652018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266652018">(Jan 03 2022 at 05:03)</a>:</h4>
<p>To Yuma Mizuno: I see you encountered issues with "obviously" from your commit messages. I think they can sometimes be useful, but sometimes they produce timeouts. When it timeouts, you can just supply the field with a faster explicit proof to avoid the timeout. Sometimes when you just finish the definition of earlier fields but has not supplied some "obvious" fields, the orange bar may take a long time to disappear, which indicates that Lean is trying to fill in the "obvious" fields, and once you add <code>, some_field_name := ,</code> indicating you're gonna supply <code>some_field_name</code> explicitly, the orange bar may disappear much faster. So in general I think removing "obviously" doesn't buy you anything and you should try to keep them, if there're no issues that I'm unaware of.</p>



<a name="266652946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266652946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266652946">(Jan 03 2022 at 05:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113489-new-members/topic/bicategory/near/266651922">said</a>:</p>
<blockquote>
<p>I think would occasionally be hard to rewrite because of dependent type issues.</p>
</blockquote>
<p>At least when the target of the pseudo/oplax functor is Cat, map_id and map_comp are nat_iso / nat_trans and rewriting won't break the .app ... It may be best to wait until when we actually use the inverses (like the Yoneda lemma) to decide which approach to adopt.</p>



<a name="266657626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/266657626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#266657626">(Jan 03 2022 at 07:26)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> <a href="#narrow/stream/113489-new-members/topic/bicategory/near/266652018">said</a></p>
<blockquote>
<p>So in general I think removing "obviously" doesn't buy you anything and you should try to keep them, unless there're issues that I'm unaware of.</p>
</blockquote>
<p>The timeout I encountered occurred when defining oplax functors by the structure command. In a new commit I succeeded in preserving <code>obviously</code> by adding an auxiliary definition for a long equation in the axiom of oplax functors. This seems to work well because <code>restate axiom</code> automatically expands the auxiliary definitions and generates a desired lemma.</p>



<a name="267164303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/267164303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#267164303">(Jan 07 2022 at 08:48)</a>:</h4>
<p>I've written down a definition of bicategories in terms of the composition functor; this shortens the definition by encapsulating many axioms into properties of functors and natural transformations. However, the pentagon and triangle axioms are quite lengthy when expressed as equality of natural transformations, and it may be easier to write them down as equality between the .app after ≫, ◁, ▷ are defined in terms of the composition functor. For simplicity I replaced isos with homs.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.products.associator</span>
<span class="kn">namespace</span> <span class="n">category_theory</span>
<span class="kd">universes</span> <span class="n">w</span> <span class="n">v</span> <span class="n">u</span>
<span class="kd">class</span> <span class="n">bicategory</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">quiver.</span><span class="o">{</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="n">B</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hom_category</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">),</span> <span class="n">category.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⟶</span> <span class="n">b</span><span class="o">)</span> <span class="bp">.</span> <span class="n">tactic.apply_instance</span><span class="o">)</span>
<span class="o">(</span><span class="n">comp</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⟶</span> <span class="n">b</span><span class="o">)</span> <span class="bp">×</span> <span class="o">(</span><span class="n">b</span> <span class="bp">⟶</span> <span class="n">c</span><span class="o">)</span> <span class="bp">⥤</span> <span class="o">(</span><span class="n">a</span> <span class="bp">⟶</span> <span class="n">c</span><span class="o">))</span>
<span class="c1">-- encompass `whisker_left_(id,comp), whisker_right_(id,comp), whisker_exchange (category.theory.bifunctor.diagonal)`</span>
<span class="o">(</span><span class="n">associator</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">comp</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">)</span> <span class="bp">⋙</span> <span class="n">comp</span> <span class="n">a</span> <span class="n">c</span> <span class="n">d</span> <span class="bp">⟶</span>
   <span class="n">prod.associator</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">⋙</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="n">comp</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span> <span class="bp">⋙</span> <span class="n">comp</span> <span class="n">a</span> <span class="n">b</span> <span class="n">d</span><span class="o">)</span>
<span class="c1">-- encompass naturality</span>
<span class="o">(</span><span class="n">id</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">⟶</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_unitor</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">prod.sectr</span> <span class="o">(</span><span class="n">id</span> <span class="n">a</span><span class="o">)</span> <span class="n">_</span> <span class="bp">⋙</span> <span class="n">comp</span> <span class="n">a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟶</span> <span class="mi">𝟭</span> <span class="n">_</span><span class="o">)</span>
<span class="o">(</span><span class="n">right_unitor</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">prod.sectl</span> <span class="n">_</span> <span class="o">(</span><span class="n">id</span> <span class="n">b</span><span class="o">)</span> <span class="bp">⋙</span> <span class="n">comp</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b</span> <span class="bp">⟶</span> <span class="mi">𝟭</span> <span class="n">_</span><span class="o">)</span>
<span class="c1">-- encompass naturality</span>
<span class="o">(</span><span class="n">pentagon</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="k">let</span>
  <span class="n">l1</span> <span class="o">:=</span> <span class="n">whisker_right</span> <span class="o">(</span><span class="n">nat_trans.prod</span> <span class="o">(</span><span class="n">associator</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">)))</span> <span class="o">(</span><span class="n">comp</span> <span class="n">a</span> <span class="n">d</span> <span class="n">e</span><span class="o">),</span>
  <span class="n">l2</span> <span class="o">:=</span> <span class="n">whisker_left</span> <span class="o">((</span><span class="n">prod.associator</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">⋙</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="n">comp</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">associator</span> <span class="n">a</span> <span class="n">b</span> <span class="n">d</span> <span class="n">e</span><span class="o">),</span>
  <span class="n">l3</span> <span class="o">:=</span> <span class="n">whisker_left</span> <span class="o">((</span><span class="n">prod.associator</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">)</span> <span class="bp">⋙</span> <span class="n">prod.associator</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
    <span class="o">(</span><span class="n">whisker_right</span> <span class="o">(</span><span class="n">nat_trans.prod</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">associator</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">))</span> <span class="o">(</span><span class="n">comp</span> <span class="n">a</span> <span class="n">b</span> <span class="n">e</span><span class="o">)),</span>
  <span class="n">r1</span> <span class="o">:=</span> <span class="n">whisker_left</span> <span class="o">(((</span><span class="n">comp</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">associator</span> <span class="n">a</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">),</span>
  <span class="n">r2</span> <span class="o">:=</span> <span class="n">whisker_left</span> <span class="o">(</span><span class="n">prod.associator</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">⋙</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="n">comp</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">))</span> <span class="o">(</span><span class="n">associator</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">e</span><span class="o">)</span>
  <span class="k">in</span> <span class="n">l1</span> <span class="bp">≫</span> <span class="n">l2</span> <span class="bp">≫</span> <span class="n">l3</span> <span class="bp">=</span> <span class="n">r1</span> <span class="bp">≫</span> <span class="n">r2</span><span class="o">)</span>
<span class="o">(</span><span class="n">triangle</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="k">let</span>
  <span class="n">l1</span> <span class="o">:=</span> <span class="n">whisker_left</span> <span class="o">((</span><span class="n">prod.sectl</span> <span class="n">_</span> <span class="o">(</span><span class="n">id</span> <span class="n">b</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">associator</span> <span class="n">a</span> <span class="n">b</span> <span class="n">b</span> <span class="n">c</span><span class="o">),</span>
  <span class="n">l2</span> <span class="o">:=</span> <span class="n">whisker_right</span> <span class="o">(</span><span class="n">nat_trans.prod</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">left_unitor</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span> <span class="o">(</span><span class="n">comp</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">l1</span> <span class="bp">≫</span> <span class="n">l2</span> <span class="bp">=</span> <span class="n">whisker_right</span> <span class="o">(</span><span class="n">nat_trans.prod</span> <span class="o">(</span><span class="n">right_unitor</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="o">(</span><span class="mi">𝟭</span> <span class="n">_</span><span class="o">)))</span> <span class="o">(</span><span class="n">comp</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span>
</code></pre></div>



<a name="267164873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/267164873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#267164873">(Jan 07 2022 at 08:56)</a>:</h4>
<p>I don't know if this is a simplification for what you want to do with them, though. I'll look into applying this approach to lax functors tomorrow. Note: the <code>let</code> expressions above are necessary, since if you substitute them in, you'd encounter unification errors and would have to insert <code>≫ eq_to_hom (by exact rfl)</code>.</p>



<a name="267210874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/267210874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#267210874">(Jan 07 2022 at 16:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/113489-new-members/topic/bicategory/near/267164303">said</a>:</p>
<blockquote>
<p>For simplicity I replaced isos with homs. (Are such bicategories ever studied in the literature?)</p>
</blockquote>
<p>I found they are called skew bicategories in <a href="https://arxiv.org/abs/1408.4953">https://arxiv.org/abs/1408.4953</a>.</p>



<a name="267275565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/267275565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#267275565">(Jan 08 2022 at 04:49)</a>:</h4>
<p>I've been able to define oplax functors in terms of <code>map</code> functors, <code>map_id</code> morphisms, and <code>map_comp</code> natural transformations, <a href="https://gist.github.com/alreadydone/f0636484e3f0d8b2110cf72ab8343c9a">posted as a gist</a>.<br>
However, it seems Lean core typechecking is very slow on the map_unitor's, and I get deterministic timeouts unless one of the map_unitor's is commented out. The problem is probably that <code>curry_obj</code> is not defined in terms of <code>sectr</code>, so a lot unfolding is necessary for Lean to see that things are defeq. In contrast, <code>map_associator</code> is parsed/checked very quickly, though I didn't add any <code>obviously</code>. An interesting observation is that unlike the <code>.app</code>/componentwise version in <a href="https://github.com/leanprover-community/mathlib/pull/11277">#11277</a>, in the nat_trans version I must insert <code>t</code> between <code>r1</code> and <code>r23</code>, because the two functors aren't defeq (but are in fact equal): on object level they're actually defeq, so <code>{ app := λ _, 𝟙 _ }</code> is a nat_trans between them, and that's why you don't need to insert <code>t</code> in the componentwise version; on the map level, their equality depends on <code>functor.map_id</code> of the functor <code>map a a</code> (or <code>map b b</code>). In contrast, <code>functor.map_comp</code> isn't required to state the three equalities.</p>



<a name="267278999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/267278999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#267278999">(Jan 08 2022 at 06:06)</a>:</h4>
<p>Can you insert an identity somewhere to prevent the unfolding? If you have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">my_target_is_X</span> <span class="bp">≫</span> <span class="n">my_source_is_X_but_this_needs_heavy_unfolding</span>
</code></pre></div>
<p>Then you can write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Im_just_id</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">complicated_version_of_X</span> <span class="o">:=</span> <span class="mi">𝟙</span> <span class="n">_</span>

<span class="n">my_target_is_X</span> <span class="bp">≫</span> <span class="n">Im_just_id</span> <span class="bp">≫</span> <span class="n">my_source_is_X_but_this_needs_heavy_unfolding</span>
</code></pre></div>
<p>Now, if you use <code>Im_just_id</code> multiple times, you've won something. Because you've replaced many heavy rfls by 1 single heavy rfl.</p>



<a name="267279583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/267279583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#267279583">(Jan 08 2022 at 06:25)</a>:</h4>
<p>There's one heavy rfl in the <code>r23</code> in the definition of <code>map_left_unitor</code> and a heavy rfl in the <code>r23</code>in the definition of <code>map_right_unitor</code>, and in each case it appears just once. Of course once the structure <code>oplax_functor</code> is defined, these rfls will be used implicitly whenever you construct a <code>oplax_functor</code>.</p>



<a name="267279695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/267279695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#267279695">(Jan 08 2022 at 06:29)</a>:</h4>
<p>I think introducing </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">sectr_functor</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span> <span class="bp">⥤</span> <span class="n">C</span> <span class="bp">×</span> <span class="n">D</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">Z</span><span class="o">,</span> <span class="n">sectr</span> <span class="n">Z</span> <span class="n">D</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span><span class="o">,</span> <span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">Z</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="mi">𝟙</span> <span class="n">Z</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>
<p>in category_theory/products/basic and using it instead of <code>curry_obj</code> would help, and moreover <code>curry_obj</code> can be defined in terms of it, but refactoring it will be a bigger project as currying.lean is imported by four files...</p>



<a name="267282406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/267282406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#267282406">(Jan 08 2022 at 07:47)</a>:</h4>
<p>today I learned <code>𝟭 C ⋙ F</code> is defeq to <code>F ⋙ 𝟭 D</code>, but neither is defeq to <code>F</code> (as I knew before, and associativity of functor composition is also defeq)...</p>



<a name="267285347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/267285347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#267285347">(Jan 08 2022 at 09:01)</a>:</h4>
<p>I thought that equality of functors was evil?</p>



<a name="267346882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/267346882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#267346882">(Jan 09 2022 at 08:58)</a>:</h4>
<p>In the <a href="https://gist.github.com/alreadydone/f0636484e3f0d8b2110cf72ab8343c9a/revisions#diff-6503605aad4153f5a02d893d06c9c9bf69c76577b3678d1c37af22fc8777afb0L58"><code>map_left_unitor</code> equality</a>, the type of the target of the left hand side is <code>𝟭 (a ⟶ b) ⋙ map a b</code>, while for the right hand side it is <code>map a b ⋙ 𝟭 (obj a ⟶ obj b)</code>, so it works "by accident". I could append unitors (and also insert associators) as is done in <a href="https://github.com/leanprover-community/mathlib/blob/b1955dcaac4bd7ce126c3466b251fd13557ece1d/src/category_theory/adjunction/basic.lean#L208">triangle identities in adjunction</a>, but that feels unnecessary and cumbersome to me, and in my tests it doesn't speed things up. Using <code>sectr_functor</code> or using <code>bicategory.id</code> directly instead of the notation <code>𝟙</code> of the <code>category_structure</code> instance constructed from <code>bicategory</code> also does little to speed.</p>
<p>The strange thing I observed is that things get slower inside <code>structure</code>. After I introduce <a href="https://gist.github.com/alreadydone/f0636484e3f0d8b2110cf72ab8343c9a#file-bicategory_functor-lean-L59">auxiliary definitions</a>, the <code>structure</code> itself speeds up to ~28s (no longer timeouts). Stuff outside of <code>structure</code> are fast:</p>
<p>parsing took 3.16ms<br>
<strong>elaboration of map_associator_aux took 439ms</strong><br>
type checking of map_associator_aux took 352ms<br>
decl post-processing of map_associator_aux took 0.12ms<br>
compilation of category_theory.map_associator_aux took 2.06ms</p>
<p>parsing took 1.92ms<br>
<strong>elaboration of map_left_unitor_aux took 3.63s</strong><br>
type checking of map_left_unitor_aux took 133ms<br>
decl post-processing of map_left_unitor_aux took 0.142ms<br>
compilation of category_theory.map_left_unitor_aux took 2.65ms</p>
<p>parsing took 1.86ms<br>
<strong>elaboration of map_right_unitor_aux took 3.54s</strong><br>
type checking of map_right_unitor_aux took 164ms<br>
decl post-processing of map_right_unitor_aux took 0.13ms<br>
elaboration: tactic compilation took 0.474ms</p>
<p>But if I inline <code>map_associator</code>, the <code>structure</code> slows down from ~28s to ~47s. With both <code>map_associator</code> and <code>map_left_unitor</code> inlined, it slows down to ~86s, but if you do <code>by { clear map_associator, exact ... }</code> when defining <code>map_left_unitor</code>, then it speeds up to ~49s; so it seems earlier fields will interfere and slow down later fields even when the later field doesn't depend on the earlier field.</p>



<a name="270871119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270871119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270871119">(Feb 06 2022 at 05:33)</a>:</h4>
<p>I'm trying to adapt my lax_grothendieck branch to the new bicategory API, but I immediately run into a problem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.bicategory.locally_discrete</span>
<span class="kd">universes</span> <span class="n">w</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">bicategory.</span><span class="o">{</span><span class="n">w</span> <span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">f</span> <span class="bp">⟶</span> <span class="n">f</span>  <span class="c1">-- : Type v</span>
</code></pre></div>
<p>while if we import <code>basic</code> instead of <code>locally_discrete</code>, then <code>f ⟶ f</code> will be of <code>Type w</code>, which is what we want. The problem is that once <code>locally_discrete</code> is imported, then <a href="https://leanprover-community.github.io/mathlib_docs/category_theory/bicategory/locally_discrete.html#category_theory.locally_discrete.quiver.hom.category_theory.small_category">this instance</a> takes precedence, even though <code>X Y : C</code> not <code>X Y : locally_discrete C</code>. How should we avoid this? Make <code>locally_discrete</code> irreducible?</p>
<p>Making the instance take a [category C] instead of [category_struct C] would solve this particular example, but if C is a strict bicategory, then we get a [category C] instance and so C would still be endowed with the locally_discrete bicategory structure instead of the original one. I wonder why <code>discrete_category</code> doesn't suffer from this problem. This works as intended:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.discrete_category</span>
<span class="kd">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="n">discrete</span> <span class="n">C</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">X</span> <span class="bp">⟶</span> <span class="n">X</span> <span class="c1">-- Type v</span>
<span class="k">#check</span> <span class="n">Y</span> <span class="bp">⟶</span> <span class="n">Y</span> <span class="c1">-- Type u</span>
</code></pre></div>



<a name="270882111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270882111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270882111">(Feb 06 2022 at 10:14)</a>:</h4>
<p>Making <code>locally_discrete</code> irreducible should work (or more precisely, doing whatever we do for <code>opposite</code>). I'm not sure why this is necessary, though--I thought that ordinary <code>def</code>s should not get unfolded during instance search, but with traces enabled it's clear that <code>locally_discrete</code> is getting unfolded.</p>



<a name="270882150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270882150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270882150">(Feb 06 2022 at 10:15)</a>:</h4>
<p>I think the <code>discrete</code> analogue works "by chance" based on the order of trying instances--except it's not really by chance because we need to go through <code>category C</code>, and I believe the local instance will always be tried first. Whereas in the <code>locally_discrete</code> case there are two paths and the local instance is not used directly at the branch point.</p>



<a name="270901453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270901453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270901453">(Feb 06 2022 at 17:40)</a>:</h4>
<p>The other solutions I can think of are:</p>
<ol>
<li>make <code>locally_discrete</code> a structure with one field, which would require certain <code>mk</code> to construct its terms, but using <code>irreducible</code> also requires first defining helper functions like <code>op</code> and <code>unop</code> before making it irreducible.</li>
<li>tweak the priority of the instance involved, which may be a simpler solution.</li>
</ol>



<a name="270904896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270904896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270904896">(Feb 06 2022 at 18:48)</a>:</h4>
<p>I guess "other" means other than fixing(?) Lean to not expand this definition during instance search</p>



<a name="270909725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270909725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270909725">(Feb 06 2022 at 20:22)</a>:</h4>
<p>Well in solution 1 the new structure isn't the same type as the original one, certainly not defeq, so Lean certainly can't reduce it to the original type during instance inference ...</p>



<a name="270910162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270910162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270910162">(Feb 06 2022 at 20:32)</a>:</h4>
<p><code>irreducible</code> is also effectively making a new type and I'd have to use analogues of <code>op</code>, <code>unop</code> and <code>quiver.hom.op</code> to transfer between objects and morphisms in these two categories on two different types, and this would be the price I have to pay to use the bicategory API to talk about a oplax functor from a 1-category (with locally discrete bicategory structure) to Cat, while I don't have to do this if I take the direct approach in <a href="https://github.com/leanprover-community/mathlib/compare/lax_grothendieck#diff-fcba77084af1e1dafef32f2c3674793f357a0495bad381534804a4c025ce28deR33">my branch</a>.</p>



<a name="270911764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270911764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270911764">(Feb 06 2022 at 21:04)</a>:</h4>
<p>Personally I like the structure approach. For one, you can use angle brackets as the anonymous constructor, whereas with an irreducible def you have to always remember what you named the constructor</p>



<a name="270924870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270924870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270924870">(Feb 07 2022 at 02:15)</a>:</h4>
<p>I also used <code>set_option trace.class_instances true</code> to take a look.<br>
The correct instance is<br>
<code>@category_struct.to_quiver (X ⟶ Y) (@category.to_category_struct (X ⟶ Y) (@bicategory.hom_category C _inst_1 X Y))</code>, <br>
which is one step shorter than the wrong instance<br>
<code>@category_struct.to_quiver (X ⟶ Y) (@category.to_category_struct (X ⟶ Y) (@locally_discrete.quiver.hom.category_theory.small_category C (@bicategory.to_category_struct C _inst_1) X Y))</code>, which is puzzling.<br>
Changing <code>attribute [instance] bicategory.hom_category</code> to <code>[instance, priority 1001]</code> fixes the problem. If no one objects I'm gonna adopt this approach.</p>



<a name="270933635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270933635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270933635">(Feb 07 2022 at 05:14)</a>:</h4>
<p>With the priority tweak, I have been able to define <a href="https://github.com/leanprover-community/mathlib/compare/lax_grothendieck_bicat?expand=1#diff-f1e819633c68f1e84abe51d548554bbf670f92dd268909f4c7fb3faa24b23df6R70">oplax functors from a 1-category <code>I</code> to a strict bicategory</a> with a simpler definition similar to that in the lax_grothendieck branch, and connect them to general oplax functors from <code>locally_discrete I</code>to the same strict bicategory via an <code>equiv</code>. I think this is a important special case worthy of a separate simpler definition.</p>
<p>This work revealed certain problems in <span class="user-mention" data-user-id="438192">@Yuma Mizuno</span>'s <code>oplax_functor</code> definition (I regret that I didn't catch them during review), namely that <code>map₂_associator'</code>, <code>map₂_left_unitor'</code> and <code>map₂_right_unitor'</code> are opposite to the simplification direction, so the auto-generated simp lemmas also point to the "wrong" direction. This can be seen from the need of <code>.symm</code> in lines 106-110. (For the associator, the direction of simplication should be from (f ≫ g) h to f (g ≫ h), in analogy to f ≫ (g ≫ h) = f ≫ g ≫ h.)</p>



<a name="270938174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270938174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270938174">(Feb 07 2022 at 06:36)</a>:</h4>
<p>For the chaining inferences problem, moving <code>category_theory.discrete_category (X ⟶ Y)</code> into the definition of <code>locally_discrete_bicategory</code> is a possible solution. Although in this approach one cannot give an instance of <code>small_category</code>, but instead just <code>category</code>, this does not seem to cause the elaborator looking for a <code>small_category</code> to miss <code>X ⟶ Y</code> for <code>X Y : locally_discrete C</code> (probably because <code>small_category</code> is defined as <code>abbreviation</code>, not <code>def</code>?).</p>



<a name="270938408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270938408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270938408">(Feb 07 2022 at 06:41)</a>:</h4>
<p>That's a good idea too! And yes <code>abbreviation</code> is definitely <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20Inference.20of.20an.20instance.20through.20a.20definition.2E/near/256019596">more transparent than</a> <code>def</code>.</p>



<a name="270942028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270942028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270942028">(Feb 07 2022 at 07:41)</a>:</h4>
<p>I just realized that the direction of <code>map₂_associator'</code> etc. are subtle.</p>
<p>The current direction is natural at least for general bicategories in the sense that the axioms say that "an oplax functor preserves the associator, left unitor, and right unitor".</p>



<a name="270944455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270944455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270944455">(Feb 07 2022 at 08:11)</a>:</h4>
<p>Yeah I now see the subtlety. If you regard a term not involving map₂ to be simpler than terms that involves it, then the current direction is good. But in my use case the part involving map₂ always simplifies to eq_to_hom ...</p>



<a name="270944674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/270944674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#270944674">(Feb 07 2022 at 08:13)</a>:</h4>
<p>I've certainly seen examples where you seem to want certain lemmas to be simp one way when you're building the API but the other way when you're using it</p>



<a name="271747662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/271747662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#271747662">(Feb 13 2022 at 14:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="438192">Yuma Mizuno</span> <a href="#narrow/stream/113489-new-members/topic/bicategory/near/270938174">said</a>:</p>
<blockquote>
<p>For the chaining inferences problem, moving <code>category_theory.discrete_category (X ⟶ Y)</code> into the definition of <code>locally_discrete_bicategory</code> is a possible solution.</p>
</blockquote>
<p>I noticed that the elaborator fails to find <code>quiver (X ⟶ Y)</code> for <code>X Y : locally_discrete B</code> in this solution (I don't understand why). So I think <span class="user-mention" data-user-id="224323">@Junyan Xu</span> 's solution (adjustment of priority) is better. I guess setting <code>locally_discrete.hom_small_category</code> to <code>priority 900</code> (some number less than 1000) also works.</p>



<a name="271752160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/271752160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#271752160">(Feb 13 2022 at 15:55)</a>:</h4>
<p><span class="user-mention" data-user-id="438192">@Yuma Mizuno</span>  Yes I saw you <a href="https://github.com/leanprover-community/mathlib/compare/bicategory-free-coherence#diff-f1e819633c68f1e84abe51d548554bbf670f92dd268909f4c7fb3faa24b23df6R43-R44">changed priority in your PR</a> and was wondering why. Can you post a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> where the quiver instance doesn't work? The following is working for me in my lax_grothendieck_bicat branch, <a href="https://github.com/leanprover-community/mathlib/compare/lax_grothendieck_bicat#diff-f1e819633c68f1e84abe51d548554bbf670f92dd268909f4c7fb3faa24b23df6R51">where your suggestion is adopted</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.bicategory.locally_discrete</span>
<span class="kd">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">locally_discrete</span> <span class="n">C</span><span class="o">)</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">quiver.</span><span class="o">{</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>
<p>(but if C is only a category_struct then the category instance on X ⟶ Y no longer exists)</p>



<a name="271753567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/271753567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#271753567">(Feb 13 2022 at 16:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.bicategory.locally_discrete</span>
<span class="kd">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">locally_discrete</span> <span class="n">C</span><span class="o">,</span> <span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">tactic.mk_instance failed to generate instance for</span>
<span class="cm">  Π (X Y : locally_discrete C), category (X ⟶ Y)</span>
<span class="cm">state:</span>
<span class="cm">C : Type u,</span>
<span class="cm">_inst_1 : category C</span>
<span class="cm">⊢ Π (X Y : locally_discrete C), category (X ⟶ Y)</span>
<span class="cm">-/</span>
</code></pre></div>
<p>Now I understand that the difference between <code>quiver</code> and <code>category</code> is not irrelevant, but the position of arguments is relevant.</p>



<a name="271753811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/271753811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#271753811">(Feb 13 2022 at 16:31)</a>:</h4>
<p>Yes whether X Y are under binder matters. <code>λ X Y, by apply_instance</code> works</p>



<a name="271755294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/271755294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuma Mizuno <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#271755294">(Feb 13 2022 at 17:05)</a>:</h4>
<p>Yes, but I would like to explain why I needed the version of instance whose arguments are under the binder. I defined <code>prelax_functor</code> from <code>locally_discrete (paths B)</code> <a href="https://github.com/leanprover-community/mathlib/compare/bicategory-free-coherence#diff-935c0a9ea1e4e45f5fe5be12ba7664d0ec2be5cc027bcdc7d6f9ec2a371c7fddR72">here</a>, which requires <code>Π (a b : locally_discrete (paths B)), quiver (a ⟶ b)</code> due to the definition of <code>prelax_functor</code>.</p>



<a name="271766759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/271766759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#271766759">(Feb 13 2022 at 21:35)</a>:</h4>
<p>interestingly, <code>by apply bicategory.hom_category</code> also works</p>



<a name="271766905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/bicategory/near/271766905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/bicategory.html#271766905">(Feb 13 2022 at 21:38)</a>:</h4>
<p>I wonder why this is failing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">class_instances</span><span class="o">]</span> <span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="bp">?</span><span class="n">x_0</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">category</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">bicategory.hom_category</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_1</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_2</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_3</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_4</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>
<span class="n">failed</span> <span class="n">is_def_eq</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
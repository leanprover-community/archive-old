---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Classes.20vs.20Structures.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html">Classes vs Structures</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="224744336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224744336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224744336">(Feb 01 2021 at 15:43)</a>:</h4>
<p>Hello, <br>
I am interested to know the reason why in Mathlib <code>monoid</code> is defined as a <code>class</code>, while <code>monoid_hom</code> is defined as a <code>structure</code>. What do we miss if we define both as classes or structures? <br>
Also when projecting the member <code>op</code> of a class <code>monoid</code>, one need to qualify it as: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">monoid_class.op</span> <span class="n">a</span> <span class="n">m</span> <span class="n">x1</span> <span class="n">x2</span>
</code></pre></div>
<p>while projecting from a structure  <code>monoid</code> can be sugared as </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">m.op_struc</span> <span class="n">x1</span> <span class="n">x2</span>
</code></pre></div>



<a name="224744488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224744488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224744488">(Feb 01 2021 at 15:44)</a>:</h4>
<p>Mathematically, if you have a type <code>M</code> then probably you only want to consider one monoid structure on it. But if you have two monoids M and N, you might want to consider many monoid homomorphisms between them.</p>



<a name="224744556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224744556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224744556">(Feb 01 2021 at 15:45)</a>:</h4>
<p>Class instances are automatically filled in by the type class inference system, which works under a "there is at most one term of this type" assumption.</p>



<a name="224744615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224744615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224744615">(Feb 01 2021 at 15:45)</a>:</h4>
<p>so <code>monoid_hom</code> definitely shouldn't be a class, but there is no harm in making <code>monoid</code> a class.</p>



<a name="224745711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224745711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224745711">(Feb 01 2021 at 15:52)</a>:</h4>
<p>Note that <a href="https://leanprover-community.github.io/mathlib_docs/find/is_monoid_hom">docs#is_monoid_hom</a> is the class version of <code>monoid_hom</code>, but it was considered a failed design because <code>simp</code> was not able to use it</p>



<a name="224758375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224758375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224758375">(Feb 01 2021 at 17:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Classes.20vs.20Structures/near/224744488">said</a>:</p>
<blockquote>
<p>Mathematically, if you have a type <code>M</code> then probably you only want to consider one monoid structure on it. But if you have two monoids M and N, you might want to consider many monoid homomorphisms between them.</p>
</blockquote>
<p>But one might want to define on <code>nat</code> a <code>monoid(nat,+,0,..)</code> and <code>monoid(nat,*,1,..)</code></p>



<a name="224758662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224758662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224758662">(Feb 01 2021 at 17:10)</a>:</h4>
<p>In practice, mathlib does that by <code>add_monoid(nat,+,0,..)</code>, which obviously doesn't scale to other monoid structures</p>



<a name="224758712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224758712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224758712">(Feb 01 2021 at 17:10)</a>:</h4>
<p>This is more of an issue about morphisms and the distinction between (+) and (*).</p>



<a name="224766796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224766796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224766796">(Feb 01 2021 at 18:05)</a>:</h4>
<p>A feature that <code>class</code> provides is that, for example, every group is automatically a monoid, so you can apply theorems about monoids to groups without any fuss.  There isn't quite so deep of a hierarchy for homomorphisms, so this kind of automatic casting seems like it would be less beneficial.</p>
<p>What appears to be a plausible design heuristic for classes vs structures is whether you plan to do rewrites of terms.  "Bundling" a term with its properties (like with <code>monoid_hom</code>) lets you rewrite that whole object while maintaining its properties, but if it were a class you'd have to worry about whether the associated typeclass still applies to the rewritten term.  I think it's a lot less frequent rewriting an expression involving the monoid's type itself in comparison to rewriting expressions of homomorphisms.  (If you work with finite sets, you can feel some of this with <code>finset</code> vs a <code>set</code> with a <code>fintype</code> instance.)</p>
<p>If I understand correctly, Coq uses structures for its algebraic hierarchy, but they use a feature called unification hints to do the automatic casting.</p>



<a name="224783174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224783174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224783174">(Feb 01 2021 at 20:06)</a>:</h4>
<p><span class="user-mention" data-user-id="358884">@Yasmine Sharoda</span> it's what looks like an extraordinary design decision that Lean's monoids are bound to the notation <code>*</code> and we have a different but isomorphic class <code>add_monoid</code> bound to the notation <code>+</code>. I've never seen this approach in any other theorem prover. A lot of people are surprised by this! But we have a <code>to_additive</code> machine which duplicates all the lemmas for us automatically (so only one of the two needs to be stated, the multiplicative one) and it works just fine! So we have two classes, <code>monoid</code> and <code>add_monoid</code>, and we can have precisely one of each structure on a type with no trouble.</p>



<a name="224789820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224789820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224789820">(Feb 01 2021 at 20:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Classes.20vs.20Structures/near/224766796">said</a>:</p>
<blockquote>
<p>A feature that <code>class</code> provides is that, for example, every group is automatically a monoid, so you can apply theorems about monoids to groups without any fuss.  There isn't quite so deep of a hierarchy for homomorphisms, so this kind of automatic casting seems like it would be less beneficial.</p>
<p>What appears to be a plausible design heuristic for classes vs structures is whether you plan to do rewrites of terms.  "Bundling" a term with its properties (like with <code>monoid_hom</code>) lets you rewrite that whole object while maintaining its properties, but if it were a class you'd have to worry about whether the associated typeclass still applies to the rewritten term.  I think it's a lot less frequent rewriting an expression involving the monoid's type itself in comparison to rewriting expressions of homomorphisms.  (If you work with finite sets, you can feel some of this with <code>finset</code> vs a <code>set</code> with a <code>fintype</code> instance.)</p>
<p>If I understand correctly, Coq uses structures for its algebraic hierarchy, but they use a feature called unification hints to do the automatic casting.</p>
</blockquote>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  Can you please elaborate more on what you mean by "rewrites of terms"? Do you mean the terms of <code>monoid</code> language? and what does that have to do with bundling?</p>



<a name="224790877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224790877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224790877">(Feb 01 2021 at 21:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Classes.20vs.20Structures/near/224783174">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="358884">Yasmine Sharoda</span> it's what looks like an extraordinary design decision that Lean's monoids are bound to the notation <code>*</code> and we have a different but isomorphic class <code>add_monoid</code> bound to the notation <code>+</code>. I've never seen this approach in any other theorem prover. A lot of people are surprised by this! But we have a <code>to_additive</code> machine which duplicates all the lemmas for us automatically (so only one of the two needs to be stated, the multiplicative one) and it works just fine! So we have two classes, <code>monoid</code> and <code>add_monoid</code>, and we can have precisely one of each structure on a type with no trouble.</p>
</blockquote>
<p>I understand that design decision. The automation provided by <code>to_additive</code> and other meta programs is what distinguishes Mathlib in a really good way. What I am asking is more of having a class like this one</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">monoid_class</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">assoc</span><span class="o">:</span> <span class="bp">∀</span>  <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">m</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>
  <span class="o">(</span><span class="n">lunit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">m</span><span class="o">,</span> <span class="n">op</span> <span class="n">e</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">runit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">m</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>and then creating 2 instances for nat, where you once instantiate <code>op</code> to be <code>+</code> and another time instantiate it to be <code>*</code>. <br>
I am not sure if the two scenarios are the same of different!</p>



<a name="224795883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224795883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224795883">(Feb 01 2021 at 21:46)</a>:</h4>
<p>With the monoid and monoid homomorphism examples, by rewriting terms I mean rewriting expressions involving monoids themselves or of monoid homomorphisms.  For example, maybe you know that <code>M = f M'</code> and then rewrite according to this.  Since you have <code>[monoid M]</code>, you don't have <code>[monoid (f M')]</code> without rewriting the instance, too, so <code>f M'</code> isn't automatically a monoid itself.</p>



<a name="224795959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224795959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224795959">(Feb 01 2021 at 21:46)</a>:</h4>
<p>Ultimately you have to hook into <code>has_add</code>, and I don't know how you'd do that with that example</p>



<a name="224795964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224795964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224795964">(Feb 01 2021 at 21:46)</a>:</h4>
<p>The issue with your <code>monoid_class</code> is that you can't extend <code>monoid_class</code> twice</p>



<a name="224795971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224795971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224795971">(Feb 01 2021 at 21:46)</a>:</h4>
<p>and <code>op</code> would be a name conflict</p>



<a name="224796200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224796200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224796200">(Feb 01 2021 at 21:48)</a>:</h4>
<p>and also you're only supposed to have one instance of a class per set of indices, so you couldn't have <code>nat</code> be both a <code>+</code> monoid and a <code>*</code> monoid in a natural way.  You'd want <code>op</code> to be one of the indices for the <code>class</code> for that, but then <code>assoc</code> and the rest would be name conflicts when you extend.  If lean had some way to rename fields when extending, it might work.</p>



<a name="224817808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224817808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224817808">(Feb 02 2021 at 01:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Classes.20vs.20Structures/near/224795883">said</a>:</p>
<blockquote>
<p>With the monoid and monoid homomorphism examples, by rewriting terms I mean rewriting expressions involving monoids themselves or of monoid homomorphisms.  For example, maybe you know that <code>M = f M'</code> and then rewrite according to this.  Since you have <code>[monoid M]</code>, you don't have <code>[monoid (f M')]</code> without rewriting the instance, too, so <code>f M'</code> isn't automatically a monoid itself.</p>
</blockquote>
<p>Thanks for the clarification.</p>



<a name="224818573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224818573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224818573">(Feb 02 2021 at 01:34)</a>:</h4>
<p>The second part of my question is why projecting a field of <code>class monoid</code> requires different syntax from projecting one from <code>structure monoid</code>. </p>
<ul>
<li>In the case of a <code>class</code>, one has to use <code>@monoid_class.op a m x1 x2</code></li>
<li>In the case of a <code>structure</code>, one can use <code>m.op x1 x2</code> (where <code>m</code> is the name of the <code>monoid</code> instance) <br>
Is that just overlooking syntactic sugar? or is there a more profound reason?</li>
</ul>



<a name="224827810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224827810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224827810">(Feb 02 2021 at 04:30)</a>:</h4>
<p>If <code>monoid_class</code> is a structure, the type of <code>op</code> is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">monoid_class.op</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="n">monoid_class</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">m</span>
</code></pre></div>
<p>As a class, the type is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">monoid_class.op</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">monoid_class</span> <span class="n">m</span><span class="o">],</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">m</span>
</code></pre></div>
<p>The difference between these is that class instance variable is automatically set to being inferred by the typeclass resolution system.  This gives you the ability to write this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">monoid_class</span> <span class="o">(</span><span class="n">op</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid_class</span> <span class="n">m</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="o">:=</span>
<span class="n">monoid_class.assoc</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>
</code></pre></div>
<p>(The <code>open</code> line imports <code>monoid_class.op</code> into the current namespace, so you can write <code>op</code> for short.)</p>



<a name="224827879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224827879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224827879">(Feb 02 2021 at 04:31)</a>:</h4>
<p>What you are observing is that <code>@monoid_class.op</code> changes the class instance argument to needing to be explicitly given.  When all goes well, you don't need to pass class instance arguments.</p>



<a name="224828024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224828024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224828024">(Feb 02 2021 at 04:33)</a>:</h4>
<p>When a class extends another, there is an automatically defined class instance definition.  This lets you do the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">semigroup_class</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span> <span class="bp">-&gt;</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">assoc</span><span class="o">:</span> <span class="bp">∀</span>  <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">m</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">monoid_class</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">semigroup_class</span> <span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">lunit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">m</span><span class="o">,</span> <span class="n">op</span> <span class="n">e</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">runit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">m</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">semigroup_class</span> <span class="o">(</span><span class="n">op</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid_class</span> <span class="n">m</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="o">:=</span>
<span class="n">semigroup_class.assoc</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>
</code></pre></div>



<a name="224933146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Classes%20vs%20Structures/near/224933146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yasmine Sharoda <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Classes.20vs.20Structures.html#224933146">(Feb 02 2021 at 20:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Classes.20vs.20Structures/near/224827879">said</a>:</p>
<blockquote>
<p>What you are observing is that <code>@monoid_class.op</code> changes the class instance argument to needing to be explicitly given.  When all goes well, you don't need to pass class instance arguments.</p>
</blockquote>
<p>Thank you!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
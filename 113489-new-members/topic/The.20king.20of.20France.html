---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/The.20king.20of.20France.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html">The king of France</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="252510377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252510377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252510377">(Sep 08 2021 at 18:31)</a>:</h4>
<p>I can't find this in the documentation. How would I define <code>c</code> below?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">U</span><span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">F</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="c1">-- F x says that x is king of France</span>

<span class="kd">axiom</span> <span class="n">only_one</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">F</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">F</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">definition</span> <span class="n">c</span> <span class="o">:=</span> <span class="s2">"the x such that F x"</span>
</code></pre></div>



<a name="252510651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252510651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252510651">(Sep 08 2021 at 18:33)</a>:</h4>
<p>You can use the axiom of choice to get a witness for there-exists:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">U</span><span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">F</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="c1">-- F x says that x is king of France</span>

<span class="kd">axiom</span> <span class="n">only_one</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">F</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">F</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">noncomputable</span>
<span class="kd">definition</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">only_one.some</span>  <span class="c1">-- short for Exists.some only_one</span>

<span class="kd">lemma</span> <span class="n">c_property</span> <span class="o">:</span> <span class="n">F</span> <span class="n">c</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">F</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">only_one.some_spec</span>
</code></pre></div>



<a name="252510860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252510860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252510860">(Sep 08 2021 at 18:35)</a>:</h4>
<p>You need to write <code>noncomputable</code> to tell Lean that it's not something it's able to actually compute -- the reason you need it is a technical non-classical-math thing you can ignore if you want.</p>



<a name="252510899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252510899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252510899">(Sep 08 2021 at 18:35)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="306601">@Kyle Miller</span>! Is there a way without Choice? (I am not against Choice but logically it shouldn't be needed here...)</p>



<a name="252511000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252511000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252511000">(Sep 08 2021 at 18:36)</a>:</h4>
<p>If I tell you there exists a unique King of France, how would you tell me who it is? This is the issue.</p>



<a name="252511183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252511183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252511183">(Sep 08 2021 at 18:37)</a>:</h4>
<p>This is an alternative:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">U</span><span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">F</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="c1">-- F x says that x is king of France</span>
<span class="kd">constant</span> <span class="n">c</span> <span class="o">:</span> <span class="n">U</span>

<span class="kd">axiom</span> <span class="n">only_one</span> <span class="o">:</span> <span class="n">F</span> <span class="n">c</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">F</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">y</span>
</code></pre></div>



<a name="252511377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252511377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252511377">(Sep 08 2021 at 18:38)</a>:</h4>
<p>There exists a King of France, and it's <code>c</code>.  This avoids the axiom of choice.</p>
<p>There are also ways to deal with this by using sigma types instead of existentials.</p>



<a name="252511722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252511722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252511722">(Sep 08 2021 at 18:41)</a>:</h4>
<p>Here's the kind of example that helped me understand why choice was needed:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ex1</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>
<span class="kd">lemma</span> <span class="n">ex2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">2</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">ex1</span> <span class="bp">=</span> <span class="n">ex2</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="252511914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252511914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252511914">(Sep 08 2021 at 18:42)</a>:</h4>
<p>I don't know if this is a type theory thing, but in regular first-order logic we would just expand the language with a new constant... or agree that any reference to <code>c</code> is officially supposed to be an abbreviation for a more elaborate statement. For instance, <code>c</code> is bald officially means: there is one and only one king of France, and he is bald.</p>



<a name="252511973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252511973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252511973">(Sep 08 2021 at 18:43)</a>:</h4>
<p>Both <code>ex1</code> and <code>ex2</code> are proofs that there is a positive natural number.  For the first, I use <code>1</code>, and for the second, I use <code>2</code>.  You'd think you could just get that witness from a proof when you want to have a positive natural number.  However, in Lean all proofs of the same proposition are equal by definition (that's proof irrelevance).</p>
<p>So, if we could extract the number from the proof, we'd get the contradictory result that <code>1 = 2</code>.</p>



<a name="252511977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252511977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252511977">(Sep 08 2021 at 18:43)</a>:</h4>
<p>There's basically no interesting way to eliminate Props into Types without choice, since the proof of a Prop doesn't contain any data (it's represented by nothing at all). If you want computable "unique choice", then you should use <code>trunc</code> instead of <code>Prop</code> (and <code>trunc</code>-ated sigma types instead of existentials).</p>



<a name="252512120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252512120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252512120">(Sep 08 2021 at 18:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="347475">Bjørn Kjos-Hanssen</span> <a href="#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252511914">said</a>:</p>
<blockquote>
<p>I don't know if this is a type theory thing, but in regular first-order logic we would just expand the language with a new constant...</p>
</blockquote>
<p>This is more or less what Lean's version of the axiom of choice is.  It introduces a whole family of constants, one for every existential. (Technically, one for every nonempty type.)</p>



<a name="252512295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252512295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252512295">(Sep 08 2021 at 18:45)</a>:</h4>
<p>Yeah, I think this is a type theory thing (my understanding is that the analogous construction in ZFC would be unproblematic). It's because Prop forgets its proofs, but Type is data, so moving from Prop to Type requires magic.</p>



<a name="252512427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252512427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252512427">(Sep 08 2021 at 18:46)</a>:</h4>
<p>The Axiom:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">axiom</span> <span class="n">classical.choice</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
</code></pre></div>
<p>The <code>Exists.some</code> function uses this indirectly, but it really is effectively giving a new constant for each existential.  The name of this constant (given your first example) is <code>Exists.some only_one</code>.</p>



<a name="252512673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252512673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252512673">(Sep 08 2021 at 18:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252511977">said</a>:</p>
<blockquote>
<p>There's basically no interesting way to eliminate Props into Types without choice</p>
</blockquote>
<p>It's all a matter of taste, but I think subsingletons are interesting.</p>



<a name="252512681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252512681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252512681">(Sep 08 2021 at 18:48)</a>:</h4>
<p>As Kevin says, every definition that involves a non-<code>Prop</code> type has some obligation to be computable in some way (I'm not sure if this is a type theory thing, or a CS-people-like-computing-things thing).  Using the definitions from my example, <code>Exists.some ex1</code> does not promise to be able to actually provide a natural number.</p>



<a name="252513174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252513174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252513174">(Sep 08 2021 at 18:52)</a>:</h4>
<p>However, on a case-by-case basis you can get a bona-fide computed thing.  The natural numbers have their own version of <a href="https://leanprover-community.github.io/mathlib_docs/find/Exists.some">docs#Exists.some</a> called <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.find">docs#nat.find</a>, which will give the first number satisfying the predicate.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ex2</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">2</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">num</span> <span class="o">:=</span> <span class="n">nat.find</span> <span class="n">ex2</span>

<span class="k">#eval</span> <span class="n">num</span>
<span class="c1">-- 1</span>
</code></pre></div>
<p>This depends on the structure of the natural numbers (induction).  In contrast, the type <code>U</code> of people in your example doesn't have any sort of structure that could be used to obtain the King.</p>



<a name="252514030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252514030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252514030">(Sep 08 2021 at 18:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="228466">Chris B</span> <a href="#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252512673">said</a>:</p>
<blockquote>
<p>It's all a matter of taste, but I think subsingletons are interesting.</p>
</blockquote>
<p>Subsingletons are interesting but the point here is that in Lean you <em>can't</em> eliminate into the from Props without choice. What you can do is eliminate <code>h : a = b</code> using <code>eq.rec</code>, which is a little more limited.</p>



<a name="252514943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252514943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252514943">(Sep 08 2021 at 19:04)</a>:</h4>
<p>Basically Lean without choice makes a distinction which is absent in ZFC, roughly speaking between "constructions" and "properties of constructions". In ZFC all you do is prove things about the universe of sets,  so you are only working in the latter world. In Lean without choice you have access to both worlds, but going from the latter to the former is mostly verboten.</p>



<a name="252515644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252515644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252515644">(Sep 08 2021 at 19:09)</a>:</h4>
<p>I think there's a typo in there, so I don't know exactly what you mean. My point was that subsingletons can eliminate from Prop to an arbitrary Sort without invoking choice.</p>



<a name="252515946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252515946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252515946">(Sep 08 2021 at 19:11)</a>:</h4>
<p>I think maybe there is some confusion between subsingleton elimination and <code>subsingleton</code>.</p>



<a name="252516461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252516461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252516461">(Sep 08 2021 at 19:15)</a>:</h4>
<p>There's a joke about them being equal in there somewhere.</p>



<a name="252516482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252516482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252516482">(Sep 08 2021 at 19:15)</a>:</h4>
<p>Ah right, you can eliminate from Props that are syntactic subsingletons, but basically this is the least interesting case.</p>



<a name="252516616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252516616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252516616">(Sep 08 2021 at 19:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252511977">said</a>:</p>
<blockquote>
<p>the proof of a Prop doesn't contain any data (it's represented by nothing at all)</p>
</blockquote>
<p>I learned a while back (to my surprise -- the only real reason I'm sharing) that Lean actually <em>does</em> represent proofs by data(*).  Lean actually will reduce proof terms, and there are examples of proofs that don't normalize <a href="#narrow/stream/113488-general/topic/Defeq.20is.20algorithmic.20in.20HoTT/near/243115821">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Defeq.20is.20algorithmic.20in.20HoTT/near/243115821</a></p>
<p>(*) I believe it erases proofs when evaluating with the VM, though.  That and proof irrelevance mean the situation's that proofs effectively have no data.</p>
<p>(Another place that proof representation apparently can matter is with <code>simp</code>, again a bit of a surprise, though this doesn't count since it's operating syntactically.)</p>



<a name="252516963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252516963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252516963">(Sep 08 2021 at 19:18)</a>:</h4>
<p>Now I think there is some confusion between "proofs" (as in the things that supposedly inhabit propositions) and proof terms. <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="252517031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252517031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252517031">(Sep 08 2021 at 19:19)</a>:</h4>
<p>It would be nice if we had a better name for the first one.</p>



<a name="252517191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252517191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252517191">(Sep 08 2021 at 19:20)</a>:</h4>
<p>I guess my main surprise wasn't that there were proof terms, but that they mattered in any way.</p>



<a name="252517901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252517901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252517901">(Sep 08 2021 at 19:25)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="130377">@David Wärn</span>'s description in terms of two worlds is a good one. But more generally, while Lean-with-<code>choice</code> corresponds to ZFC plus some universes, Lean-without-<code>choice</code> definitely doesn't correspond to anything like ZF. For example, Lean-without-<code>choice</code> doesn't prove LEM (as far as we know??)</p>



<a name="252518003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252518003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252518003">(Sep 08 2021 at 19:26)</a>:</h4>
<p>You could cook up some system of axioms to replace <code>choice</code> (like LEM and "unique choice") to get something that looks approximately like ZF, but there is not that much practical reason to do so.</p>



<a name="252518054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252518054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252518054">(Sep 08 2021 at 19:26)</a>:</h4>
<p>(If a "proof" is a proof term, maybe an "oath" is a proof-modulo-irrelevance.  Lean solemnly swears it's seen the proof.)</p>



<a name="252519397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252519397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252519397">(Sep 08 2021 at 19:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252517901">said</a>:</p>
<blockquote>
<p>I think <span class="user-mention silent" data-user-id="130377">David Wärn</span>'s description in terms of two worlds is a good one. But more generally, while Lean-with-<code>choice</code> corresponds to ZFC plus some universes,</p>
</blockquote>
<p>I would say it is closer to ZF+GC ("global choice"), in which there is a class function that selects elements from every nonempty set, or alternatively a well ordering of the universe</p>



<a name="252519561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252519561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252519561">(Sep 08 2021 at 19:36)</a>:</h4>
<p>In ZFC, you usually can't construct definable functions that make use of a choice witness; it all has to be behind an existential</p>



<a name="252519682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252519682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252519682">(Sep 08 2021 at 19:37)</a>:</h4>
<p>It would be possible to get something more like ZFC in lean if the axiom was instead <a href="https://leanprover-community.github.io/mathlib_docs/find/classical.axiom_of_choice">docs#classical.axiom_of_choice</a></p>



<a name="252521256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252521256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252521256">(Sep 08 2021 at 19:47)</a>:</h4>
<p>If we interpret each <code>Type n</code> as a universe <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">U_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> then <code>choice.{n}</code> only needs choice over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">U_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, which is a set. But then ZFC + some universes is maybe too much rather than too little. Anyways, it wasn't really the point but I should have said something less precise there.</p>



<a name="252521257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252521257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252521257">(Sep 08 2021 at 19:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252518054">said</a>:</p>
<blockquote>
<p>(If a "proof" is a proof term, maybe an "oath" is a proof-modulo-irrelevance.  Lean solemnly swears it's seen the proof.)</p>
</blockquote>
<p>I think this is still too syntactic. An element of a proposition is more of a hypothetical than an actual proof - Lean <em>hasn't</em> seen the proof, it's just assuming the proposition to be true. These elements are elements in the same way that <code>real</code> has uncountably many elements even though there are only countably many terms of type <code>real</code></p>



<a name="252521679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252521679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252521679">(Sep 08 2021 at 19:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252521256">said</a>:</p>
<blockquote>
<p>If we interpret each <code>Type n</code> as a universe <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">U_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> then <code>choice.{n}</code> only needs choice over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">U_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, which is a set. But then ZFC + some universes is maybe too much rather than too little. Anyways, it wasn't really the point but I should have said something less precise there.</p>
</blockquote>
<p>Even though it's a set (and thus amenable to the axiom of choice), you still don't get an explicit witness, except behind an existential, so it doesn't let you construct definable functions, unless you fix a set of choice functions "at the outset", which is messy because the choice of choice function becomes a parameter on every theorem</p>



<a name="252522239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252522239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252522239">(Sep 08 2021 at 19:53)</a>:</h4>
<p>Jacques Carette suggested the term "omniscient" to describe, as I understand it, the non-constructive aspect of classical mathematics that doesn't distinguish between knowing that there is exactly one king of France and knowing who the king of France is. (Or for a more practical example, not distinguishing between knowing that a given element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>p</mi><msup><mo stretchy="false">)</mo><mo>×</mo></msup></mrow><annotation encoding="application/x-tex">(\mathbb{Z}/p)^\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbb">Z</span><span class="mord">/</span><span class="mord mathnormal">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span></span></span></span> can be expressed as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>e</mi></msup></mrow><annotation encoding="application/x-tex">g^e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span></span></span></span> for a unique <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> mod <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, and being able to compute <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>.)</p>



<a name="252522292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252522292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252522292">(Sep 08 2021 at 19:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252521679">said</a>:</p>
<blockquote>
<p>unless you fix a set of choice functions "at the outset", which is messy because the choice of choice function becomes a parameter on every theorem</p>
</blockquote>
<p>Oh right, this part is indeed a bit weird.</p>



<a name="252523379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252523379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252523379">(Sep 08 2021 at 20:00)</a>:</h4>
<p>I didn't mean to suggest that Lean actually has seen a proof -- we're taking Lean at its word.  That's its oath. (At least as far as asserting the proposition is true.)</p>
<p>Point taken about using language that makes it seem like there actually are proof terms for every true proposition.</p>



<a name="252524341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252524341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ania Misiorek <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252524341">(Sep 08 2021 at 20:06)</a>:</h4>
<p>Has anyone successfully downloaded lean3 on a macOS with an M1 chip? Seems to be a lot of issues.</p>



<a name="252524483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252524483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252524483">(Sep 08 2021 at 20:07)</a>:</h4>
<p><span class="user-mention" data-user-id="438769">@Ania Misiorek</span> Welcome! Please start a new thread for your question. (You can edit your message and change the title.)</p>



<a name="252524492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252524492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252524492">(Sep 08 2021 at 20:07)</a>:</h4>
<p>you might want to ask this in a more appropriate thread? We're talking about the King of France here. Search for M1 before you do though (use the search bar at the top of the app), because this has come up before.</p>



<a name="252524929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252524929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252524929">(Sep 08 2021 at 20:10)</a>:</h4>
<p>(I apologize immensely for the following name idea in advance...  A term of a proposition could be called a "troof.")</p>



<a name="252525398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252525398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252525398">(Sep 08 2021 at 20:12)</a>:</h4>
<p>Kyle, you're now the one in the wrong thread ;b</p>



<a name="252526101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252526101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252526101">(Sep 08 2021 at 20:17)</a>:</h4>
<p>(fixed -- and apparently took you with me)</p>



<a name="252540949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252540949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252540949">(Sep 08 2021 at 22:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/The.20king.20of.20France/near/252510651">said</a>:</p>
<blockquote>
<p>You can use the axiom of choice to get a witness for there-exists:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">U</span><span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">F</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="c1">-- F x says that x is king of France</span>

<span class="kd">axiom</span> <span class="n">only_one</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">F</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">F</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">noncomputable</span>
<span class="kd">definition</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">only_one.some</span>  <span class="c1">-- short for Exists.some only_one</span>

<span class="kd">lemma</span> <span class="n">c_property</span> <span class="o">:</span> <span class="n">F</span> <span class="n">c</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">F</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">only_one.some_spec</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Unfortunately I get this cryptic error message:<br>
"invalid field notation, 'some' is not a valid "field" because environment does not contain 'Exists.some'<br>
  only_one"</p>



<a name="252541190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252541190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252541190">(Sep 08 2021 at 22:08)</a>:</h4>
<p>Ah, right, you need a mathlib theorem for that.  If you add</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.basic</span>
</code></pre></div>
<p>it will work.  (I had <code>import tactic</code> at the top of my file, which imports it transitively.)</p>



<a name="252541779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252541779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252541779">(Sep 08 2021 at 22:13)</a>:</h4>
<p>(That error message means "I see <code>only_one</code> is an <code>Exists</code>.  I see you are asking for <code>.some</code>.  I looked for <code>Exists.some</code>, but I don't know what that is."  This usually shows up if either (1) Lean guessed the types wrong, (2) you're missing some imports, or (3) you mistyped the stuff after the dot.)</p>



<a name="252542254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252542254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bjørn Kjos-Hanssen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252542254">(Sep 08 2021 at 22:17)</a>:</h4>
<p>Thanks again <span class="user-mention" data-user-id="306601">@Kyle Miller</span>  now I got it to work, even with "every country has a unique king":</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.basic</span>
<span class="kn">open</span> <span class="n">classical</span>

<span class="kd">constant</span> <span class="n">U</span><span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">F</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">U</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="c1">-- F a x says that x is king of a</span>

<span class="kd">definition</span> <span class="n">is_only_one</span> <span class="o">(</span><span class="n">a</span> <span class="n">x</span><span class="o">:</span><span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="n">F</span> <span class="n">a</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">F</span> <span class="n">a</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">axiom</span> <span class="n">only_one</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">a</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">is_only_one</span> <span class="n">a</span> <span class="n">x</span>

<span class="kd">noncomputable</span> <span class="kd">definition</span> <span class="n">c</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">U</span> <span class="o">:=</span> <span class="o">(</span><span class="n">only_one</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">some</span>  <span class="c1">-- short for Exists.some only_one</span>

<span class="kd">lemma</span> <span class="n">c_property</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span>  <span class="n">F</span> <span class="n">a</span> <span class="o">(</span><span class="n">c</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">F</span> <span class="n">a</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">c</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">only_one</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec</span>
</code></pre></div>



<a name="252542340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252542340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252542340">(Sep 08 2021 at 22:17)</a>:</h4>
<p><code>is_only_one</code> is called <a href="https://leanprover-community.github.io/mathlib_docs/find/exists_unique">docs#exists_unique</a> btw</p>



<a name="252545671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/The%20king%20of%20France/near/252545671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/The.20king.20of.20France.html#252545671">(Sep 08 2021 at 22:47)</a>:</h4>
<p>Terminology attempt number three: <em>proof term</em> vs <em>truth term</em>, or a <em>proof</em> vs a <em>truth</em>.  We syntactically construct proof terms for a proposition, but these just witness the singular truth term whose type is the given proposition.</p>
<p>(I've heard a model theorist use truth term as thing that evaluates the truth of a proposition with respect to a model, so there's mild overloading.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
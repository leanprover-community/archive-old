---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Binet.20Formula.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html">Binet Formula</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206712029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206712029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206712029">(Aug 12 2020 at 15:47)</a>:</h4>
<p>I just spent a few hours defining the golden ratio and proving Binet formula for the Fibonacci sequence. Is this already in mathlib ? If not, should I PR it ?</p>



<a name="206712081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206712081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206712081">(Aug 12 2020 at 15:48)</a>:</h4>
<p>Btw, <code>ring_exp</code> is awesome</p>



<a name="206712720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206712720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206712720">(Aug 12 2020 at 15:52)</a>:</h4>
<p>I don't think we have this yet and I think it is worth PRing.</p>



<a name="206713046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206713046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206713046">(Aug 12 2020 at 15:54)</a>:</h4>
<p>This is a codewars kata <a href="https://www.codewars.com/kata/5d2b89d4b90c0a001f4a6456/lean">https://www.codewars.com/kata/5d2b89d4b90c0a001f4a6456/lean</a> but I don't think that should stop us from having Binet in mathlib (however some peoples solutions on there which you can check out if you submit your solution might have cool methods worth considering), which proof did you do?</p>



<a name="206715251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206715251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206715251">(Aug 12 2020 at 16:10)</a>:</h4>
<p>Oh I didn't know about this. My proof is based on this predicate : </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">satisfy_fib_rec</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">u</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>


<p>which is stable under weighted sum (is this the right way to say that ?)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">satisfy_fib_rec_linear</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">satisfy_fib_rec</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">satisfy_fib_rec</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">satisfy_fib_rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">v</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>


<p>I also prove by induction that a sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">u_0 = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">u_1 = 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> which satisfies the above predicate is equal to the Fibonacci sequence :</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">eq_fib_of_satisfy_fib_rec</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="n">u</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">u</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hₙ</span> <span class="o">:</span> <span class="n">satisfy_fib_rec</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">.</span><span class="n">fib</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>


<p>Then I just have to show that <code>λ n, (φ^n)</code> and <code>λ n, ((-φ⁻¹)^n)</code> satisfy this predicate, and what is left is just computation</p>



<a name="206738469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206738469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206738469">(Aug 12 2020 at 19:20)</a>:</h4>
<p>I had a look to all answers. Mine was clearly not the shortest (but I wasn't really trying to make it short). Although maybe some of what I've proved about <code>satisfy_fib_rec</code> could be useful for studying e.g Lucas Number, I think I won't use it in a PR, there are much better proofs. <span class="user-mention" data-user-id="235229">@Alexey Solovyev</span> <span class="user-mention" data-user-id="125393">@Junyan Xu</span> do you mind if I use parts of your solutions to this kata for making the mathlib proof ?</p>



<a name="206739452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206739452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexey Solovyev <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206739452">(Aug 12 2020 at 19:29)</a>:</h4>
<p><span class="user-mention" data-user-id="268315">@Anatole Dedecker</span> You may use any part of my solution for the mathlib proof. In general, all Codewars solutions are licensed under the FreeBSD 2-Clause License (<a href="https://www.codewars.com/about/terms-of-service">https://www.codewars.com/about/terms-of-service</a>).</p>



<a name="206740433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206740433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206740433">(Aug 12 2020 at 19:37)</a>:</h4>
<p>Yeah that would be my suggestion too it would be cool to do something a bit more general. Like Lucas numbers too or any length 2 linear recurrence, but I didnt want to hold up your PR!</p>



<a name="206741012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206741012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206741012">(Aug 12 2020 at 19:42)</a>:</h4>
<p>Well, there's no hurry and that's not really complicated maths, I can definitely work on it if you think it's worth to have in mathlib</p>



<a name="206742248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206742248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206742248">(Aug 12 2020 at 19:53)</a>:</h4>
<p>Having the version for any linear recurrence would be a great end goal, I think its definitely worth to have that in mathlib eventually. I.e. the solution of any <a href="https://en.wikipedia.org/wiki/Constant-recursive_sequence">https://en.wikipedia.org/wiki/Constant-recursive_sequence</a>  like in theorem 1 of this random pdf <a href="https://www.math.kth.se/math/GRU/2012.2013/SF1610/CINTE/mastertheorem.pdf">https://www.math.kth.se/math/GRU/2012.2013/SF1610/CINTE/mastertheorem.pdf</a> . The case where the roots have multiplicity one is an important special case. These sorts of recurrences really do come up in modern number theory anyway <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="206746297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/206746297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#206746297">(Aug 12 2020 at 20:22)</a>:</h4>
<p>Glad you like my proof, and you are welcome to use it! Not sure about mathlib contribution policies but you may mention my github handle @alreadydone where appropriate.<br>
<span class="user-mention silent" data-user-id="268315">Anatole Dedecker</span> <a href="#narrow/stream/113489-new-members/topic/Binet.20Formula/near/206738469">said</a>:</p>
<blockquote>
<p>I had a look to all answers. Mine was clearly not the shortest (but I wasn't really trying to make it short). Although maybe some of what I've proved about <code>satisfy_fib_rec</code> could be useful for studying e.g Lucas Number, I think I won't use it in a PR, there are much better proofs. <span class="user-mention silent" data-user-id="235229">Alexey Solovyev</span> <span class="user-mention silent" data-user-id="125393">Junyan Xu</span> do you mind if I use parts of your solutions to this kata for making the mathlib proof ?</p>
</blockquote>



<a name="207021768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207021768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207021768">(Aug 15 2020 at 13:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/Binet.20Formula/near/206742248">said</a>:</p>
<blockquote>
<p>Having the version for any linear recurrence would be a great end goal, I think its definitely worth to have that in mathlib eventually. I.e. the solution of any <a href="https://en.wikipedia.org/wiki/Constant-recursive_sequence">https://en.wikipedia.org/wiki/Constant-recursive_sequence</a>  like in theorem 1 of this random pdf <a href="https://www.math.kth.se/math/GRU/2012.2013/SF1610/CINTE/mastertheorem.pdf">https://www.math.kth.se/math/GRU/2012.2013/SF1610/CINTE/mastertheorem.pdf</a> . The case where the roots have multiplicity one is an important special case. These sorts of recurrences really do come up in modern number theory anyway :)</p>
</blockquote>
<p>Ok so I started working on this, and after a long time of hesitations I've settled down on the following definitions. Before I continue, could you tell me if they look usable ? (Same question about the statement of <code>target</code> theorem`)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span><span class="bp">.</span><span class="n">ring_division</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">dimension</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">polynomial</span><span class="bp">.</span><span class="n">big_operators</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">structure</span> <span class="n">linear_recurrence</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span> <span class="o">(</span><span class="n">order</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">coeffs</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">order</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">linear_recurrence</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">linear_recurrence</span> <span class="n">α</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_solution</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="err">∑</span> <span class="n">i</span><span class="o">,</span> <span class="n">E</span><span class="bp">.</span><span class="n">coeffs</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">u</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">i</span><span class="o">))</span>

<span class="n">def</span> <span class="n">mk_sol</span> <span class="o">(</span><span class="n">init</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="k">then</span> <span class="n">init</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="k">else</span>
  <span class="err">∑</span> <span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span><span class="o">,</span> <span class="k">have</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="bp">+</span> <span class="n">k</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">k</span><span class="bp">.</span><span class="mi">2</span><span class="bp">;</span> <span class="n">omega</span><span class="o">,</span>
    <span class="n">E</span><span class="bp">.</span><span class="n">coeffs</span> <span class="n">k</span> <span class="bp">*</span> <span class="n">mk_sol</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_sol_mk_sol</span> <span class="o">(</span><span class="n">init</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">E</span><span class="bp">.</span><span class="n">is_solution</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">mk_sol</span> <span class="n">init</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mk_sol</span><span class="bp">;</span> <span class="n">simp</span>

<span class="n">def</span> <span class="n">mk_sol_eq_init</span> <span class="o">(</span><span class="n">init</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span><span class="o">,</span> <span class="n">E</span><span class="bp">.</span><span class="n">mk_sol</span> <span class="n">init</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">init</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mk_sol</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">fin</span><span class="bp">.</span><span class="n">coe_eq_val</span><span class="o">,</span> <span class="n">n</span><span class="bp">.</span><span class="mi">2</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">eq_mk_of_is_sol_of_eq_init</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">init</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="bp">→</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">E</span><span class="bp">.</span><span class="n">is_solution</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">heq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">init</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">E</span><span class="bp">.</span><span class="n">mk_sol</span> <span class="n">init</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span>
  <span class="k">then</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mk_sol</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">h&#39;</span><span class="o">,</span> <span class="n">dif_pos</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact_mod_cast</span> <span class="n">heq</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">h&#39;</span><span class="bp">⟩</span>
  <span class="k">else</span> <span class="k">begin</span>
    <span class="n">rw</span> <span class="n">mk_sol</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">sub_add_cancel</span> <span class="o">(</span><span class="n">le_of_not_lt</span> <span class="n">h&#39;</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">h</span> <span class="o">(</span><span class="n">n</span><span class="bp">-</span><span class="n">E</span><span class="bp">.</span><span class="n">order</span><span class="o">),</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h&#39;</span><span class="o">],</span>
    <span class="n">congr&#39;</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">k</span><span class="o">,</span>
    <span class="n">exact</span> <span class="k">have</span> <span class="n">wf</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="bp">+</span> <span class="n">k</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">k</span><span class="bp">.</span><span class="mi">2</span><span class="bp">;</span> <span class="n">omega</span><span class="o">,</span>
      <span class="k">by</span> <span class="n">rw</span> <span class="n">eq_mk_of_is_sol_of_eq_init</span>
  <span class="kn">end</span>

<span class="n">def</span> <span class="n">sol_space</span> <span class="o">:</span> <span class="n">subspace</span> <span class="n">α</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">u</span> <span class="bp">|</span> <span class="n">E</span><span class="bp">.</span><span class="n">is_solution</span> <span class="n">u</span><span class="o">},</span>
  <span class="n">zero_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">add_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span> <span class="n">v</span> <span class="n">hu</span> <span class="n">hv</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">sum_add_distrib</span><span class="o">,</span> <span class="n">hu</span> <span class="n">n</span><span class="o">,</span> <span class="n">hv</span> <span class="n">n</span><span class="o">],</span>
  <span class="n">smul_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">u</span> <span class="n">hu</span> <span class="n">n</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hu</span> <span class="n">n</span><span class="o">,</span> <span class="n">mul_sum</span><span class="o">]</span><span class="bp">;</span> <span class="n">congr&#39;</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">ac_refl</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">is_sol_iff_mem_sol_space</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">E</span><span class="bp">.</span><span class="n">is_solution</span> <span class="n">u</span> <span class="bp">↔</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">E</span><span class="bp">.</span><span class="n">sol_space</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">refl</span>

<span class="n">def</span> <span class="n">sol_space_linear_equiv_init_space</span> <span class="o">:</span>
  <span class="n">E</span><span class="bp">.</span><span class="n">sol_space</span> <span class="err">≃ₗ</span><span class="o">[</span><span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">fin</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">map_add&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span> <span class="k">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">norm_cast</span><span class="o">,</span>
  <span class="n">map_smul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">u</span><span class="o">,</span> <span class="k">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">E</span><span class="bp">.</span><span class="n">mk_sol</span> <span class="n">u</span><span class="o">,</span> <span class="n">E</span><span class="bp">.</span><span class="n">is_sol_mk_sol</span> <span class="n">u</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="k">by</span> <span class="n">ext</span> <span class="n">n</span><span class="bp">;</span> <span class="n">symmetry</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">E</span><span class="bp">.</span><span class="n">eq_mk_of_is_sol_of_eq_init</span> <span class="n">u</span><span class="bp">.</span><span class="mi">2</span><span class="bp">;</span> <span class="n">intros</span> <span class="n">k</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="n">function</span><span class="bp">.</span><span class="n">funext_iff</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">E</span><span class="bp">.</span><span class="n">mk_sol_eq_init</span> <span class="n">u</span> <span class="n">n</span><span class="o">)</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">sol_space_dim</span> <span class="o">:</span>
  <span class="n">vector_space</span><span class="bp">.</span><span class="n">dim</span> <span class="n">α</span> <span class="n">E</span><span class="bp">.</span><span class="n">sol_space</span> <span class="bp">=</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">dim_fin_fun</span> <span class="n">α</span> <span class="bp">_</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="bp">▸</span> <span class="n">E</span><span class="bp">.</span><span class="n">sol_space_linear_equiv_init_space</span><span class="bp">.</span><span class="n">dim_eq</span>

<span class="n">def</span> <span class="n">char_poly</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">polynomial</span><span class="bp">.</span><span class="n">monomial</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span> <span class="mi">1</span> <span class="bp">-</span> <span class="o">(</span><span class="err">∑</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span><span class="o">,</span> <span class="n">polynomial</span><span class="bp">.</span><span class="n">monomial</span> <span class="n">i</span> <span class="o">(</span><span class="n">E</span><span class="bp">.</span><span class="n">coeffs</span> <span class="n">i</span><span class="o">))</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">polynomial</span><span class="bp">.</span><span class="n">eval₂_finset_sum</span>

<span class="kn">lemma</span> <span class="n">geom_sol_iff_root_char_poly</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">E</span><span class="bp">.</span><span class="n">is_solution</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">q</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">E</span><span class="bp">.</span><span class="n">char_poly</span><span class="bp">.</span><span class="n">is_root</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">char_poly</span><span class="o">,</span> <span class="n">polynomial</span><span class="bp">.</span><span class="n">is_root</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span> <span class="n">polynomial</span><span class="bp">.</span><span class="kn">eval</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">polynomial</span><span class="bp">.</span><span class="n">eval₂_finset_sum</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span>
              <span class="n">ring_hom</span><span class="bp">.</span><span class="n">id_apply</span><span class="o">,</span> <span class="n">polynomial</span><span class="bp">.</span><span class="n">eval₂_monomial</span><span class="o">,</span> <span class="n">polynomial</span><span class="bp">.</span><span class="n">eval₂_sub</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">h</span> <span class="mi">0</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">zero_add</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="err">←</span> <span class="n">sub_eq_zero_iff_eq</span> <span class="n">at</span> <span class="n">h</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">sub_eq_zero_iff_eq</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pow_add</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">mul_sum</span><span class="o">],</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">ring</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">target</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">E</span><span class="bp">.</span><span class="n">char_poly</span><span class="bp">.</span><span class="n">roots</span><span class="o">,</span> <span class="n">E</span><span class="bp">.</span><span class="n">char_poly</span><span class="bp">.</span><span class="n">root_multiplicity</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">E</span><span class="bp">.</span><span class="n">order</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">E</span><span class="bp">.</span><span class="n">is_solution</span> <span class="n">u</span> <span class="bp">↔</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">polynomial</span> <span class="n">α</span><span class="o">)</span>
      <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span> <span class="bp">&lt;</span> <span class="n">E</span><span class="bp">.</span><span class="n">char_poly</span><span class="bp">.</span><span class="n">root_multiplicity</span> <span class="n">x</span><span class="o">),</span>
    <span class="n">u</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="err">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">E</span><span class="bp">.</span><span class="n">char_poly</span><span class="bp">.</span><span class="n">roots</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">^</span><span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span> <span class="n">linear_recurrence</span>
</code></pre></div>



<a name="207022706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022706">(Aug 15 2020 at 13:47)</a>:</h4>
<p><code>field \a</code> should be something like <code>comm_semiring \a</code>. I don't see any subtraction or division in alpha here.</p>



<a name="207022763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022763">(Aug 15 2020 at 13:48)</a>:</h4>
<p>But this looks like a great set-up in general. Did you try using it to make sure it's usable for e.g. Binet?</p>



<a name="207022767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022767">(Aug 15 2020 at 13:48)</a>:</h4>
<p>Well yes but then I can't define the vector space of solutions</p>



<a name="207022771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022771">(Aug 15 2020 at 13:49)</a>:</h4>
<p>sure you can, it's the semimodule of solutions</p>



<a name="207022779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022779">(Aug 15 2020 at 13:49)</a>:</h4>
<p>the axioms for a vector space don't mention subtraction or division either</p>



<a name="207022783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022783">(Aug 15 2020 at 13:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Binet.20Formula/near/207022771">said</a>:</p>
<blockquote>
<p>sure you can, it's the semimodule of solutions</p>
</blockquote>
<p>What about dimensions ? I don't see them defined for anything else than a vector_space</p>



<a name="207022788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022788">(Aug 15 2020 at 13:49)</a>:</h4>
<p>only free semimodules have dimensions</p>



<a name="207022833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022833">(Aug 15 2020 at 13:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Binet.20Formula/near/207022763">said</a>:</p>
<blockquote>
<p>But this looks like a great set-up in general. Did you try using it to make sure it's usable for e.g. Binet?</p>
</blockquote>
<p>Oh I should try this indeed</p>



<a name="207022834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022834">(Aug 15 2020 at 13:50)</a>:</h4>
<p>but <code>fin E.order → α</code> is free</p>



<a name="207022860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022860">(Aug 15 2020 at 13:51)</a>:</h4>
<p>So now an interesting question is the following:</p>



<a name="207022925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022925">(Aug 15 2020 at 13:52)</a>:</h4>
<p>Say that the auxiliary polynomial (a monic polynomial with coefficients in alpha) is a product of linear factors (X-a1)(X-a2)...(X-an). When is (1,a1,a1^2,...,a1^{n-1}),(1,a2,a2^2,...,a2^{n-1}),...,(1,an,an^2,...an^{n-1}) a basis? And here you need a field.</p>



<a name="207022980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207022980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207022980">(Aug 15 2020 at 13:54)</a>:</h4>
<p>Because even for the integers if you consider X^2-1, i.e. a_{n+2}=a_n, then the roots are +-1, so the power sequences are (1,1,1,...) and (1,-1,1,-1,...), and you cannot find a Z-linear combination of these which makes (1,0,1,0,...) because you can't divide by 2.</p>



<a name="207023048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207023048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207023048">(Aug 15 2020 at 13:56)</a>:</h4>
<p>So I suggest that all the beginning stuff is done for semirings (you probably don't even need commutative if you say which order you are summing things in, but perhaps this is going too far), but if you want to try to prove the "first main theorem of recurrence relations", which is that if the aux poly has distinct roots in the ground ring then (1,a1,a1^2,...),(1,a2,a2^2,...) etc form a basis, then you should do this for a field.</p>



<a name="207023066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207023066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207023066">(Aug 15 2020 at 13:56)</a>:</h4>
<p>Yep that looks good, I'll do this !</p>



<a name="207023080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207023080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207023080">(Aug 15 2020 at 13:57)</a>:</h4>
<p>And then there are more fundamental theorems, for example with repeated roots there is some other solution, something like (0,1<em>a,2</em>a^2,3*a^3), and these give a basis, and probably you can also say something when the roots are not in the ground field too -- but actually I think that these more general theorems should be proved another way.</p>



<a name="207023206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207023206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207023206">(Aug 15 2020 at 14:00)</a>:</h4>
<p>Let's stick to fields for this more subtle stuff. Then the vector space of solutions is n-dimensional because of the linear equiv you defined. There is also an operator sending (s0,s1,s2,s3,...) to (s1,s2,s3,...), and the point of the (1,a,a^2,a^3,...) solutions is that they are eigenvectors for this operator. The aux poly is the char poly of this operator. So actually you should prove the (1,a,a^2,..) stuff is a basis by deducing it from the general statement that an endomorphism of a fdvs (evdf) whose char poly has distinct linear factors has a basis of eigenvectors.</p>



<a name="207023212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207023212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207023212">(Aug 15 2020 at 14:00)</a>:</h4>
<p>and the more general stuff comes from theorems like Jordan decomposition.</p>



<a name="207025082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207025082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207025082">(Aug 15 2020 at 14:54)</a>:</h4>
<p>Hmmm I have read about this approach, but I thought we didn't have eigen stuff in mathlib <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="207025493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207025493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207025493">(Aug 15 2020 at 15:05)</a>:</h4>
<p>Yes but it's not far away. I guess what I'm saying is that the natural thing to do is to wait until these theorems are in mathlib</p>



<a name="207025560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207025560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207025560">(Aug 15 2020 at 15:07)</a>:</h4>
<p>Oh okay. So should I PR the infrastructure and then wait a bit before proving my target lemma ?</p>



<a name="207025697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207025697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207025697">(Aug 15 2020 at 15:10)</a>:</h4>
<p>Btw is there a name for the "shift n consecutive terms" operator ?</p>



<a name="207025803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207025803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207025803">(Aug 15 2020 at 15:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Binet.20Formula/near/207022788">said</a>:</p>
<blockquote>
<p>only free semimodules have dimensions</p>
</blockquote>
<p>I a free semimodule's dimension defined in mathlib ? I'm struggling to find it</p>



<a name="207025990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Binet%20Formula/near/207025990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Binet.20Formula.html#207025990">(Aug 15 2020 at 15:18)</a>:</h4>
<p>I'm not sure that it will be there. You are proving that it's isomorphic to <code>fin n -&gt; alpha</code> which is all you need.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Formalising.20Peano.20axioms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html">Formalising Peano axioms</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="263777861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263777861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miguel Marco <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263777861">(Dec 05 2021 at 17:01)</a>:</h4>
<p>Hi everybody,</p>
<p>I have recently started to look into lean, and, as a learning exercise, I decided to try to formalize Peano axioms in Lean.</p>
<p>The idea became motivated by an introductory course  about sets and numbers that is taught by my department, so I thought it owuld be nice to prepare some material to show to the students (or instructors) of the course, that fits the corresponding syllabus.</p>
<p>So they way it is taught, is by assuming some naive set theory, and then stating the following axioms:</p>
<ol>
<li>There exists a set named <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span></li>
<li>There exists an element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">0\in\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span></li>
<li>There is an injective function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">s:\mathbb{N}\to\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span></li>
<li>There is no <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">n\in \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s(n)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></li>
<li>If a subset <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">S\subseteq \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> satisfies that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">0\in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi>S</mi><mo>⇒</mo><mi>s</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">n\in S \Rightarrow s(s)\in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">S=\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span></li>
</ol>
<p>And from there, we go to prove several properties by induction, define the sum and so on.</p>
<p>I know that the "right" way to do this in Lean is to use the inductive type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>, but since i would like the material to follow the course, i tried to somehow mimic enough of naive set theory instead of making the students switch to think in terms of type theory.</p>
<p>This was my attempt so far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="bp">`</span><span class="n">Conjunto</span><span class="bp">`</span> <span class="o">:=</span> <span class="kt">Type</span>  <span class="c1">-- this is just to use a notation familiar to students</span>

<span class="kd">constant</span> <span class="n">N</span> <span class="o">:</span> <span class="n">Conjunto</span>   <span class="c1">--  This would be the way to introduce  axiom 1</span>
<span class="kd">constant</span> <span class="n">cero</span> <span class="o">:</span> <span class="n">N</span>  <span class="c1">--  same for axiom 2</span>

<span class="kd">constant</span> <span class="n">sig</span><span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span>
<span class="kd">axiom</span> <span class="n">siginy</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="o">(</span><span class="n">sig</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">sig</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span>   <span class="c1">-- these two lines together would be axiom 3</span>

<span class="kd">axiom</span> <span class="n">ceronosig</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">sig</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">cero</span><span class="o">)</span>  <span class="c1">-- axiom 4</span>

<span class="kd">axiom</span> <span class="n">induction</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">S</span><span class="o">:(</span><span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="n">S</span> <span class="n">cero</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">S</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">S</span> <span class="o">(</span><span class="n">sig</span> <span class="n">n</span><span class="o">)))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">S</span> <span class="n">n</span> <span class="o">)</span> <span class="c1">--   this is the way I found to introduce axiom 5</span>
                  <span class="c1">-- It is not exactly the statement of the axiom, since we deal with predicates instead of subsets</span>
                  <span class="c1">--  but it could be acceptable to reinstate the axiom in these terms</span>
</code></pre></div>
<p>So the idea is to be able to use this setting to prove properties by induction. My first attempt was to prove the existence of a predecessor for naturals that are not cero:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">anterior</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="o">(</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="n">cero</span><span class="o">)</span>  <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">sig</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">):=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
</code></pre></div>
<p>So now my goal is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">n</span><span class="o">:</span> <span class="n">N</span>
<span class="bp">⊢</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">cero</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">sig</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span>
</code></pre></div>
<p>so far so good.</p>
<p>Now I want to introduce a predicate to apply the induction axiom. I try this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">P1</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>  <span class="bp">∀</span>  <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="o">((</span><span class="n">m</span> <span class="bp">=</span> <span class="n">cero</span> <span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">m2</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">sig</span> <span class="n">m2</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">),</span>
</code></pre></div>
<p>hoping to get a hypothesis like <code> ∀  m:N, ((m = cero ) ∨ (∃ m2:N, sig m2 = m) )</code> , but what i get is just <code>P1 : Prop</code>, which i cannot use to prove the goal.</p>
<p>Is there a way to introduce a hypothesis with the type i want? Or is there a better way to formalize my five axioms(that stick to the idea of naive set theory) and prove theorems by inducton?</p>



<a name="263778181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263778181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263778181">(Dec 05 2021 at 17:06)</a>:</h4>
<p>I don't think declaring axioms like in your code is a good idea. this is because Lean is extremely bad at handling <code>axiom</code>s and <code>constant</code>s. try using <code>variables</code> or typeclasses instead, similar to the suggestions in the <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/Sebastian.20Zivota">#new members &gt; Sebastian Zivota</a> thread</p>



<a name="263778197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263778197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263778197">(Dec 05 2021 at 17:06)</a>:</h4>
<p><a href="#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263149134">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Sebastian.20Zivota/near/263149134</a></p>



<a name="263778385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263778385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263778385">(Dec 05 2021 at 17:10)</a>:</h4>
<p>You want <code>have : ∀ ...,</code> not <code>let p : Prop := ∀ ...</code></p>



<a name="263778476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263778476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263778476">(Dec 05 2021 at 17:12)</a>:</h4>
<p>assuming "conjunto" means set, mathlib has a model of ZFC that you can use <a href="https://leanprover-community.github.io/mathlib_docs/set_theory/zfc.html">https://leanprover-community.github.io/mathlib_docs/set_theory/zfc.html</a></p>



<a name="263778765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263778765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263778765">(Dec 05 2021 at 17:18)</a>:</h4>
<p>I find it unlikely that the zfc formalization will be at all helpful here</p>



<a name="263778843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263778843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263778843">(Dec 05 2021 at 17:20)</a>:</h4>
<p>Proof of <code>anterior</code>:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">anterior</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">cero</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">sig</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">induction</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">n</span> <span class="n">h</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">use</span> <span class="n">n</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="263779371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263779371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263779371">(Dec 05 2021 at 17:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="270523">Huỳnh Trần Khanh</span> <a href="#narrow/stream/113489-new-members/topic/Formalising.20Peano.20axioms/near/263778181">said</a>:</p>
<blockquote>
<p>I don't think declaring axioms like in your code is a good idea. this is because Lean is extremely bad at handling <code>axiom</code>s and <code>constant</code>s.</p>
</blockquote>
<p>I don't think the last half of this statement is true, but certainly the first half is. One way to avoid using <code>axiom</code>s is to use a <code>class</code> instead:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="bp">`</span><span class="n">Conjunto</span><span class="bp">`</span> <span class="o">:=</span> <span class="kt">Type</span>  <span class="c1">-- this is just to use a notation familiar to students</span>

<span class="kd">class</span> <span class="n">is_N</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">Conjunto</span><span class="o">)</span> <span class="o">:=</span>   <span class="c1">--  This would be the way to introduce  axiom 1</span>
<span class="o">(</span><span class="n">cero</span> <span class="o">:</span> <span class="n">N</span><span class="o">)</span>  <span class="c1">--  same for axiom 2</span>
<span class="o">(</span><span class="n">sig</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">siginy</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="o">(</span><span class="n">sig</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">sig</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>   <span class="c1">-- these two lines together would be axiom 3</span>
<span class="o">(</span><span class="n">ceronosig</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">sig</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">cero</span><span class="o">))</span>  <span class="c1">-- axiom 4</span>
<span class="o">(</span><span class="n">induction</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">S</span><span class="o">:(</span><span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="n">S</span> <span class="n">cero</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">S</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">S</span> <span class="o">(</span><span class="n">sig</span> <span class="n">n</span><span class="o">)))</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">S</span> <span class="n">n</span> <span class="o">))</span> <span class="c1">--   this is the way I found to introduce axiom 5</span>
                  <span class="c1">-- It is not exactly the statement of the axiom, since we deal with predicates instead of subsets</span>
                  <span class="c1">--  but it could be acceptable to reinstate the axiom in these terms</span>
</code></pre></div>
<p>which you can then use in your <code>anterior</code> as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">is_N</span>  <span class="c1">-- so we don't have to type `is_N.cero`</span>

<span class="kd">theorem</span> <span class="n">anterior</span> <span class="o">{</span><span class="n">N</span><span class="o">}</span> <span class="o">[</span><span class="n">is_N</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="c1">-- "if N satisfies our axioms then..."</span>
  <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="o">(</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="n">cero</span><span class="o">)</span>  <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">sig</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">):=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>As a bonus, by using <code>class</code> you can then prove that <code>ℕ</code> satisfies these axioms:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">ℕ_is_N</span> <span class="o">:</span> <span class="n">is_N</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">cero</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">sig</span> <span class="o">:=</span> <span class="n">nat.succ</span><span class="o">,</span>
  <span class="n">siginy</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">nat.succ.inj</span><span class="o">,</span>
  <span class="n">ceronosig</span> <span class="o">:=</span> <span class="n">nat.succ_ne_zero</span><span class="o">,</span>
  <span class="n">induction</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">h0</span><span class="o">,</span> <span class="n">hs</span><span class="o">⟩,</span> <span class="n">nat.rec</span> <span class="n">h0</span> <span class="n">hs</span> <span class="o">}</span>
</code></pre></div>



<a name="263780055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263780055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263780055">(Dec 05 2021 at 17:46)</a>:</h4>
<p><span class="user-mention" data-user-id="461731">@Miguel Marco</span> If you rearrange the induction axiom like this, then it's easier to use it to induct on a particular variable (and <code>apply</code> will automatically give you two goals to prove):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">axiom</span> <span class="n">induction</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">S</span><span class="o">:(</span><span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">S</span> <span class="n">cero</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">S</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">S</span> <span class="o">(</span><span class="n">sig</span> <span class="n">m</span><span class="o">))</span> <span class="bp">→</span> <span class="n">S</span> <span class="n">n</span>

<span class="kd">theorem</span> <span class="n">anterior</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="o">(</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="n">cero</span><span class="o">)</span>  <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">sig</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">):=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">induction</span> <span class="n">_</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">m</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">right</span><span class="o">,</span> <span class="n">use</span> <span class="n">m</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="263780418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263780418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263780418">(Dec 05 2021 at 17:54)</a>:</h4>
<p>I think writing axioms for small examples like this is perfectly fine.  Writing your own axioms should be avoided when you want to be certain that your proofs are correct (like for big projects with many things depending on the axioms), but for a demonstration that doesn't seem to be such a stringent requirement.</p>
<p>That said, it's easy enough to use Lean's <code>nat</code> to prove your axioms are good:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="bp">`</span><span class="n">Conjunto</span><span class="bp">`</span> <span class="o">:=</span> <span class="kt">Type</span>
<span class="kd">def</span> <span class="n">N</span> <span class="o">:</span> <span class="n">Conjunto</span> <span class="o">:=</span> <span class="n">ℕ</span>
<span class="kd">def</span> <span class="n">cero</span> <span class="o">:</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">nat.zero</span>
<span class="kd">def</span> <span class="n">sig</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">nat.succ</span>
<span class="kd">def</span> <span class="n">siginy</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="o">(</span><span class="n">sig</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">sig</span> <span class="n">m</span><span class="o">)</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">nat.succ_injective</span>
<span class="kd">theorem</span> <span class="n">ceronosig</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="bp">¬</span><span class="o">(</span><span class="n">sig</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">cero</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.succ_ne_zero</span>
<span class="kd">def</span> <span class="n">induction</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">S</span><span class="o">:(</span><span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">S</span> <span class="n">cero</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">S</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">S</span> <span class="o">(</span><span class="n">sig</span> <span class="n">m</span><span class="o">))</span> <span class="bp">→</span> <span class="n">S</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">nat.rec_on</span>
</code></pre></div>



<a name="263780527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263780527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263780527">(Dec 05 2021 at 17:57)</a>:</h4>
<p>You can make the induction axiom be in terms of Lean sets:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">induction</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">S</span><span class="o">:</span><span class="n">set</span> <span class="n">N</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">cero</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">sig</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span> <span class="bp">→</span> <span class="n">S</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">S</span><span class="o">,</span> <span class="bp">@</span><span class="n">nat.rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span>
</code></pre></div>



<a name="263780627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/263780627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#263780627">(Dec 05 2021 at 17:59)</a>:</h4>
<p>Though it seems you have to give the inductive set directly for Lean to not mess up the set membership syntax:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">anterior</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="o">(</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="n">cero</span><span class="o">)</span>  <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">sig</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">):=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">induction</span> <span class="o">{</span><span class="n">n'</span><span class="o">:</span><span class="n">N</span> <span class="bp">|</span> <span class="n">n'</span> <span class="bp">=</span> <span class="n">cero</span> <span class="bp">∨</span> <span class="bp">∃</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">sig</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n'</span><span class="o">}</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">m</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">right</span><span class="o">,</span> <span class="n">use</span> <span class="n">m</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="264496657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/264496657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miguel Marco <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#264496657">(Dec 10 2021 at 19:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Formalising.20Peano.20axioms/near/263780527">said</a>:</p>
<blockquote>
<p>You can make the induction axiom be in terms of Lean sets:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">induction</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">S</span><span class="o">:</span><span class="n">set</span> <span class="n">N</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">cero</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">sig</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span> <span class="bp">→</span> <span class="n">S</span> <span class="n">n</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">S</span><span class="o">,</span> <span class="bp">@</span><span class="n">nat.rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Thanks everybody for the answers. I managed to make something decent from them.</p>
<p>On a second try, using Lean set, I am stuck trying to prove a theorem where my goal is :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span><span class="o">:</span> <span class="n">N</span>
<span class="n">h</span><span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">O</span><span class="bp">+</span><span class="n">n</span> <span class="bp">=</span> <span class="n">n</span>
<span class="bp">⊢</span> <span class="n">sig</span> <span class="n">a</span> <span class="bp">∈</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">O</span><span class="bp">+</span><span class="n">n</span> <span class="bp">=</span> <span class="n">n</span>
</code></pre></div>
<p>I guess that to prove the goal I just have to construct a proof that <code>O+(sig a)=(sig a)</code>. But my trouble is how to extract a proof of <code>O+a=a</code> from hypothesis <code>h</code>. </p>
<p>Is there a tactic for that?</p>



<a name="264497611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/264497611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#264497611">(Dec 10 2021 at 19:37)</a>:</h4>
<p><code>h</code> is definitionally equal to <code>0 + n = n</code>. You could either do <code>dsimp at h</code> (probably even <code>dsimp only at h</code> will work but I can't check because you didn't post a mwe), or <code>change 0+a=a at h</code>.</p>



<a name="264503103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/264503103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#264503103">(Dec 10 2021 at 20:25)</a>:</h4>
<p><span class="user-mention" data-user-id="461731">@Miguel Marco</span> It looks like you're running into what happens when Lean tries to infer the inductive set for that<code>induction</code> axiom -- it turns it into a lambda, losing the set syntax.</p>
<p>It seems like there's a way to get Lean to infer the right thing by using <code>{n' | _}</code> for that argument:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">anterior</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="o">((</span><span class="n">n</span> <span class="bp">=</span> <span class="n">cero</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">m</span><span class="o">:</span><span class="n">N</span><span class="o">,</span> <span class="n">sig</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)):=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">induction</span> <span class="o">{</span><span class="n">n'</span> <span class="bp">|</span> <span class="n">_</span><span class="o">}</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">m</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">right</span><span class="o">,</span> <span class="n">use</span> <span class="n">m</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>You can change <code>n'</code> to whatever you want, and it's how you name the induction variable.</p>
<p>By the way, if you want to make sure you only use the axioms you've defined, keeping Lean from making use of built-in definitional equalities, I think putting this line after all your axioms should work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">attribute</span> <span class="o">[</span><span class="n">irreducible</span><span class="o">]</span> <span class="n">N</span>
</code></pre></div>



<a name="264503289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Formalising%20Peano%20axioms/near/264503289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Formalising.20Peano.20axioms.html#264503289">(Dec 10 2021 at 20:26)</a>:</h4>
<p>To answer your immediate question, <code>h</code> is exactly a proof of <code>O+a = a</code>, and you fix the syntactic oddness with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">change</span> <span class="n">O</span><span class="bp">+</span><span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="n">at</span> <span class="n">h</span>
</code></pre></div>
<p>though it would be better to avoid seeing anything like that in the first place if it can be helped. (<em>Edit:</em> I somehow missed that Kevin already mentioned <code>change</code>.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/working.20with.20club.20sets.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html">working with club sets</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="305950149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/305950149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Connor Gordon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#305950149">(Oct 25 2022 at 03:45)</a>:</h4>
<p>This may already be in the library somewhere, but I am hoping to prove the result that the intersection of two club sets on ω₁ (<a href="https://en.wikipedia.org/wiki/Club_set">https://en.wikipedia.org/wiki/Club_set</a>) is club. However, I'm having trouble even getting started with formalizing these definitions (if you think this is a bit ambitious for someone at my level, let me know).</p>
<p>My first goal was to get omega_1 into my code. To do this, I wrote</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">ω₁</span> <span class="o">:=</span> <span class="n">cardinal.ord</span> <span class="o">(</span><span class="n">cardinal.aleph</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>matching the documentation in <a href="https://leanprover-community.github.io/mathlib_docs/set_theory/cardinal/ordinal.html">set_theory.cardinal.ordinal</a> and <a href="https://leanprover-community.github.io/mathlib_docs/set_theory/ordinal/basic.html">set_theory.ordinal.basic</a> (as a side note, what does "noncomputable" mean in this context?). Typing <code>#check ω₁</code> does indeed give something of type <code>ordinal</code>, as one would expect.</p>
<p>Since I'm only interested in subsets of ω₁, it would be great if I could somehow create a type (or some other structure?) of such subsets, but I'm not sure how to do this. Is this possible, and if so, how would I go about it?</p>
<p>Supposing such a type exists, the next thing would be to define notions of <code>is_closed</code>,<code>is_unbounded</code>, and <code>is_club</code> (or perhaps some better naming convention) for subsets of ω₁. These would roughly correspond to the assertions that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">is_closed</span> <span class="n">S</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">A</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">sup</span> <span class="n">A</span> <span class="bp">&lt;</span> <span class="n">ω₁</span> <span class="bp">→</span> <span class="n">sup</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">)</span>
<span class="n">is_unbounded</span> <span class="n">S</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">α</span> <span class="bp">&lt;</span> <span class="n">ω₁</span><span class="o">)</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">β</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">)</span> <span class="n">α</span> <span class="bp">≤</span> <span class="n">β</span>
<span class="n">is_club</span> <span class="n">S</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">S</span> <span class="bp">∧</span> <span class="n">is_unbounded</span> <span class="n">S</span>
</code></pre></div>
<p>(pardon the almost certainly incorrect syntax). How would I properly go about implementing these properties?</p>
<p>Should I continue to pursue this project, I'll definitely have more questions, but this seems like a reasonable place to end for now. Thank you so much for your time!</p>



<a name="305955731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/305955731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#305955731">(Oct 25 2022 at 05:10)</a>:</h4>
<p>An ordinal in Lean is an "equivalence class" (implemented via quotient type) of well orders, so one needs <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient.out">docs#quotient.out</a> to get back a type; if <code>o</code> is an ordinal then <code>(quotient.out o).r</code> is a well order on the type <code>(quotient.out o).α</code> with ordinal <code>o</code> (<a href="https://leanprover-community.github.io/mathlib_docs/find/ordinal.type_out">docs#ordinal.type_out</a>), and <code>set (quotient.out o).α</code> is your desired type of subsets. However, <code>(quotient.out o).α</code> is some random type obtained from choice and its elements are not ordinals, and moreover it isn't automatically equipped with the well order <code>(quotient.out o).r</code> so you can't directly use <code>&lt;</code>, which make it hard to work with. So I instead recommend you just use subsets of ordinals (<code>set ordinal</code>) and requiring such a subset to be a subset of ω₁ amounts to requiring it's contained in the left-infinite, right-open interval <a href="https://leanprover-community.github.io/mathlib_docs/find/set.Iio">docs#set.Iio</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.cardinal.ordinal</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">ω₁</span> <span class="o">:=</span> <span class="o">(</span><span class="n">cardinal.aleph</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">ord</span> <span class="c1">-- using dot notation here</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>

<span class="kd">def</span> <span class="n">set.is_subset_of</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">set.Iio</span> <span class="n">α</span>
<span class="kd">def</span> <span class="n">set.is_closed</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">A</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="n">Sup</span> <span class="n">A</span> <span class="bp">&lt;</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sup</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">A</span>
<span class="kd">def</span> <span class="n">set.is_unbounded</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">γ</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">β</span> <span class="bp">≤</span> <span class="n">γ</span>
<span class="kd">def</span> <span class="n">set.is_club</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">S.is_subset_of</span> <span class="n">α</span> <span class="bp">∧</span> <span class="n">S.is_closed</span> <span class="n">α</span> <span class="bp">∧</span> <span class="n">S.is_unbounded</span> <span class="n">α</span>
</code></pre></div>



<a name="305979684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/305979684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#305979684">(Oct 25 2022 at 08:29)</a>:</h4>
<p>Note that <a href="https://leanprover-community.github.io/mathlib_docs/find/set.unbounded">docs#set.unbounded</a> already exists, but maybe that has a different meaning</p>



<a name="305999057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/305999057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#305999057">(Oct 25 2022 at 10:31)</a>:</h4>
<p>I would say that these definitions are nothing to do with ordinals and should probably be made much more generally (and indeed might well be there already).</p>



<a name="306973740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/306973740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Connor Gordon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#306973740">(Oct 30 2022 at 15:30)</a>:</h4>
<p>Thanks for the help! (And the comments about some of this already existing and/or this could/should be made in greater generality have been noted, but I am still rather new to this so I think I'll stick to doing this as-is for now and if I want to add it to mathlib eventually I can implement it in such generality).</p>
<p>With your help, I have managed to formalize the theorem I am trying to prove, and the proof that the intersection of two closed sets is closed. However, I am not really sure how to implement the proof of unboundedness. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.ordinal.basic</span>
<span class="kn">import</span> <span class="n">set_theory.ordinal.arithmetic</span>
<span class="kn">import</span> <span class="n">set_theory.ordinal.topology</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal.basic</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal.ordinal</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal.cofinality</span>

<span class="c1">-- Based on https://en.wikipedia.org/wiki/Club_set</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>

<span class="kd">def</span> <span class="n">set.is_subset_of</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">set.Iio</span> <span class="n">α</span>
<span class="kd">def</span> <span class="n">set.is_closed</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">A</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="n">Sup</span> <span class="n">A</span> <span class="bp">&lt;</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sup</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">A</span>
<span class="kd">def</span> <span class="n">set.is_unbounded</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">γ</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">β</span> <span class="bp">≤</span> <span class="n">γ</span>
<span class="kd">def</span> <span class="n">set.is_club</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">S.is_subset_of</span> <span class="n">α</span> <span class="bp">∧</span> <span class="n">S.is_closed</span> <span class="n">α</span> <span class="bp">∧</span> <span class="n">S.is_unbounded</span> <span class="n">α</span>

<span class="c1">-- Proof that the intersection of two club sets is club</span>
<span class="kd">theorem</span> <span class="n">inter_club_is_club</span>  <span class="o">{</span><span class="n">C₁</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">{</span><span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">{</span><span class="n">κ</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span>
<span class="o">{</span><span class="n">h1</span> <span class="o">:</span> <span class="n">set.is_club</span> <span class="n">C₁</span> <span class="n">κ</span><span class="o">}</span> <span class="o">{</span><span class="n">h2</span> <span class="o">:</span> <span class="n">set.is_club</span> <span class="n">C₂</span> <span class="n">κ</span><span class="o">}</span> <span class="o">{</span><span class="n">hκ</span> <span class="o">:</span> <span class="n">κ.cof</span> <span class="bp">&gt;</span> <span class="n">cardinal.aleph_0</span><span class="o">}</span> <span class="o">:</span>
<span class="n">set.is_club</span> <span class="o">(</span><span class="n">C₁</span> <span class="bp">∩</span> <span class="n">C₂</span><span class="o">)</span> <span class="n">κ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.is_club</span><span class="o">,</span> <span class="n">set.is_subset_of</span><span class="o">,</span> <span class="n">set.is_closed</span><span class="o">,</span> <span class="n">set.is_unbounded</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
<span class="c1">-- Proof of being a subset of κ</span>
  <span class="o">{</span>
    <span class="gr">sorry</span><span class="o">,</span> <span class="c1">--omitted</span>
  <span class="o">},</span>
  <span class="n">split</span><span class="o">,</span>
<span class="c1">-- Proof of being closed</span>
  <span class="o">{</span>
    <span class="gr">sorry</span><span class="o">,</span> <span class="c1">--omitted</span>
  <span class="o">},</span>
<span class="c1">-- Proof of being unbounded</span>
  <span class="n">intros</span> <span class="n">β</span> <span class="n">hβ</span><span class="o">,</span>
  <span class="c1">-- Construct a sequence of γ n recursively such that β ≤ γ 1 ≤ γ 2 ≤ ...,</span>
  <span class="c1">-- γ 1, γ 3, γ 5, ... are in C₁, and γ 2, γ 4, γ 6, ... are in C₂. Since C₁</span>
  <span class="c1">-- and C₂ are closed and the cofinality of κ is uncountable, we can take</span>
  <span class="c1">-- the supremum of each of these to get  elements of C₁ and C₂, and</span>
  <span class="c1">-- by the interweaving they are equal to the same value γ, which is</span>
  <span class="c1">-- in C₁ ∩ C₂. Then β ≤ γ, showing unboundedness</span>
  <span class="gr">sorry</span><span class="o">,</span>
</code></pre></div>
<p>I've looked at <a href="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html">induction and recursion</a>, but I have no idea how I might go about implementing the construction outlined in the comments using this. In particular, the choice for each γ n is non-constructive; we simply use unboundedness to know such γ n exist. I don't know how to invoke this existential quantifier in a recursive definition. Could I get some help?</p>



<a name="306975269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/306975269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#306975269">(Oct 30 2022 at 15:44)</a>:</h4>
<p>I have errors on your code. I added <code>import set_theory.cardinal.ordinal</code> but I still have an error in hypothesis <code>h\kappa</code>. The error is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">field</span> <span class="kd">notation</span><span class="o">,</span> <span class="bp">'</span><span class="n">cof'</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">valid</span> <span class="s2">"field"</span> <span class="n">because</span> <span class="n">environment</span> <span class="n">does</span> <span class="n">not</span> <span class="n">contain</span> <span class="bp">'</span><span class="n">ordinal.cof'</span>
</code></pre></div>
<p>Do I need more imports? I don't know my way around the set theory part of the library at all.</p>



<a name="306975373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/306975373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#306975373">(Oct 30 2022 at 15:45)</a>:</h4>
<p>Oh I got it -- <code>import set_theory.cardinal.cofinality</code>. It's helpful if you post fully working code when you're asking questions.</p>



<a name="306976053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/306976053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#306976053">(Oct 30 2022 at 15:49)</a>:</h4>
<p>Yes, I see your problem. Defining functions in the middle of a tactic proof is tricky. I would be tempted to make the definition outside the proof and make a basic API for it (i.e. prove some lemmas about it) so you don't have to do all this when you're in the middle of a proof and your main goal is something else. In Lean it's much better to have 5 short lemmas/definitions than one monster one which tries to do everything at once, this is part of the art of translating mathematics into Lean. I'll see if I can write something coherent.</p>



<a name="306983820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/306983820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#306983820">(Oct 30 2022 at 16:55)</a>:</h4>
<p>Here's a start (I need to do other things right now). I've defined the gamma sequence and proved its values alternate between the two sets.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.cardinal.ordinal</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal.cofinality</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>

<span class="kd">def</span> <span class="n">set.is_subset_of</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">set.Iio</span> <span class="n">α</span>
<span class="kd">def</span> <span class="n">set.is_closed</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">A</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="n">Sup</span> <span class="n">A</span> <span class="bp">&lt;</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sup</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">A</span>
<span class="kd">def</span> <span class="n">set.is_unbounded</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">γ</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">β</span> <span class="bp">≤</span> <span class="n">γ</span>
<span class="kd">def</span> <span class="n">set.is_club</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">S.is_subset_of</span> <span class="n">α</span> <span class="bp">∧</span> <span class="n">S.is_closed</span> <span class="n">α</span> <span class="bp">∧</span> <span class="n">S.is_unbounded</span> <span class="n">α</span>

<span class="c1">-- you have written no API for your definitions. Here's an example of a useful lemma or two.</span>
<span class="c1">-- The idea is that every definition comes with a cost; you make it easier to use</span>
<span class="c1">-- by writing lemmas about it and then it's nicer to use when you're proving harder stuff</span>
<span class="c1">-- using it. You didn't pay the cost yet so it's hard work working with your definitions.</span>
<span class="c1">-- These make it a bit easier.</span>
<span class="kd">lemma</span> <span class="n">set.is_club.is_unbounded</span> <span class="o">:</span> <span class="n">S.is_club</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">S.is_unbounded</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.2.2</span>
<span class="kd">lemma</span> <span class="n">set.is_subset_of.lt</span> <span class="o">:</span> <span class="n">S.is_subset_of</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">β</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">b</span> <span class="n">hβ</span><span class="o">,</span> <span class="n">h</span> <span class="n">hβ</span>
<span class="kd">lemma</span> <span class="n">set.is_club.is_subset_of</span> <span class="o">:</span> <span class="n">S.is_club</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">S.is_subset_of</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.1</span>

<span class="sd">/-- Given two unbounded subsets C₁ and C₂ of an ordinal α, and an initial value β, construct</span>
<span class="sd">a sequence `β = γ 0 ≤ γ 1 ≤ γ 2 ≤ ...` with γ i in C (i mod 2). -/</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">gamma_sequence</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">C₁</span> <span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">C₁.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">C₂.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">α</span><span class="o">}</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">β</span><span class="o">,</span> <span class="n">hβ</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="c1">-- odd case</span>
    <span class="k">let</span> <span class="n">is_unbounded</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h1.is_unbounded</span> <span class="n">C₁</span> <span class="n">α</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="k">in</span>
    <span class="o">⟨</span><span class="n">is_unbounded.some</span><span class="o">,</span> <span class="o">(</span><span class="n">h1.is_subset_of</span> <span class="n">C₁</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lt</span> <span class="n">C₁</span> <span class="n">α</span> <span class="n">_</span> <span class="n">is_unbounded.some_spec.some</span><span class="o">⟩</span> <span class="k">else</span>
    <span class="k">let</span> <span class="n">is_unbounded</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h2.is_unbounded</span> <span class="n">C₂</span> <span class="n">α</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="k">in</span>
    <span class="o">⟨</span><span class="n">is_unbounded.some</span><span class="o">,</span> <span class="o">(</span><span class="n">h2.is_subset_of</span> <span class="n">C₂</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lt</span> <span class="n">C₂</span> <span class="n">α</span> <span class="n">_</span> <span class="n">is_unbounded.some_spec.some</span><span class="o">⟩</span>

<span class="c1">-- I've made the definition so now I need to prove lots of things about it to make it usable</span>
<span class="kd">lemma</span> <span class="n">gamma_sequence_even_aux</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">C₁</span> <span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">C₁.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">C₂.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="bp">=</span>
    <span class="k">let</span> <span class="n">is_unbounded</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h2.is_unbounded</span> <span class="n">C₂</span> <span class="n">α</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>
      <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="k">in</span>
    <span class="o">⟨</span><span class="n">is_unbounded.some</span><span class="o">,</span> <span class="o">(</span><span class="n">h2.is_subset_of</span> <span class="n">C₂</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lt</span> <span class="n">C₂</span> <span class="n">α</span> <span class="n">_</span> <span class="n">is_unbounded.some_spec.some</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">gamma_sequence</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">foo</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">nat.mul_add_mod</span><span class="o">],</span> <span class="n">norm_num</span> <span class="o">},</span>
  <span class="n">simp_rw</span> <span class="n">if_neg</span> <span class="n">foo</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">gamma_sequence_odd_aux'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">C₁</span> <span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">C₁.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">C₂.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">))</span> <span class="bp">=</span>
    <span class="k">let</span> <span class="n">is_unbounded</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h1.is_unbounded</span> <span class="n">C₁</span> <span class="n">α</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>
      <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="k">in</span>
    <span class="o">⟨</span><span class="n">is_unbounded.some</span><span class="o">,</span> <span class="o">(</span><span class="n">h1.is_subset_of</span> <span class="n">C₁</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lt</span> <span class="n">C₁</span> <span class="n">α</span> <span class="n">_</span> <span class="n">is_unbounded.some_spec.some</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">gamma_sequence</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">foo</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">nat.mul_add_mod</span><span class="o">],</span> <span class="n">norm_num</span> <span class="o">},</span>
  <span class="n">simp_rw</span> <span class="n">if_pos</span> <span class="n">foo</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">gamma_sequence_odd_aux</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">C₁</span> <span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">C₁.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">C₂.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span>
    <span class="k">let</span> <span class="n">is_unbounded</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h1.is_unbounded</span> <span class="n">C₁</span> <span class="n">α</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>
      <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="k">in</span>
    <span class="o">⟨</span><span class="n">is_unbounded.some</span><span class="o">,</span> <span class="o">(</span><span class="n">h1.is_subset_of</span> <span class="n">C₁</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lt</span> <span class="n">C₁</span> <span class="n">α</span> <span class="n">_</span> <span class="n">is_unbounded.some_spec.some</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">gamma_sequence_odd_aux'</span> <span class="n">α</span> <span class="n">n</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- the even elements of the sequence beyond 2 are in C₂</span>
<span class="kd">lemma</span> <span class="n">gamma_sequence_even</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">C₁</span> <span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">C₁.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">C₂.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">∈</span> <span class="n">C₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">is_unbounded</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h2.is_unbounded</span> <span class="n">C₂</span> <span class="n">α</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>
      <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">gamma_sequence_even_aux</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">is_unbounded.some_spec.some</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- the odd elements of the sequence are in C₁</span>
<span class="kd">lemma</span> <span class="n">gamma_sequence_odd</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">C₁</span> <span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">C₁.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">C₂.is_club</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">∈</span> <span class="n">C₁</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">is_unbounded</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h1.is_unbounded</span> <span class="n">C₁</span> <span class="n">α</span> <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>
      <span class="o">(</span><span class="n">gamma_sequence</span> <span class="n">α</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">gamma_sequence_odd_aux</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">is_unbounded.some_spec.some</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="306983954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/306983954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#306983954">(Oct 30 2022 at 16:56)</a>:</h4>
<p>This is the pattern to proving stuff like this about the sequence; prove it outside your main proof and then just drop it in.</p>



<a name="306989026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/306989026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Connor Gordon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#306989026">(Oct 30 2022 at 17:46)</a>:</h4>
<p>Thank you so much! I'll work with this and see if I can complete the proof from here.</p>



<a name="307399736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/working%20with%20club%20sets/near/307399736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Connor Gordon <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/working.20with.20club.20sets.html#307399736">(Nov 01 2022 at 20:39)</a>:</h4>
<p>Alright, I very nearly have it all now; all that's left is to use the cofinality assumption to show that the supremum of the gamma sequence is less than kappa. I have a bit of code that almost does what I want, but there's seemingly an issue with types and the universes those types come from, or something like that? Not totally clear. Here's the error message I'm getting:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">ordinal.sup_lt_ord</span>
<span class="n">term</span>
  <span class="n">γ_seq_val</span> <span class="n">κ</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ordinal</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_1</span> <span class="bp">→</span> <span class="n">ordinal</span>
</code></pre></div>
<p>Here's a minimal (almost-)working example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.ordinal.basic</span>
<span class="kn">import</span> <span class="n">set_theory.ordinal.arithmetic</span>
<span class="kn">import</span> <span class="n">set_theory.ordinal.topology</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal.basic</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal.ordinal</span>
<span class="kn">import</span> <span class="n">set_theory.cardinal.cofinality</span>
<span class="kn">import</span> <span class="n">data.nat.parity</span>

<span class="c1">-- Based on https://en.wikipedia.org/wiki/Club_set</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">κ</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>

<span class="c1">-- Basic definitions</span>
<span class="kd">def</span> <span class="n">set.is_subset_of</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">S</span> <span class="bp">⊆</span> <span class="n">set.Iio</span> <span class="n">κ</span>
<span class="kd">def</span> <span class="n">set.is_closed</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">A</span> <span class="bp">⊆</span> <span class="n">S</span><span class="o">,</span> <span class="n">Sup</span> <span class="n">A</span> <span class="bp">&lt;</span> <span class="n">κ</span> <span class="bp">→</span> <span class="n">Sup</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">A</span>
<span class="kd">def</span> <span class="n">set.is_unbounded</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">κ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">γ</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">γ</span>
<span class="kd">def</span> <span class="n">set.is_club</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">S.is_subset_of</span> <span class="n">κ</span> <span class="bp">∧</span> <span class="n">S.is_closed</span> <span class="n">κ</span> <span class="bp">∧</span> <span class="n">S.is_unbounded</span> <span class="n">κ</span>

<span class="c1">-- Convenience lemmas</span>
<span class="kd">lemma</span> <span class="n">set.is_club.is_unbounded</span> <span class="o">:</span> <span class="n">S.is_club</span> <span class="n">κ</span> <span class="bp">→</span> <span class="n">S.is_unbounded</span> <span class="n">κ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.2.2</span>
<span class="kd">lemma</span> <span class="n">set.is_subset_of.lt</span> <span class="o">:</span> <span class="n">S.is_subset_of</span> <span class="n">κ</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">β</span> <span class="bp">∈</span> <span class="n">S</span><span class="o">,</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">κ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span> <span class="n">β</span> <span class="n">hβ</span><span class="o">,</span> <span class="n">h</span> <span class="n">hβ</span>
<span class="kd">lemma</span> <span class="n">set.is_club.is_subset_of</span> <span class="o">:</span> <span class="n">S.is_club</span> <span class="n">κ</span> <span class="bp">→</span> <span class="n">S.is_subset_of</span> <span class="n">κ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.1</span>
<span class="kd">lemma</span> <span class="n">set.is_club.is_closed</span> <span class="o">:</span> <span class="n">S.is_club</span> <span class="n">κ</span> <span class="bp">→</span> <span class="n">S.is_closed</span> <span class="n">κ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.2.1</span>

<span class="c1">-- The proof of unboundedness involves a recursive construction of a sequence of ordinals γ n</span>
<span class="c1">-- The following is based heavily on code from Kevin Buzzard on Zulip: https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/working.20with.20club.20sets</span>

<span class="c1">-- Define the sequence recursively</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">γ_seq</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">κ</span><span class="o">)</span> <span class="o">{</span><span class="n">C₁</span> <span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">C₁.is_club</span> <span class="n">κ</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">C₂.is_club</span> <span class="n">κ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">κ</span><span class="o">}</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">β</span><span class="o">,</span> <span class="n">hβ</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">n</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="c1">-- odd</span>
    <span class="k">let</span> <span class="n">is_unbounded</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h1.is_unbounded</span> <span class="n">C₁</span> <span class="n">κ</span> <span class="o">(</span><span class="n">γ_seq</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">γ_seq</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="k">in</span>
    <span class="o">⟨</span><span class="n">is_unbounded.some</span><span class="o">,</span> <span class="o">(</span><span class="n">h1.is_subset_of</span> <span class="n">C₁</span> <span class="n">κ</span><span class="o">)</span><span class="bp">.</span><span class="n">lt</span> <span class="n">C₁</span> <span class="n">κ</span> <span class="n">_</span> <span class="n">is_unbounded.some_spec.some</span><span class="o">⟩</span>
    <span class="k">else</span> <span class="k">let</span> <span class="n">is_unbounded</span> <span class="o">:=</span> <span class="o">(</span><span class="n">h2.is_unbounded</span> <span class="n">C₂</span> <span class="n">κ</span> <span class="o">(</span><span class="n">γ_seq</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">γ_seq</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="k">in</span>
    <span class="o">⟨</span><span class="n">is_unbounded.some</span><span class="o">,</span> <span class="o">(</span><span class="n">h2.is_subset_of</span> <span class="n">C₂</span> <span class="n">κ</span><span class="o">)</span><span class="bp">.</span><span class="n">lt</span> <span class="n">C₂</span> <span class="n">κ</span> <span class="n">_</span> <span class="n">is_unbounded.some_spec.some</span><span class="o">⟩</span>

<span class="c1">-- Extract the values from the gamma sequence</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">γ_seq_val</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">κ</span><span class="o">)</span> <span class="o">{</span><span class="n">C₁</span> <span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">C₁.is_club</span> <span class="n">κ</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">C₂.is_club</span> <span class="n">κ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">γ_seq</span> <span class="n">κ</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>

<span class="c1">-- Define the supremum of the sequence</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">γ_sup</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">κ</span><span class="o">)</span> <span class="o">{</span><span class="n">C₁</span> <span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">C₁.is_club</span> <span class="n">κ</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">C₂.is_club</span> <span class="n">κ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span> <span class="n">ordinal.sup</span> <span class="o">(</span><span class="n">γ_seq_val</span> <span class="n">κ</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span>

<span class="c1">-- Show this supremum is less than κ</span>
<span class="kd">lemma</span> <span class="n">sup_lt_kappa</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">&lt;</span> <span class="n">κ</span><span class="o">)</span> <span class="o">{</span><span class="n">C₁</span> <span class="n">C₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ordinal.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">C₁.is_club</span> <span class="n">κ</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">C₂.is_club</span> <span class="n">κ</span><span class="o">)</span> <span class="o">(</span><span class="n">hκ</span> <span class="o">:</span> <span class="n">κ.cof</span> <span class="bp">&gt;</span> <span class="n">cardinal.aleph_0</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">γ_sup</span> <span class="n">κ</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">κ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">γ_sup</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">foo</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">γ_seq_val</span> <span class="n">κ</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">n</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">κ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ordinal.sup</span> <span class="o">(</span><span class="n">γ_seq_val</span> <span class="n">κ</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">κ</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="c1">-- apply @ordinal.sup_lt_ord.{u} _ ((γ_seq_val κ hβ h1 h2)) κ,</span>
    <span class="c1">-- this really should work but it doesn't quite</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">foo</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">γ_seq</span> <span class="n">κ</span> <span class="n">hβ</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">property</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>If I can get this last bit, I will have completed the proof that the intersection of two club sets is club. Any ideas on how I could make this work?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/ratfunc.20composition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html">ratfunc composition</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279339553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279339553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279339553">(Apr 18 2022 at 21:58)</a>:</h4>
<p>I've been working with <code>f : R -&gt; R</code> and using <code>f^[n]</code> to represent <code>f ( f ( f ( ... f ( x ) ) ) )</code>, I want to do this with <code>ratfunc R</code> but it doesn't work since <code>nat.iterate R</code> doesn't seem to work on type <code>R -&gt; R</code>, does anyone have any tips on how to represent this with <code>ratfunc R</code> ?</p>



<a name="279339718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279339718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279339718">(Apr 18 2022 at 22:00)</a>:</h4>
<p>(deleted)</p>



<a name="279340353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279340353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279340353">(Apr 18 2022 at 22:06)</a>:</h4>
<p>The first thing to figure out is how to compose two rational functions and get a rational function. Then you can just fold I guess.</p>



<a name="279341358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279341358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279341358">(Apr 18 2022 at 22:17)</a>:</h4>
<p>I think I have to use <code>ratfunc.eval</code> #ratfunc.eval but I don't really understand it too well :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Evaluate</span> <span class="n">a</span> <span class="n">rational</span> <span class="n">function</span> <span class="n">p</span> <span class="n">given</span> <span class="n">a</span> <span class="n">ring</span> <span class="n">hom</span> <span class="n">f</span> <span class="k">from</span> <span class="n">the</span> <span class="n">scalar</span> <span class="n">field</span> <span class="n">to</span> <span class="n">the</span> <span class="n">target</span> <span class="n">and</span> <span class="n">a</span> <span class="n">value</span> <span class="n">x</span> <span class="n">for</span> <span class="n">the</span> <span class="kd">variable</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target.</span>
</code></pre></div>
<p>Don't I just need to pass the rational function and the value I want to evaluate at ? What is the ring hom thing?</p>



<a name="279341610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279341610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279341610">(Apr 18 2022 at 22:20)</a>:</h4>
<p>(<a href="https://leanprover-community.github.io/mathlib_docs/find/ratfunc.eval">docs#ratfunc.eval</a>)</p>



<a name="279341713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279341713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279341713">(Apr 18 2022 at 22:21)</a>:</h4>
<p>The implementation of <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.comp">docs#polynomial.comp</a> might give some ideas</p>



<a name="279341822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279341822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279341822">(Apr 18 2022 at 22:23)</a>:</h4>
<p>I would guess you pick the ring_hom as <code>algebra_map _ _</code></p>



<a name="279343122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279343122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279343122">(Apr 18 2022 at 22:39)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ratfunc">docs#ratfunc</a></p>



<a name="279343312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279343312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279343312">(Apr 18 2022 at 22:41)</a>:</h4>
<p>I don't think you can use evaluation. If the ground field is finite then not even a polynomial is determined by its values. A rational function can take infinity as a value so I don't think ring homomorphisms are relevant either. I guess you need to evaluate on the other rational function itself</p>



<a name="279343496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279343496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279343496">(Apr 18 2022 at 22:44)</a>:</h4>
<p>Aah I see, yes this is the point, you don't eval at an element of K, you eval at an element of ratfunc.</p>



<a name="279346012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279346012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279346012">(Apr 18 2022 at 23:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/ratfunc.20composition/near/279343496">said</a>:</p>
<blockquote>
<p>Aah I see, yes this is the point, you don't eval at an element of K, you eval at an element of ratfunc.</p>
</blockquote>
<p>Trying to understand that more, so far I've experimented with this example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.ratfunc</span>

<span class="k">#check</span> <span class="n">ratfunc.eval</span> <span class="n">id</span> <span class="mi">1</span> <span class="o">(</span><span class="n">ratfunc.X</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span>
</code></pre></div>
<p>but it errors with :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">ratfunc.eval</span> <span class="n">id</span>
<span class="n">term</span>
  <span class="n">id</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_1</span> <span class="bp">→</span> <span class="bp">?</span><span class="n">m_1</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="bp">?</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_1</span> <span class="bp">→+*</span> <span class="bp">?</span><span class="n">m_2</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span> <span class="bp">?</span><span class="o">)</span>
</code></pre></div>



<a name="279346434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279346434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279346434">(Apr 18 2022 at 23:25)</a>:</h4>
<p>yep that error makes perfect sense. Maybe you want <a href="http://ring_hom.id">ring_hom.id</a> or something?</p>



<a name="279346746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279346746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279346746">(Apr 18 2022 at 23:29)</a>:</h4>
<p>Ok, I tried that : </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.ratfunc</span>

<span class="k">#check</span> <span class="n">ratfunc.eval</span> <span class="n">ring_hom.id</span> <span class="mi">1</span> <span class="o">(</span><span class="n">ratfunc.X</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span>
</code></pre></div>
<p>but with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">ratfunc.eval</span> <span class="n">ring_hom.id</span>
<span class="n">term</span>
  <span class="n">ring_hom.id</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">non_assoc_semiring</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→+*</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="bp">?+</span><span class="mi">1</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_1</span> <span class="bp">→+*</span> <span class="bp">?</span><span class="n">m_2</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span> <span class="bp">?</span><span class="o">)</span>
</code></pre></div>



<a name="279346803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279346803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Callum Cassidy-Nolan <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279346803">(Apr 18 2022 at 23:30)</a>:</h4>
<p>Can you explain the point of evaluating a <code>ratfunc</code> with another <code>ratfunc</code> ? Why not evaluate it with a value in <code>R</code> ?</p>



<a name="279347651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279347651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279347651">(Apr 18 2022 at 23:41)</a>:</h4>
<p>I think that <code>ratfunc.eval ratfunc.C q p</code> should give the expected composition <code>p ∘ q</code>. The idea is that the ring homomorphism <code> ratfunc.C</code> let you see the coefficients of <code>p</code>as elements of <code>ratfunc R</code>, and this rational function with coefficients in <code>ratfunc R</code> can then be evaluated at <code>q</code>.</p>



<a name="279347812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279347812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279347812">(Apr 18 2022 at 23:44)</a>:</h4>
<p>I think something like this is what you want:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.ratfunc</span>

<span class="kd">noncomputable theory</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ratfunc</span> <span class="n">K</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">comp</span> <span class="o">:</span> <span class="n">ratfunc</span> <span class="n">K</span> <span class="o">:=</span>
<span class="n">f.eval</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">K</span> <span class="o">(</span><span class="n">ratfunc</span> <span class="n">K</span><span class="o">))</span> <span class="n">g</span>


<span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">comp</span> <span class="n">f</span><span class="o">)</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="n">ratfunc.X</span> <span class="c1">-- should be f (f (f (X))) n times</span>
</code></pre></div>
<p>the point is to define composition of rational functions as a rational function, rather than as a plain function so we remember more information</p>
<p>Edit: Oops this is basically what <span class="user-mention" data-user-id="329754">@Antoine Labelle</span> said <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="279351423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279351423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279351423">(Apr 19 2022 at 00:38)</a>:</h4>
<p>Is <code>comp</code> associative?</p>



<a name="279351730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279351730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279351730">(Apr 19 2022 at 00:43)</a>:</h4>
<p>It should be, yes</p>



<a name="279351958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279351958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279351958">(Apr 19 2022 at 00:47)</a>:</h4>
<p>Actually, one problem is that, mathematically, the composition of rational functions is not quite well-defined everywhere : for example there is no good way to compose <code>1/X</code> with constant rational function <code>0</code>.  In these cases, the definition I gave above should probably evaluate to <code>0 : ratfunc R</code>, just as in lean <code>a/0</code> is defined (somewhat arbitrarily) to be <code>0</code>.</p>



<a name="279352244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279352244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279352244">(Apr 19 2022 at 00:51)</a>:</h4>
<p>I think there would be some problem with composing (in standard order) the rational functions <code>X + 1</code>, <code>1 / (X - 1)</code>, <code>1</code>.</p>



<a name="279355620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279355620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279355620">(Apr 19 2022 at 01:59)</a>:</h4>
<p>You're right, it might be associative only when it's well-defined</p>



<a name="279370404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ratfunc%20composition/near/279370404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/ratfunc.20composition.html#279370404">(Apr 19 2022 at 07:00)</a>:</h4>
<p>Interesting! Looks to me like this only happens when one of the functions involved is constant, which would imply that this operation is still power associative, and the above iterated function is well defined despite this, do we need a new typeclass for power associative monoids <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
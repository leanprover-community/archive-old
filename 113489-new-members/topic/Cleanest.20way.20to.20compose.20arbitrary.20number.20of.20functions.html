---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html">Cleanest way to compose arbitrary number of functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="318258622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318258622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318258622">(Dec 28 2022 at 13:48)</a>:</h4>
<p>Suppose <code>n : ℕ</code> and that I have <code>f : (fin n) → (α → α)</code> and <code>a : α</code>. What is the cleanest way to write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>0</mn></msub><mi>a</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_{n-1}(f_{n-2}(...(f_0 a)....))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">...</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord">....</span><span class="mclose">))</span></span></span></span> in Lean?</p>



<a name="318260304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318260304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318260304">(Dec 28 2022 at 13:59)</a>:</h4>
<p>I would write it like <code>f $ g $ h x</code></p>



<a name="318261010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318261010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318261010">(Dec 28 2022 at 14:03)</a>:</h4>
<p>That only works for n=3 though</p>



<a name="318261225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318261225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318261225">(Dec 28 2022 at 14:05)</a>:</h4>
<p>Ah, <code>n</code> is an input of <code>f</code>. I got confused because you wrote it subscripted in LaTeX (as if you had those functions at hand).</p>
<p>In Lean 4, I would <code>foldl</code> on <code>List.range n</code></p>



<a name="318263142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318263142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318263142">(Dec 28 2022 at 14:15)</a>:</h4>
<p>How do you provide an element of <code>fin 0</code> though?</p>



<a name="318265162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318265162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318265162">(Dec 28 2022 at 14:25)</a>:</h4>
<p>I would write something along the lines of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">composeN</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">match</span> <span class="n">h1</span><span class="o">:</span><span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">id</span>
  <span class="bp">|</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">mut</span> <span class="n">fn</span> <span class="o">:=</span> <span class="n">f</span> <span class="mi">0</span>
    <span class="n">for</span> <span class="n">h2</span><span class="o">:</span><span class="n">idx</span> <span class="k">in</span> <span class="o">[</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="o">]</span> <span class="k">do</span>
      <span class="n">fn</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">idx</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp_all</span><span class="o">[(</span><span class="bp">·</span> <span class="bp">∈</span> <span class="bp">·</span><span class="o">)]⟩</span> <span class="bp">∘</span> <span class="n">fn</span>
    <span class="n">fn</span>
</code></pre></div>
<p>the <code>List.range</code> approach is annoying to work with because you would have to prove the bounds on the values inside List.range and I don't know whether we have built in lemmata for that. This works with a default Lean 4 installation.</p>



<a name="318265445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318265445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318265445">(Dec 28 2022 at 14:27)</a>:</h4>
<p>Based on how you are writing the <code>Fin</code> type here you are probably asking a Lean 3 quesiton though and I have no clue about that. There the List.range approachw ith something along the lines of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">composeN</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">range</span> <span class="o">:=</span> <span class="n">List.range</span> <span class="n">n</span>
  <span class="n">range.foldl</span> <span class="o">(</span><span class="n">init</span> <span class="o">:=</span> <span class="n">id</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">elem</span> <span class="bp">=&gt;</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">elem</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span> <span class="bp">∘</span> <span class="n">acc</span><span class="o">)</span>
</code></pre></div>
<p>should work out but I have no clue about the things you have available.</p>



<a name="318265720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318265720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318265720">(Dec 28 2022 at 14:28)</a>:</h4>
<p>This question is related: <a href="#narrow/stream/270676-lean4/topic/iterating.20over.20.60Fin.20n.60/near/314789036">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/iterating.20over.20.60Fin.20n.60/near/314789036</a></p>



<a name="318265905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318265905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318265905">(Dec 28 2022 at 14:30)</a>:</h4>
<p>The following code works in Lean 3.<br>
Unfortunately, I don't know how to typecast <code>(fin 5) → (ℤ → ℤ)</code> to <code>list (ℤ → ℤ)</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.matrix.notation</span>

<span class="kd">def</span> <span class="n">g</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">5</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ℤ</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">!</span><span class="o">[(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)]</span>
<span class="kd">def</span> <span class="n">g'</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℤ</span> <span class="bp">→</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span>      <span class="o">[(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)]</span>

<span class="kd">def</span> <span class="n">chain</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">list.foldl</span> <span class="o">(</span><span class="bp">∘</span><span class="o">)</span> <span class="n">id</span> <span class="n">f</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">g</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">$</span> <span class="o">(</span><span class="n">g</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">$</span> <span class="o">(</span><span class="n">g</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">$</span> <span class="o">(</span><span class="n">g</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">$</span> <span class="o">(</span><span class="n">g</span> <span class="mi">4</span><span class="o">)</span> <span class="mi">9</span>

<span class="k">#eval</span> <span class="n">chain</span> <span class="n">g'</span> <span class="mi">9</span>
</code></pre></div>
<p>Both <code>#eval</code>s return 624.</p>



<a name="318266187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318266187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318266187">(Dec 28 2022 at 14:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">functions</span> <span class="o">:</span> <span class="n">Fin</span> <span class="mi">3</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">2</span> <span class="bp">=&gt;</span> <span class="n">h</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">g</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">f</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">composeN</span> <span class="n">functions</span> <span class="bp">=</span> <span class="n">h</span> <span class="bp">∘</span> <span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span><span class="o">[</span><span class="n">composeN</span><span class="o">,</span> <span class="n">forIn'</span><span class="o">,</span> <span class="n">Std.Range.forIn'</span><span class="o">,</span> <span class="n">Std.Range.forIn'.loop</span><span class="o">,</span> <span class="n">functions</span><span class="o">,</span> <span class="n">Id.run</span><span class="o">]</span>
</code></pre></div>
<p>formally  verified <span aria-label="tm" class="emoji emoji-2122" role="img" title="tm">:tm:</span></p>



<a name="318272835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318272835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318272835">(Dec 28 2022 at 15:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions/near/318265905">said</a>:</p>
<blockquote>
<p>Unfortunately, I don't know how to typecast <code>(fin 5) → (ℤ → ℤ)</code> to <code>list (ℤ → ℤ)</code>.</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.of_fn">docs#list.of_fn</a></p>



<a name="318273057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318273057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318273057">(Dec 28 2022 at 15:10)</a>:</h4>
<p>There might be a nice way to use <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cons_induction">docs#fin.cons_induction</a> here</p>



<a name="318273255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318273255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318273255">(Dec 28 2022 at 15:11)</a>:</h4>
<p>I updates my solution above. Thanks!</p>



<a name="318280134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318280134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318280134">(Dec 28 2022 at 15:55)</a>:</h4>
<p>Thanks to all</p>



<a name="318280366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318280366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318280366">(Dec 28 2022 at 15:56)</a>:</h4>
<p>I am surprised this is not in mathlib yet though as I would have guessed somebody should have needed this at some point</p>



<a name="318280681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318280681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318280681">(Dec 28 2022 at 15:58)</a>:</h4>
<p>I wonder if it should be pushed</p>



<a name="318290100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318290100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318290100">(Dec 28 2022 at 16:38)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span>, why not list.foldr to avoid the need to reverse?</p>



<a name="318290595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318290595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318290595">(Dec 28 2022 at 16:41)</a>:</h4>
<p>I doubt this is very useful to have in mathlib; if you're working frequently with functions from a type to itself, you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/function.End">docs#function.End</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">comp_n</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">function.End</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">list.of_fn</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span>
</code></pre></div>



<a name="318291312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318291312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318291312">(Dec 28 2022 at 16:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions/near/318290100">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span>, why not list.foldr to avoid the need to reverse?</p>
</blockquote>
<p>I can do <code>(list.of_fn f).reverse.foldr (∘) id</code> instead. But you probably meant something different, didn't you?</p>



<a name="318291667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318291667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318291667">(Dec 28 2022 at 16:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">list.of_fn</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">foldr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span> <span class="bp">∘</span> <span class="n">x</span><span class="o">)</span> <span class="n">id</span>
</code></pre></div>



<a name="318291723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318291723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318291723">(Dec 28 2022 at 16:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">list.of_fn</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span> <span class="bp">∘</span> <span class="n">x</span><span class="o">)</span> <span class="n">id</span>
</code></pre></div>



<a name="318291758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318291758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318291758">(Dec 28 2022 at 16:49)</a>:</h4>
<p>These four functions seem (but I haven't really checked it) to do the same.</p>



<a name="318291821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318291821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318291821">(Dec 28 2022 at 16:49)</a>:</h4>
<p>Either I reverse the list, or I reverse the sides of the composition.</p>



<a name="318291963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318291963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318291963">(Dec 28 2022 at 16:50)</a>:</h4>
<p>There doesn't seem to be a difference for our purpose between these two:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">foldl</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">[]</span>       <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">foldl</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">l</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">foldr</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="o">[]</span>       <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="o">(</span><span class="n">foldr</span> <span class="n">l</span><span class="o">)</span>
</code></pre></div>



<a name="318292333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318292333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318292333">(Dec 28 2022 at 16:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions/near/318290595">said</a>:</p>
<blockquote>
<p>I doubt this is very useful to have in mathlib; if you're working frequently with functions from a type to itself, you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/function.End">docs#function.End</a></p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">comp_n</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">function.End</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">list.of_fn</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Why is it named after endomorphisms and not just general unary operations?</p>



<a name="318307278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Cleanest%20way%20to%20compose%20arbitrary%20number%20of%20functions/near/318307278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions.html#318307278">(Dec 28 2022 at 18:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113489-new-members/topic/Cleanest.20way.20to.20compose.20arbitrary.20number.20of.20functions/near/318291723">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">list.of_fn</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span> <span class="bp">∘</span> <span class="n">x</span><span class="o">)</span> <span class="n">id</span>
</code></pre></div><br>
</p>
</blockquote>
<p><code>(list.of_fn f).foldl (flip (∘)) id</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
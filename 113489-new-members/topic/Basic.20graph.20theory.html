---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Basic.20graph.20theory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html">Basic graph theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="210310183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210310183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> modderme123 <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210310183">(Sep 16 2020 at 19:40)</a>:</h4>
<p>So I learned a little bit of lean through the natural numbers game, and I thought I would try to prove some basic graph theory proofs. I'm trying to prove that twice the sum of the edges is equal to the sum of the degrees in a simple graph. So far I have defined a graph (I've also created a complete graph and shown that is a graph), but I got stuck on the sum_degrees theorem</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">graph</span> <span class="o">:=</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span>
  <span class="o">(</span><span class="n">E_irreflexive</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">E</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">E_symmetric</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">E</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sum_fun</span> <span class="o">:</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="n">sum_fun</span><span class="o">(</span><span class="n">m</span><span class="o">)(</span><span class="n">n</span><span class="o">)</span>

<span class="n">def</span> <span class="n">edges</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="k">have</span> <span class="n">sum</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">sum_fun</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">sum_fun</span> <span class="o">(</span><span class="n">sum</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">degree</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="k">have</span> <span class="n">check_edge</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">exact</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="k">then</span> <span class="n">sum_fun</span> <span class="n">check_edge</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">sum_degrees</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">sum_fun</span> <span class="o">(</span><span class="n">degree</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">edges</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</code></pre></div>


<p>Any advice on how to start this theorem?</p>



<a name="210312018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210312018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210312018">(Sep 16 2020 at 19:54)</a>:</h4>
<p>A way I've proved this is with a combinatorial proof.  You can introduce an intermediate object, a <em>dart</em>, which is an ordered pair of adjacent vertices.  A dart is <em>at</em> a vertex if the vertex is the first entry of the pair, and you can show that the number of darts at a vertex is equal to the degree of the vertex --- then since darts are partitioned into which vertices they're at, you have the number of darts is equal to the sum of degrees.  There is a two-to-one map that sends darts to their corresponding edges, so the number of darts is equal to twice the number of edges.</p>



<a name="210312316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210312316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210312316">(Sep 16 2020 at 19:57)</a>:</h4>
<p>(Let me know if you want to be added to the private Zulip graph theory stream. There are a number of people working on formalizing graph theory in Lean.  Also, right now you can use the <code>combinatorics.simple_graph</code> library, which defines things like simple graphs and the degree of a vertex for a (locally) finite graph.  Your definition of a graph when <code>V = n</code> would be equivalent to <code>simple_graph (fin n)</code>.)</p>



<a name="210313984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210313984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210313984">(Sep 16 2020 at 20:09)</a>:</h4>
<p>Looking more carefully at your definitions, it looks like <code>edges</code> is counting the number of darts.  Adding in a definition that counts the number of edges, too, you might be able to use this setup:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">graph</span> <span class="o">:=</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">E_irreflexive</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">E</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">E_symmetric</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">E</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sum_fun</span> <span class="o">:</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">sum_fun</span> <span class="n">m</span> <span class="n">n</span>

<span class="n">def</span> <span class="n">edges</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">sum</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">sum_fun</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span>
<span class="k">in</span> <span class="n">sum_fun</span> <span class="n">sum</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span>

<span class="n">def</span> <span class="n">degree</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">check_edge</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
<span class="k">in</span> <span class="n">sum_fun</span> <span class="n">check_edge</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span>

<span class="n">def</span> <span class="n">darts</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">sum</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">sum_fun</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span>
<span class="k">in</span> <span class="n">sum_fun</span> <span class="n">sum</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span>

<span class="kn">lemma</span> <span class="n">darts_eq_twice_edges</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">darts</span> <span class="n">G</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">edges</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">darts_eq_sum_degrees</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">darts</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">sum_fun</span> <span class="o">(</span><span class="n">degree</span> <span class="n">G</span><span class="o">)</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">sum_degrees</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">sum_fun</span> <span class="o">(</span><span class="n">degree</span> <span class="n">G</span><span class="o">)</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">edges</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">darts_eq_sum_degrees</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">darts_eq_twice_edges</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="210314228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210314228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210314228">(Sep 16 2020 at 20:11)</a>:</h4>
<p>You'll have to prove a number of lemmas about <code>sum_fun</code> for transforming sums of indicator functions, I think.</p>



<a name="210328886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210328886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210328886">(Sep 16 2020 at 22:40)</a>:</h4>
<p>To get you started, I proved <code>darts_eq_twice_edges</code> and added a number of lemmas for <code>sum_fun</code>.  This also shows off a nice feature of Lean, where you can introduce your own notation --- I adapted the summation notation from <code>algebra.big_operators</code> for your <code>sum_fun</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">structure</span> <span class="n">graph</span> <span class="o">:=</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">E_irreflexive</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">E</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">E_symmetric</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">E</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sum_fun</span> <span class="o">:</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">sum_fun</span> <span class="n">m</span> <span class="n">n</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">∑</span><span class="bp">`</span> <span class="n">binders</span> <span class="bp">`</span> <span class="n">to</span> <span class="bp">`</span> <span class="n">n</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span><span class="o">:</span><span class="mi">67</span> <span class="n">f</span><span class="o">,</span> <span class="n">sum_fun</span> <span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span>
<span class="c1">-- this means `∑ x to n, foo` denotes `sum_fun (λ x, foo) n`</span>
<span class="c1">-- the `∑` is entered using \sum</span>

<span class="n">def</span> <span class="n">edges</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="n">def</span> <span class="n">degree</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="n">def</span> <span class="n">darts</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">sum_to_zero_eq</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">sum_zero_eq</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_to_zero_eq</span><span class="o">,</span>
  <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_add_eq_add_sum</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span>
    <span class="n">ring</span><span class="o">,</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_if_true</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">p</span> <span class="n">x</span> <span class="k">then</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">n_n</span> <span class="o">(</span><span class="n">lt_add_one</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">k</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hlt</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt</span><span class="bp">.</span><span class="n">step</span> <span class="n">hlt</span><span class="o">,</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_if_false</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">p</span> <span class="n">x</span> <span class="k">then</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">n_n</span> <span class="o">(</span><span class="n">lt_add_one</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">k</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hlt</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt</span><span class="bp">.</span><span class="n">step</span> <span class="n">hlt</span><span class="o">,</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_delta</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="k">then</span> <span class="n">f</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="n">generalizing</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="n">n_n</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">n_n</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">sum_if_false</span><span class="o">,</span>
      <span class="n">simp</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">y</span><span class="o">,</span> <span class="n">intros</span> <span class="n">hlt</span> <span class="n">heq</span><span class="o">,</span> <span class="n">subst</span> <span class="n">heq</span><span class="o">,</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_asymm</span> <span class="n">hlt</span> <span class="n">hlt</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h&#39;</span><span class="o">],</span>
      <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h_a</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_fun_restrict&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">sum_if_true</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_succ</span><span class="o">,</span>
    <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">m_ih</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span>
    <span class="n">exfalso</span><span class="o">,</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_fun_restrict</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">m</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">sum_fun_restrict&#39;</span> <span class="n">f</span> <span class="n">n</span> <span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="n">n</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_sub_of_le</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_congr</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">n_ih</span><span class="o">],</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt</span><span class="bp">.</span><span class="n">step</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">lt_add_one</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">swap_sum</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">m</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">m</span><span class="o">,</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="n">generalizing</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">sum_add_eq_add_sum</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">darts_eq_twice_edges</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">darts</span> <span class="n">G</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">edges</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">darts</span><span class="o">,</span> <span class="n">edges</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">),</span> <span class="n">sum_fun_restrict</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="o">(</span><span class="k">by</span> <span class="n">linarith</span><span class="o">),</span>
  <span class="n">dsimp</span> <span class="n">at</span> <span class="n">key</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_congr</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">key</span><span class="o">,</span> <span class="n">clear</span> <span class="n">key</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="k">then</span> <span class="o">(</span><span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="k">if</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">yel</span><span class="o">,</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">cc</span> <span class="o">}</span> <span class="o">},</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">key&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="k">then</span> <span class="o">(</span><span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">xel</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">sum_congr</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">key</span> <span class="n">x</span><span class="o">),</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">sum_congr</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">key&#39;</span><span class="o">,</span> <span class="n">clear</span> <span class="n">key</span> <span class="n">key&#39;</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">y</span> <span class="n">x</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="k">if</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">xel</span> <span class="n">y</span> <span class="n">yel</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:=</span> <span class="n">G</span><span class="bp">.</span><span class="n">E_symmetric</span> <span class="n">x</span> <span class="n">y</span> <span class="n">xel</span> <span class="n">yel</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">],</span>
    <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">cc</span> <span class="o">}</span> <span class="o">},</span>
    <span class="n">exfalso</span><span class="o">,</span> <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_asymm</span> <span class="n">h_1</span> <span class="n">h_2</span><span class="o">,</span>
    <span class="n">exfalso</span><span class="o">,</span> <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h_1</span><span class="o">,</span> <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h_2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">le_iff_eq_or_lt</span> <span class="n">at</span> <span class="n">h_1</span> <span class="n">h_2</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h_1</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">h_2</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">x</span> <span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">subst</span> <span class="n">y</span> <span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">G</span><span class="bp">.</span><span class="n">E_irreflexive</span> <span class="bp">_</span> <span class="n">yel</span> <span class="n">h</span> <span class="o">},</span>
    <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_asymm</span> <span class="n">h_1</span> <span class="n">h_2</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">y</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">revert</span> <span class="n">h</span><span class="o">,</span> <span class="n">contrapose</span><span class="o">,</span> <span class="n">push_neg</span><span class="o">,</span> <span class="n">exact</span> <span class="n">G</span><span class="bp">.</span><span class="n">E_symmetric</span> <span class="n">y</span> <span class="n">x</span> <span class="n">yel</span> <span class="n">xel</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">],</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">key&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">y</span> <span class="n">x</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">+</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">xel</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">sum_congr</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">key</span> <span class="n">x</span> <span class="n">xel</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">sum_add_eq_add_sum</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">sum_congr</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">key&#39;</span><span class="o">,</span> <span class="n">clear</span> <span class="n">key</span> <span class="n">key&#39;</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_add_eq_add_sum</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">swap_sum</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">two_mul</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">darts_eq_sum_degrees</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">darts</span> <span class="n">G</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="n">degree</span> <span class="n">G</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">sum_degrees</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="n">degree</span> <span class="n">G</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">edges</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">darts_eq_sum_degrees</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">darts_eq_twice_edges</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="210329015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210329015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210329015">(Sep 16 2020 at 22:41)</a>:</h4>
<p>I'm sure the proof can be simplified by quite a bit.  It's just suggesting that there aren't enough lemmas to manipulate <code>sum_fun</code> yet!</p>



<a name="210329129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210329129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210329129">(Sep 16 2020 at 22:43)</a>:</h4>
<p>Oh, that's funny. I didn't realize that everything was set up to completely prove it!  It's just</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">darts_eq_sum_degrees</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">darts</span> <span class="n">G</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="n">degree</span> <span class="n">G</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="210329328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210329328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> modderme123 <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210329328">(Sep 16 2020 at 22:46)</a>:</h4>
<p>Wow, this is awesome!</p>



<a name="210331067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210331067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210331067">(Sep 16 2020 at 23:10)</a>:</h4>
<p>Found a way to simplify it somewhat.  Using <code>apply sum_congr</code> makes it so Lean tells you what needs to be proved, rather you than needing to tell Lean the statement with <code>have</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">structure</span> <span class="n">graph</span> <span class="o">:=</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">E_irreflexive</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">E</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">E_symmetric</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">E</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sum_fun</span> <span class="o">:</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">m</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">m</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">sum_fun</span> <span class="n">m</span> <span class="n">n</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="err">∑</span><span class="bp">`</span> <span class="n">binders</span> <span class="bp">`</span> <span class="n">to</span> <span class="bp">`</span> <span class="n">n</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span><span class="o">:</span><span class="mi">67</span> <span class="n">f</span><span class="o">,</span> <span class="n">sum_fun</span> <span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span>
<span class="c1">-- this means `∑ x to n, foo` denotes `sum_fun (λ x, foo) n`</span>
<span class="c1">-- the `∑` is entered using \sum</span>

<span class="n">def</span> <span class="n">edges</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="n">def</span> <span class="n">degree</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="n">def</span> <span class="n">darts</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">sum_to_zero_eq</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="mi">0</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">sum_zero_eq</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_to_zero_eq</span><span class="o">,</span>
  <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_add_eq_add_sum</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span>
    <span class="n">ring</span><span class="o">,</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_if_true</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">p</span> <span class="n">x</span> <span class="k">then</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">n_n</span> <span class="o">(</span><span class="n">lt_add_one</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">k</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hlt</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt</span><span class="bp">.</span><span class="n">step</span> <span class="n">hlt</span><span class="o">,</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_if_false</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="k">if</span> <span class="n">p</span> <span class="n">x</span> <span class="k">then</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">n_n</span> <span class="o">(</span><span class="n">lt_add_one</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">k</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hlt</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt</span><span class="bp">.</span><span class="n">step</span> <span class="n">hlt</span><span class="o">,</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_fun_restrict&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">sum_if_true</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_succ</span><span class="o">,</span>
    <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">m_ih</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span>
    <span class="n">exfalso</span><span class="o">,</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_fun_restrict</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">m</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">sum_fun_restrict&#39;</span> <span class="n">f</span> <span class="n">n</span> <span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="n">n</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_sub_of_le</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">sum_congr</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">n_ih</span><span class="o">],</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt</span><span class="bp">.</span><span class="n">step</span> <span class="n">h&#39;</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">lt_add_one</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">swap_sum</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">m</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">y</span> <span class="n">to</span> <span class="n">m</span><span class="o">,</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="n">generalizing</span> <span class="n">m</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dunfold</span> <span class="n">sum_fun</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">sum_add_eq_add_sum</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">n_ih</span><span class="o">,</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">indic_indic_eq_and</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">b</span><span class="o">]:</span>
  <span class="o">(</span><span class="k">if</span> <span class="n">a</span> <span class="k">then</span> <span class="o">(</span><span class="k">if</span> <span class="n">b</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="k">if</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">b</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">cc</span> <span class="o">}</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">darts_eq_twice_edges</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">darts</span> <span class="n">G</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">edges</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">darts</span><span class="o">,</span> <span class="n">edges</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">),</span> <span class="n">sum_fun_restrict</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="o">(</span><span class="k">by</span> <span class="n">linarith</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">sum_congr</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">key</span><span class="o">,</span> <span class="n">clear</span> <span class="n">key</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">two_mul</span><span class="o">,</span>
  <span class="n">conv_rhs</span> <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">rw</span> <span class="n">swap_sum</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">sum_add_eq_add_sum</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">sum_congr</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">xel</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">sum_add_eq_add_sum</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">sum_congr</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">y</span> <span class="n">yel</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">G</span><span class="bp">.</span><span class="n">E_symmetric</span> <span class="n">x</span> <span class="n">y</span> <span class="n">xel</span> <span class="n">yel</span> <span class="n">h</span><span class="o">],</span>
  <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">refl</span> <span class="bp">&lt;|&gt;</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">cc</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">exfalso</span><span class="o">,</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_asymm</span> <span class="n">h_1</span> <span class="n">h_2</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span> <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h_1</span><span class="o">,</span> <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h_2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="n">subst</span> <span class="n">x</span><span class="o">,</span> <span class="n">exact</span> <span class="n">G</span><span class="bp">.</span><span class="n">E_irreflexive</span> <span class="bp">_</span> <span class="n">yel</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="n">y</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">revert</span> <span class="n">h</span><span class="o">,</span> <span class="n">contrapose</span><span class="o">,</span> <span class="n">push_neg</span><span class="o">,</span> <span class="n">exact</span> <span class="n">G</span><span class="bp">.</span><span class="n">E_symmetric</span> <span class="n">y</span> <span class="n">x</span> <span class="n">yel</span> <span class="n">xel</span> <span class="o">},</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">],</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">darts_eq_sum_degrees</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="n">darts</span> <span class="n">G</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="n">degree</span> <span class="n">G</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">sum_degrees</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span><span class="o">)</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">x</span> <span class="n">to</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">,</span> <span class="n">degree</span> <span class="n">G</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">edges</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">darts_eq_sum_degrees</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">darts_eq_twice_edges</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="210350679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210350679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> toc <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210350679">(Sep 17 2020 at 05:54)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I'd like to be added to the secret graph theory group. I'm a bit of a novice at lean still but that is (roughly) my focus.</p>



<a name="210868631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210868631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anton Lorenzen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210868631">(Sep 22 2020 at 13:23)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I would also like to be part of the graph theory stream</p>



<a name="210902270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/210902270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#210902270">(Sep 22 2020 at 17:15)</a>:</h4>
<p>Done!</p>



<a name="212914265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212914265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Lehéricy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212914265">(Oct 10 2020 at 12:42)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I would like to be added to the graph theory stream please!</p>



<a name="212914919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212914919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212914919">(Oct 10 2020 at 13:02)</a>:</h4>
<p>Welcome Thomas!</p>



<a name="212914938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212914938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212914938">(Oct 10 2020 at 13:03)</a>:</h4>
<p>Don't play too much with graphs, probability theory in mathlib needs you!</p>



<a name="212915454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212915454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Lehéricy <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212915454">(Oct 10 2020 at 13:13)</a>:</h4>
<p>Thank you Patrick! <br>
I know :) I have two goals for now, one is doing a bit of deterministic planar map theory (proving some bijection between different classes of maps), and the second is to try to prove Donsker's invariance principle. Both would be useful for random planar maps. It seemed the graph theory half was more accessible as a warm-up.</p>



<a name="212930995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212930995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212930995">(Oct 10 2020 at 19:25)</a>:</h4>
<p><span class="user-mention" data-user-id="337939">@Thomas Lehéricy</span> It appears you've been added! The stream has been rather quiet since the beginning of the semester, though.</p>
<p>I'd like the theory of combinatorial maps in general, which generalizes planar maps to graphs on surfaces of arbitrary genus (you could say a combinatorial map is a multigraph with faces attached such that the result is a closed oriented surface, possibly disconnected).  I have a couple ways of encoding them, but I wanted to see how the simple graphs API would work out, to then inform the design of the multigraphs API, to then inform the design of the combinatorial maps API.  Plus, many results can be lifted from one to the next, so it seems to be a good order to do things.</p>
<p>(Once all three exist, we can say we can state the 4-color theorem.  A finite simple graph is <em>planar</em> if it comes from a combinatorial map of genus 0.  The theorem is that every planar simple graph has a proper vertex 4-coloring.)</p>
<p>Somewhere I have most of the formalization of Sperner's lemma with some early attempts at multigraphs and combinatorial maps, but to finish it it'd be nice to flesh them out more.</p>



<a name="212931067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212931067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212931067">(Oct 10 2020 at 19:27)</a>:</h4>
<p>We've got quite the backlog of PRs at the moment, but is there a plan for the next few graph theory PRs yet?</p>



<a name="212931072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212931072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212931072">(Oct 10 2020 at 19:27)</a>:</h4>
<p>I still don't understand why this stream is private.</p>



<a name="212931380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212931380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212931380">(Oct 10 2020 at 19:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I'm not sure.  <span class="user-mention" data-user-id="252300">@Jalex Stark</span>, any reason to keep it private anymore?</p>



<a name="212931464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212931464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212931464">(Oct 10 2020 at 19:36)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> Not immediately from me... Teaching and postdoc applications have taken priority...  There is a quasi-plan for PRs in a post on the <a class="stream" data-stream-id="252551" href="/#narrow/stream/252551-graph-theory">#graph theory</a> stream though.</p>



<a name="212931711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212931711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212931711">(Oct 10 2020 at 19:43)</a>:</h4>
<p>I think there was some value to it being private in the past and now it's clearly better as a public stream. I've made the change.</p>



<a name="212931757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212931757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212931757">(Oct 10 2020 at 19:44)</a>:</h4>
<p>I've also been planning on writing up at least a blog post on the different ways of dealing with subgraphs-as-graphs so that they can be more easily evaluated.  I've swapped out different designs on the <code>simple_graphs2</code> branch a few times, and it's always been relatively painless, so that at least indicates that we won't be locked into a design if a better one comes up.</p>



<a name="212931775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212931775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212931775">(Oct 10 2020 at 19:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/210826149">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/210822743">said</a>:</p>
<blockquote>
<p>What do you think the next PR from this branch should be?</p>
</blockquote>
<p>Most of <code>simple_graph/basic.lean</code> seems good, except for the incomplete stuff about graph operations.  Some simp lemmas relating <code>simple_graph_on</code> to <code>simple_graph</code> might not make sense.  Also <code>simple_graph_from_rel_adj</code> can probably wait.</p>
<p>The definitions in <code>simple_graph/hom.lean</code> seem fine, but the lemmas should be reviewed since the api is underutilized and seems somewhat incomplete.</p>
<p><code>simple_graph/subgraph.lean</code> seems good, except for things about cycles and maybe induced graphs.  Cardinality results should be reviewed -- there's no application of them yet so the design might not be good.</p>
<p><code>simple_graph/simple_graph_on.lean</code> is fine enough. It could certainly be expanded, but it at least has a <code>bounded_lattice</code> instance.</p>
<p><code>simple_graph/degree_sum.lean</code> is close, but I think it can still be simplified a lot given a person sufficiently competent with <code>big_operators</code>.  It also would be nice to have an explicit handshake lemma.</p>
</blockquote>
<p>I think this is the quasiplan that kyle referred to</p>



<a name="212931876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212931876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212931876">(Oct 10 2020 at 19:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20graph.20theory/near/212931711">said</a>:</p>
<blockquote>
<p>I think there was some value to it being private in the past and now it's clearly better as a public stream. I've made the change.</p>
</blockquote>
<p>Are you sure you changed it?</p>



<a name="212932031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212932031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212932031">(Oct 10 2020 at 19:53)</a>:</h4>
<p>I no longer see a "lock" icon next to the stream: <a href="#narrow/stream/252551-graph-theory">https://leanprover.zulipchat.com/#narrow/stream/252551-graph-theory</a></p>



<a name="212932036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212932036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212932036">(Oct 10 2020 at 19:54)</a>:</h4>
<p>When I click your link, Zulip says "This stream does not exist or is private."</p>



<a name="212932080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212932080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212932080">(Oct 10 2020 at 19:54)</a>:</h4>
<p>It says "public stream" in the stream settings for me</p>



<a name="212932083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212932083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212932083">(Oct 10 2020 at 19:54)</a>:</h4>
<p>Strange: <a href="/user_uploads/3121/PJhBnwt-GsOHKY44C1FH_7sn/Screen-Shot-2020-10-10-at-3.54.36-PM.png">Screen-Shot-2020-10-10-at-3.54.36-PM.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/PJhBnwt-GsOHKY44C1FH_7sn/Screen-Shot-2020-10-10-at-3.54.36-PM.png" title="Screen-Shot-2020-10-10-at-3.54.36-PM.png"><img src="/user_uploads/3121/PJhBnwt-GsOHKY44C1FH_7sn/Screen-Shot-2020-10-10-at-3.54.36-PM.png"></a></div>



<a name="212932097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212932097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212932097">(Oct 10 2020 at 19:55)</a>:</h4>
<p>Weird.</p>



<a name="212932100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212932100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212932100">(Oct 10 2020 at 19:55)</a>:</h4>
<p>I force reloaded the page and it works now!</p>



<a name="212932169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212932169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212932169">(Oct 10 2020 at 19:57)</a>:</h4>
<p>A caveat about that plan: the graph operations of contraction/deletion of graphs are not formalized correctly to be useful for anything to do with studying graph minors yet.  There's a way to encode the type of all contractions and deletions with some nice properties, but it will take some development before it's ready.  (Here's the idea for matroids, where it's simpler: the type consists of a pair of subsets C and F of the ground set, where C is a subset of F.  Then the way in which it is a matroid is you restrict to F and then contract by C.  It seems to let you easily state relationships between contractions, deletions, and duals using equality.  Graphs are somewhat more complicated because, for example, isolated vertices matter.)</p>



<a name="212932309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212932309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212932309">(Oct 10 2020 at 20:01)</a>:</h4>
<p>I'd love to see a few matroid PRs as well. I got stuck on contractions and deletions in <a href="https://github.com/bryangingechen/lean-matroids">my old matroids repo</a> and never had a chance to go back and figure them out.</p>



<a name="212932431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212932431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212932431">(Oct 10 2020 at 20:04)</a>:</h4>
<p><span class="user-mention" data-user-id="329425">@Peter Nelson</span> and Edward Lee (who doesn't seem to be on Zulip) are still working on them</p>



<a name="212938730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212938730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212938730">(Oct 10 2020 at 23:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20graph.20theory/near/212930995">said</a>:</p>
<blockquote>
<p>A finite simple graph is <em>planar</em> if it comes from a combinatorial map of genus 0.</p>
</blockquote>
<p>Surely it's planar if it can be drawn in the plane without edges crossing (and likewise for embeddings in surfaces of other genus); that should be easy to state right now, and reflects what I'd think of as the common understanding of what it means for a graph to be planar. You might then need the Jordan curve theorem or related results to prove that being planar is equivalent to characterisations that are more convenient to work with combinatorially, however.</p>



<a name="212939085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212939085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212939085">(Oct 10 2020 at 23:10)</a>:</h4>
<p>I believe that when Gonthier proved the four colour theorem in Coq he reduced everything to the setting where all paths were contained in the union of the lines x=integer and y=integer on the plane and all areas were unions of squares.</p>



<a name="212939289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212939289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212939289">(Oct 10 2020 at 23:16)</a>:</h4>
<p>I knew someone would object to this characterization of planar graphs <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>. 2D topology is very well behaved.  Topological, smooth, and PL topology are basically equivalent, so, up to homeomorphism, you can just write down the cell structure, which is what the combinatorial map is.  I'm pretty sure it's easier to state everything in terms of the combinatorial data of the cell structure (it can be given as two permutations on the same set, one a fixedpoint-free involution), and the genus is easy to calculate for it.   Someone can then prove the correspondence between this notion of planarity and the topological one later -- I'm not sure you really gain anything by worrying about topological planarity of a graph for the 4-color theorem.</p>



<a name="212939628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/212939628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#212939628">(Oct 10 2020 at 23:27)</a>:</h4>
<p>Cf. the discussions of how it shouldn't really matter which of several different equivalent properties is considered to be "the" definition, but formalisation forces you to pick just one (and then proving that they are all equivalent becomes part of filling out the API and justifying that your definition defines the same thing as someone else's concept of "the" definition).</p>



<a name="216824926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/216824926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Haden Hooyeon Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#216824926">(Nov 16 2020 at 01:27)</a>:</h4>
<p>Hello! I just finished the natural number game (again! things have changed a lot over the past year I guess). <br>
I'm looking for resources/tutorials that are relevant to basic graph theory. I see that <a class="stream" data-stream-id="252551" href="/#narrow/stream/252551-graph-theory">#graph theory</a> stream exists so I'm following it, but are there resources like the natural number game that can help me get my hands dirty? thanks!</p>



<a name="216837830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/216837830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#216837830">(Nov 16 2020 at 06:58)</a>:</h4>
<p>We don't have anything like the NNG for graph theory... the NNG is pretty unique in this regard</p>



<a name="216837855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/216837855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#216837855">(Nov 16 2020 at 06:59)</a>:</h4>
<p>graph theory is a pretty tricky subject for formalisation, because there are 37 different variations on the definition of a graph.</p>



<a name="221484875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221484875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Krenn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221484875">(Jan 04 2021 at 02:57)</a>:</h4>
<p>Hi! I am interested in Lean, but havent really used it, just want to understand the structures and progress atm. I am interested to see some simple graph theory in Lean mathlib. I was refered to this:<br>
<a href="https://github.com/leanprover-community/mathlib/tree/hedetniemi/src">https://github.com/leanprover-community/mathlib/tree/hedetniemi/src</a></p>
<p>This branch is not included in the main repo, is it? Is there a reason for that? It seems the graph theory project in the link above hasnt been used for hte last 9months. Any plans of implementing this into the main library? Thanks!</p>



<a name="221485634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221485634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221485634">(Jan 04 2021 at 03:16)</a>:</h4>
<p>There is a secret graph theory stream, I think. If you join that then you might get a clearer idea of what's going on.</p>



<a name="221486087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221486087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Krenn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221486087">(Jan 04 2021 at 03:29)</a>:</h4>
<p>Oh super interesting. How could i join?</p>



<a name="221486167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221486167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221486167">(Jan 04 2021 at 03:30)</a>:</h4>
<p>it's not really secret anymore</p>



<a name="221486177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221486177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221486177">(Jan 04 2021 at 03:30)</a>:</h4>
<p>you can find it in the zulip stream list</p>



<a name="221486182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221486182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221486182">(Jan 04 2021 at 03:31)</a>:</h4>
<p><a class="stream" data-stream-id="252551" href="/#narrow/stream/252551-graph-theory">#graph theory</a></p>



<a name="221486371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221486371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Krenn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221486371">(Jan 04 2021 at 03:35)</a>:</h4>
<p>great thanks! will observe a bit and hope this gives an interesting entry point :)</p>



<a name="221491599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221491599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221491599">(Jan 04 2021 at 05:52)</a>:</h4>
<p><span class="user-mention" data-user-id="297962">@Mario Krenn</span> the basic stuff from the <code>hedetniemi</code> branch is now in mathlib. But not the stuff in the direction of Hedetniemi itself. We got stuck in some stuff about random graphs. And then I got side-tracked by tons of other stuff. I'm not actually working with graphs myself, but if someone who actually knows something about random graphs would take that on, I think it would be a lot of fun.</p>



<a name="221501625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221501625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Krenn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221501625">(Jan 04 2021 at 09:02)</a>:</h4>
<p>I dont know much about random graphs. But i would take a certain, simple proof in graph theory (about a property of perfect matchings) as motivation to learn using Lean. The simple property is used in quantum physics, which is my field of research, so when spending time on Lean i still can cheat myself that i work on my research :) I will come back here for sure with questions as soon as i managed the most basic examples. Thanks!</p>



<a name="221528379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221528379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221528379">(Jan 04 2021 at 14:25)</a>:</h4>
<p><span class="user-mention" data-user-id="297962">@Mario Krenn</span> cool, you should certainly talk with the people in the graph theory stream (-;</p>



<a name="221529288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221529288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221529288">(Jan 04 2021 at 14:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20graph.20theory/near/221491599">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="297962">Mario Krenn</span> the basic stuff from the <code>hedetniemi</code> branch is now in mathlib. But not the stuff in the direction of Hedetniemi itself. We got stuck in some stuff about random graphs. And then I got side-tracked by tons of other stuff. I'm not actually working with graphs myself, but if someone who actually knows something about random graphs would take that on, I think it would be a lot of fun.</p>
</blockquote>
<p>Since I had recent success with probability in combinatorics with the ballot problem and past success in using random graphs to show lower Ramsey bounds, I'm working on showing that there are graphs with arbitrarily high girth and chromatic number (which I think was the missing bit in Hedetniemi?) together with <span class="user-mention" data-user-id="303889">@Alena Gusakov</span></p>



<a name="221529483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221529483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221529483">(Jan 04 2021 at 14:33)</a>:</h4>
<p>That's cool news!</p>



<a name="221529496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221529496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221529496">(Jan 04 2021 at 14:33)</a>:</h4>
<p>That was indeed the main missing bit.</p>



<a name="221578166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/221578166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#221578166">(Jan 04 2021 at 20:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="297962">Mario Krenn</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20graph.20theory/near/221501625">said</a>:</p>
<blockquote>
<p>I dont know much about random graphs. But i would take a certain, simple proof in graph theory (about a property of perfect matchings) as motivation to learn using Lean. The simple property is used in quantum physics, which is my field of research, so when spending time on Lean i still can cheat myself that i work on my research :) I will come back here for sure with questions as soon as i managed the most basic examples. Thanks!</p>
</blockquote>
<p>Perfect matchings for simple graphs recently were added to mathlib <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.matching.is_perfect">docs#simple_graph.matching.is_perfect</a> (there are some branches that have some more code that should get PRd sometime soon).  What about perfect matchings are you interested in formalizing?  Feel free to answer this in a new topic over at <a class="stream" data-stream-id="252551" href="/#narrow/stream/252551-graph-theory">#graph theory</a>!</p>



<a name="231971617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/231971617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#231971617">(Mar 26 2021 at 14:16)</a>:</h4>
<p>Has there been any progress on subgraphs? I'd find it useful for some code I'm writing, and am happy to help with the PR, but not sure what the possible approaches are and the advantages/disadvantages</p>



<a name="231972924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/231972924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#231972924">(Mar 26 2021 at 14:25)</a>:</h4>
<p>Maybe we can use the new <code>set_like</code> to define them</p>



<a name="231973068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/231973068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#231973068">(Mar 26 2021 at 14:26)</a>:</h4>
<p>And give <code>set_like</code> some additional power about <code>closure</code></p>



<a name="231974074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/231974074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#231974074">(Mar 26 2021 at 14:32)</a>:</h4>
<p>is <a href="https://github.com/leanprover-community/mathlib/blob/2bef33c0e7ea7b4adb3a340adc00eed86f992fc3/src/data/set_like.lean">this</a> what you're on about?</p>



<a name="231974147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/231974147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#231974147">(Mar 26 2021 at 14:32)</a>:</h4>
<p>wait I can say <a href="https://github.com/leanprover-community/mathlib/issues/6768">#6768</a> and that links it I think</p>



<a name="231974345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/231974345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#231974345">(Mar 26 2021 at 14:33)</a>:</h4>
<p>that seems really useful if it works though, sub objects have been more annoying than expected the few times that I've used them</p>



<a name="231975228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/231975228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#231975228">(Mar 26 2021 at 14:38)</a>:</h4>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> what kind of subgraphs do you have in mind? <code>set_like</code> should be good for induced subgraphs</p>



<a name="231977719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/231977719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#231977719">(Mar 26 2021 at 14:51)</a>:</h4>
<p>I wanted the general-case (I'm studying a graph parameter that is monotonic on subgraphs) but it's no big deal regardless; there was one comment a while ago:</p>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20graph.20theory/near/212931757">said</a>:</p>
<blockquote>
<p>I've also been planning on writing up at least a blog post on the different ways of dealing with subgraphs-as-graphs so that they can be more easily evaluated.  I've swapped out different designs on the <code>simple_graphs2</code> branch a few times, and it's always been relatively painless, so that at least indicates that we won't be locked into a design if a better one comes up.</p>
</blockquote>
<p>that mentioned there was issues with different approaches so wanted to see what they were before getting stuck in writing code</p>



<a name="232050958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20graph%20theory/near/232050958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Basic.20graph.20theory.html#232050958">(Mar 27 2021 at 00:56)</a>:</h4>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> -- <span class="user-mention" data-user-id="329425">@Peter Nelson</span> has been working with matroids, including submatroids, contraction, deletion, etc, using the following definition:<br>
<a href="https://github.com/e45lee/lean-matroids/blob/master/src/matroid/submatroid/matroid_in.lean#L18">https://github.com/e45lee/lean-matroids/blob/master/src/matroid/submatroid/matroid_in.lean#L18</a><br>
Maybe he can comment on whether this would be a good choice for graphs.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
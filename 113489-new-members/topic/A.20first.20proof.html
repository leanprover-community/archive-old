---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/A.20first.20proof.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html">A first proof</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="291132451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291132451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calvin Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291132451">(Jul 28 2022 at 02:05)</a>:</h4>
<p>Hello!<br>
I have a bit of (programming) experience in Lean4 and theorem proving experience in Agda/Coq but I'm new to Lean3.<br>
I'm currently trying to show that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi mathvariant="normal">/</mi><mi>I</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">M/IM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">R/I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>-module.</p>
<p>Here is my first attempt at a lean3 proof to show that the scalar multiplication is well defined, I'm hoping some of you could give me some pointers on things I could do better going forward, since working with setoids here was a bit rough (and appears to be just as bad when defining the module laws).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>
<span class="kd">instance</span> <span class="n">quotient_over_ideal_smul_residue</span> <span class="o">:</span> <span class="n">has_smul</span> <span class="o">(</span><span class="n">R</span> <span class="bp">⧸</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="bp">⧸</span> <span class="o">(</span><span class="n">I</span> <span class="bp">•</span> <span class="bp">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">⟨</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="n">quotient.lift_on₂'</span> <span class="n">r</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">submodule.quotient.mk</span> <span class="bp">$</span> <span class="n">r</span> <span class="bp">•</span> <span class="n">m</span><span class="o">)</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">r₁</span> <span class="n">m₁</span> <span class="n">r₂</span> <span class="n">m₂</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">unfold</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">submodule.quotient.eq</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span> <span class="bp">+</span> <span class="o">(</span><span class="n">r₁</span> <span class="bp">-</span> <span class="n">r₂</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ring</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">clear</span> <span class="n">this</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">r₂</span> <span class="bp">+</span> <span class="o">(</span><span class="n">r₁</span> <span class="bp">-</span> <span class="n">r₂</span><span class="o">))</span><span class="bp">•</span><span class="n">m₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="bp">•</span><span class="n">m₁</span> <span class="bp">+</span> <span class="o">(</span><span class="n">r₁</span> <span class="bp">-</span> <span class="n">r₂</span><span class="o">)</span><span class="bp">•</span><span class="n">m₁</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">add_smul</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">clear</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">add_sub_right_comm</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">submodule.add_mem</span> <span class="o">(</span><span class="n">I</span> <span class="bp">•</span> <span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)),</span>
    <span class="o">{</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">m₁</span> <span class="bp">=</span> <span class="n">m₂</span> <span class="bp">+</span> <span class="o">(</span><span class="n">m₁</span> <span class="bp">-</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">eq_add_of_sub_eq'</span> <span class="n">rfl</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">,</span> <span class="n">add_sub_right_comm</span><span class="o">,</span> <span class="n">add_comm_group.sub_eq_add_neg</span><span class="o">,</span> <span class="n">add_neg_self</span><span class="o">,</span> <span class="n">zero_add</span> <span class="o">],</span>
      <span class="n">clear</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">apply</span> <span class="o">(</span><span class="n">submodule.smul_mem'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">rw</span> <span class="n">submodule.quotient_rel_r_def</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
      <span class="n">assumption</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">apply</span> <span class="n">submodule.smul_mem_smul</span><span class="o">,</span>
      <span class="o">{</span>
        <span class="n">rw</span> <span class="bp">←</span> <span class="n">quotient.eq'</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>
        <span class="n">rw</span> <span class="bp">←</span> <span class="n">ideal.quotient.eq</span><span class="o">,</span>
        <span class="n">assumption</span><span class="o">,</span>
      <span class="o">},</span>
      <span class="o">{</span>
        <span class="n">exact</span> <span class="n">submodule.mem_top</span><span class="o">,</span>
      <span class="o">},</span>
    <span class="o">},</span>
  <span class="kd">end</span><span class="o">⟩</span>
</code></pre></div>



<a name="291135501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291135501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291135501">(Jul 28 2022 at 03:03)</a>:</h4>
<p>This is a great start! The data all seems good to me so far! I golfed your proof just a bit... I hope this illustrates some useful Lean3/mathlib tricks.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.ideal.quotient</span>
<span class="kn">import</span> <span class="n">algebra.category.Module.abelian</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">quotient_over_ideal_smul_residue</span> <span class="o">:</span> <span class="n">has_smul</span> <span class="o">(</span><span class="n">R</span> <span class="bp">⧸</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="bp">⧸</span> <span class="o">(</span><span class="n">I</span> <span class="bp">•</span> <span class="bp">⊤</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">⟨</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="n">quotient.lift_on₂'</span> <span class="n">r</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">r'</span> <span class="n">m'</span><span class="o">,</span> <span class="n">submodule.quotient.mk</span> <span class="o">(</span><span class="n">r'</span> <span class="bp">•</span> <span class="n">m'</span><span class="o">))</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">r₁</span> <span class="n">m₁</span> <span class="n">r₂</span> <span class="n">m₂</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">quotient.eq'</span> <span class="n">at</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">at</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">erw</span> <span class="n">quotient_add_group.mk'_eq_mk'</span> <span class="n">at</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span><span class="n">hm</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span><span class="n">hn</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">dsimp</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">smul_add</span><span class="o">,</span> <span class="n">add_smul</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">],</span>
    <span class="n">symmetry</span><span class="o">,</span> <span class="n">convert</span> <span class="n">add_zero</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">submodule.quotient.mk_smul</span><span class="o">,</span> <span class="bp">←</span> <span class="n">submodule.quotient.mk_add</span><span class="o">],</span>
    <span class="n">rw</span> <span class="n">submodule.quotient.mk_eq_zero</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">submodule.add_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">submodule.add_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">refine</span> <span class="n">submodule.smul_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hn</span> <span class="o">},</span>
    <span class="n">all_goals</span> <span class="o">{</span> <span class="n">refine</span> <span class="n">submodule.smul_mem_smul</span> <span class="n">hm</span> <span class="n">trivial</span><span class="o">,</span> <span class="o">},</span>
  <span class="kd">end</span> <span class="o">⟩</span>
</code></pre></div>



<a name="291138361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291138361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calvin Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291138361">(Jul 28 2022 at 03:59)</a>:</h4>
<p>Thank you!<br>
I have a few questions (and thanks for <code>obtain</code> I really needed that but couldn't find it)<br>
Doesn't this use nonterminal simps in several places? I've heard that could be an issue</p>



<a name="291151218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291151218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291151218">(Jul 28 2022 at 07:53)</a>:</h4>
<p><code>simp only</code> is OK, since it explicitly lists what is going to happen. <code>dsimp</code> is usually also fine because the result of simplifying is guaranteed to be definitionally equal, although I prefer <code>dsimp only</code>.</p>



<a name="291151808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291151808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291151808">(Jul 28 2022 at 08:00)</a>:</h4>
<p>You can also see how it is done in mathlib here: <a href="https://leanprover-community.github.io/mathlib_docs/find/module.has_quotient.quotient.module">docs#module.has_quotient.quotient.module</a>.</p>



<a name="291153403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291153403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291153403">(Jul 28 2022 at 08:20)</a>:</h4>
<p>It's annoying that <code>squeeze_dsimp</code> usually doesn't return a valid result ...</p>



<a name="291226655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291226655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291226655">(Jul 28 2022 at 17:34)</a>:</h4>
<p>Yes, you mean it suggests <code>dsimp only</code> but <code>dsimp only</code> doesn't work? I've seen this many times. Does the output of <code>show_term {dsimp}</code> make any sense?</p>



<a name="291232574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291232574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291232574">(Jul 28 2022 at 18:25)</a>:</h4>
<blockquote>
<p>Yes, you mean it suggests dsimp only but dsimp only doesn't work?</p>
</blockquote>
<p>Yes exactly. I never tried <code>show_term</code>; I thought it must be used with a block of tactics that solve the goal!</p>



<a name="291232681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291232681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291232681">(Jul 28 2022 at 18:26)</a>:</h4>
<p><code>show_term {dsimp}</code> should work fine in a tactic proof. It might give you an awful mess though, I never tried. This only occurred to me recently, and I've not had <code>squeeze_dsimp</code> fail on me since I had the idea.</p>



<a name="291240482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291240482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Calvin Lee <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291240482">(Jul 28 2022 at 19:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/113489-new-members/topic/A.20first.20proof/near/291151808">said</a>:</p>
<blockquote>
<p>You can also see how it is done in mathlib here: <a href="https://leanprover-community.github.io/mathlib_docs/find/module.has_quotient.quotient.module">docs#module.has_quotient.quotient.module</a>.</p>
</blockquote>
<p>OMG i tried looking for this for so long and couldn't find it</p>



<a name="291241627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291241627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291241627">(Jul 28 2022 at 19:40)</a>:</h4>
<p><code>show_term {dsimp}</code> just returns <code>refine id _</code> ... at least in <a href="https://github.com/leanprover-community/mathlib/pull/15681/files#diff-8d28e1c85b22df3c99f61de0a89bc1e7ba35a56eae6db74bcdec15750d007e50R80">this case</a>. If I use <code>set_option pp.implicit true</code> it returns something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">refine</span> <span class="bp">@</span><span class="n">id</span>
  <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">×</span> <span class="o">({</span><span class="n">j</span> <span class="bp">//</span> <span class="n">j</span> <span class="bp">≠</span> <span class="n">i</span><span class="o">}</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">))</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span>
        <span class="bp">@</span><span class="n">dite</span> <span class="n">Y</span> <span class="o">(</span><span class="n">j</span> <span class="bp">=</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">_inst_3</span> <span class="n">j</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">i</span><span class="o">),</span> <span class="n">y.fst</span><span class="o">)</span>
          <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">j</span> <span class="bp">=</span> <span class="n">i</span><span class="o">),</span> <span class="n">y.snd</span> <span class="o">(</span><span class="bp">@</span><span class="n">subtype.mk</span> <span class="n">N</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">N</span><span class="o">),</span> <span class="n">j</span> <span class="bp">≠</span> <span class="n">i</span><span class="o">)</span> <span class="n">j</span> <span class="n">h</span><span class="o">)))</span>
       <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">),</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">,</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="o">{</span><span class="n">j</span> <span class="bp">//</span> <span class="n">j</span> <span class="bp">≠</span> <span class="n">i</span><span class="o">}),</span> <span class="n">f</span> <span class="bp">↑</span><span class="n">j</span><span class="o">))</span> <span class="n">y</span><span class="o">)</span>
       <span class="n">j</span> <span class="bp">=</span>
     <span class="n">y</span> <span class="n">j</span><span class="o">)</span>
  <span class="n">_</span>
</code></pre></div>
<p>but using <code>change</code> would certainly be shorter than copying this.</p>



<a name="291244861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291244861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291244861">(Jul 28 2022 at 20:05)</a>:</h4>
<p>In the case you linked to, <code>dsimp only</code> changes the goal to <code>dite</code> not <code>ite</code> but for me changing <code>dsimp</code> to <code>dsimp only</code> doesn't break the proof (and similarly for line 79) (I pushed the changes)</p>



<a name="291247458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/A%20first%20proof/near/291247458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/A.20first.20proof.html#291247458">(Jul 28 2022 at 20:26)</a>:</h4>
<p>Thanks! It doesn't work for the remaining two <code>dsimp</code> in the file though.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
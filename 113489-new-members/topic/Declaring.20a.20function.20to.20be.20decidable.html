---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html">Declaring a function to be decidable</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="201416111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201416111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201416111">(Jun 19 2020 at 17:00)</a>:</h4>
<p>Hi, I didn't see anything in Chapter 11 of TPIL about taking a function (which Lean fails to synthesize "decidable" for) and specifying it is decidable.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">open</span> <span class="n">equiv</span> <span class="c1">-- &quot;perm x&quot; is &quot;equiv x x&quot; AKA &quot;x ≃ x&quot;</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Defining a predicate for a permutation on a finite set to be a k-cycle</span>
<span class="cm">Start at 0, and take k steps (which don&#39;t bring you to 0 until the last one)</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">cyclicrec</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">},</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
 <span class="bp">|</span> <span class="n">n</span> <span class="mi">0</span>        <span class="n">curr</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">curr</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">curr</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">((</span><span class="n">p</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">curr</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">)</span>
                                            <span class="bp">∧</span> <span class="n">cyclicrec</span> <span class="n">m</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">curr</span><span class="o">)</span> <span class="n">p</span>

<span class="n">def</span> <span class="n">cyclic</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">},</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
 <span class="bp">|</span> <span class="mi">0</span>        <span class="bp">_</span> <span class="o">:=</span> <span class="n">ff</span> <span class="c1">-- exclude 0-cycles</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">cyclicrec</span> <span class="n">m</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">succ_pos&#39;</span><span class="bp">⟩</span> <span class="n">p</span>

<span class="bp">//</span> <span class="n">something</span> <span class="n">like</span><span class="o">:</span> <span class="kn">instance</span> <span class="n">decidable</span> <span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span><span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)}</span> <span class="o">:</span> <span class="o">(</span><span class="n">cyclic</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="err">???</span>
</code></pre></div>


<p>I'd like to make some unit tests to see if my definition is sane, so I construct a concrete instance  like <code>def cyc : perm (fin 3) := (0 1 2)</code> and would like to do something like <code>#eval cyclic cyc</code> and see <code>tt</code>, and likewise for <code>#eval cyclic not_cyc</code> to show <code>ff</code>. Is there a way to do this in Lean?</p>



<a name="201422360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201422360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201422360">(Jun 19 2020 at 17:58)</a>:</h4>
<p>for me your definitions fail at the equation compiler level</p>



<a name="201425268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201425268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201425268">(Jun 19 2020 at 18:25)</a>:</h4>
<p>Hm, I'm using Lean (version 3.16.2, commit 8f928c403cee, Release). I'd love to test it on the Lean Web Editor but it seems like you can't import from mathlib using that? (I get <code>file 'data/equiv/basic' not found in the LEAN_PATH</code>)</p>



<a name="201425516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201425516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201425516">(Jun 19 2020 at 18:28)</a>:</h4>
<p>I'm not exactly sure what failing at the equation compiler level specifically means - I thought the definition was valid because my VScode editor is not highlighting anything</p>



<a name="201425566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201425566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201425566">(Jun 19 2020 at 18:28)</a>:</h4>
<p>Hmm, you might have to clear the library cache, because <a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.equiv.basic%0A">this</a> works for me in the Lean web editor. To do so, click the (?) button and then scroll to the bottom and click the "Clear library cache and refresh" button.</p>



<a name="201425593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201425593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201425593">(Jun 19 2020 at 18:29)</a>:</h4>
<p>Using VS Code is highly preferred to using the web editor, by the way.</p>



<a name="201425622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201425622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201425622">(Jun 19 2020 at 18:29)</a>:</h4>
<p>Sorry, I was using leanprover.github rather than leanprover-community.github.</p>



<a name="201425713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201425713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201425713">(Jun 19 2020 at 18:30)</a>:</h4>
<p>That one imports a 2018 version of mathlib, I think.</p>



<a name="201425832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201425832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201425832">(Jun 19 2020 at 18:31)</a>:</h4>
<p>OK, I made some slight tweaks, and this should work with the latest version of mathlib and the community web editor:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">open</span> <span class="n">equiv</span> <span class="n">nat</span> <span class="c1">-- &quot;perm x&quot; is &quot;equiv x x&quot; AKA &quot;x ≃ x&quot;</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Defining a predicate for a permutation on a finite set to be a k-cycle</span>
<span class="cm">Start at 0, and take k steps (which don&#39;t bring you to 0 until the last one)</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">cyclicrec</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">},</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
 <span class="bp">|</span> <span class="n">n</span> <span class="mi">0</span>        <span class="n">curr</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">curr</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">curr</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">((</span><span class="n">p</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">curr</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">)</span>
                                            <span class="bp">∧</span> <span class="n">cyclicrec</span> <span class="n">m</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">curr</span><span class="o">)</span> <span class="n">p</span>

<span class="n">def</span> <span class="n">cyclic</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">},</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
 <span class="bp">|</span> <span class="mi">0</span>        <span class="bp">_</span> <span class="o">:=</span> <span class="n">ff</span> <span class="c1">-- exclude 0-cycles</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">cyclicrec</span> <span class="n">m</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">succ_pos&#39;</span><span class="bp">⟩</span> <span class="n">p</span>
</code></pre></div>


<p>(I'm using a version of mathlib that's just a few days old, but still on Lean 3.16.3.)</p>



<a name="201426346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201426346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201426346">(Jun 19 2020 at 18:37)</a>:</h4>
<p>Thanks! So if you just add</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">iden</span>  <span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="c1">-- identity permutation</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="k">if</span> <span class="n">h</span><span class="o">:</span> <span class="n">cyclic</span> <span class="n">iden</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
</code></pre></div>


<p>You'll see that it is not able to synthesize <code>decidable</code> for <code>cyclic p</code>.  </p>
<p>Is the problem then that Lean doesn't know that <code>iden</code> is decidable, rather than an issue with <code>cyclic</code>?</p>



<a name="201426775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201426775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201426775">(Jun 19 2020 at 18:42)</a>:</h4>
<p>A lot of stuff in mathlib was written by mathematicians, who are typically not bothered with decidability. Certainly this is decidable, indeed I can think of a really crap algorithm which decides it, but I can quite believe that nobody put it into mathlib. If you're interested in that kind of thing then there are two ways to go: either you do some super-inefficient general thing saying "clearly some brute force argument works, so done", or you write an algorithm which actually terminates in practice. Of course the latter is much harder, because you'll also have to formally verify that your algorithm works.</p>



<a name="201426829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201426829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201426829">(Jun 19 2020 at 18:43)</a>:</h4>
<p>It would not surprise me if the corresponding thing were in Coq, they are far more concerned with these issues.</p>



<a name="201426890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201426890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201426890">(Jun 19 2020 at 18:43)</a>:</h4>
<p>I am not really able to help more -- most Lean files I write start with assuming the axiom that everything is decidable -- I am more interested in proofs than algorithms. But there are certainly people here who could help (although they might not read <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a> -- you could ask in <a class="stream" data-stream-id="116395" href="/#narrow/stream/116395-maths">#maths</a> as this is a perfectly respectable question)</p>



<a name="201427747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201427747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201427747">(Jun 19 2020 at 18:53)</a>:</h4>
<p>Thanks, I appreciate the in-depth answer! I can post there too. Though I still don't understand what the actual problem I'm facing is. Is there some dependency (in <code>data.{nat,equiv,fintype}.basic</code>) that I'm implicitly using that's noncomputable (and I'd have to find it and replace with something computable)?</p>



<a name="201427890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201427890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201427890">(Jun 19 2020 at 18:54)</a>:</h4>
<p><code>decidable</code> is an inductive type. <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions</a></p>



<a name="201427971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201427971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201427971">(Jun 19 2020 at 18:55)</a>:</h4>
<p>If you want to make a term of type <code>decidable p</code> then you have two constructors available to you -- you either have to prove that p is true or that p is false.</p>



<a name="201428062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201428062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201428062">(Jun 19 2020 at 18:56)</a>:</h4>
<p>I am not a computer scientist and I found the abstract description in TPIL quite hard to follow in this abstract setting. However when I looked at the proof that &lt;= on nat was decidable in Lean it all made sense.</p>



<a name="201428126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201428126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201428126">(Jun 19 2020 at 18:56)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">decidable_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">b</span>     <span class="o">:=</span> <span class="n">is_true</span> <span class="o">(</span><span class="n">zero_le</span> <span class="n">b</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="n">is_false</span> <span class="o">(</span><span class="n">not_succ_le_zero</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">decidable_le</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">is_true</span> <span class="n">h</span>  <span class="o">:=</span> <span class="n">is_true</span> <span class="o">(</span><span class="n">succ_le_succ</span> <span class="n">h</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">is_false</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">is_false</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">le_of_succ_le_succ</span> <span class="n">a</span><span class="o">))</span>
  <span class="kn">end</span>
</code></pre></div>



<a name="201428273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201428273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201428273">(Jun 19 2020 at 18:58)</a>:</h4>
<p>This is a pretty sensible algorithm to work out if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\leq b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> -- if one is 0 it's easy, and if they're both positive then subtract one and continue. Note that in this case you have to pass to Lean proofs of things like if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\leq b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn><mo>≤</mo><mi>b</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a+1\leq b+1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> -- it's a formally verified algorithm.</p>



<a name="201428410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201428410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201428410">(Jun 19 2020 at 18:59)</a>:</h4>
<p>For decidability of questions like cyclicity of a permutation, you could either attempt to write some sort of sensible algorithm like that, or you can perhaps (I am not strong in this area so take everything I say with a pinch of salt) just do it by magic -- say "it's a finite computation, so there's bound to be an algorithm"</p>



<a name="201428551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201428551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201428551">(Jun 19 2020 at 19:01)</a>:</h4>
<p>There is an art to this, and some people (who don't read <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a> ) are very good at it. Unfortunately I'm not one of those people, because I just cheat and add the axiom that all props are decidable whenever I run into an undecidability issue. I'm afraid I've now told you everything I know about decidability. You might want to ask in #maths .</p>



<a name="201428686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201428686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201428686">(Jun 19 2020 at 19:02)</a>:</h4>
<p>But I think the answer to your question is that pretty much <em>everything</em> is implicitly undecidable, in the sense that most propositions in Lean won't have the decidable predicate proved for them, perhaps because of laziness -- it is not a high priority around here.</p>



<a name="201429261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201429261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201429261">(Jun 19 2020 at 19:09)</a>:</h4>
<p>Thanks! I wanted to take a crack at it before asking maths, but I can't even get the signature to typecheck:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">decidable_cyclic</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">Π</span> <span class="n">p</span><span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">cyclic</span> <span class="n">p</span><span class="o">)</span>
  <span class="bp">_</span>     <span class="bp">_</span>     <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>Error</p>
<div class="codehilite"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">decidable</span> <span class="o">(</span><span class="n">cyclic</span> <span class="n">p</span><span class="o">)</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="kt">Type</span>
</code></pre></div>


<p>This doesn't make sense to me since <code>cyclic p</code> is a <code>Prop</code> and <code>decidable</code> is <code>Prop -&gt; Type</code>.</p>



<a name="201429290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201429290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201429290">(Jun 19 2020 at 19:09)</a>:</h4>
<p>Just pattern matching off the <code>decidable_le</code> example</p>



<a name="201430044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201430044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201430044">(Jun 19 2020 at 19:17)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">decidable_cyclic</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">Π</span> <span class="n">p</span><span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">cyclic</span> <span class="n">p</span><span class="o">)</span>
<span class="o">:=</span> <span class="n">sorry</span>

<span class="n">def</span> <span class="n">iden</span>  <span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="c1">-- identity permutation</span>
<span class="bp">#</span><span class="kn">check</span> <span class="k">if</span> <span class="n">h</span><span class="o">:</span> <span class="n">cyclic</span> <span class="n">iden</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
</code></pre></div>



<a name="201430102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201430102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201430102">(Jun 19 2020 at 19:18)</a>:</h4>
<p>The <code>_</code>s in the &lt;= example are matching a and b, which you don't have (they're proving forall a b, ...)</p>



<a name="201430230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201430230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201430230">(Jun 19 2020 at 19:19)</a>:</h4>
<p>I see, ok think I've got enough info to try this now - thanks so much!</p>



<a name="201430237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201430237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201430237">(Jun 19 2020 at 19:19)</a>:</h4>
<p>Good luck!</p>



<a name="201430343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201430343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201430343">(Jun 19 2020 at 19:20)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">decidable_cyclic</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">Π</span> <span class="n">p</span><span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">cyclic</span> <span class="n">p</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>I just saw you had two inputs too -- sorry, was talking nonsense earlier. You were missing the bar.</p>



<a name="201430807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201430807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201430807">(Jun 19 2020 at 19:25)</a>:</h4>
<p>oops - good catch!</p>



<a name="201433025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201433025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201433025">(Jun 19 2020 at 19:48)</a>:</h4>
<p>Thinking about this -- the order should be computable, and so should the sizes of the orbits, so if you had a theorem saying that the permutation was cyclic iff one orbit has size equal to the order and the others all have size 1 then <code>dec_trivial</code> might be able to tell that this is decidable.</p>



<a name="201433385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201433385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201433385">(Jun 19 2020 at 19:52)</a>:</h4>
<p>Oh maybe our definitions are different. It's annoying that the derive handler can't do this though</p>



<a name="201433458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201433458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201433458">(Jun 19 2020 at 19:52)</a>:</h4>
<p>Do I understand correctly that your definition of cyclic means that <code>p</code> should be an <code>n</code>-cycle? not just an arbitrary cycle?<br>
In any case you might find <code>decidable_of_iff</code> usefull, you can then change to an equivalent proposition for which proving decidablity is easier.</p>



<a name="201438234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201438234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201438234">(Jun 19 2020 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable/near/201428686">said</a>:</p>
<blockquote>
<p>But I think the answer to your question is that pretty much <em>everything</em> is implicitly undecidable, in the sense that most propositions in Lean won't have the decidable predicate proved for them, perhaps because of laziness -- it is not a high priority around here.</p>
</blockquote>
<p>As far as I know, this is not true. We've proved decidability for basically every predicate for which it makes sense</p>



<a name="201438290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201438290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201438290">(Jun 19 2020 at 20:47)</a>:</h4>
<p>But you mathematicians are moving fast and maybe not keeping this practice up for newly defined predicates</p>



<a name="201438328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201438328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201438328">(Jun 19 2020 at 20:47)</a>:</h4>
<p>I'm sure you know a lot more about what's decidable than I do Mario!</p>



<a name="201438349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201438349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201438349">(Jun 19 2020 at 20:47)</a>:</h4>
<p>I believe the correct version of that statement would be <code>decidable (cyclic A)</code> given <code>fintype A</code> and <code>decidable_eq A</code></p>



<a name="201438475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201438475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201438475">(Jun 19 2020 at 20:49)</a>:</h4>
<p>However this is not a very good implementation computation wise</p>



<a name="201438517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201438517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201438517">(Jun 19 2020 at 20:49)</a>:</h4>
<p>but it's better than nothing and it will probably suffice for groups of size 3 or so</p>



<a name="201439089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201439089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201439089">(Jun 19 2020 at 20:56)</a>:</h4>
<p><span class="user-mention" data-user-id="300622">@Kris Brown</span> Reading this thread more carefully, I notice that the definition of <code>cyclic</code> is not the usual mathematical style definition, but rather an explicit recursive function that could be used as the algorithm. In this case, there is a simple hack you can do to make it obviously decidable: change the return type from <code>Prop</code> to <code>bool</code> and let coercion do the rest</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">open</span> <span class="n">equiv</span> <span class="n">nat</span> <span class="c1">-- &quot;perm x&quot; is &quot;equiv x x&quot; AKA &quot;x ≃ x&quot;</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Defining a predicate for a permutation on a finite set to be a k-cycle</span>
<span class="cm">Start at 0, and take k steps (which don&#39;t bring you to 0 until the last one)</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">cyclicrec</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">},</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">bool</span>
 <span class="bp">|</span> <span class="n">n</span> <span class="mi">0</span>        <span class="n">curr</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">curr</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">curr</span> <span class="n">p</span> <span class="o">:=</span> <span class="o">((</span><span class="n">p</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">curr</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">)</span>
                                            <span class="bp">∧</span> <span class="n">cyclicrec</span> <span class="n">m</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">curr</span><span class="o">)</span> <span class="n">p</span>

<span class="n">def</span> <span class="n">cyclic</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">},</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">bool</span>
 <span class="bp">|</span> <span class="mi">0</span>        <span class="bp">_</span> <span class="o">:=</span> <span class="n">ff</span> <span class="c1">-- exclude 0-cycles</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">cyclicrec</span> <span class="n">m</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">succ_pos&#39;</span><span class="bp">⟩</span> <span class="n">p</span>

<span class="n">def</span> <span class="n">iden</span>  <span class="o">:</span> <span class="n">perm</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="c1">-- identity permutation</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="k">if</span> <span class="n">h</span><span class="o">:</span> <span class="n">cyclic</span> <span class="n">iden</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="c1">-- 1</span>
</code></pre></div>



<a name="201439192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201439192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201439192">(Jun 19 2020 at 20:57)</a>:</h4>
<p>Would you want PRs for any additional decidability proofs? I have</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">r</span><span class="o">]</span>

<span class="kn">instance</span> <span class="n">decidable_exists_of_subsets</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">t</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">t</span> <span class="err">⊆</span> <span class="n">s</span><span class="o">),</span> <span class="n">r</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">decidable_of_iff</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">t</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">t</span> <span class="err">∈</span> <span class="n">s</span><span class="bp">.</span><span class="n">powerset</span><span class="o">),</span> <span class="n">r</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="err">$</span> <span class="k">by</span> <span class="n">finish</span>

<span class="kn">variable</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">instance</span> <span class="n">decidable_exists_of_ssubsets</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">t</span> <span class="o">(</span><span class="n">ht</span> <span class="o">:</span> <span class="n">t</span> <span class="err">⊂</span> <span class="n">s</span><span class="o">),</span> <span class="n">r</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">decidable_of_iff</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">t</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">t</span> <span class="err">∈</span> <span class="n">s</span><span class="bp">.</span><span class="n">powerset</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">s</span> <span class="err">⊆</span> <span class="n">t</span><span class="o">),</span> <span class="n">r</span> <span class="n">t</span> <span class="n">s</span><span class="o">)</span> <span class="err">$</span> <span class="k">by</span> <span class="n">finish</span>
</code></pre></div>



<a name="201439461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201439461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201439461">(Jun 19 2020 at 21:00)</a>:</h4>
<p>Hm, that seems okay, although you can end up writing a lot of such functions without some guiding principles</p>



<a name="201439737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201439737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201439737">(Jun 19 2020 at 21:02)</a>:</h4>
<p>I don't mind asking people to craft their predicates in a particular way in order to make them more obviously decidable. In examples like this, it's just as possible that the real predicate isn't explicitly over a finset at all (or subsets or ssubsets of one) but rather the predicate <code>r</code> is false outside the finset <code>s</code> for some reason</p>



<a name="201439771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201439771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201439771">(Jun 19 2020 at 21:03)</a>:</h4>
<p>so you would have to insert some rewrite anyway</p>



<a name="201439817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201439817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201439817">(Jun 19 2020 at 21:03)</a>:</h4>
<p>(but if you are going to PR these functions you should do the forall version too)</p>



<a name="201439913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201439913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201439913">(Jun 19 2020 at 21:04)</a>:</h4>
<p>Also, <code>r</code> should not depend on <code>s</code> here, there is no reason for that dependency</p>



<a name="201441246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201441246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201441246">(Jun 19 2020 at 21:19)</a>:</h4>
<p>You are right, it still works without the explicit dependence on <code>s</code>. I guess Lean is smarter than I realised! I'm not sure I understand your first point though. Do you mean it should be made over a more general type sharing some of <code>finset</code>'s properties?</p>



<a name="201443129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Declaring%20a%20function%20to%20be%20decidable/near/201443129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Declaring.20a.20function.20to.20be.20decidable.html#201443129">(Jun 19 2020 at 21:41)</a>:</h4>
<p>Oh I just found completely by accident that there is a definition <code>is_cycle</code> in group_theory.perm.sign expressing the same notion, seems like there are a lot of lemmas for it there already.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
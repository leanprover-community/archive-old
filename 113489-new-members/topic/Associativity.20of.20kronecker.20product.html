---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html">Associativity of kronecker product</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219268285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219268285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yunong Shi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219268285">(Dec 08 2020 at 21:53)</a>:</h4>
<p>Hi, everyone. <span class="user-mention" data-user-id="368033">@Runzhou Tao</span>  and I are new to Lean. We want to use Lean in quantum computing. As a practice, we want to prove the associativity of tensor products of (finite dimensional) matrices in different dimensions using the following code. It seems like defining kronecker product as on line 14, it depends on the dimension of the matrices, thus we cannot express the associativity theorem easily because the 3rd matrix will have a different dimension (a failed trial is on line 26). I am wondering is there a way of defining kronecker product (and matrices) so that the associativity can be expressed and proved? Thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.matrix.basic</span>

<span class="kd">def</span> <span class="n">comp</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="o">(</span><span class="n">m</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">a</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">nlinarith</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">q</span><span class="o">)</span>


<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">my_matrix</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">ℝ</span>

<span class="kd">def</span> <span class="n">kron</span> <span class="o">{</span><span class="n">m1</span> <span class="n">n1</span> <span class="n">m2</span> <span class="n">n2</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="n">m1</span> <span class="n">n1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="n">m2</span> <span class="n">n2</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="o">(</span><span class="n">m1</span><span class="bp">*</span><span class="n">m2</span><span class="o">)</span> <span class="o">(</span><span class="n">n1</span><span class="bp">*</span><span class="n">n2</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">i</span> <span class="k">with</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">j</span> <span class="k">with</span> <span class="n">j</span> <span class="n">hj</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">i1</span> <span class="o">:=</span> <span class="n">i</span> <span class="bp">%</span> <span class="n">m1</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">j1</span> <span class="o">:=</span> <span class="n">j</span> <span class="bp">%</span> <span class="n">n1</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">i2</span> <span class="o">:=</span> <span class="n">i</span> <span class="bp">/</span> <span class="n">m1</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">j2</span> <span class="o">:=</span> <span class="n">j</span> <span class="bp">/</span> <span class="n">n1</span><span class="o">,</span>
    <span class="n">exact</span> <span class="mi">0</span><span class="o">,</span> <span class="c1">-- m1 n1 m2 n2 should not be</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">kron_assoc</span> <span class="o">{</span><span class="n">m1</span> <span class="n">n1</span> <span class="n">m2</span> <span class="n">n2</span> <span class="n">m3</span> <span class="n">n3</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="n">m1</span> <span class="n">n1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="n">m2</span> <span class="n">n2</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="n">m3</span> <span class="n">n3</span><span class="o">)</span> <span class="o">:</span>
<span class="n">kron</span> <span class="o">(</span><span class="n">kron</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">kron</span> <span class="n">a</span> <span class="o">(</span><span class="n">kron</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="219268934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219268934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219268934">(Dec 08 2020 at 21:59)</a>:</h4>
<p>Yup, this is a standard problem with dependent type theory and there are a few ways around it, although I still haven't really internalised them. The problem is that <code>x*(y*z)</code> and <code>(x*y)*z</code> are equal, but not definitionally equal.</p>



<a name="219269668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219269668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219269668">(Dec 08 2020 at 22:06)</a>:</h4>
<p>This is the ugly way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">my_matrix_equiv</span> <span class="o">{</span><span class="n">m₁</span> <span class="n">n₁</span> <span class="n">m₂</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m₁</span> <span class="bp">=</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">n₁</span> <span class="bp">=</span> <span class="n">n₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="n">m₁</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="n">m₂</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m₁</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n₁</span><span class="o">),</span> <span class="n">a</span> <span class="n">i</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">⟨</span><span class="n">i.1</span><span class="o">,</span> <span class="n">hm</span> <span class="bp">▸</span> <span class="n">i.2</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">j.1</span><span class="o">,</span> <span class="n">hn</span> <span class="bp">▸</span> <span class="n">j.2</span><span class="o">⟩</span>

<span class="kd">theorem</span> <span class="n">kron_assoc</span> <span class="o">{</span><span class="n">m1</span> <span class="n">n1</span> <span class="n">m2</span> <span class="n">n2</span> <span class="n">m3</span> <span class="n">n3</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="n">m1</span> <span class="n">n1</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="n">m2</span> <span class="n">n2</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">my_matrix</span> <span class="n">m3</span> <span class="n">n3</span><span class="o">)</span> <span class="o">:</span>
<span class="n">my_matrix_equiv</span> <span class="o">(</span><span class="n">mul_assoc</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_assoc</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">kron</span> <span class="o">(</span><span class="n">kron</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">kron</span> <span class="n">a</span> <span class="o">(</span><span class="n">kron</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>but I think there are better ways nowadays.</p>



<a name="219273698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219273698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219273698">(Dec 08 2020 at 22:44)</a>:</h4>
<p>Note that <code>comp a b</code> exists already as <a href="https://leanprover-community.github.io/mathlib_docs/find/fin_prod_fin_equiv">docs#fin_prod_fin_equiv</a>, <code>fin_prod_fin_equiv (a, b)</code></p>



<a name="219273799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219273799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219273799">(Dec 08 2020 at 22:45)</a>:</h4>
<p>You can also use <code>heq</code>, which isn't always as bad as its made out to be, <code>kron (kron a b) c == kron a (kron b c)</code></p>



<a name="219274079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219274079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219274079">(Dec 08 2020 at 22:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.matrix.notation</span>

<span class="kn">section</span> <span class="n">repr</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">m'</span> <span class="n">n'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_repr</span> <span class="n">X</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">vec_repr</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n'</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">string</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">_</span> <span class="n">v</span><span class="o">,</span> <span class="n">string.intercalate</span> <span class="s2">", "</span> <span class="o">((</span><span class="n">vector.of_fn</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">to_list.map</span> <span class="n">repr</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">vec_repr_instance</span> <span class="o">:</span> <span class="n">has_repr</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n'</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">vec_repr</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">matrix_repr</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">m'</span> <span class="n">n'</span><span class="o">},</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m'</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n'</span><span class="o">)</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">string</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">M</span><span class="o">,</span> <span class="n">string.intercalate</span> <span class="s2">";</span><span class="se">\n</span><span class="s2">"</span> <span class="o">((</span><span class="n">vector.of_fn</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">to_list.map</span> <span class="n">repr</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">matrix_repr_instance</span> <span class="o">:</span>
  <span class="n">has_repr</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n'</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m'</span><span class="o">)</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">matrix_repr</span><span class="o">⟩</span>

<span class="kd">end</span> <span class="n">repr</span>

<span class="kn">section</span> <span class="n">kron</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">K</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">kron</span> <span class="o">{</span><span class="n">m1</span> <span class="n">n1</span> <span class="n">m2</span> <span class="n">n2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">m1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">m2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">K</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">((</span><span class="n">m1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">m2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">((</span><span class="n">n1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="n">K</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="o">((</span><span class="n">a</span> <span class="o">⟨</span><span class="n">i</span> <span class="bp">/</span> <span class="o">(</span><span class="n">m2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">nat.div_lt_iff_lt_mul'</span> <span class="o">(</span><span class="n">nat.succ_pos'</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">i.is_lt</span><span class="o">⟩</span>
           <span class="o">⟨</span><span class="n">j</span> <span class="bp">/</span> <span class="o">(</span><span class="n">n2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">nat.div_lt_iff_lt_mul'</span> <span class="o">(</span><span class="n">nat.succ_pos'</span><span class="o">))</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">j.is_lt</span><span class="o">⟩)</span>
           <span class="bp">•</span> <span class="n">b</span><span class="o">)</span>
           <span class="o">⟨</span><span class="n">i</span> <span class="bp">%</span> <span class="o">(</span><span class="n">m2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">nat.mod_lt</span> <span class="n">_</span> <span class="n">nat.succ_pos'</span><span class="o">⟩</span>
           <span class="o">⟨</span><span class="n">j</span> <span class="bp">%</span> <span class="o">(</span><span class="n">n2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">nat.mod_lt</span> <span class="n">_</span> <span class="n">nat.succ_pos'</span><span class="o">⟩</span>


<span class="k">#eval</span> <span class="n">kron</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]]</span> <span class="bp">!</span><span class="o">[</span><span class="bp">!</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">],</span> <span class="bp">!</span><span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">]]</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">0, 5, 0, 10;</span>
<span class="cm">6, 7, 12, 14;</span>
<span class="cm">0, 15, 0, 20;</span>
<span class="cm">18, 21, 24, 28</span>
<span class="cm">-/</span>

<span class="kd">theorem</span> <span class="n">kron_assoc</span>
<span class="o">{</span><span class="n">m1</span> <span class="n">n1</span> <span class="n">m2</span> <span class="n">n2</span> <span class="n">m3</span> <span class="n">n3</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">K</span><span class="o">]</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">m1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">m2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">m3</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n3</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">K</span><span class="o">)</span>
  <span class="o">:</span>
<span class="n">kron</span> <span class="o">(</span><span class="bp">@</span><span class="n">kron</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="bp">==</span> <span class="o">(</span><span class="bp">@</span><span class="n">kron</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="o">(</span><span class="bp">@</span><span class="n">kron</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>



<a name="219275483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219275483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219275483">(Dec 08 2020 at 23:04)</a>:</h4>
<p>Although proving associativity might be a tiny bit simpler if the mul definition is used instead of smul</p>



<a name="219279433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219279433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219279433">(Dec 08 2020 at 23:39)</a>:</h4>
<p>Hi and welcome! I also work in quantum information, and I've thought a bit about the best way to represent states on multiple quantum systems in Lean. I think the way to go will be to write a pi-type version of the code in <code>linear_algebra/tensor_product.lean</code>. What we have there is the tensor product of two spaces <code>M</code> and <code>N</code>, and it's defined as a <code>free_add_monoid M × N</code> quotiented by an appropriate equivalence relation, so basically arbitrary sums of vectors of the form <code>x ⊗ y</code> and then selecting the right equivalence classes. I think we should do the same thing with <code>free_add_monoid (Π i : ι, f i)</code> with <code>f : ι → Type*</code> in order to have more than two systems. This would have the advantage of avoiding these associativity problems, by not even having an order on the systems in the first place.</p>



<a name="219279738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219279738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219279738">(Dec 08 2020 at 23:43)</a>:</h4>
<p>It also lets us work at a more abstract level, which I've (somewhat counterintuitively) found to be a lot easier in Lean. I also tried to go this route when I first learned Lean (i.e. do everything with concrete matrices) and it was constant pain, with indices everywhere.</p>



<a name="219283066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219283066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yunong Shi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219283066">(Dec 09 2020 at 00:25)</a>:</h4>
<p>Thanks everyone. It will take some time for me to fully understand your replies. Let me get back to some of you later.</p>



<a name="219283757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219283757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yunong Shi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219283757">(Dec 09 2020 at 00:34)</a>:</h4>
<p><span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> Thanks for the great suggestions and glad to know someone here is in quantum computation as well! As I understand your comment, there are two suggestions: 1. we can work with abstract tensor product that defined in <code>linear_algebra/tensor_product.lean</code>. 2. Using Pi-type to get rid of the dimension dependence. For 1, will the abstract definition make some proof harder, for example, prove some concrete results are indeed tensor products? For 2, I think it's a great idea! Will it involve some changes in the matrix definition (matrices with arbitrary dimensions)? Maybe I should look into the implementation more.</p>



<a name="219311234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219311234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219311234">(Dec 09 2020 at 09:06)</a>:</h4>
<p><span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> <span class="user-mention" data-user-id="365384">@Yunong Shi</span>  Not sure if it's useful for your application, but I've formalized an alternative definition of tensors in here: <br>
<a href="https://github.com/leanprover-community/mathlib/blob/1f309c52c472a6cd37e41c580a470033e63d4720/src/data/holor.lean">https://github.com/leanprover-community/mathlib/blob/1f309c52c472a6cd37e41c580a470033e63d4720/src/data/holor.lean</a></p>
<p>We called this alternative view on tensors "holors" (I think we found that word in the literature somewhere). The difference is that this definition views the tensors as multidimensional arrays, not as functions. It's like viewing linear maps as matrices. The holor file also contains a proof of associativity of the tensor product.</p>



<a name="219312397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219312397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219312397">(Dec 09 2020 at 09:19)</a>:</h4>
<p><span class="user-mention" data-user-id="129120">@Alexander Bentkamp</span>, is there a reason you use \N and not <code>fin n</code> like matrices (usually) use?</p>



<a name="219313358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219313358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219313358">(Dec 09 2020 at 09:30)</a>:</h4>
<p>I guess it makes the whole definition a bit simpler, but I am not sure. In some sense, the definition of <code>holor_index</code> is like <code>fin n</code>, but on lists.</p>



<a name="219313667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219313667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219313667">(Dec 09 2020 at 09:33)</a>:</h4>
<p>How would the definition of <code>holor_index</code> look like with <code>fin n</code>? I guess you would need a Pi-type or something?</p>



<a name="219313766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219313766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219313766">(Dec 09 2020 at 09:33)</a>:</h4>
<p>For matrices, it's simpler. It's just <code>fin n ⨉ fin m</code>.</p>



<a name="219314184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219314184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219314184">(Dec 09 2020 at 09:38)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">holor</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">ds</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">ds</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">ds</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span>
</code></pre></div>



<a name="219314350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219314350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219314350">(Dec 09 2020 at 09:40)</a>:</h4>
<p>Eg <code>holor ℝ ![fin 2, fin 3, fin 4]</code> for a 2x3x4 tensor</p>



<a name="219314396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219314396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219314396">(Dec 09 2020 at 09:40)</a>:</h4>
<p>wow, what is the <code>![...]</code> notation? It constructs <code>fin n</code>?</p>



<a name="219314452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219314452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219314452">(Dec 09 2020 at 09:41)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html">https://leanprover-community.github.io/mathlib_docs/data/matrix/notation.html</a></p>



<a name="219314529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219314529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219314529">(Dec 09 2020 at 09:42)</a>:</h4>
<p>Well, then the reason for my definition was that the <code>fin n</code>/matrix library wasn't as developed back then.</p>



<a name="219314537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219314537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219314537">(Dec 09 2020 at 09:42)</a>:</h4>
<p>It constructs <code>fin n →  T</code></p>



<a name="219314635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219314635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219314635">(Dec 09 2020 at 09:43)</a>:</h4>
<p>Ugh, that definition doesn't work: (<a href="#narrow/stream/113488-general/topic/fintype.20instances.20for.20matrix.20notation/near/219314820">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fintype.20instances.20for.20matrix.20notation/near/219314820</a>)</p>



<a name="219316845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219316845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219316845">(Dec 09 2020 at 10:06)</a>:</h4>
<p>On second thoughts, my definition probably doesn't work because it means 2-tensors and 3-tensors have different types</p>



<a name="219316900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219316900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219316900">(Dec 09 2020 at 10:07)</a>:</h4>
<p>Maybe I'll explore trying to overhaul holor to use it and see where I get stuck</p>



<a name="219317933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219317933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexander Bentkamp <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219317933">(Dec 09 2020 at 10:18)</a>:</h4>
<p>Sure, go for it. It would be nice to have it more consistent with the matrix library.</p>



<a name="219320202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219320202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219320202">(Dec 09 2020 at 10:44)</a>:</h4>
<p>Having explored a little more, I think all the <code>holor_index</code> stuff is still quite hard to write with <code>fin</code>. <a href="https://github.com/leanprover-community/mathlib/issues/4406">#4406</a> would make it easier.</p>



<a name="219335301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219335301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219335301">(Dec 09 2020 at 13:29)</a>:</h4>
<p><span class="user-mention" data-user-id="129120">@Alexander Bentkamp</span> Thanks for pointing this out! This is very close to what I want, but I think the definition I outlined above would still be worth doing, for a few reasons. I would really like to avoid having the tensor factors indexed by a specific predefined type like <code>ℕ</code> or <code>fin n</code>: for example, in a typical application in quantum information, we would have a quantum state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>φ</mi><msub><mo stretchy="false">⟩</mo><mrow><msup><mi>A</mi><mi>n</mi></msup><msup><mi>B</mi><mi>n</mi></msup><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">|φ⟩_{A^n B^n E}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">φ</span><span class="mclose"><span class="mclose">⟩</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">A^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">B^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> being two <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>-qubit states, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> being some other quantum system. So this object would be a vector in a space that is the tensor product of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n+1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> spaces with those labels, and I'd like to be able to keep those system labels and never have to artificially number them. Also, one would want to be able to support infinite-dimensional spaces, which wouldn't be possible with holors.</p>



<a name="219337230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219337230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219337230">(Dec 09 2020 at 13:46)</a>:</h4>
<p><span class="user-mention" data-user-id="365384">@Yunong Shi</span> I don't know what your plans are, but here's my take on doing quantum information in Lean at the moment: we're not there yet! :-) To give you an idea of the current situation, unitaries are not there, adjoints are not there (so forget Hermitian operators), there is no spectral decomposition, and we only got complex inner products and eigenvalues about two months ago. If you have a specific application that doesn't require too many of those features it might be possible to get started now, but personally my plan is to try to get those into mathlib by making PRs whenever I have a bit of time before trying to do actual quantum information.</p>



<a name="219337587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219337587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219337587">(Dec 09 2020 at 13:49)</a>:</h4>
<p>Depending on what you're doing, one option might be to switch to Coq and use this library: <a href="https://github.com/inQWIRE/QWIRE">https://github.com/inQWIRE/QWIRE</a></p>



<a name="219388496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219388496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yunong Shi <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219388496">(Dec 09 2020 at 19:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product/near/219337230">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="365384">Yunong Shi</span> I don't know what your plans are, but here's my take on doing quantum information in Lean at the moment: we're not there yet! :-) To give you an idea of the current situation, unitaries are not there, adjoints are not there (so forget Hermitian operators), there is no spectral decomposition, and we only got complex inner products and eigenvalues about two months ago. If you have a specific application that doesn't require too many of those features it might be possible to get started now, but personally my plan is to try to get those into mathlib by making PRs whenever I have a bit of time before trying to do actual quantum information.</p>
</blockquote>
<p>Thanks for the info. I'd love to help with the dev of libraries for quantum information. I will probably look at the code you mentioned and play around with it first.</p>



<a name="219518216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219518216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219518216">(Dec 10 2020 at 19:01)</a>:</h4>
<p>I just managed to motivate myself to have a crack at this idea for the  tensor product of an indexed family of spaces: <a href="https://github.com/leanprover-community/mathlib/issues/5311">#5311</a></p>



<a name="219539535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219539535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219539535">(Dec 10 2020 at 21:58)</a>:</h4>
<p>What should the tensor product of an empty index be? For the sake of tensor algebras, it feels like it should be isomorphic to <code>R</code>, but I think your PR is isomorphic to the trivial ring.</p>



<a name="219539590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219539590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219539590">(Dec 10 2020 at 21:58)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mrow><mo>⊗</mo><mn>0</mn></mrow></msup><mo>=</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">M^{\otimes 0}=R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊗</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> but I'm not sure if that's what you're asking</p>



<a name="219540110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219540110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219540110">(Dec 10 2020 at 22:03)</a>:</h4>
<p>If you mean <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⨂</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="normal">∅</mi></mrow></msub><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\bigotimes_{i \in \emptyset} M_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.088602em;vertical-align:-0.338602em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22528999999999993em;"><span style="top:-2.4002900000000005em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight">∅</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.338602em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, this should definitely be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, as in Kevin's answer.</p>



<a name="219540230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219540230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219540230">(Dec 10 2020 at 22:03)</a>:</h4>
<p>Having it the zero ring would break the usual formulas for the union of set indexes.</p>



<a name="219540614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219540614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219540614">(Dec 10 2020 at 22:06)</a>:</h4>
<p><del>That's mostly what I'm asking, but for an indexed tensor product instead of a homogenous power</del> - edit: yes</p>



<a name="219549200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219549200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219549200">(Dec 10 2020 at 23:38)</a>:</h4>
<p>My math answer would also be <code>R</code>, but right now the code assumes that the index type is nonempty.</p>



<a name="219549250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219549250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219549250">(Dec 10 2020 at 23:39)</a>:</h4>
<p>It's a bit awkward to change, because the <code>has_scalar</code> instance is defined by choosing one of the indices and doing <code>smul</code> on that coordinate.</p>



<a name="219549379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219549379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219549379">(Dec 10 2020 at 23:41)</a>:</h4>
<p>Also right now we can only do the tensor product over the whole type, and not a subset. It might be useful to put that in actually.</p>



<a name="219550751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219550751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219550751">(Dec 11 2020 at 00:00)</a>:</h4>
<p>Storing an R and <code>Pi i, M i</code> term separately under your quotient would fix that base case</p>



<a name="219551636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Associativity%20of%20kronecker%20product/near/219551636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Associativity.20of.20kronecker.20product.html#219551636">(Dec 11 2020 at 00:13)</a>:</h4>
<p>Yeah, I was hoping for a more clever way but it doesn't look possible.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
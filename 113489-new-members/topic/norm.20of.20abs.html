---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/norm.20of.20abs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html">norm of abs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="226065147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226065147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226065147">(Feb 11 2021 at 22:07)</a>:</h4>
<p>The first lemma is easily proved. The second should follow trivially, but Lean will not accept my proof - it says </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kd">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="n">max</span> <span class="n">b</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">)</span>
</code></pre></div>
<p>what am I doing wrong please?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.ordered</span>

<span class="kd">universe</span> <span class="n">v</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_add_comm_group</span> <span class="n">β</span><span class="o">]</span>  <span class="o">[</span><span class="n">normed_group</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">norm_max_eq_norm</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∥</span><span class="n">max</span> <span class="n">b</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">)</span><span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">le_total</span>  <span class="n">b</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">)</span>  <span class="k">with</span> <span class="n">bn</span> <span class="n">bp</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">max_eq_right</span> <span class="n">bn</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">max_eq_left</span> <span class="n">bp</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">norm_abs_eq_norm</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∥</span><span class="n">abs</span> <span class="n">b</span> <span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">abs</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">le_total</span>  <span class="n">b</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">)</span>  <span class="k">with</span> <span class="n">bn</span> <span class="n">bp</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">max_eq_right</span> <span class="n">bn</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">max_eq_left</span> <span class="n">bp</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>Thanks,</p>
<p>Christopher</p>



<a name="226065634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226065634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226065634">(Feb 11 2021 at 22:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">norm_abs_eq_norm</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∥</span><span class="n">abs</span> <span class="n">b</span> <span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">abs</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">le_total</span>  <span class="n">b</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">)</span>  <span class="k">with</span> <span class="n">bn</span> <span class="n">bp</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">convert</span> <span class="n">norm_max_eq_norm</span> <span class="n">b</span><span class="o">,</span>
    <span class="c">/-</span><span class="cm"></span>
<span class="cm">    linear_ordered_add_comm_group.to_add_comm_group β = normed_group.to_add_comm_group</span>
<span class="cm">    -/</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="o">},</span><span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>When you write <code>[linear_ordered_add_comm_group β]</code> Lean puts the structure of a linear ordered additive group on beta; when you write <code>[normed_group β]</code> it puts a totally different structure of a normed additive group on beta. They might have different 0's, different additions etc. The goal after <code>convert</code> is the statement that the two group structures coincide -- the way you have set things up, they don't.</p>



<a name="226067163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226067163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226067163">(Feb 11 2021 at 22:25)</a>:</h4>
<p>Unfortunately, <code>normed_group</code> is defined in <code>analysis.normed_space.basic</code> and this file does not have the magic words <code>set_option old_structure_cmd true</code> in it, so I do not know how to fix this.</p>



<a name="226067187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226067187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226067187">(Feb 11 2021 at 22:25)</a>:</h4>
<p>Okay, thanks, that makes sense. So I can add that as an additional hypothesis and it works.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">norm_abs_eq_norm</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">linear_ordered_add_comm_group.to_add_comm_group</span> <span class="n">β</span> <span class="bp">=</span> <span class="n">normed_group.to_add_comm_group</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∥</span><span class="n">abs</span> <span class="n">b</span> <span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">abs</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">norm_max_eq_norm</span> <span class="n">b</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226067485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226067485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226067485">(Feb 11 2021 at 22:28)</a>:</h4>
<p>You can, but this solution will not scale. Type class inference expects there to be only one (at most) structure of add_comm_group on a type, up to definitional equality. Your solution will hence be a nightmare to use. What is even more worrying is that adding <code>set_option old_structure_cmd true</code> to <code>analysis.normed_space.basic</code> makes Lean segfault, a rather rare occurrence nowadays.</p>



<a name="226067876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226067876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226067876">(Feb 11 2021 at 22:32)</a>:</h4>
<p>It works in the case that  β is ℝ.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.ordered</span>

<span class="kd">universe</span> <span class="n">v</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_add_comm_group</span> <span class="n">β</span><span class="o">]</span>  <span class="o">[</span><span class="n">normed_group</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">norm_max_eq_norm</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span> <span class="o">)</span> <span class="o">:</span> <span class="bp">∥</span><span class="n">max</span> <span class="n">b</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">)</span><span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">le_total</span>  <span class="n">b</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">)</span>  <span class="k">with</span> <span class="n">bn</span> <span class="n">bp</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">max_eq_right</span> <span class="n">bn</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">max_eq_left</span> <span class="n">bp</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">norm_abs_eq_norm</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∥</span><span class="n">abs</span> <span class="n">b</span> <span class="bp">∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">abs</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">norm_max_eq_norm</span> <span class="n">b</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="226067938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226067938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226067938">(Feb 11 2021 at 22:32)</a>:</h4>
<p>What sort of mathematical object are you trying to model by assuming a normed group whose order is linear?</p>



<a name="226067941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226067941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226067941">(Feb 11 2021 at 22:32)</a>:</h4>
<p>That's because the reals have been given a compatible normed group and linear ordered group structure.</p>



<a name="226068031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226068031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226068031">(Feb 11 2021 at 22:33)</a>:</h4>
<p>Alex that's a fair question, but another fair question is whether it is possible to make such a structure in mathlib.</p>



<a name="226068539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226068539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226068539">(Feb 11 2021 at 22:38)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> - I've proved that the continuous bounded real-valued functions on a topological space form a lattice under the natural ordering - I was just trying to see if the result still held if I replaced ℝ with a more abstract structure.</p>



<a name="226068957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226068957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226068957">(Feb 11 2021 at 22:42)</a>:</h4>
<p>See <a href="#narrow/stream/113488-general/topic/old.20structure.20command.20segfault/near/226068687">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/old.20structure.20command.20segfault/near/226068687</a> . I might well be missing an obvious way to do this.</p>



<a name="226068973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226068973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226068973">(Feb 11 2021 at 22:42)</a>:</h4>
<p>You can define the class you want like this :</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.ordered</span>

<span class="kd">class</span> <span class="n">linear_normed_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">linear_order</span> <span class="n">α</span><span class="o">,</span> <span class="n">normed_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">a</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">linear_normed_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">linear_ordered_add_comm_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span><span class="bp">..</span><span class="n">h</span><span class="o">}</span>
</code></pre></div>



<a name="226069072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226069072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226069072">(Feb 11 2021 at 22:43)</a>:</h4>
<p>This solution doesn't scale, but I agree that right now it seems like the best way to do it.</p>



<a name="226069136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226069136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226069136">(Feb 11 2021 at 22:44)</a>:</h4>
<p>Why doesn't it scale?</p>



<a name="226069254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226069254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226069254">(Feb 11 2021 at 22:45)</a>:</h4>
<p>I mean, you had to add a random axiom when we have a perfectly good class (<code>linear_ordered_add_comm_group</code>) which already contained that axiom. What if it had been a normed locally ringed add_comm_topos or something?</p>



<a name="226069475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226069475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226069475">(Feb 11 2021 at 22:47)</a>:</h4>
<p>But I've made an instance of the original class so, while there was a little bit of copy pasting to set this up it should be now invisible to the user that it was set up this way instead of the old structure command way.</p>



<a name="226069592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226069592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226069592">(Feb 11 2021 at 22:48)</a>:</h4>
<p>I think Leo's suggestion was that if mathlib users want to write automation in lean 4 to not have to do the copy-pasting of the axioms by hand (and therefore not break as much if someone renames one?) that should be doable.</p>



<a name="226069604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226069604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226069604">(Feb 11 2021 at 22:48)</a>:</h4>
<p>Fair enough, I was just envisaging a situation where you had to add a gazillion axioms but I agree it's just the structure def.</p>



<a name="226070295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226070295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226070295">(Feb 11 2021 at 22:55)</a>:</h4>
<p><span class="user-mention" data-user-id="373192">@Christopher Hoskin</span> if you add the lines</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">linear_normed_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">linear_order</span> <span class="n">α</span><span class="o">,</span> <span class="n">normed_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">a</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">linear_normed_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">linear_ordered_add_comm_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span><span class="bp">..</span><span class="n">h</span><span class="o">}</span>
</code></pre></div>
<p>to the top of your file you should be able to replace</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_add_comm_group</span> <span class="n">β</span><span class="o">]</span>  <span class="o">[</span><span class="n">normed_group</span> <span class="n">β</span><span class="o">]</span>
</code></pre></div>
<p>with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_normed_group</span> <span class="n">β</span><span class="o">]</span>
</code></pre></div>
<p>and hopefully everything should work!</p>



<a name="226738816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226738816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226738816">(Feb 17 2021 at 22:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/norm.20of.20abs/near/226067938">said</a>:</p>
<blockquote>
<p>What sort of mathematical object are you trying to model by assuming a normed group whose order is linear?</p>
</blockquote>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> , <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  Thanks for your help. Sorry for the delay in replying, but I've been considering this question, and I think the right sort object to model for this problem is a normed lattice ordered group (like a Riesz space, but without real-valued scalar multiplication or completeness of the norm. I've defined a lattice ordered group as follows (c.f. L. Fuchs, "Partially ordered algebraic systems" Chapter V):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_abs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">abs</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`|`</span><span class="n">a</span><span class="bp">`|`</span> <span class="o">:=</span> <span class="n">has_abs.abs</span> <span class="n">a</span>

<span class="kd">class</span> <span class="n">lattice_add_comm_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">add_comm_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">lattice</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">lattice_add_comm_group_has_abs</span> <span class="o">[</span><span class="n">lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_abs</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="bp">⊔-</span><span class="n">a</span><span class="o">⟩</span>
</code></pre></div>
<p>I made <code>has_abs</code> a class, as there are other structures which have a notion of absolute value (e.g. certain GM-spaces  and GL-spaces).</p>
<p>I've then proved a number of results including</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">abs_abs_eq_abs</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">|</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>(proof omitted for brevity - the absence of scalar multiplication by 1/2 introduces some subtleties!)</p>
<p>Then for the normed lattice ordered group,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">normed_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">lattice</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_abs</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">solid</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">≤</span> <span class="bp">|</span><span class="n">b</span><span class="bp">|</span> <span class="bp">→</span> <span class="bp">∥</span><span class="n">a</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span><span class="o">)</span>
<span class="kd">instance</span> <span class="n">a</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">lattice_add_comm_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span><span class="bp">..</span><span class="n">h</span><span class="o">}</span>
</code></pre></div>
<p>Mostly, this seems to do what I want:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_lattice_add_comm_group</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">test</span> <span class="o">:</span> <span class="bp">|</span><span class="n">d</span><span class="bp">|</span> <span class="bp">=</span> <span class="n">d</span><span class="bp">⊔</span><span class="o">(</span><span class="bp">-</span><span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">has_abs.abs</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">test2</span> <span class="o">:</span> <span class="bp">|</span><span class="n">d</span><span class="bp">|</span> <span class="bp">=|</span> <span class="bp">|</span><span class="n">d</span><span class="bp">|</span> <span class="bp">|</span>   <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">abs_abs_eq_abs</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>However, it goes a bit wrong when I try to prove:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">max_abs_eq_norm</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∥|</span> <span class="n">b</span> <span class="bp">|∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">le_antisymm_iff</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">apply</span> <span class="n">normed_lattice_add_comm_group.solid</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">abs_abs_eq_abs</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">apply</span> <span class="n">normed_lattice_add_comm_group.solid</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">abs_abs_eq_abs</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>Perhaps I am missing a coercion?</p>
<p>Christopher</p>



<a name="226746315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226746315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226746315">(Feb 17 2021 at 23:55)</a>:</h4>
<p>I can't manage to put your posts together into one file -- I am getting errors with abses. Can you just post one <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> ? Just to be clear -- I'm saying that I can't set things up so I can see the problem you are seeing. Thanks. PS your proof of <code>test</code> should probably be <code>refl</code>.</p>



<a name="226771421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226771421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226771421">(Feb 18 2021 at 06:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/norm.20of.20abs/near/226746315">said</a>:</p>
<blockquote>
<p>I can't manage to put your posts together into one file -- I am getting errors with abses. Can you just post one <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> ? Just to be clear -- I'm saying that I can't set things up so I can see the problem you are seeing. Thanks. PS your proof of <code>test</code> should probably be <code>refl</code>.</p>
</blockquote>
<p>Thanks for your help. Here is a mwe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ordered_group</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="c1">-- Notation class for absolute value of an element</span>
<span class="kd">class</span> <span class="n">has_abs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">abs</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="c1">-- Write |a| for the absolute value of a</span>
<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`|`</span><span class="n">a</span><span class="bp">`|`</span> <span class="o">:=</span> <span class="n">has_abs.abs</span> <span class="n">a</span>

<span class="c1">-- Define a lattice ordered group</span>
<span class="kd">class</span> <span class="n">lattice_add_comm_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">add_comm_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">lattice</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>

<span class="c1">-- Define the absolute value of an element of a lattice ordered group</span>
<span class="kd">instance</span> <span class="n">lattice_add_comm_group.to_has_abs</span> <span class="o">[</span><span class="n">lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_abs</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span>  <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="bp">⊔-</span><span class="n">a</span><span class="o">⟩</span>

<span class="c1">-- Every lattice additive commutative group is also an ordered additive commutative group</span>
<span class="kd">instance</span> <span class="n">lattice_add_comm_group.to_ordered_add_comm_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="o">[</span><span class="n">s</span> <span class="o">:</span> <span class="n">lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">ordered_add_comm_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="n">s.add</span><span class="o">,</span> <span class="bp">..</span><span class="n">s</span> <span class="o">}</span>

<span class="c1">-- Absolute value is idempotent</span>
<span class="kd">lemma</span> <span class="n">abs_idempotent</span> <span class="o">[</span><span class="n">lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">|</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- Define a normed lattice ordered group</span>
<span class="kd">class</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">normed_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">lattice</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_abs</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">solid</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">≤</span> <span class="bp">|</span><span class="n">b</span><span class="bp">|</span> <span class="bp">→</span> <span class="bp">∥</span><span class="n">a</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span><span class="o">)</span>

<span class="c1">-- Every normed lattice ordered group is a lattice ordered group</span>
<span class="kd">instance</span> <span class="n">a</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">lattice_add_comm_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span><span class="bp">..</span><span class="n">h</span><span class="o">}</span>

<span class="c1">-- Let β be a normed lattice ordered group</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_lattice_add_comm_group</span> <span class="n">β</span><span class="o">]</span>

<span class="c1">-- Lean can infer the definition of the absolute value</span>
<span class="kd">lemma</span> <span class="n">test</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">|</span><span class="n">b</span><span class="bp">|</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">⊔</span><span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Lean knows that abs_idempotent holds for normed lattice ordered group</span>
<span class="kd">lemma</span> <span class="n">test2</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">|</span> <span class="bp">|</span><span class="n">d</span><span class="bp">|</span> <span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="n">d</span><span class="bp">|</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">abs_idempotent</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">But `rw` fails here with:</span>

<span class="cm">rewrite tactic failed, did not find instance of the pattern in the target expression</span>
<span class="cm">  | |b| |</span>
<span class="cm">state:</span>
<span class="cm">β : Type u,</span>
<span class="cm">_inst_1 : normed_lattice_add_comm_group β,</span>
<span class="cm">b : β</span>
<span class="cm">⊢ | |b| | ≤ |b|</span>

<span class="cm">Or, with set_option pp.all true</span>

<span class="cm">rewrite tactic failed, did not find instance of the pattern in the target expression</span>
<span class="cm">  @has_abs.abs.{u} β (@lattice_add_comm_group.to_has_abs.{u} β (@a.{u} β _inst_1))</span>
<span class="cm">    (@has_abs.abs.{u} β (@lattice_add_comm_group.to_has_abs.{u} β (@a.{u} β _inst_1)) b)</span>
<span class="cm">state:</span>
<span class="cm">β : Type u,</span>
<span class="cm">_inst_1 : normed_lattice_add_comm_group.{u} β,</span>
<span class="cm">b : β</span>
<span class="cm">⊢ @has_le.le.{u} β</span>
<span class="cm">    (@preorder.to_has_le.{u} β</span>
<span class="cm">       (@partial_order.to_preorder.{u} β</span>
<span class="cm">          (@semilattice_inf.to_partial_order.{u} β</span>
<span class="cm">             (@lattice.to_semilattice_inf.{u} β (@normed_lattice_add_comm_group.to_lattice.{u} β _inst_1)))))</span>
<span class="cm">    (@has_abs.abs.{u} β (@normed_lattice_add_comm_group.to_has_abs.{u} β _inst_1)</span>
<span class="cm">       (@has_abs.abs.{u} β (@lattice_add_comm_group.to_has_abs.{u} β (@a.{u} β _inst_1)) b))</span>
<span class="cm">    (@has_abs.abs.{u} β (@normed_lattice_add_comm_group.to_has_abs.{u} β _inst_1) b)</span>
<span class="cm">-/</span>

<span class="kd">lemma</span> <span class="n">norm_abs_eq_norm</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∥|</span> <span class="n">b</span> <span class="bp">|∥</span> <span class="bp">=</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">le_antisymm_iff</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">apply</span> <span class="n">normed_lattice_add_comm_group.solid</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">abs_idempotent</span> <span class="n">b</span><span class="o">,</span>
    <span class="gr">sorry</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">apply</span> <span class="n">normed_lattice_add_comm_group.solid</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">abs_idempotent</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>Not sure if it is better to introduce the absolute value as I have done here, or to have <code>lattice_add_comm_group</code> extend <code>has_abs</code> and introduce it that way?</p>
<p>Christopher</p>



<a name="226775633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226775633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226775633">(Feb 18 2021 at 07:58)</a>:</h4>
<p>Changing <code>normed_lattice_add_comm_group</code> to extend <code>lattice_add_comm_group</code> may help</p>



<a name="226775661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226775661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226775661">(Feb 18 2021 at 07:58)</a>:</h4>
<p>As might <code>set_option old_structure_cmd true</code></p>



<a name="226787550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226787550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226787550">(Feb 18 2021 at 10:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">apply</span> <span class="n">normed_lattice_add_comm_group.solid</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_of_eq</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">abs_idempotent</span> <span class="n">b</span><span class="o">,</span>
    <span class="c1">-- ⊢ normed_lattice_add_comm_group.to_has_abs = lattice_add_comm_group.to_has_abs</span>
</code></pre></div>



<a name="226788248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/226788248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#226788248">(Feb 18 2021 at 10:07)</a>:</h4>
<p>Your <code>normed_lattice_add_comm_group</code> takes something with a normed group structure, a lattice structure, and an abs structure which might be completely unrelated to these other two structures, puts a second <code>abs</code> on it coming from the normed group and lattice structure, and then is complaining (correctly) that these two abs structures are unrelated to each other.</p>



<a name="227016578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/227016578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#227016578">(Feb 19 2021 at 19:35)</a>:</h4>
<p>Yes, that makes sense - I was thrown off guard by the <code>test</code> and <code>test2</code> lemmas holding. I guess they work because Lean can cast everything to <code>lattice_add_comm_group</code> whereas in the <code>norm_abs_eq_norm</code> lemma the <code>solid</code> axiom is stated before Lean knows that <code>normed_lattice_add_comm_group</code> is an instance of <code>lattice_add_comm_group</code>?</p>
<p>One way of working around this appears to be the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Define a normed lattice ordered group</span>
<span class="kd">class</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">normed_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">lattice</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">solid'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span><span class="bp">⊔-</span><span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">⊔-</span><span class="n">b</span> <span class="bp">→</span> <span class="bp">∥</span><span class="n">a</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span><span class="o">)</span>

<span class="c1">-- Every normed lattice ordered group is a lattice ordered group</span>
<span class="kd">instance</span> <span class="n">a</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">lattice_add_comm_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span><span class="bp">..</span><span class="n">h</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">normed_lattice_add_comm_group.solid</span> <span class="o">[</span><span class="n">normed_lattice_add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">|</span><span class="n">a</span><span class="bp">|</span> <span class="bp">≤</span> <span class="bp">|</span><span class="n">b</span><span class="bp">|</span> <span class="bp">→</span> <span class="bp">∥</span><span class="n">a</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span> <span class="o">:=</span>
  <span class="n">normed_lattice_add_comm_group.solid'</span>
</code></pre></div>
<p>Unless I'm misunderstanding, I think <span class="user-mention" data-user-id="310045">@Eric Wieser</span> 's suggestion will get us back to my original problem of having two separate group structures defined with no relationship between them?</p>
<p>I'm not yet sufficiently versed in classes to know if my solution is a sensible way of setting things up, but I can proceed with this approach and see how it goes, unless someone wants to make an alternative suggestion?</p>
<p>Thanks again for your time,</p>
<p>Christopher</p>



<a name="227018718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/227018718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#227018718">(Feb 19 2021 at 19:50)</a>:</h4>
<p>you want something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">normed_lattice_add_comm_group</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">normed_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">lattice_add_comm_group</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">solid'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span><span class="bp">⊔-</span><span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">⊔-</span><span class="n">b</span> <span class="bp">→</span> <span class="bp">∥</span><span class="n">a</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="n">b</span><span class="bp">∥</span><span class="o">)</span>
</code></pre></div>



<a name="227018727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/norm%20of%20abs/near/227018727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/norm.20of.20abs.html#227018727">(Feb 19 2021 at 19:50)</a>:</h4>
<p>The test examples work because Lean is choosing a random abs and happens to get the right one. If there are two instances of a class defined on a type then things get very unpredictable, I don't have much experience in knowing which one is used in various cases because if you have two instances of a class on a type then that's what needs to be fixed rather than persuading Lean to use one over the other. You have run into a genuine issue here and our current Lean 3 workaround isn't robust and is furthermore not going to work in Lean 4, so at some point somebody will write some machinery which makes all of this easier and you'll be able to do what you were doing initially, but unfortunately we're not there yet. I agree with Alex that this workaround where you extend disjoint fields and then add in the extra fields which you can't get because of clashes is right now the best way to proceed. The other approach would be to make normed_group an old structure but to be quite frank the Lean 4 porting people might tell us at some point to remove all old structure command shenannigans so I'm loathe to put any more in right now.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
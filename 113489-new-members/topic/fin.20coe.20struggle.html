---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113489-new-members/topic/fin.20coe.20struggle.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/index.html">new members</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html">fin coe struggle</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207814230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fin%20coe%20struggle/near/207814230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html#207814230">(Aug 24 2020 at 07:31)</a>:</h4>
<p>Okay so I must be missing something but I can't find how to prove this <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span>  </p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207814459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fin%20coe%20struggle/near/207814459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html#207814459">(Aug 24 2020 at 07:35)</a>:</h4>
<p>What's the definition of the coercion? If this proof is not refl then I think it says that you shouldn't be using the coercion</p>



<a name="207814586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fin%20coe%20struggle/near/207814586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html#207814586">(Aug 24 2020 at 07:36)</a>:</h4>
<p>I mean the coercion from fin to fin. There are perfectly well defined maps between fins which will behave very well, but recently people have been using some far less well behaved maps eg +1 and then complaining that everything is horrible because there are secret %(n+1) operators involved</p>



<a name="207814673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fin%20coe%20struggle/near/207814673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html#207814673">(Aug 24 2020 at 07:38)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">fin</span><span class="bp">.</span><span class="n">coe_coe_of_lt</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="bp">_</span><span class="o">)</span>
</code></pre></div>



<a name="207814728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fin%20coe%20struggle/near/207814728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html#207814728">(Aug 24 2020 at 07:38)</a>:</h4>
<p>Thanks ! I should have searched better I guess...</p>



<a name="207814821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fin%20coe%20struggle/near/207814821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html#207814821">(Aug 24 2020 at 07:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/fin.20coe.20struggle/near/207814586">said</a>:</p>
<blockquote>
<p>I mean the coercion from fin to fin. There are perfectly well defined maps between fins which will behave very well, but recently people have been using some far less well behaved maps eg +1 and then complaining that everything is horrible because there are secret %(n+1) operators involved</p>
</blockquote>
<p>I know these coercions are trickier than most other (e.g <code>norm_cast</code> can't deal with them), but this example should be true anyway (and it is indeed)</p>



<a name="207814868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fin%20coe%20struggle/near/207814868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html#207814868">(Aug 24 2020 at 07:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/fin.20coe.20struggle/near/207814459">said</a>:</p>
<blockquote>
<p>What's the definition of the coercion?</p>
</blockquote>
<p>It looks like it's <code>fin.val (nat.cast n)</code>, with some type hinting in there somewhere.</p>



<a name="207814994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fin%20coe%20struggle/near/207814994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html#207814994">(Aug 24 2020 at 07:43)</a>:</h4>
<p>That means <code>foo</code> is <code>n % (n + 1) = n</code>.  (Not definitionally, though.)</p>



<a name="207815400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fin%20coe%20struggle/near/207815400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html#207815400">(Aug 24 2020 at 07:49)</a>:</h4>
<p>Any map that uses % somehow is going to be hard to work with. None of the natural maps from fin n to fin (n+1) use %</p>



<a name="207837091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/fin%20coe%20struggle/near/207837091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113489-new-members/topic/fin.20coe.20struggle.html#207837091">(Aug 24 2020 at 12:31)</a>:</h4>
<p>It's probably better to use <code>fin.last n</code> instead of whatever introduced <code>(n : fin n.succ)</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
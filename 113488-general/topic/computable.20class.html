---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/computable.20class.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html">computable class</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="274328626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274328626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274328626">(Mar 06 2022 at 21:16)</a>:</h4>
<p>There had been some previous discussion about having a <code>computable</code> class that mirrors <code>decidable</code>, but for <code>Type</code> instead of <code>Prop</code> (two threads: <a href="#narrow/stream/113489-new-members/topic/nonconstructive.20proofs/near/252687109">1</a> <a href="#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260186582">2</a>). If it were possible, what this might let us do for mathlib is use mathematically convenient <code>noncomputable</code> definitions, then off to the side have <code>decidable</code> and <code>computable</code> instances for when we want to actually compute something. What I hope is (1) that this would free those who don't care about computability from having to think about adding the right decidability instances to their theorems (and even if you do care about computability, this is usually irrelevant information anyway), and (2) that this would alleviate diamond problems that come from including decidability instances in our class hierarchy.</p>
<p>The idea is to have a class</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compute</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">compute_eq</span> <span class="o">:</span> <span class="n">compute</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">export</span> <span class="n">computable</span><span class="o">(</span><span class="n">compute</span><span class="o">)</span>
</code></pre></div>
<p>and then you would be able to write <code>compute z</code> when <code>z</code> is a noncomputable term that can be computed in some way.</p>
<p>When I've tried this in Lean 3, there's been a problem that <code>computable</code> instances need to be marked <code>noncomputable</code>, defeating the whole point of this class.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Lean 3 code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.basic</span>

<span class="kd">class</span> <span class="n">computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compute</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">compute_eq</span> <span class="o">:</span> <span class="n">compute</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">computable</span><span class="o">(</span><span class="n">compute</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">erased</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">singleton</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">p</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">erased.of</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">p</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">singleton</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">id</span><span class="o">⟩</span> <span class="o">}</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">erased.out</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x.singleton.some</span>

<span class="kd">noncomputable</span> <span class="c1">-- needs to be noncomputable??</span>
<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">computable</span> <span class="o">(</span><span class="n">erased.of</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">compute</span> <span class="o">:=</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">compute_eq</span> <span class="o">:=</span> <span class="o">((</span><span class="n">erased.of</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">singleton.some_spec</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span>

<span class="kd">noncomputable</span> <span class="c1">-- :-(</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">compute</span> <span class="o">(</span><span class="n">erased.of</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span>
</code></pre></div>
</div></div>
<p>Oddly, <code>#eval</code> is happy to compute with this noncomputable instance anyway:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">compute</span> <span class="o">(</span><span class="n">erased.of</span> <span class="mi">2</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span>
<span class="c1">-- 2</span>
</code></pre></div>
<p>I tried implementing <code>Computable</code> today in Lean 4, and in my small tests it is able to tell that these instances are computable.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">compute</span> <span class="o">:</span> <span class="n">α</span>
  <span class="n">compute_eq</span> <span class="o">:</span> <span class="n">compute</span> <span class="bp">=</span> <span class="n">x</span>

<span class="kn">export</span> <span class="n">Computable</span><span class="o">(</span><span class="n">compute</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">erased</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
  <span class="n">singleton</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">p</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">erased.of</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">p</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span>
  <span class="n">singleton</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">id</span><span class="o">⟩</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">erased.out</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Classical.choose</span> <span class="n">x.singleton</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">Computable</span> <span class="o">(</span><span class="n">erased.of</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span> <span class="n">where</span>
  <span class="n">compute</span> <span class="o">:=</span> <span class="n">x</span>
  <span class="n">compute_eq</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Classical.choose_spec</span> <span class="o">(</span><span class="n">erased.of</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">singleton</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">compute</span> <span class="o">(</span><span class="n">erased.of</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span>

<span class="kn">section</span> <span class="n">from_mathlib4</span>

<span class="kn">namespace</span> <span class="n">WellFounded</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="n">unsafe</span> <span class="kd">def</span> <span class="n">fix'.impl</span> <span class="o">(</span><span class="n">hwf</span> <span class="o">:</span> <span class="n">WellFounded</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="n">x</span> <span class="o">:=</span>
  <span class="n">F</span> <span class="n">x</span> <span class="k">fun</span> <span class="n">y</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">impl</span> <span class="n">hwf</span> <span class="n">F</span> <span class="n">y</span>

<span class="kd">set_option</span> <span class="n">codegen</span> <span class="n">false</span> <span class="k">in</span>
<span class="kd">@[implementedBy fix'.impl]</span>
<span class="kd">def</span> <span class="n">fix'</span> <span class="o">(</span><span class="n">hwf</span> <span class="o">:</span> <span class="n">WellFounded</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">hwf.fix</span> <span class="n">F</span> <span class="n">x</span>

<span class="kd">end</span> <span class="n">WellFounded</span>

<span class="kn">namespace</span> <span class="n">Nat</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">lbp</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">k</span>

<span class="kd">variable</span> <span class="o">[</span><span class="n">DecidablePred</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">wf_lbp</span> <span class="o">:</span> <span class="n">WellFounded</span> <span class="o">(</span><span class="n">lbp</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="k">let</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">pn</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">H</span><span class="bp">;</span> <span class="bp">?</span><span class="n">_</span><span class="o">⟩</span>
  <span class="k">suffices</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">k</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">Acc</span> <span class="o">(</span><span class="n">lbp</span> <span class="n">p</span><span class="o">)</span> <span class="n">k</span> <span class="k">from</span> <span class="k">fun</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">this</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">Nat.le_add_left</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
  <span class="n">intro</span> <span class="n">m</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span> <span class="n">refine</span> <span class="k">fun</span> <span class="n">k</span> <span class="n">kn</span> <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="k">fun</span> <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">a</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="bp">?</span><span class="n">_</span><span class="o">⟩</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="n">pn</span> <span class="o">(</span><span class="n">a</span> <span class="n">_</span> <span class="n">kn</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">m</span> <span class="n">IH</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="n">IH</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">Nat.add_right_comm</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">kn</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">find_x</span> <span class="o">:</span> <span class="o">{</span><span class="n">n</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">m</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">wf_lbp</span> <span class="n">p</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">fix'</span> <span class="o">(</span><span class="n">C</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">k</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="bp">∀</span><span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="o">{</span><span class="n">n</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">m</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">m</span><span class="o">})</span>
  <span class="o">(</span><span class="k">fun</span> <span class="n">m</span> <span class="n">IH</span> <span class="n">al</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">pm</span> <span class="o">:</span> <span class="n">p</span> <span class="n">m</span> <span class="k">then</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">pm</span><span class="o">,</span> <span class="n">al</span><span class="o">⟩</span> <span class="k">else</span>
      <span class="k">have</span> <span class="n">this</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">n</span> <span class="n">h</span> <span class="bp">=&gt;</span>
        <span class="o">(</span><span class="n">Nat.eq_or_lt_of_le</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="k">fun</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">e</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">pm</span><span class="o">)</span> <span class="o">(</span><span class="n">al</span> <span class="n">n</span><span class="o">)</span>
      <span class="n">IH</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">this</span><span class="o">⟩</span> <span class="k">fun</span> <span class="n">n</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">this</span> <span class="n">n</span> <span class="bp">$</span> <span class="n">Nat.le_of_succ_le_succ</span> <span class="n">h</span><span class="o">)</span>
  <span class="mi">0</span> <span class="k">fun</span> <span class="n">n</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">absurd</span> <span class="n">h</span> <span class="o">(</span><span class="n">Nat.not_lt_zero</span> <span class="n">_</span><span class="o">)</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">find</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Nat.find_x</span> <span class="n">p</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">find_spec</span> <span class="o">:</span> <span class="n">p</span> <span class="o">(</span><span class="n">Nat.find</span> <span class="n">p</span> <span class="n">H</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Nat.find_x</span> <span class="n">p</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">find_min</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">},</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">Nat.find</span> <span class="n">p</span> <span class="n">H</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">m</span> <span class="o">:=</span> <span class="bp">@</span><span class="o">(</span><span class="n">Nat.find_x</span> <span class="n">p</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span>

<span class="kn">protected</span> <span class="kd">theorem</span> <span class="n">find_min'</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat.find</span> <span class="n">p</span> <span class="n">H</span> <span class="bp">≤</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">Nat.ge_of_not_lt</span> <span class="bp">λ</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">Nat.find_min</span> <span class="n">p</span> <span class="n">H</span> <span class="n">l</span> <span class="n">h</span>

<span class="kd">end</span> <span class="n">Nat</span>

<span class="kd">end</span> <span class="n">from_mathlib4</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">inf</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">Classical.propDecidable</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="k">then</span> <span class="n">Nat.find</span> <span class="n">_</span> <span class="n">h</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">DecidablePred</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">Decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span><span class="o">)]</span> <span class="o">:</span> <span class="n">Computable</span> <span class="o">(</span><span class="n">inf</span> <span class="n">p</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">compute</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="k">then</span> <span class="n">Nat.find</span> <span class="n">p</span> <span class="n">h</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="n">compute_eq</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">split</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">inf</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span>
    <span class="n">rename</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">h</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">Eq.mpr_prop</span> <span class="o">(</span><span class="n">eq_true</span> <span class="n">h</span><span class="o">)</span> <span class="n">True.intro</span> <span class="bp">=</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">rfl</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span>
    <span class="n">rename</span> <span class="n">DecidablePred</span> <span class="n">p</span> <span class="bp">=&gt;</span> <span class="n">instp</span>
    <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">Classical.propDecidable</span> <span class="o">(</span><span class="n">p</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">instp</span> <span class="o">:=</span> <span class="kd">by</span>
      <span class="n">apply</span> <span class="n">Subsingleton.elim</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">inf</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Decidable.isTrue</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">compute</span> <span class="o">(</span><span class="n">inf</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">x</span><span class="o">))</span>

<span class="k">#eval</span> <span class="n">compute</span> <span class="o">(</span><span class="n">inf</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">37</span><span class="o">))</span>
<span class="c1">-- 37</span>
</code></pre></div>
</div></div>
<p>In this, there's the same <code>erased</code> example along with a <code>noncomputable</code> definition of <code>inf</code> for natural numbers that uses <code>Nat.find</code> to compute it.</p>
<p>This makes me wonder: is this a fundamental limitation of the noncomputability system in Lean 3, or is it a fixable bug?</p>



<a name="274331838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274331838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274331838">(Mar 06 2022 at 22:26)</a>:</h4>
<p>I prototyped something like this a while ago, but with <a href="https://gist.github.com/eric-wieser/103ad49e8c5c4415991b7622f77c48e0">quite a different implementation</a></p>



<a name="274331913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274331913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274331913">(Mar 06 2022 at 22:28)</a>:</h4>
<p>Although I guess actually that's not to similar to what you have, it just fits the same ambiguous "decidable but for Type" specification</p>



<a name="274333503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274333503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274333503">(Mar 06 2022 at 23:00)</a>:</h4>
<p>If you think about <code>decidable</code> as being a term-level partial function <code>to_bool : Prop -&gt; bool</code> that has the property that <code>(to_bool p : Prop) = p</code>, then it's clearer that this is what "decidable but for Type" sort of should be.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">decidable'</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_bool</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span>
<span class="o">(</span><span class="n">to_bool_eq</span> <span class="o">:</span> <span class="o">(</span><span class="n">to_bool</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span>
</code></pre></div>
<p>This does suggest that <code>computable</code> is too rigid in that it requires the computed value lie in the same type, so something like the following would be an alternative:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Gives a type in which computations are more convenient.</span>
<span class="sd">Instances do not have to be computable. -/</span>
<span class="kd">class</span> <span class="n">computable_type</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">cast</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">computable_type</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compute</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">compute_eq</span> <span class="o">:</span> <span class="n">compute</span> <span class="bp">=</span> <span class="n">computable_type.cast</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>However, I'm not sure this is necessary since you could always <code>compute (to_foo x)</code> for a relevant <code>to_foo</code> function.</p>



<a name="274335545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274335545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274335545">(Mar 06 2022 at 23:46)</a>:</h4>
<p>It looks like with enough of what Mario calls "laundering" through <a href="https://leanprover-community.github.io/mathlib_docs/find/erased">docs#erased</a> and of applying the <code>inline</code> attribute, it actually is possible to  get this to work in Lean 3. When I'd tried using <code>erased</code> like this before, I couldn't get <code>if</code> to <code>compute</code>, but <code>compute (if 0 &lt; m then Inf {n | n &lt; m} else 0)</code> seems to work fine now that the instances are <code>inline</code>.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Lean 3 code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">order.order_iso_nat</span>
<span class="kn">import</span> <span class="n">data.erased</span>

<span class="kd">class</span> <span class="n">computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compute</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">compute_eq</span> <span class="o">:</span> <span class="n">compute</span> <span class="bp">=</span> <span class="n">x.out</span><span class="o">)</span>

<span class="kd">abbreviation</span> <span class="n">compute</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">computable.compute</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">compute_eq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="n">compute</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">computable.compute_eq.trans</span> <span class="o">(</span><span class="n">erased.out_mk</span> <span class="n">_</span><span class="o">)</span>

<span class="sd">/-- This should only be used when `x` is not `noncomputable`.</span>
<span class="sd">It might not be necessary, since presumably you'd only `compute` noncomputable things,</span>
<span class="sd">but it's useful for the `if` test below. -/</span>
<span class="kd">@[priority 0, inline]</span>
<span class="kd">instance</span> <span class="n">computable_default</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">erased.out_mk</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">computable.nat_Inf</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="o">(</span><span class="n">Inf</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">n</span><span class="o">}))</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span>
<span class="k">then</span> <span class="o">⟨</span><span class="n">nat.find</span> <span class="n">h</span><span class="o">,</span> <span class="n">eq.trans</span> <span class="o">(</span><span class="kd">by</span> <span class="n">convert</span> <span class="o">(</span><span class="n">nat.Inf_def</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="o">(</span><span class="n">erased.out_mk</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩</span>
<span class="k">else</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="o">}⟩</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">is_true</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">compute</span> <span class="o">(</span><span class="n">Inf</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">computable.ite</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">p</span><span class="o">]</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">[</span><span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">y</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="o">(</span><span class="k">if</span> <span class="n">p</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="k">then</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">if_pos</span> <span class="n">h</span><span class="o">]</span> <span class="k">else</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">if_neg</span> <span class="n">h</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">decidable.exists_nat_lt</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">is_false</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">])</span>
<span class="k">else</span> <span class="n">is_true</span> <span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">nat.succ_pos</span> <span class="n">_</span><span class="o">⟩,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">baz</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">compute</span> <span class="o">(</span><span class="k">if</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="k">then</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">}</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>
</div></div>
<p>With Lean 4, you don't need this additional complexity, and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">Decidable</span> <span class="n">p</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">Computable</span> <span class="n">x</span><span class="o">]</span> <span class="o">[</span><span class="n">Computable</span> <span class="n">y</span><span class="o">]</span> <span class="o">:</span> <span class="n">Computable</span> <span class="o">(</span><span class="k">if</span> <span class="n">p</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="k">then</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span><span class="bp">;</span> <span class="n">assumption</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span><span class="bp">;</span> <span class="n">assumption</span><span class="o">)</span>
</code></pre></div>
<p>works fine.</p>



<a name="274341282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274341282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274341282">(Mar 07 2022 at 01:59)</a>:</h4>
<p>Here's another experiment along these lines. In the spoiler block there are <code>computable</code> instances for getting coefficients of simple polynomial expressions (addition, multiplication, constant powers), and this lets you evaluate, for instance,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">compute</span> <span class="bp">$</span> <span class="o">((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">^</span><span class="mi">10</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="mi">3</span>
<span class="c1">-- 120</span>
</code></pre></div>
<p>The implementation I gave for <code>pow</code> is pretty bad (I think it's exponentially slow in the exponent), but in any case it can be evaluated faster by adding in a specialized instance that relies on the binomial theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">binomial_compute</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="o">(((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">n.choose</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">polynomial.coeff_one_add_X_pow</span><span class="o">]⟩</span>

<span class="k">#eval</span> <span class="n">compute</span> <span class="bp">$</span> <span class="o">((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">^</span><span class="mi">10</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="mi">3</span>
<span class="c1">-- 120</span>
</code></pre></div>
<div class="spoiler-block"><div class="spoiler-header">
<p>Lean 3 code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>
<span class="kn">import</span> <span class="n">order.order_iso_nat</span>
<span class="kn">import</span> <span class="n">data.erased</span>
<span class="kn">import</span> <span class="n">data.polynomial</span>
<span class="kn">import</span> <span class="n">data.nat.choose</span>

<span class="kd">class</span> <span class="n">computable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">erased</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compute</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">compute_eq</span> <span class="o">:</span> <span class="n">compute</span> <span class="bp">=</span> <span class="n">x.out</span><span class="o">)</span>

<span class="kd">abbreviation</span> <span class="n">compute</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">computable.compute</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">compute_eq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="n">compute</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">computable.compute_eq.trans</span> <span class="o">(</span><span class="n">erased.out_mk</span> <span class="n">_</span><span class="o">)</span>

<span class="sd">/-- This should only be used when `x` is not `noncomputable`. -/</span>
<span class="kd">@[inline]</span>
<span class="kd">def</span> <span class="n">computable_default</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">erased.out_mk</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">computable.nat_Inf</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="o">(</span><span class="n">Inf</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">n</span><span class="o">}))</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">p</span> <span class="n">n</span>
<span class="k">then</span> <span class="o">⟨</span><span class="n">nat.find</span> <span class="n">h</span><span class="o">,</span> <span class="n">eq.trans</span> <span class="o">(</span><span class="kd">by</span> <span class="n">convert</span> <span class="o">(</span><span class="n">nat.Inf_def</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="o">(</span><span class="n">erased.out_mk</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">⟩</span>
<span class="k">else</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="o">}⟩</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">is_true</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">compute</span> <span class="o">(</span><span class="n">Inf</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">computable.ite</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">p</span><span class="o">]</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">[</span><span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="n">y</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="o">(</span><span class="k">if</span> <span class="n">p</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="k">then</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">if_pos</span> <span class="n">h</span><span class="o">]</span> <span class="k">else</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">if_neg</span> <span class="n">h</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">decidable.exists_nat_lt</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">is_false</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">])</span>
<span class="k">else</span> <span class="n">is_true</span> <span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">nat.succ_pos</span> <span class="n">_</span><span class="o">⟩,</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="n">decidable.exists_nat_lt'</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">is_true</span> <span class="o">⟨</span><span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">lt_add_one</span> <span class="n">m</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">baz</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">compute</span> <span class="o">(</span><span class="k">if</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="k">then</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span><span class="o">}</span> <span class="k">else</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">})</span>

<span class="kn">section</span> <span class="n">poly</span>
<span class="n">open_locale</span> <span class="n">big_operators</span> <span class="n">polynomial</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">polynomial.C_coeff</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">polynomial.C</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">r</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert_to</span> <span class="o">(</span><span class="n">polynomial.C</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">polynomial.X</span> <span class="bp">^</span> <span class="mi">0</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">polynomial.coeff_C_mul_X_pow</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">polynomial.C_coeff.compute</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="bp">$</span> <span class="o">(</span><span class="n">polynomial.C</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">computable_default</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">polynomial.one_coeff.compute</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="bp">$</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert_to</span> <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="bp">$</span> <span class="o">(</span><span class="n">polynomial.C</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">))</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span><span class="o">),</span>
  <span class="n">apply</span> <span class="n">polynomial.C_coeff.compute</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">polynomial.X_coeff.compute</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="bp">$</span> <span class="o">(</span><span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">convert_to</span> <span class="n">_</span> <span class="bp">=</span> <span class="o">((</span><span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="bp">^</span> <span class="mi">1</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">polynomial.coeff_X_pow</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">polynomial.coeff_add.compute</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">[</span><span class="n">computable</span> <span class="bp">$</span> <span class="n">erased.mk</span> <span class="bp">$</span> <span class="n">p.coeff</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">computable</span> <span class="bp">$</span> <span class="n">erased.mk</span> <span class="bp">$</span> <span class="n">q.coeff</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="bp">$</span> <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="n">compute</span> <span class="o">(</span><span class="n">p.coeff</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="n">compute</span> <span class="o">(</span><span class="n">q.coeff</span> <span class="n">n</span><span class="o">),</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">compute_eq</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">polynomial.coeff_mul.compute</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">[</span><span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="n">computable</span> <span class="bp">$</span> <span class="n">erased.mk</span> <span class="bp">$</span> <span class="n">p.coeff</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="n">computable</span> <span class="bp">$</span> <span class="n">erased.mk</span> <span class="bp">$</span> <span class="n">q.coeff</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="bp">$</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">polynomial.coeff_mul</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">compute_eq</span> <span class="o">(</span><span class="n">p.coeff</span> <span class="n">y</span><span class="o">)),</span> <span class="bp">←</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">compute_eq</span> <span class="o">(</span><span class="n">q.coeff</span> <span class="n">y</span><span class="o">))],</span>
  <span class="n">apply</span> <span class="n">computable_default</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">polynomial.coeff_pow.compute</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span>
  <span class="o">[</span><span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="n">computable</span> <span class="bp">$</span> <span class="n">erased.mk</span> <span class="bp">$</span> <span class="n">p.coeff</span> <span class="n">k</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">k</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="bp">$</span> <span class="o">(</span><span class="n">p</span> <span class="bp">^</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">],</span> <span class="n">resetI</span><span class="o">,</span> <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#eval</span> <span class="n">compute</span> <span class="o">(((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">]))</span><span class="bp">.</span><span class="n">coeff</span> <span class="mi">3</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="c1">-- 0</span>
<span class="k">#eval</span> <span class="n">compute</span> <span class="o">(((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">^</span><span class="mi">10</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="mi">3</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="c1">-- 120</span>

<span class="kd">@[inline]</span>
<span class="kd">instance</span> <span class="n">binomial_compute</span> <span class="o">(</span><span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">computable</span> <span class="o">(</span><span class="n">erased.mk</span> <span class="o">(((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">n.choose</span> <span class="n">k</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">polynomial.coeff_one_add_X_pow</span><span class="o">]⟩</span>

<span class="k">#eval</span> <span class="n">compute</span> <span class="o">(((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">^</span><span class="mi">10</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="mi">3</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="c1">-- 120</span>

<span class="kd">end</span> <span class="n">poly</span>
</code></pre></div>
</div></div>



<a name="274355435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274355435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274355435">(Mar 07 2022 at 06:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/computable.20class/near/274328626">said</a>:</p>
<blockquote>
<p>This makes me wonder: is this a fundamental limitation of the noncomputability system in Lean 3, or is it a fixable bug?</p>
</blockquote>
<p>If I've understood it correctly, this is fixable in Lean 3. The noncomputability checker wasn't skipping inductive type parameters in constructors (which I'm under the impression have no computational relevance), and if we make it skip those, the <code>computable</code> class would work just about the same between Lean 3 and Lean 4.</p>
<p>Would this break anything in theory?</p>
<p>Here's a PR: <a href="https://github.com/leanprover-community/lean/pull/693">lean#693</a> (it passes all the tests on my machine, so it doesn't appear to have broken anything in that respect)</p>



<a name="274355777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274355777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274355777">(Mar 07 2022 at 06:56)</a>:</h4>
<p>After the noncomputability checker, the compiler seems to <a href="https://github.com/leanprover-community/lean/blob/master/src/library/compiler/simp_inductive.cpp#L331">do something similar</a> and skip parameters and also additional computationally irrelevant arguments (these are handled by a separate mechanism in the noncomputability checker).</p>



<a name="274356207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274356207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274356207">(Mar 07 2022 at 07:03)</a>:</h4>
<p>Another question: what's the actual role of <code>noncomputable</code>? If the noncomputability checker fails to say something is noncomputable, is the only effect that the code generator will eventually raise an error?</p>



<a name="274361581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274361581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274361581">(Mar 07 2022 at 08:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/113488-general/topic/computable.20class/near/274341282">said</a>:</p>
<blockquote>
<p>Here's another experiment along these lines. In the spoiler block there are <code>computable</code> instances for getting coefficients of simple polynomial expressions (addition, multiplication, constant powers), and this lets you evaluate, for instance,</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">compute</span> <span class="bp">$</span> <span class="o">((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">^</span><span class="mi">10</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="mi">3</span>
<span class="c1">-- 120</span>
</code></pre></div><br>
</p>
</blockquote>
<p>That looks nice! I really like this. Of course something similar could be accomplished with <code>norm_num</code>. However, what I really like is the promise that this will get rid of all sorts of computability issues in definitions. We should be able to work with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">cardinal.mk</span> <span class="n">X</span> <span class="bp">&lt;</span> <span class="bp">\</span><span class="n">omega</span>
</code></pre></div>
<p>and just have some version of <code>compute</code> that takes care of computations in <code>zmod 8</code> when needed.</p>



<a name="274361609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274361609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274361609">(Mar 07 2022 at 08:32)</a>:</h4>
<p>Just to make sure, will</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">compute</span> <span class="o">(((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">^</span><span class="mi">10</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">120</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>also work?</p>



<a name="274362442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274362442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274362442">(Mar 07 2022 at 08:43)</a>:</h4>
<p>That last one seems like the purview of <code>norm_num</code>, but there's nothing but the usual things stopping a <code>rfl</code> proof like that. That one's too big for my implementation, but something smaller is fine when it's using the binomial theorem instance:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">compute</span> <span class="o">(((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">^</span><span class="mi">3</span><span class="o">)</span><span class="bp">.</span><span class="n">coeff</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="274362905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274362905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274362905">(Mar 07 2022 at 08:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/computable.20class/near/274361581">said</a>:</p>
<blockquote>
<p>and just have some version of <code>compute</code> that takes care of computations in <code>zmod 8</code> when needed.</p>
</blockquote>
<p>I imagine <code>finset</code> could stay as-is, just with noncomputable operations in the API that become computable when you <code>compute</code> with the right decidability instances.  Then, if we had your proposed <code>fintype</code> class, <code>fintype.univ</code> could noncomputably give a <code>finset</code> that becomes computable when <code>compute</code>d. (I think that's behind <code>fin_cases</code>, which I think you're referring to with <code>zmod 8</code>.)</p>



<a name="274371601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274371601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274371601">(Mar 07 2022 at 10:16)</a>:</h4>
<p>This is an interesting solution to the computing with polynomials issue.</p>



<a name="274371793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274371793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274371793">(Mar 07 2022 at 10:18)</a>:</h4>
<p>I know you're keen on getting rid of the laundering, but the <code>class Computable (x : Erased α) where compute : α ...</code> variant has one big advantage, namely that you can write the blanket instance <code>instance [Computable (erase a)] where compute := a ...</code>.</p>



<a name="274371868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274371868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274371868">(Mar 07 2022 at 10:19)</a>:</h4>
<p>Without this blanket instance, I imagine it will be awkward to compute open terms like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">compute</span> <span class="bp">$</span> <span class="o">((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span>
</code></pre></div>



<a name="274372021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274372021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274372021">(Mar 07 2022 at 10:21)</a>:</h4>
<p>On second thought, I'm not sure the blanket instance helps at all.</p>



<a name="274372329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274372329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274372329">(Mar 07 2022 at 10:24)</a>:</h4>
<p>BTW, you probably want to generalize your ite-compute instance so that it gets rid of <code>classical.prop_decidable</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">Decidable</span> <span class="n">p</span><span class="o">]</span> <span class="o">{</span><span class="n">inst</span> <span class="o">:</span> <span class="n">Decidable</span> <span class="n">p</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">Computable</span> <span class="n">x</span><span class="o">]</span> <span class="o">[</span><span class="n">Computable</span> <span class="n">y</span><span class="o">]</span> <span class="o">:</span>
    <span class="n">Computable</span> <span class="o">(</span><span class="bp">@</span><span class="n">ite</span> <span class="n">_</span> <span class="n">p</span> <span class="n">inst</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



<a name="274373197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20class/near/274373197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20class.html#274373197">(Mar 07 2022 at 10:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/113488-general/topic/computable.20class/near/274371868">said</a>:</p>
<blockquote>
<p>Without this blanket instance, I imagine it will be awkward to compute open terms like this:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">compute</span> <span class="bp">$</span> <span class="o">((</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">polynomial.X</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">^</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">coeff</span> <span class="n">n</span>
</code></pre></div><br>
</p>
</blockquote>
<p>At least with how it's set up, this one is fine since the exponent is presumed to be computable, and it's up to the caller of <code>foo</code> to <code>compute</code> the natural number if necessary.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">foo</span> <span class="mi">10</span>
<span class="c1">-- 184756</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
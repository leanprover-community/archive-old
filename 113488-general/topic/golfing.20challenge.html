---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/golfing.20challenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html">golfing challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="242770628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242770628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242770628">(Jun 15 2021 at 17:36)</a>:</h4>
<p>Is there a one line proof of this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="o">({</span><span class="mi">0</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">))</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">⁻¹'</span> <span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="242772700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242772700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242772700">(Jun 15 2021 at 17:52)</a>:</h4>
<p>This is just over the 100 character limit:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.fin</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">set.ext_iff</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="o">({</span><span class="mi">0</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">))</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">⁻¹'</span> <span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">H</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">H</span> <span class="n">x</span><span class="bp">;</span> <span class="n">set</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span><span class="bp">;</span> <span class="n">set</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">g</span> <span class="n">x</span><span class="bp">;</span> <span class="n">fin_cases</span> <span class="n">y</span><span class="bp">;</span> <span class="n">fin_cases</span> <span class="n">z</span><span class="bp">;</span> <span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span>
<span class="c1">--λ H, by simp at H; ext; specialize H x; set y := f x; set z := g x; fin_cases y; fin_cases z; simp * at *</span>
</code></pre></div>



<a name="242772820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242772820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242772820">(Jun 15 2021 at 17:53)</a>:</h4>
<p>I wish we had <code>sets [y,z] [f x, g x]</code>. Also <code>fin_cases *</code> doesn't work as I expected.</p>



<a name="242773025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242773025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242773025">(Jun 15 2021 at 17:54)</a>:</h4>
<p>Golfed <code>specialize</code> down to <code>have :=</code></p>



<a name="242773186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242773186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242773186">(Jun 15 2021 at 17:55)</a>:</h4>
<p>Is it ok to move the hypothesis to the left of the colon?</p>



<a name="242773294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242773294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242773294">(Jun 15 2021 at 17:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.fin</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">set.ext_iff</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="o">({</span><span class="mi">0</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">))</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">⁻¹'</span> <span class="o">{</span><span class="mi">0</span><span class="o">})</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">H</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">H</span> <span class="n">x</span><span class="bp">;</span> <span class="n">set</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span><span class="bp">;</span> <span class="n">set</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">g</span> <span class="n">x</span><span class="bp">;</span> <span class="n">fin_cases</span> <span class="n">y</span><span class="bp">;</span> <span class="n">fin_cases</span> <span class="n">z</span><span class="bp">;</span> <span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span>
</code></pre></div>



<a name="242773309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242773309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242773309">(Jun 15 2021 at 17:56)</a>:</h4>
<p>That's now &lt; 100 chars</p>



<a name="242773354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242773354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242773354">(Jun 15 2021 at 17:57)</a>:</h4>
<p>Nice!</p>



<a name="242773361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242773361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242773361">(Jun 15 2021 at 17:57)</a>:</h4>
<p>I wish <code>fin_cases [f x, g x]</code> would work. That would avoid the <code>set</code>s.</p>



<a name="242773410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242773410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242773410">(Jun 15 2021 at 17:57)</a>:</h4>
<p>yeah that would be nice.</p>



<a name="242775723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242775723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242775723">(Jun 15 2021 at 18:14)</a>:</h4>
<p>Moving the <code>have</code> after the two <code>set</code>s  breaks the proof <span aria-label="head bandage" class="emoji emoji-1f915" role="img" title="head bandage">:head_bandage:</span></p>



<a name="242775792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242775792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242775792">(Jun 15 2021 at 18:14)</a>:</h4>
<p>Turning <code>have</code> into <code>set</code> or <code>let</code> doesn't work either.</p>



<a name="242780258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242780258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242780258">(Jun 15 2021 at 18:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/golfing.20challenge/near/242772820">said</a>:</p>
<blockquote>
<p>I wish we had <code>sets [y,z] [f x, g x]</code>. Also <code>fin_cases *</code> doesn't work as I expected.</p>
</blockquote>
<p>In term mode <code>let x := 1, y := 2</code> works, but in tactic mode the comma is seen as next tactic, maybe a bracketed version of this would be good though <code>set [x := 1, y := 2]</code>?</p>



<a name="242783391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242783391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242783391">(Jun 15 2021 at 19:05)</a>:</h4>
<p>A variant of <span class="user-mention" data-user-id="112680">@Johan Commelin</span> 's proof is now part of  <a href="https://github.com/leanprover-community/mathlib/issues/7954">#7954</a></p>



<a name="242785426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/242785426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#242785426">(Jun 15 2021 at 19:20)</a>:</h4>
<p>Might be easier to do this for bool (can just use cases on the bool val), and use the fin 2 to bool iso</p>



<a name="244382362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244382362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244382362">(Jun 30 2021 at 06:31)</a>:</h4>
<p>From LTE. I can't believe this proof is optimal, but I don't see a better proof either.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">lemma</span> <span class="n">real.Sup_mul</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Sup</span> <span class="o">({</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">Sup</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">P₁</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span> <span class="bp">∧</span>
    <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">y</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">}</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">P₂</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">P₁</span> <span class="bp">↔</span> <span class="n">P₂</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">P₁</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="n">real.Sup_le</span> <span class="n">_</span> <span class="n">h.1</span> <span class="n">h.2</span><span class="o">,</span>
        <span class="n">rintro</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
        <span class="n">apply</span> <span class="n">mul_le_mul_of_nonneg_left</span> <span class="n">_</span> <span class="n">hr.le</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">H</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">real.le_Sup</span> <span class="n">_</span> <span class="n">h.2</span> <span class="n">hx</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="n">H</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">le_div_iff'</span> <span class="n">hr</span><span class="o">,</span> <span class="n">real.Sup_le</span> <span class="n">_</span> <span class="n">h.1</span> <span class="n">h.2</span><span class="o">],</span>
        <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">le_div_iff'</span> <span class="n">hr</span><span class="o">,</span>
        <span class="n">rw</span> <span class="bp">←</span> <span class="n">H</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">real.le_Sup</span> <span class="n">_</span> <span class="n">h.2</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">real.Sup_def</span><span class="o">],</span>
      <span class="n">classical</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span><span class="o">,</span> <span class="n">dif_neg</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">],</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="n">H</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">},</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">and_congr</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">],</span>
      <span class="n">rw</span> <span class="n">exists_comm</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_comm</span><span class="o">,</span> <span class="n">exists_eq_left'</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">and_comm</span><span class="o">],</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_eq_left'</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="n">r</span><span class="o">,</span> <span class="bp">←</span> <span class="n">div_eq_iff_mul_eq</span> <span class="n">hr.ne.symm</span><span class="o">],</span>
      <span class="n">split</span><span class="bp">;</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">x</span> <span class="bp">/</span> <span class="n">r</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
        <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_div_cancel</span> <span class="n">y</span> <span class="n">hr.ne.symm</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">le_div_iff</span> <span class="n">hr</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">hx</span> <span class="n">_</span> <span class="n">hy</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">*</span> <span class="n">x</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
        <span class="n">rw</span> <span class="bp">←</span> <span class="n">div_le_iff'</span> <span class="n">hr</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">hx</span> <span class="n">_</span> <span class="n">hy</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="244387755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244387755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244387755">(Jun 30 2021 at 07:44)</a>:</h4>
<p>This is a bit shorter and a bit less gnarly but it's still pretty long:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span> <span class="n">a</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="bp">←</span><span class="n">le_div_iff</span> <span class="n">ha</span><span class="o">],</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">real.Sup_mul</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Sup</span> <span class="o">({</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">Sup</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hb</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="c1">-- unbounded case</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">real.Sup_of_not_bdd_above</span> <span class="n">hb</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">real.Sup_of_not_bdd_above</span><span class="o">],</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="n">hb</span> <span class="o">⟨</span><span class="n">r</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">B</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">foo</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hB</span> <span class="o">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">hrb</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">hb</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">*</span> <span class="n">B</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rintro</span> <span class="n">_</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hys</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">mul_le_mul_left</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hB</span> <span class="n">hys</span> <span class="o">},</span>
  <span class="n">by_cases</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="c1">-- empty case</span>
    <span class="n">rw</span> <span class="n">set.not_nonempty_iff_eq_empty</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hs</span><span class="o">,</span> <span class="n">real.Sup_empty</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">hs</span> <span class="k">with</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">cSup_le_iff</span> <span class="n">hrb</span> <span class="o">⟨</span><span class="n">r</span> <span class="bp">*</span> <span class="n">t</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">rintros</span> <span class="n">b</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hys</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">mul_le_mul_left</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">le_cSup</span> <span class="n">hb</span> <span class="n">hys</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">foo</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">cSup_le</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">rintros</span> <span class="n">b</span> <span class="n">hbs</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">foo</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">le_cSup</span> <span class="n">hrb</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hbs</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="244388357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244388357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244388357">(Jun 30 2021 at 07:51)</a>:</h4>
<p>The problem (for those idly watching on) is that basically the definition of "Sup S" is "if S is empty or unbounded it's zero, else it's what a mathematician would call Sup S" so I had to break into three cases.</p>



<a name="244389371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244389371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244389371">(Jun 30 2021 at 08:02)</a>:</h4>
<p>It feels like we're missing a <code>cSup_image</code> lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">lemma</span> <span class="n">real.Sup_mul</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Sup</span> <span class="o">({</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">Sup</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="n">exists_prop</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">Sup</span> <span class="o">(((</span><span class="bp">*</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">Sup</span> <span class="n">s</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">mul_le_mul_left</span> <span class="n">hr</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="n">r</span><span class="o">),</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  this: monotone f</span>
<span class="cm">  ⊢ Sup (f '' s) = f (Sup s)</span>
<span class="cm">  -/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="244390618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244390618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244390618">(Jun 30 2021 at 08:16)</a>:</h4>
<p>Eric, you haven't read Kevin's message carefully enough</p>



<a name="244390682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244390682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244390682">(Jun 30 2021 at 08:16)</a>:</h4>
<p>The lemma you have in mind is wrong. Counter-example: <code>f</code> maps <code>x</code> to <code>x+1</code> and <code>s = univ</code>.</p>



<a name="244390808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244390808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244390808">(Jun 30 2021 at 08:18)</a>:</h4>
<p>You need to add the assumption that <code>f</code> preserves zero and something like <code>f '' s</code> is bounded iff <code>s</code> is bounded. Yes, it's a pain, that's the point.</p>



<a name="244390979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244390979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244390979">(Jun 30 2021 at 08:20)</a>:</h4>
<p>Here's the version I'm thinking of:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">cSup_image</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span>
  <span class="o">[</span><span class="n">conditionally_complete_linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">conditionally_complete_lattice</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hs'</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">Sup</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">Sup</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">hf.map_bdd_above</span> <span class="n">hs</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">hf.cSup_image_le</span> <span class="n">hs'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_upper_bounds</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_cSup</span> <span class="n">hs</span> <span class="n">hx</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">hf.le_cSup_image</span> <span class="n">_</span> <span class="n">hs</span><span class="o">,</span>
  <span class="gr">sorry</span> <span class="c1">-- `Sup s ∈ s` - is this true, given we have a linear order?</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span> <span class="n">a</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="bp">←</span><span class="n">le_div_iff</span> <span class="n">ha</span><span class="o">],</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">real.Sup_mul'</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Sup</span> <span class="o">({</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">Sup</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hb</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="c1">-- unbounded case</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">real.Sup_of_not_bdd_above</span> <span class="n">hb</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">real.Sup_of_not_bdd_above</span><span class="o">],</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="n">hb</span> <span class="o">⟨</span><span class="n">r</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">B</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">foo</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hB</span> <span class="o">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="n">by_cases</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="c1">-- empty case</span>
    <span class="n">rw</span> <span class="n">set.not_nonempty_iff_eq_empty</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hs</span><span class="o">,</span> <span class="n">real.Sup_empty</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">simp_rw</span> <span class="n">exists_prop</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">mul_le_mul_left</span> <span class="n">hr</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">cSup_image</span> <span class="n">s</span> <span class="n">hb</span> <span class="n">hs</span> <span class="n">_</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I don't know whether that <code>sorry</code> is true</p>



<a name="244391060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244391060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244391060">(Jun 30 2021 at 08:20)</a>:</h4>
<p><code>sorry</code> looks false to me: bounded subsets of reals don't need to contain their Sup</p>



<a name="244391094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244391094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244391094">(Jun 30 2021 at 08:21)</a>:</h4>
<p>Take <code>(0, x)</code>. The Sup is <code>x</code>, but not contained in the open interval</p>



<a name="244391136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244391136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244391136">(Jun 30 2021 at 08:21)</a>:</h4>
<p>Yeah otherwise everything would have a maximal element.</p>



<a name="244391485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244391485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244391485">(Jun 30 2021 at 08:25)</a>:</h4>
<p>Does <code>cSup_image</code> look true, even if my proof went in a bad direction?</p>



<a name="244391574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244391574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244391574">(Jun 30 2021 at 08:26)</a>:</h4>
<p>No, it doesn't</p>



<a name="244392029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244392029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244392029">(Jun 30 2021 at 08:32)</a>:</h4>
<p>Alright, in that case I back down my <code>cSup_image</code> suggestion, and just offer a golfed version of Kevin's proof (keeping his <code>foo</code>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">real.Sup_mul''</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Sup</span> <span class="o">({</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">Sup</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="n">exists_prop</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">Sup</span> <span class="o">(((</span><span class="bp">*</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">Sup</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hb</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="c1">-- unbounded case</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">real.Sup_of_not_bdd_above</span> <span class="n">hb</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">real.Sup_of_not_bdd_above</span><span class="o">],</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="n">hb</span> <span class="o">⟨</span><span class="n">r</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">B</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">foo</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hB</span> <span class="o">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">hm</span> <span class="o">:</span> <span class="n">monotone</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">mul_le_mul_left</span> <span class="n">hr</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hrb</span> <span class="o">:=</span> <span class="n">hm.map_bdd_above</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="c1">-- empty case</span>
    <span class="n">rw</span> <span class="n">set.not_nonempty_iff_eq_empty</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hs</span><span class="o">,</span> <span class="n">real.Sup_empty</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">hm.cSup_image_le</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_cSup</span> <span class="n">hb</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">foo</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">cSup_le</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">rintros</span> <span class="n">b</span> <span class="n">hbs</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">foo</span> <span class="n">hr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">le_cSup</span> <span class="n">hrb</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hbs</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="244392270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244392270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244392270">(Jun 30 2021 at 08:34)</a>:</h4>
<p>This is soo painful. This kind of proof is a really cruel example of how far we are from having a usable tool. Where is AI when we need it?</p>



<a name="244392345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244392345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244392345">(Jun 30 2021 at 08:35)</a>:</h4>
<p>Is this an example of <code>cSup</code> / <a href="https://leanprover-community.github.io/mathlib_docs/find/conditionally_complete_linear_order">docs#conditionally_complete_linear_order</a> being too weird a definition to have a generalizable API?</p>



<a name="244392437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244392437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244392437">(Jun 30 2021 at 08:36)</a>:</h4>
<p>Eg the fact that we don't have a typeclass that says <code>Sup s = 0</code> if <code>s</code> is not bounded / empty. Maybe the only instance where that's true is the reals though anyway, I think the other instances all have a <code>bot</code>.</p>



<a name="244392658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244392658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244392658">(Jun 30 2021 at 08:39)</a>:</h4>
<p>This generalizes out the multiplication, at least (slightly cleaned up):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">lemma</span> <span class="n">real.Sup_image</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf'</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">):</span>
  <span class="n">Sup</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">Sup</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hb</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">),</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="c1">-- unbounded case</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">real.Sup_of_not_bdd_above</span> <span class="n">hb</span><span class="o">,</span> <span class="n">real.Sup_of_not_bdd_above</span><span class="o">,</span> <span class="n">hf'</span><span class="o">],</span>
    <span class="n">contrapose</span><span class="bp">!</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">f.monotone.map_bdd_above</span> <span class="n">hb</span> <span class="o">},</span>

  <span class="k">have</span> <span class="n">hrb</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">convert</span> <span class="n">monotone.map_bdd_above</span> <span class="n">f.symm.monotone</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">},</span>

  <span class="n">by_cases</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="c1">-- empty case</span>
    <span class="n">rw</span> <span class="n">set.not_nonempty_iff_eq_empty</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hs</span><span class="o">,</span> <span class="n">real.Sup_empty</span><span class="o">,</span> <span class="n">hf'</span><span class="o">],</span> <span class="o">},</span>

  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">hs</span> <span class="k">with</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">cSup_le_iff</span> <span class="n">hb</span> <span class="o">⟨</span><span class="n">f</span> <span class="n">t</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">rintros</span> <span class="n">b</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hys</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">f.monotone</span> <span class="o">(</span><span class="n">le_cSup</span> <span class="n">hrb</span> <span class="n">hys</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">f.apply_symm_apply</span> <span class="o">(</span><span class="n">Sup</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)),</span>
    <span class="n">apply</span> <span class="n">f.monotone</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">cSup_le</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">f.symm.monotone</span> <span class="o">(</span><span class="n">f.monotone.le_cSup_image</span> <span class="n">hb</span> <span class="n">hrb</span><span class="o">),</span>
    <span class="n">simp</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">real.Sup_mul</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Sup</span> <span class="o">({</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">Sup</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">S</span> <span class="o">:=</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="bp">''</span> <span class="n">s</span> <span class="k">with</span> <span class="n">hS</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">this</span><span class="o">,</span> <span class="n">hS</span><span class="o">],</span>
  <span class="k">let</span> <span class="n">ff</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="n">r</span><span class="o">),</span>
    <span class="n">inv_fun</span> <span class="o">:=</span> <span class="o">((</span><span class="bp">*</span><span class="o">)</span> <span class="n">r</span><span class="bp">⁻¹</span><span class="o">),</span>
    <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">map_rel_iff'</span> <span class="o">:=</span> <span class="n">_</span>
  <span class="o">},</span>
  <span class="n">refine</span> <span class="n">real.Sup_image</span> <span class="n">s</span> <span class="n">ff</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hr.ne'</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hr.ne'</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_le_mul_left</span> <span class="n">hr</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="244393170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393170">(Jun 30 2021 at 08:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113488-general/topic/golfing.20challenge/near/244392270">said</a>:</p>
<blockquote>
<p>This is soo painful. This kind of proof is a really cruel example of how far we are from having a usable tool. Where is AI when we need it?</p>
</blockquote>
<p>I claim that the reason it's painful is that we spend a lot of time dealing with the junk case where Sup(S) is meaningless and it coincidentally happens to be the case that the lemma is true anyway -- this is precisely what hurts Eric's approach, where a more conceptual lemma is not true because it fails in the junk cases. However Johan is a mathematician so presumably only cares about this lemma in the case where Sup(S) is not junk, in which case the proof is just those last 8 lines of Eric's proof and looks far more reasonable. So whilst I agree with you that in some sense this is a problem with the tool, the problem is that we mathematicians now have taken on board this whole "garbage in garbage out" approach with our definitions and are trying to prove lemmas which are easier for people to use, and harder to prove. </p>
<p>I think the real question is: take Eric's abstraction about monotone functions and sups, and now add in the hypotheses that the set is nonempty and bounded. Then the abstraction becomes true, the proof will be short, and it looks useful to me. Is this good enough for Johan's application? I bet it is.</p>



<a name="244393349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393349">(Jun 30 2021 at 08:46)</a>:</h4>
<p>Argument from CS people: "the great thing about garbage-in garbage-out defs is that sometimes stuff is true without side conditions! For example a/b + c/b = (a+c)/b is true without assuming b=0! This is a big win!". Mathematician: "...but I have hb : b != 0 in my local context anyway"</p>



<a name="244393384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393384">(Jun 30 2021 at 08:46)</a>:</h4>
<blockquote>
<p>Is this good enough for Johan's application? I bet it is.</p>
</blockquote>
<p>Yes it is. But it shifts the burden, as you say yourself:</p>
<blockquote>
<p>prove lemmas which are easier for people to use, and harder to prove.</p>
</blockquote>



<a name="244393416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393416">(Jun 30 2021 at 08:47)</a>:</h4>
<p>We all agree that it's cute that <code>/</code> can be extended to all of the reals, however it extends to a junk function which mathematicians have no use for most of the time apart from super-low-level stuff, so will not show up at all after some point (in the sense that <code>hb : b != 0</code> will always be there)</p>



<a name="244393439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393439">(Jun 30 2021 at 08:47)</a>:</h4>
<p>Because it means that I have to do the painful checking that my input is not garbage at the place where I want to apply the lemma. And at that point I really don't want to be bothered by those "silly" side conditions.</p>



<a name="244393559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393559">(Jun 30 2021 at 08:48)</a>:</h4>
<p>So you're saying that you _don't_ have the handy hypotheses that S is nonempty and bounded above in your local context, even though they're going to be there in the mathematical source you're formalising?</p>



<a name="244393581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393581">(Jun 30 2021 at 08:48)</a>:</h4>
<p>Let me check exactly what I have</p>



<a name="244393593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393593">(Jun 30 2021 at 08:49)</a>:</h4>
<p>If this is a serious problem for you then probably one should push ahead with Eric's abstraction</p>



<a name="244393763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393763">(Jun 30 2021 at 08:50)</a>:</h4>
<p>The norm of a locally constant function is the Sup norm. But if the range is empty or unbounded...</p>



<a name="244393796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393796">(Jun 30 2021 at 08:51)</a>:</h4>
<p>There should perhaps be a "one size fits all" lemma of the form "to prove some theorem about Sups, it suffices to prove it when all the sets are nonempty and bounded above, and also that it works for 0" (except I am currnetly unclear how one manages the situation we have here, where there are two sets and it's a cute lemma that one is empty/unbounded iff the other one is), and then use the mono lemma for the sensible case...oh crap the mono lemma isn't even true in the unbounded case of course, it needs continuity as well</p>



<a name="244393817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393817">(Jun 30 2021 at 08:51)</a>:</h4>
<p>So, we are on a compact space, so it cannot be unbounded. But it can still be empty.</p>



<a name="244393858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393858">(Jun 30 2021 at 08:51)</a>:</h4>
<p>Mathematically, the sup of an empty collection of norms is the sup of the empty set in <code>nnreal</code> so it really is 0</p>



<a name="244393928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244393928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244393928">(Jun 30 2021 at 08:52)</a>:</h4>
<p>Maybe we should embrace <code>nnreal</code> a bit more.</p>



<a name="244394040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244394040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244394040">(Jun 30 2021 at 08:53)</a>:</h4>
<p>The analysts seem to have thought hard about where to use it (e.g. they don't want to use it for metric spaces but do want to use it for some measure theory)</p>



<a name="244394102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244394102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244394102">(Jun 30 2021 at 08:54)</a>:</h4>
<p>See <a href="https://github.com/leanprover-community/lean-liquid/blob/master/src/prop_92/concrete.lean#L58L127">https://github.com/leanprover-community/lean-liquid/blob/master/src/prop_92/concrete.lean#L58L127</a> for a bit more pain</p>



<a name="244394628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244394628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244394628">(Jun 30 2021 at 08:59)</a>:</h4>
<p>Kevin, the issue is not only that S can be unbounded, it's also that S can be bounded and f(S) unbounded.</p>



<a name="244397570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244397570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244397570">(Jun 30 2021 at 09:30)</a>:</h4>
<p>If <code>f</code> is a <code>A ≃o A</code> as in <span class="user-mention" data-user-id="307953">@Ruben Van de Velde</span>'s version then <a href="https://leanprover-community.github.io/mathlib_docs/find/monotone.map_bdd_above">docs#monotone.map_bdd_above</a> means that f(S) and S are both bounded, right?</p>



<a name="244398756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244398756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244398756">(Jun 30 2021 at 09:41)</a>:</h4>
<p>Aah interesting -- Patrick and I are thinking of maps like y=tan(x) which send the bounded region (-pi/2,pi/2) to an unbounded region, but tan is not defined on all of the reals.</p>



<a name="244399521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244399521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244399521">(Jun 30 2021 at 09:48)</a>:</h4>
<p>Another issue with the latest proposed <code>cSup_image</code> lemma is that <code>f</code> can be discontinuous at <code>Sup x</code>: <code>s = {x : ℝ | x &lt; 0}</code> and <code>f = real.sign</code>.</p>



<a name="244399623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244399623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244399623">(Jun 30 2021 at 09:49)</a>:</h4>
<p>Here's a generalized version of <span class="user-mention" data-user-id="307953">@Ruben Van de Velde</span>'s:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">lemma</span> <span class="n">order_iso.cSup_image</span>
  <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">conditionally_complete_lattice</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">conditionally_complete_lattice</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hs'</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">):</span>
  <span class="n">Sup</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">Sup</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">f.monotone.cSup_image_le</span> <span class="n">hs'</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_cSup</span> <span class="n">hs</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">f.apply_symm_apply</span> <span class="o">(</span><span class="n">Sup</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)),</span>
    <span class="n">apply</span> <span class="n">f.monotone</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">cSup_le</span> <span class="n">hs'</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">f.symm.monotone</span> <span class="o">(</span><span class="n">f.monotone.le_cSup_image</span> <span class="n">hb</span> <span class="n">hs</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">f.symm_apply_apply</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">real.Sup_image</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf'</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">):</span>
  <span class="n">Sup</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">Sup</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">hb</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">s</span><span class="o">),</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="c1">-- unbounded case</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">real.Sup_of_not_bdd_above</span> <span class="n">hb</span><span class="o">,</span> <span class="n">real.Sup_of_not_bdd_above</span><span class="o">,</span> <span class="n">hf'</span><span class="o">],</span>
    <span class="n">contrapose</span><span class="bp">!</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">f.monotone.map_bdd_above</span> <span class="n">hb</span> <span class="o">},</span>

  <span class="k">have</span> <span class="n">hrb</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">s</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">convert</span> <span class="n">monotone.map_bdd_above</span> <span class="n">f.symm.monotone</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">},</span>

  <span class="n">by_cases</span> <span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="c1">-- empty case</span>
    <span class="n">rw</span> <span class="n">set.not_nonempty_iff_eq_empty</span> <span class="n">at</span> <span class="n">hs</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hs</span><span class="o">,</span> <span class="n">real.Sup_empty</span><span class="o">,</span> <span class="n">hf'</span><span class="o">],</span> <span class="o">},</span>

  <span class="n">exact</span> <span class="n">f.cSup_image</span> <span class="n">s</span> <span class="n">hrb</span> <span class="n">hs</span><span class="o">,</span>
<span class="kd">end</span>

<span class="sd">/-- `equiv.mul_left'` as an order_iso. TODO: add this for all the other equivs too. -/</span>
<span class="kd">@[simps {simp_rhs := tt}]</span>
<span class="kd">def</span> <span class="n">order_iso.mul_left'</span> <span class="o">{</span><span class="n">K</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">≃</span><span class="n">o</span> <span class="n">K</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_rel_iff'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">mul_le_mul_left</span> <span class="n">hk</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">equiv.mul_left'</span> <span class="n">k</span> <span class="n">hk.ne'</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">real.Sup_mul</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">Sup</span> <span class="o">({</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">})</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">Sup</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="n">exists_prop</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">real.Sup_image</span> <span class="n">s</span> <span class="o">(</span><span class="n">order_iso.mul_left'</span> <span class="n">r</span> <span class="n">hr</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_zero</span> <span class="n">_</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="244399850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244399850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244399850">(Jun 30 2021 at 09:52)</a>:</h4>
<p><del>My guess would be that <code>mul_left_iso</code> already exists somewhere</del>. Yep: <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.mul_left'">docs#equiv.mul_left'</a></p>



<a name="244399988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244399988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244399988">(Jun 30 2021 at 09:53)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  the first lemma is <a href="https://leanprover-community.github.io/mathlib_docs/find/set.nonempty.cSup_mem">docs#set.nonempty.cSup_mem</a></p>



<a name="244445212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golfing%20challenge/near/244445212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golfing.20challenge.html#244445212">(Jun 30 2021 at 15:50)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/8150">#8150</a> adds <code>order_iso.mul_left'</code> and similar defintions</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/computable.20real.20functions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html">computable real functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="181131411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181131411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181131411">(Nov 19 2019 at 16:56)</a>:</h4>
<p>Let R denote the Dedekind reals. I know that constructively it is consistent that all functions R -&gt; R are continuous. In the other direction, what functions R -&gt; R definitely are computable? I assume polynomials are; what about the exponential function for example? Or any function which provably grows faster than any polynomial?</p>



<a name="181132082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181132082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181132082">(Nov 19 2019 at 17:03)</a>:</h4>
<p>What kind of dedekind reals are we talking here? Are they functions <code>Q -&gt; bool</code> that decide the relation <code>q &lt; x</code>?</p>



<a name="181132705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181132705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181132705">(Nov 19 2019 at 17:10)</a>:</h4>
<p>There are various notions of computability for infinitary objects. There is a survey overview of the history here: <a href="https://arxiv.org/pdf/1206.3431.pdf" target="_blank" title="https://arxiv.org/pdf/1206.3431.pdf">https://arxiv.org/pdf/1206.3431.pdf</a>, and Section 2.9 has some of the relevant definitions. (Even more complications arise when you start talking about partial functions.)</p>
<p>The most common and useful definition is called "Type II computability." Roughly, a function f(x) is type II computable if there is an algorithm which, given as input a function representing a Cauchy sequence of rationals converging to x with an explicit rate of convergence, computes arbitrarily good approximations to f(x). Any reasonable computable function will have this property.</p>
<p>Once can also talk about complexity bounded computation, like primitive recursive functions on the reals and polynomial time computable functions on the reals. That gets messy. But for the most basic notion of computability, the basic intuitions work pretty well: if you can compute arbitrarily good approximations to the output given the ability to query arbitrarily good approximation to the input, the function is computable.</p>



<a name="181133145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181133145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181133145">(Nov 19 2019 at 17:14)</a>:</h4>
<blockquote>
<p>What kind of dedekind reals are we talking here? Are they functions <code>Q -&gt; bool</code> that decide the relation <code>q &lt; x</code>?</p>
</blockquote>
<p>I guess I specifically mean the one in the HoTT book, but it's also one I've seen elsewhere. A Dedekind real is a pair of <code>L : Q -&gt; Prop</code> and <code>U : Q -&gt; Prop</code> which satisfy some axioms which mean they look like <code>({q | q &lt; r}, {q | q &gt; r})</code>.</p>



<a name="181133961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181133961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181133961">(Nov 19 2019 at 17:22)</a>:</h4>
<p>For something like the exponential function, which is differentiable everywhere and computable on cauchy sequences, it seems there is no problem computing it on dedekind reals either</p>



<a name="181134231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181134231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181134231">(Nov 19 2019 at 17:25)</a>:</h4>
<p>This might be relevant: <a href="https://mathoverflow.net/questions/236483/difference-between-constructive-dedekind-and-cauchy-reals-in-computation" target="_blank" title="https://mathoverflow.net/questions/236483/difference-between-constructive-dedekind-and-cauchy-reals-in-computation">https://mathoverflow.net/questions/236483/difference-between-constructive-dedekind-and-cauchy-reals-in-computation</a></p>



<a name="181135656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181135656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181135656">(Nov 19 2019 at 17:40)</a>:</h4>
<p>Oh, sorry, I missed the "Dedekind" part. Ignore everything I said. Even though some people like Dedekind reals, I find them really unnatural to think about computationally.</p>



<a name="181136068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181136068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181136068">(Nov 19 2019 at 17:44)</a>:</h4>
<p>I'm actually interested in the constructive aspects, not computational ones. (This is really a math question but I thought Patrick would complain if I asked in on <a class="stream" data-stream-id="116395" href="/#narrow/stream/116395-maths">#maths</a>)</p>



<a name="181136592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181136592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181136592">(Nov 19 2019 at 17:51)</a>:</h4>
<p>The HoTT book proves that the Dedekind reals are Cauchy complete. So let's say I want to evaluate the exponential function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\exp(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> by the power series. I need to know its rate of convergence. If I had an integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">|x| &lt; N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>, then I could construct a Cauchy sequence with known rate of convergence and produce <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\exp(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>.</p>



<a name="181136682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181136682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181136682">(Nov 19 2019 at 17:52)</a>:</h4>
<p>Haha, I see I chose a poor topic name.</p>



<a name="181136866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181136866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181136866">(Nov 19 2019 at 17:54)</a>:</h4>
<p>Hopefully it's obvious that two Cauchy sequences with the same terms but different rates of convergence converge to the same Dedekind real</p>



<a name="181137045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181137045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181137045">(Nov 19 2019 at 17:56)</a>:</h4>
<p>then at least if <code>Prop</code> really means subsingletons like in HoTT, then I think I'm done. Since I can pick some rational lower and upper bounds, use those to construct the Cauchy sequence, and then prove that the result doesn't depend on the choice of bounds.</p>



<a name="181154490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181154490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181154490">(Nov 19 2019 at 21:09)</a>:</h4>
<blockquote>
<p>I'm actually interested in the constructive aspects, not computational ones. (This is really a math question but I thought Patrick would complain if I asked in on <a class="stream" data-stream-id="116395" href="/#narrow/stream/116395-maths">#maths</a>)</p>
</blockquote>
<p>Hey, I don't mind questions about constructive maths in maths. Constructive maths is definitely a part of maths. It's a very specialized part of math, and you don't expect to find it represented in most math departments (or even expect most mathematicians to have heard of it). But that's fine, everybody is allowed to be interested in arcane maths. What is less pleasant is people preaching that all mathematics should be constructive. But most of all, what I would really really find sad would be to make mathlib less useful to mathematicians in order to make it more constructive. We already have mathcomp in Coq for this.</p>



<a name="181175338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181175338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181175338">(Nov 20 2019 at 02:43)</a>:</h4>
<p>I'll use the word "computable" here since that is my wheelhouse, but this should also hold for any notion of "constructive" that is worth its weight in salt.  There is a mysterious and magical (please don't burn me at the stake!), but altogether real principle: Every <strong>natural</strong> real number and <strong>natural</strong> real continuous function is computable.  Period.  The proof might not be known, but it is and you should just accept that it is and look for the proof.  This means that exponential functions, polynomials, super exponential functions, integrals of natural continuous functions, integrals of natural measurable functions, your favorite continuous function from undergrad, and so on are computable.  Now, proving that it is computable might take a bit of work, but usually that work is just following the classical proof that the function is continuous.  After working out a few examples, you get the hang of it.  <strong>I don't say this (just) to be polemic.  This principle had a profound positive effect on my research.  I stopped worrying if real functions were computable and figured either someone else already showed they were or that I could prove it easily when I got to the point I needed that fact.</strong><br>
Here is some clarification:</p>
<ul>
<li>I am sure you are trying to think of counterexamples, but I would wager good money you can't find any.  One can debate the definition of "natural" here, but there are some obvious things which aren't.  You can't just plug in a non-natural non-computable number into continuous function with parameters.  All parameters (for example, coefficients in polynomials) need to be filled in with natural real numbers (or you can talk about the theorem which says that for all parameters the resulting function is computable uniformly relative to the parameters).  Also, you can't do some arbitrary encoding of the Turing machines (which are already arbitrarily encoded) or Hilbert's tenth problem.  (If there was a natural encoding that would be another matter, but my point is that such natural encodings don't exist.)</li>
<li>This is not an obviously principle as far as I can tell.  It fits in the same uncomfortable zone as the Church-Turing thesis where it is not a theorem, and probably can't be formalized, but it sure seems true (and is quite useful).</li>
<li>This principle is special to real (and complex) functions.  For functions from natural numbers to natural numbers (of which all are continuous), there are clear examples of natural functions (for example Hilbert's 10th problem) which are not computable.</li>
<li>Here is a special application of my principle.  It is not proven yet <a href="https://mathoverflow.net/questions/249617/is-the-area-of-the-mandelbrot-provably-computable" target="_blank" title="https://mathoverflow.net/questions/249617/is-the-area-of-the-mandelbrot-provably-computable">if the area of the Mandelbrot set is computable</a>.  Regardless, my principle says it is.</li>
</ul>



<a name="181187308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181187308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181187308">(Nov 20 2019 at 08:16)</a>:</h4>
<blockquote>
<p>Let R denote the Dedekind reals. [...] In the other direction, what functions R -&gt; R definitely are computable?</p>
</blockquote>
<p>Andrej Bauer and Paul Taylor did some work on computation with Dedekind reals. Start with <a href="http://math.andrej.com/2008/08/24/efficient-computation-with-dedekind-reals/" target="_blank" title="http://math.andrej.com/2008/08/24/efficient-computation-with-dedekind-reals/">Andrej's blog post</a>.</p>



<a name="181261891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181261891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181261891">(Nov 20 2019 at 23:41)</a>:</h4>
<p>I feel a bit self conscious about my post above.  Most of the strong statements in first paragraph were for effect (and to peak your interest) and I don’t mean them to be dogmatic, just helpful advice.</p>



<a name="181261970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181261970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181261970">(Nov 20 2019 at 23:43)</a>:</h4>
<p>Also, since this conversation is open, I have a question.  In computability theory, the two-sided Dedikind cut approach and the Cauchy sequence approach (with a given rate of convergence) are equicomputable.  However, in constructive mathematics, it seems that they are talked about as if they are not equivalent.  This confuses me because it seems like there is a clear construction to go from a two-sided Dedikind cut to a Cauchy sequence and back.  Am I missing something here?  Is the Cauchy version of the HoTT construction not equivalent to the Dedekind HoTT construction?</p>



<a name="181312599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181312599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181312599">(Nov 21 2019 at 15:05)</a>:</h4>
<blockquote>
<p>Also, since this conversation is open, I have a question.  In computability theory, the two-sided Dedekind cut approach and the Cauchy sequence approach (with a given rate of convergence) are equicomputable.  However, in constructive mathematics, it seems that they are talked about as if they are not equivalent.  This confuses me because it seems like there is a clear construction to go from a two-sided Dedekind cut to a Cauchy sequence and back.  Am I missing something here?  Is the Cauchy version of the HoTT construction not equivalent to the Dedekind HoTT construction?</p>
</blockquote>
<p>Let's leave HoTT out of it, since we're just talking about sets. If we work in a bare-bones constructive setting (no impredicativity, no countable choice, and no Markov's principle), then most definitions are inequivalent: equivalence classes of rapidly converging Cauchy sequences, the Cauchy completion of the rationals, the decidable Dedekind reals, arbitrary Dedekind reals (= points of the localic reals), and the order completion of the rationals. If we assume countable choice (or just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">C</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="double-struck">N</mi><mo separator="true">,</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathrm{AC}(\mathbb{N},\mathbb{N}) </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">A</span><span class="mord mathrm">C</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">N</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mclose">)</span></span></span></span>), then we get isomorphisms between the quotient of rapidly converging Cauchy sequences, the Cauchy reals, and the Dedekind reals.<br>
The comparison between computability theory and constructive analysis is not always straight-forward, though: Classically, a computable (Cauchy) real is either rational or not, and hence is in either case a decidable Dedekind real (over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">A</mi></mrow><mn>0</mn></msub></mrow><annotation encoding="application/x-tex"> \mathrm{RCA}_0 </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">R</span><span class="mord mathrm">C</span><span class="mord mathrm">A</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>). However, to turn a sequence of Cauchy reals into a sequence of decidable Dedekind reals requires <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">A</mi></mrow><mn>0</mn></msub></mrow><annotation encoding="application/x-tex"> \mathrm{ACA}_0 </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">A</span><span class="mord mathrm">C</span><span class="mord mathrm">A</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. I think that the type-two theory of effectivity provides a better link with constructive analysis, via realizability, cf. e.g. the <a href="https://www2.mathematik.tu-darmstadt.de/~streicher/THESES/lietz.pdf" target="_blank" title="https://www2.mathematik.tu-darmstadt.de/~streicher/THESES/lietz.pdf">thesis by Lietz</a>.</p>



<a name="181313598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181313598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181313598">(Nov 21 2019 at 15:14)</a>:</h4>
<blockquote>
<p>If we assume countable choice (or just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">C</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="double-struck">N</mi><mo separator="true">,</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{AC}(\mathbb{N},\mathbb{N})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">A</span><span class="mord mathrm">C</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">N</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mclose">)</span></span></span></span>), then we get isomorphisms between the quotient of rapidly converging Cauchy sequences, the Cauchy reals, and the Dedekind reals.</p>
</blockquote>
<p>Could you elaborate on this? It's also not clear to me why you can't build a dedekind real from a rapidly converging cauchy sequence or vice versa</p>



<a name="181314073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181314073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181314073">(Nov 21 2019 at 15:19)</a>:</h4>
<p>There are maps from rapidly converging Cauchy sequences to the Cauchy reals and from there to the Dedekind reals. Models where the Cauchy and Dedekind reals differ are discussed in <a href="https://mathoverflow.net/questions/128569/a-model-where-dedekind-reals-and-cauchy-reals-are-different" target="_blank" title="https://mathoverflow.net/questions/128569/a-model-where-dedekind-reals-and-cauchy-reals-are-different">this MO question</a>. Lemma 11.4.1 in the HoTT book discusses the equivalence given CC (or LEM).</p>



<a name="181317110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181317110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181317110">(Nov 21 2019 at 15:47)</a>:</h4>
<p>For the fact that the set of equivalence classes of rapidly converging Cauchy reals need not be Cauchy complete, see Lubarsky's <em><a href="http://dx.doi.org/10.1016/j.entcs.2006.09.012" target="_blank" title="http://dx.doi.org/10.1016/j.entcs.2006.09.012">On the Cauchy Completeness of the Constructive Cauchy Reals</a></em>. (I think it's misleading to call this set the <em>Cauchy reals</em>, then: that name should be reserved for the Cauchy completion of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex"> \mathbb{Q} </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord mathbb">Q</span></span></span></span></span>.)</p>



<a name="181319233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181319233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181319233">(Nov 21 2019 at 16:06)</a>:</h4>
<p>There's also a natural map from <em>decidable</em> Dedekind reals to rapidly converging Cauchy reals. Maybe that's one you had in mind.</p>



<a name="181320148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181320148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181320148">(Nov 21 2019 at 16:14)</a>:</h4>
<p>A dedekind real is located, meaning that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi mathvariant="double-struck">Q</mi></mrow></msub><mo separator="true">,</mo><mi>x</mi><mo>&lt;</mo><mi>y</mi><mo>→</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>L</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∈</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi_{x,y:\mathbb{Q}},x&lt;y\to (x\in L)+(y\in U)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.332223em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">:</span><span class="mord mtight"><span class="mord mathbb mtight">Q</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span>. So that means that given an initial interval such as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">0\in L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">1\in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>, if you let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">x=1/3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>2</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">y=2/3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">/</span><span class="mord">3</span></span></span></span> then either <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">x\in L</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">y\in R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>, and in either case you have a new interval bracketing the real of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">2/3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">/</span><span class="mord">3</span></span></span></span> of the original. Repeating this process yields a rapidly converging cauchy sequence for the real</p>



<a name="181320412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181320412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181320412">(Nov 21 2019 at 16:17)</a>:</h4>
<p>This does not require the cuts themselves to be decidable (i.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>L</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo mathvariant="normal">∉</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x\in L)+(x\notin L)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span></span></span></span>)</p>



<a name="181321047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181321047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181321047">(Nov 21 2019 at 16:23)</a>:</h4>
<p>Located means rather <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi mathvariant="double-struck">Q</mi></mrow></msub><mo separator="true">,</mo><mi>x</mi><mo>&lt;</mo><mi>y</mi><mo>→</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>L</mi><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∈</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \prod_{x,y:\mathbb{Q}}, x&lt;y \to (x \in L) \vee (y \in U) </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.18251299999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">:</span><span class="mord mtight"><span class="mord mathbb mtight">Q</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span>. You need CC to go to your formulation.</p>



<a name="181321096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181321096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181321096">(Nov 21 2019 at 16:23)</a>:</h4>
<p>In that case I'm confused by what flavor of constructivism we're talking about</p>



<a name="181321244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181321244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181321244">(Nov 21 2019 at 16:24)</a>:</h4>
<p>why would you want to squash that predicate?</p>



<a name="181321256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181321256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181321256">(Nov 21 2019 at 16:25)</a>:</h4>
<p>As I said, some bare-bones version without CC? But with enough machinery to distinguish between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex"> + </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex"> \vee </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∨</span></span></span></span> (and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex"> \exists </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex"> \sum </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>).</p>



<a name="181321262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181321262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181321262">(Nov 21 2019 at 16:25)</a>:</h4>
<p>To make a proposition.</p>



<a name="181321481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181321481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181321481">(Nov 21 2019 at 16:27)</a>:</h4>
<p>Otherwise, I suppose you could take the quotient of “Dedekind reals with locators”, but then I think we just get the image of the Cauchy sequences.</p>



<a name="181321618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181321618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181321618">(Nov 21 2019 at 16:28)</a>:</h4>
<p>No, I think you are right, you need that quotient to make something with the right equality but the quotient blocks the ability to iterate</p>



<a name="181321757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181321757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181321757">(Nov 21 2019 at 16:30)</a>:</h4>
<p>Right, that's why I said Cauchy <em>sequences</em> (of rationals) rather than the <em>Cauchy reals</em> (= the Cauchy completion of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi></mrow><annotation encoding="application/x-tex"> \mathbb{Q} </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="mord"><span class="mord mathbb">Q</span></span></span></span></span>).</p>



<a name="181321759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181321759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181321759">(Nov 21 2019 at 16:30)</a>:</h4>
<p>In short we have a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi mathvariant="normal">∥</mi><mi>A</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">A\to \|A\|</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathdefault">A</span><span class="mord">∥</span></span></span></span> and we can't iterate it to produce <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi mathvariant="double-struck">N</mi><mo>→</mo><mi>A</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\|\mathbb{N}\to A\|</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">∥</span></span></span></span></p>



<a name="181321836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181321836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181321836">(Nov 21 2019 at 16:31)</a>:</h4>
<p>(The quotient isn't quite a squash but the idea is similar)</p>



<a name="181323365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181323365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181323365">(Nov 21 2019 at 16:49)</a>:</h4>
<p>Indeed, the equivalence of (existence of locator) and (being the limit of a Cauchy sequence of rationals) is Thm. 3.8.8 in Auke Booij's <em><a href="https://arxiv.org/pdf/1805.06781.pdf" target="_blank" title="https://arxiv.org/pdf/1805.06781.pdf">Extensional constructive real analysis via locators</a></em></p>



<a name="181639159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181639159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181639159">(Nov 22 2019 at 13:55)</a>:</h4>
<p><span class="user-mention" data-user-id="233147">@Ulrik Buchholtz</span>, thanks for the references and the discussion!</p>
<blockquote>
<p>The comparison between computability theory and constructive analysis is not always straight-forward, though: Classically, a computable (Cauchy) real is either rational or not, and hence is in either case a decidable Dedekind real (over RCA0). However, to turn a sequence of Cauchy reals into a sequence of decidable Dedekind reals requires ACA0.  I think that the type-two theory of effectivity provides a better link with constructive analysis, via realizability</p>
</blockquote>
<p>To be clear, when I say “computable analysis”, I don’t mean RCA0 and its unashamed use of the LEM.  I mean something more like type-two effectivity with uniform reductions (like Weihrauch reduction).  There is a uniform algorithm which takes a name for a two-sided Dedekind real (given as names for Sigma^0_1 sets of rationals strictly above and below, and names for a particular point in each set) and computes a name for a rapidly converging Cauchy sequence of rationals converging to that same real.   Conversely, given a Cauchy sequence of rationals with a given rate of convergence one can uniformly compute a name for a two-sided Dedekind real which is the limit of this sequence.</p>



<a name="181639228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181639228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181639228">(Nov 22 2019 at 13:56)</a>:</h4>
<p>The bigger question which confuses me is <strong>why is this so ugly?</strong>  My research was in computable probability theory, and before I left academics I also became fairly interested in constructive measure theory.  I read all the research and even wrote <a href="https://arxiv.org/abs/1812.03375" target="_blank" title="https://arxiv.org/abs/1812.03375">a survey on the subject</a>.  When I read the informal work of Bishop, Bishop-Bridges and others I was left with a picture of a rich and beautiful constructive theory which exactly matches the already beautiful theory I saw in computable analysis.  However, when I think about formalizing it in say Coq (or constructive Lean), it seems that one can’t even decide what constructive definition of real numbers to use (much left a constructive definition of a “measurable set” of real numbers).  I’m trying to reconcile this picture.  Do any of the following solutions make sense?</p>
<ol>
<li>There is an obviously correct constructive definition of real numbers and all these other wrong definitions just need to be modified slightly to be equivalent.</li>
<li>To develop a constructive theory of analysis, one just has to assume certain axioms, like countable choice, but these axioms don’t hurt the computational interpretation of the type theory.</li>
<li>There isn’t a single right definition of computable reals, but instead a type class of reals, and any type of “reals” which is in this type class has good properties and can be used for constructive analysis.</li>
<li>(I find this hard to except, but the final option seems to be) constructive analysis is really just messy and ugly and Bishop’s book glossed over this messiness (or made significant logical errors).</li>
</ol>



<a name="181639531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181639531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181639531">(Nov 22 2019 at 13:58)</a>:</h4>
<p>Last, to be clear.  I'm not advocating for constructive mathematics in Lean, or for constructive math to replace classical math.  I'm also not going to develop constructive probability theory in Coq or any other system.  I don't have the time or dedication for such a project.</p>



<a name="181640597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computable%20real%20functions/near/181640597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computable.20real.20functions.html#181640597">(Nov 22 2019 at 14:09)</a>:</h4>
<p>(Also considering that we haven’t even given a classical formal proof of SLLN, I can imagine the work needed to give a formal constructive proof.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
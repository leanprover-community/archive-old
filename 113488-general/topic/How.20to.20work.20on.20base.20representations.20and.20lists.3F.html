---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html">How to work on base representations and lists?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="224487487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224487487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224487487">(Jan 29 2021 at 15:34)</a>:</h4>
<p>I'm trying to work out with integers base representations using <code>data.nat.digits</code> and here is a MWE where I am completely stuck:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.digits</span>


<span class="kd">lemma</span> <span class="n">mwe</span>
  <span class="o">(</span><span class="n">b</span> <span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span>
  <span class="n">list.sum</span> <span class="o">((</span><span class="n">nat.digits</span> <span class="n">b</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span>
  <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">conv</span> <span class="o">{</span>
      <span class="n">to_rhs</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span> <span class="n">nat.of_digits_digits</span> <span class="n">b</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">rw</span> <span class="n">nat.of_digits_eq_foldr</span> <span class="n">b</span><span class="o">,</span>
    <span class="c1">-- how to carry on?</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span>
</code></pre></div>
<p>I have the feeling the <code>list</code> API is not really enough and unsure if I should switch to something like <code>finset</code> and use only <code>finset</code> in my code but as the base repr API provides me only with <code>list</code>, I'm not sure.</p>
<p>I guess what should I do is to develop adhoc lemmas to show that foldr and the map_with_index coincide in the way I want using induction or something like this.</p>



<a name="224493715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224493715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224493715">(Jan 29 2021 at 16:09)</a>:</h4>
<p>Seems like there is indeed a <code>map_with_index</code>-shaped hole in the mathlib API -- quick <code>grep</code> didn't find anything. For this particular application, you need the lemma that <code>map_with_index</code> is equal to a <code>foldr</code>; after that you should be able to use <code>foldr</code> fusion to get rid of the <code>sum</code>. The <code>map_with_index</code> lemma would probably go into <code>data/list/indexes.lean</code>.</p>



<a name="224496099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224496099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224496099">(Jan 29 2021 at 16:23)</a>:</h4>
<p>Does <code>rw map_with_index</code> make progress? Or is <a href="https://leanprover-community.github.io/mathlib_docs/find/list.map_with_index">docs#list.map_with_index</a> not defined conveniently?</p>
<p>Edit now the link is there: Looks like it's not. Maybe it should be redefined in terms of foldr?</p>



<a name="224497057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224497057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224497057">(Jan 29 2021 at 16:29)</a>:</h4>
<p>This applies to a lot of the list functions. Could be that the direct recursive formulation is more efficient than the <code>foldr</code> one.</p>



<a name="224497731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224497731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224497731">(Jan 29 2021 at 16:33)</a>:</h4>
<p>I think it's simpler than that - <code>map_with_index</code> is defined before <code>foldr</code> (and both are in lean core)</p>



<a name="224504838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224504838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224504838">(Jan 29 2021 at 17:19)</a>:</h4>
<p>I would make a lemma that says that <code>l.map_with_index f</code> can be expressed as a <code>l.enum.map (uncurry f)</code> or something</p>



<a name="224504851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224504851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224504851">(Jan 29 2021 at 17:19)</a>:</h4>
<p>And then you'll be in the clear, because <code>enum</code> and <code>map</code> have way more lemmas.</p>



<a name="224505001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224505001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224505001">(Jan 29 2021 at 17:20)</a>:</h4>
<p>For example, the relevant one here could be <a href="https://leanprover-community.github.io/mathlib_docs/find/list.enum_eq_zip_range">docs#list.enum_eq_zip_range</a></p>



<a name="224505057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224505057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224505057">(Jan 29 2021 at 17:21)</a>:</h4>
<p>And I expect there might be an inductive step here.</p>



<a name="224506948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224506948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224506948">(Jan 29 2021 at 17:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256311">Jannis Limperg</span> <a href="#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224493715">said</a>:</p>
<blockquote>
<p>Seems like there is indeed a <code>map_with_index</code>-shaped hole in the mathlib API -- quick <code>grep</code> didn't find anything. For this particular application, you need the lemma that <code>map_with_index</code> is equal to a <code>foldr</code>; after that you should be able to use <code>foldr</code> fusion to get rid of the <code>sum</code>. The <code>map_with_index</code> lemma would probably go into <code>data/list/indexes.lean</code>.</p>
</blockquote>
<p>Would that be something like: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.sum_map_with_index_eq_foldr</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">as</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">):</span>
  <span class="o">(</span><span class="n">as.map_with_index</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="n">as.foldr</span> <span class="o">(</span><span class="n">something</span> <span class="n">here</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>?</p>



<a name="224527946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224527946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224527946">(Jan 29 2021 at 20:22)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.uncurry</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">function.uncurry</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">prod.map</span> <span class="o">(</span><span class="n">has_add.add</span> <span class="mi">1</span><span class="o">)</span> <span class="n">id</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
   <span class="n">simp</span><span class="o">,</span> <span class="c1">-- why is it simplified to a single arg function on the lhs?</span>
<span class="kd">end</span>
</code></pre></div>
<p>Curious case, I encountered while trying the path <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> suggested ; and what would be a standard way to move forward?</p>



<a name="224528163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224528163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224528163">(Jan 29 2021 at 20:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.uncurry</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">function.uncurry</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">prod.map</span> <span class="o">(</span><span class="n">has_add.add</span> <span class="mi">1</span><span class="o">)</span> <span class="n">id</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="224528232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224528232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224528232">(Jan 29 2021 at 20:25)</a>:</h4>
<p>Okay, indeed, that was simple, thanks !</p>



<a name="224528785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224528785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224528785">(Jan 29 2021 at 20:31)</a>:</h4>
<p>While I'm on the subject, is this,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.map_with_index_core_eq_map_with_index</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">as</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">):</span>
  <span class="n">list.map_with_index_core</span> <span class="n">f</span> <span class="n">n</span> <span class="n">as</span> <span class="bp">=</span> <span class="n">list.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">i</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="n">as</span>
  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>something that is "in the library" or follows quitely easily from the library or should be proved?</p>



<a name="224528951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224528951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224528951">(Jan 29 2021 at 20:32)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.map_with_index_core_eq</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l.map_with_index_core</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">f</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.map_with_index</span><span class="o">,</span> <span class="n">list.map_with_index_core</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list.map_with_index</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">list.map_with_index_core</span><span class="o">,</span> <span class="n">hl</span><span class="o">,</span> <span class="n">add_left_comm</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="224528960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224528960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224528960">(Jan 29 2021 at 20:32)</a>:</h4>
<p>I had to prove this, it wasn't in the library</p>



<a name="224529484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224529484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224529484">(Jan 29 2021 at 20:36)</a>:</h4>
<p>Thanks a lot <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> !</p>



<a name="224530930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224530930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224530930">(Jan 29 2021 at 20:49)</a>:</h4>
<p>Full proof:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.digits</span>
<span class="kn">import</span> <span class="n">data.list.range</span>

<span class="kd">lemma</span> <span class="n">list.map_with_index_core_eq</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l.map_with_index_core</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">f</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.map_with_index</span><span class="o">,</span> <span class="n">list.map_with_index_core</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list.map_with_index</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">list.map_with_index_core</span><span class="o">,</span> <span class="n">hl</span><span class="o">,</span> <span class="n">add_left_comm</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">list.map_uncurry_zip_eq_zip_with</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">list.map</span> <span class="o">(</span><span class="n">function.uncurry</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">l.zip</span> <span class="n">l'</span><span class="o">)</span> <span class="bp">=</span> <span class="n">list.zip_with</span> <span class="n">f</span> <span class="n">l</span> <span class="n">l'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">l'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l'</span> <span class="k">with</span> <span class="n">hd'</span> <span class="n">tl'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">list.zip_with_map_left</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">δ</span><span class="o">)</span> <span class="o">(</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">list.zip_with</span> <span class="n">f</span> <span class="o">(</span><span class="n">l.map</span> <span class="n">g</span><span class="o">)</span> <span class="n">l'</span> <span class="bp">=</span> <span class="n">list.zip_with</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="n">l</span> <span class="n">l'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">l'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l'</span> <span class="k">with</span> <span class="n">hd'</span> <span class="n">tl'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">list.zip_with_map_right</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">δ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">list.zip_with</span> <span class="n">f</span> <span class="n">l</span> <span class="o">(</span><span class="n">l'.map</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">list.zip_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">)</span> <span class="n">l</span> <span class="n">l'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">l'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l'</span> <span class="k">with</span> <span class="n">hd'</span> <span class="n">tl'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">list.map_with_index_eq_enum_map_uncurry</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">l.map_with_index</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">l.enum.map</span> <span class="o">(</span><span class="n">function.uncurry</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.map_with_index</span><span class="o">,</span> <span class="n">list.map_with_index_core</span><span class="o">,</span> <span class="n">list.enum_eq_zip_range</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">list.map_with_index</span><span class="o">,</span> <span class="n">list.map_with_index_core</span><span class="o">,</span> <span class="n">list.map_with_index_core_eq</span><span class="o">,</span> <span class="n">hl</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">list.enum_eq_zip_range</span><span class="o">,</span> <span class="n">list.range_succ_eq_map</span><span class="o">,</span> <span class="n">list.zip_with_map_left</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">list.sum_zip_with_distrib_left</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">list.zip_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">l</span> <span class="n">l'</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">l.zip_with</span> <span class="n">f</span> <span class="n">l'</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">f</span> <span class="n">n</span> <span class="n">l'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l'</span> <span class="k">with</span> <span class="n">hd'</span> <span class="n">tl'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">,</span> <span class="n">mul_add</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">aux</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">list.zip_with</span> <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">nat.succ</span><span class="o">)</span> <span class="o">(</span><span class="n">list.range</span> <span class="n">l.length</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span>
  <span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">list.zip_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">list.range</span> <span class="n">l.length</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">list.zip_with</span> <span class="o">(((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">nat.succ</span><span class="o">))</span> <span class="o">(</span><span class="n">list.range</span> <span class="n">l.length</span><span class="o">)</span> <span class="n">l</span> <span class="bp">=</span>
      <span class="n">list.zip_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span> <span class="o">(</span><span class="n">list.range</span> <span class="n">l.length</span><span class="o">)</span> <span class="n">l</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">],</span>
  <span class="n">ring</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">mwe</span>  <span class="o">(</span><span class="n">b</span> <span class="n">n</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">list.sum</span> <span class="o">((</span><span class="n">nat.digits</span> <span class="n">b</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">conv</span> <span class="o">{</span>
      <span class="n">to_rhs</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span> <span class="n">nat.of_digits_digits</span> <span class="n">b</span> <span class="n">n</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">list.map_with_index_eq_enum_map_uncurry</span><span class="o">,</span> <span class="n">list.enum_eq_zip_range</span><span class="o">,</span>
      <span class="n">list.map_uncurry_zip_eq_zip_with</span><span class="o">,</span> <span class="n">nat.of_digits_eq_foldr</span> <span class="n">b</span><span class="o">],</span>
  <span class="n">induction</span> <span class="n">b.digits</span> <span class="n">n</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.range_succ_eq_map</span><span class="o">,</span> <span class="n">list.zip_with_map_left</span><span class="o">,</span> <span class="n">aux</span><span class="o">,</span> <span class="n">hl</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="224530948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224530948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224530948">(Jan 29 2021 at 20:49)</a>:</h4>
<p>Feel free to PR any of these to mathlib.</p>



<a name="224531389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224531389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224531389">(Jan 29 2021 at 20:51)</a>:</h4>
<p>The crucial part was to just consider <code>nat.digits b n</code> as some random list. For that, your work to use <code>nat.of_digits_digits</code> and <code>nat.of_digits_eq_foldr</code> was crucial.</p>



<a name="224531614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224531614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224531614">(Jan 29 2021 at 20:52)</a>:</h4>
<p>Everything else is just juggling the various list operations. And writing a distrib lemma.</p>



<a name="224534900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224534900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224534900">(Jan 29 2021 at 21:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224531614">said</a>:</p>
<blockquote>
<p>Everything else is just juggling the various list operations. And writing a distrib lemma.</p>
</blockquote>
<p>Indeed, but the proofs you wrote are a lot nicer than mine which were a bit tedious and slow I guess, thank you for the example, I learnt a lot from this!</p>



<a name="224534984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224534984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224534984">(Jan 29 2021 at 21:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224530948">said</a>:</p>
<blockquote>
<p>Feel free to PR any of these to mathlib.</p>
</blockquote>
<p>I will try to open a PR in the next hours with those :)</p>



<a name="224535214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224535214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224535214">(Jan 29 2021 at 21:19)</a>:</h4>
<p>I think it's really neat that a lot of the proofs are just:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">l'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l'</span> <span class="k">with</span> <span class="n">hd'</span> <span class="n">tl'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="224535249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224535249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224535249">(Jan 29 2021 at 21:19)</a>:</h4>
<p>That means that there are good simp lemmas elsewhere, and that the list operation makes sense.</p>



<a name="224535390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224535390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224535390">(Jan 29 2021 at 21:20)</a>:</h4>
<p>There can probably be some general <code>list.zip_with</code> <code>congr</code> lemma that expects hypotheses that would prove goals of this type.</p>



<a name="224544781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224544781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224544781">(Jan 29 2021 at 22:31)</a>:</h4>
<p>Here's a first PR: <a href="https://github.com/leanprover-community/mathlib/pull/5963">https://github.com/leanprover-community/mathlib/pull/5963</a> — <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> Let me know how do you want to be credited for the proofs :)</p>



<a name="224547320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224547320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224547320">(Jan 29 2021 at 22:55)</a>:</h4>
<p>And here's the second one: <a href="https://github.com/leanprover-community/mathlib/pull/5964">https://github.com/leanprover-community/mathlib/pull/5964</a></p>



<a name="224552335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224552335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224552335">(Jan 29 2021 at 23:59)</a>:</h4>
<p>Follow-up question <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> — how would you simplify the proof of:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">map_of_map_with_index_eq_map</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">):</span>
  <span class="n">list.map</span> <span class="n">g</span> <span class="o">(</span><span class="n">list.map_with_index</span> <span class="n">f</span> <span class="n">L</span><span class="o">)</span> <span class="bp">=</span> <span class="n">list.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="n">a</span><span class="o">))</span> <span class="n">L</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">L</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.map_with_index</span><span class="o">,</span> <span class="n">list.map_with_index_core</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">list.map_with_index</span><span class="o">,</span> <span class="n">list.map_with_index</span><span class="o">,</span>
      <span class="n">list.map_with_index_core</span><span class="o">,</span> <span class="n">list.map_with_index_core</span><span class="o">,</span>
      <span class="n">list.map_with_index_core_eq</span><span class="o">,</span> <span class="n">list.map_with_index_core_eq</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">],</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>It seems like I cannot rewrite both sides directly with one application of <code>rw</code>, unsure of a simpler path?</p>



<a name="224552463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224552463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224552463">(Jan 30 2021 at 00:01)</a>:</h4>
<p>Also I suppose there's no easy way to write down the composition as <code>g \circ f</code> and that would still be a currified function?</p>



<a name="224555461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224555461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224555461">(Jan 30 2021 at 00:44)</a>:</h4>
<p>Also, more difficult question I guess about casts, I have a cast in front of some <code>map_with_index</code> which I want to be lifted inside the function, it appears to me that <code>norm_cast</code> does not work out of the box, so I supposed there was some coercion theorem missing here, I tried to write down this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[norm_cast]</span> <span class="kd">lemma</span> <span class="n">cast_map_index_sum</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">}</span>
<span class="o">[</span><span class="n">add_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">γ</span><span class="o">]</span>
<span class="o">[</span><span class="n">has_lift_t</span> <span class="n">β</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">):</span>
  <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">list.map_with_index</span> <span class="n">f</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="n">list.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">↑</span><span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span><span class="o">:</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">begin</span>
   <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span><span class="o">,</span>
   <span class="n">unfold</span> <span class="n">list.map_with_index</span><span class="o">,</span>
   <span class="n">unfold</span> <span class="n">list.map_with_index_core</span><span class="o">,</span>
   <span class="n">rw</span> <span class="n">list.sum_nil</span><span class="o">,</span>
   <span class="n">rw</span> <span class="n">list.sum_nil</span><span class="o">,</span>
   <span class="gr">sorry</span><span class="o">,</span>
   <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>
<p>but unsure if I'm going through the right way, also I do not see how to clear out <code>coe 0 = 0</code> — surely, a coercion of 0 is still 0?</p>



<a name="224555808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224555808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224555808">(Jan 30 2021 at 00:49)</a>:</h4>
<p>Here's a MWE of what I'm trying to do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>
<span class="kn">import</span> <span class="n">analysis.special_functions.pow</span>
<span class="kn">import</span> <span class="n">data.nat.digits</span>

<span class="kd">lemma</span> <span class="n">of_digits_eq_sum_map_with_index</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">):</span>
  <span class="n">nat.of_digits</span> <span class="n">b</span> <span class="n">L</span> <span class="bp">=</span> <span class="n">list.sum</span> <span class="o">(</span><span class="n">L.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">mwe</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">):</span> <span class="n">abs</span> <span class="o">((</span><span class="n">nat.of_digits</span> <span class="n">b</span> <span class="n">l</span><span class="o">):</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">abs</span> <span class="o">(</span><span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="bp">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw_mod_cast</span> <span class="n">of_digits_eq_sum_map_with_index</span><span class="o">,</span> <span class="n">norm_cast</span> <span class="o">}</span>
</code></pre></div>



<a name="224556312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224556312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224556312">(Jan 30 2021 at 00:56)</a>:</h4>
<p>If you just assume <code>has_lift_t β γ</code>, that just means you have a coe from beta to gamma that could do anything</p>



<a name="224557037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224557037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224557037">(Jan 30 2021 at 01:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.map_map_with_index_core</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">(</span><span class="n">l.map_with_index_core</span> <span class="n">f</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">l.map_with_index_core</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="n">a</span><span class="o">))</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">intros</span><span class="bp">;</span> <span class="n">induction</span> <span class="n">l</span> <span class="n">generalizing</span> <span class="n">n</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">list.map_with_index_core</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">list.map_map_with_index</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l.map_with_index</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">list.map_map_with_index_core</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">lemma</span> <span class="n">of_digits_eq_sum_map_with_index</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">):</span>
  <span class="n">nat.of_digits</span> <span class="n">b</span> <span class="n">L</span> <span class="bp">=</span>
  <span class="n">list.sum</span> <span class="o">(</span><span class="n">L.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">mwe</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">):</span> <span class="n">abs</span> <span class="o">((</span><span class="n">nat.of_digits</span> <span class="n">b</span> <span class="n">l</span><span class="o">):</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">abs</span> <span class="o">(</span><span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="bp">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">rw_mod_cast</span> <span class="n">of_digits_eq_sum_map_with_index</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">list.sum_hom</span> <span class="n">_</span> <span class="o">(</span><span class="n">nat.cast_add_monoid_hom</span> <span class="n">ℝ</span><span class="o">),</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">this</span><span class="o">,</span> <span class="n">list.map_map_with_index</span><span class="o">]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="224605929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224605929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224605929">(Jan 30 2021 at 21:28)</a>:</h4>
<p>In the continuity of list lemmas that I'm not sure they exist or should exist, I'm looking now at:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.le_map_with_index</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span><span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">canonically_linear_ordered_add_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">):</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i_le</span><span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">l.length</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">l</span> <span class="n">i</span> <span class="n">i_le</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">i</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">l</span> <span class="n">i</span> <span class="n">i_le</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h_f_le</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.map_with_index</span><span class="o">,</span> <span class="n">list.map_with_index_core</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.map_with_index</span><span class="o">,</span> <span class="n">list.map_with_index_core</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">list.map_with_index_core_eq</span><span class="o">,</span> <span class="n">list.map_with_index_core_eq</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">add_le_add</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">h_f_le</span> <span class="mi">0</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">hl</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">h_f_le</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hi</span><span class="o">],</span>
   <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>I was able to produce the proof by myself, but I would be interested into feedback regarding whether this is a good statement, and would there be a more natural way to prove it?</p>



<a name="224608636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224608636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224608636">(Jan 30 2021 at 22:15)</a>:</h4>
<p>And another question also:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mwe</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">):</span>
  <span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">((</span><span class="n">a</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)))</span> <span class="bp">=</span> <span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">abs</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">abs</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">is_absolute_value.abv_mul</span><span class="o">,</span> <span class="n">is_absolute_value.abv_pow</span><span class="o">],</span>
    <span class="n">norm_cast</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">mul_nonneg</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">pow_nonneg</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat.zero_le</span> <span class="n">_</span><span class="o">,</span>
  <span class="kd">end</span>
</code></pre></div>
<p>Is there a way to avoid proving this by proving equality of functions, it seems like a simple rewrite cannot "enter the function" and assume generic parameters to perform its rewrite?</p>



<a name="224611372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224611372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224611372">(Jan 30 2021 at 23:26)</a>:</h4>
<p>Btw, your <code>mwe</code> is not a true <code>mwe</code>; you're missing imports. Adding <code>import data.real.basic</code> makes the code error-free. (It's not a huge deal but figuring out what imports need to be added is annoying.)</p>



<a name="224611671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224611671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224611671">(Jan 30 2021 at 23:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="355764">Hanting Zhang</span> <a href="#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224611372">said</a>:</p>
<blockquote>
<p>Btw, your <code>mwe</code> is not a true <code>mwe</code>; you're missing imports. Adding <code>import data.real.basic</code> makes the code error-free. (It's not a huge deal but figuring out what imports need to be added is annoying.)</p>
</blockquote>
<p>Sorry for that, I'll change it</p>



<a name="224611699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224611699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224611699">(Jan 30 2021 at 23:35)</a>:</h4>
<p><code>simp</code> can enter binders like this</p>



<a name="224611833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224611833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224611833">(Jan 30 2021 at 23:39)</a>:</h4>
<p>The issue here seems to be that you are using a lemma that isn't suitable for simp; with <code>abs_mul</code> it works fine</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mwe</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">):</span>
  <span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">((</span><span class="n">a</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)))</span> <span class="bp">=</span> <span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">abs</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">abs</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">abs_mul</span><span class="o">,</span> <span class="n">abs_pow</span><span class="o">]</span>
</code></pre></div>



<a name="224612085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224612085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224612085">(Jan 30 2021 at 23:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224611833">said</a>:</p>
<blockquote>
<p>The issue here seems to be that you are using a lemma that isn't suitable for simp; with <code>abs_mul</code> it works fine</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mwe</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">):</span>
  <span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">((</span><span class="n">a</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)))</span> <span class="bp">=</span> <span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">abs</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">abs</span> <span class="n">b</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">abs_mul</span><span class="o">,</span> <span class="n">abs_pow</span><span class="o">]</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Alright, makes sense</p>



<a name="224612204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224612204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224612204">(Jan 30 2021 at 23:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> what does it mean for a lemma to be suitable for <code>simp</code> ?<br>
e.g. what makes <code>abs_mul</code> more suitable than <code>abv_mul</code> ?</p>



<a name="224612293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224612293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224612293">(Jan 30 2021 at 23:52)</a>:</h4>
<p>the lhs of <code>abv_mul</code> starts with a variable, so there is no key</p>



<a name="224612298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224612298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224612298">(Jan 30 2021 at 23:52)</a>:</h4>
<p>Ah alright, indeed, adding explicitly the absolute value makes it work in general context, thanks!</p>



<a name="224612305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224612305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224612305">(Jan 30 2021 at 23:53)</a>:</h4>
<p>the fact that <code>abs_mul</code> is about the constant <code>abs</code> rather than an arbitrary absolute value like thing is what makes the difference</p>



<a name="224670306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224670306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224670306">(Jan 31 2021 at 22:44)</a>:</h4>
<p>Hello again, I'm stuck on a le lemmas for lists, here's a MWE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.cau_seq</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>
<span class="kn">import</span> <span class="n">analysis.special_functions.pow</span>


<span class="kd">lemma</span> <span class="n">list.le_map_with_index</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span><span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">canonically_linear_ordered_add_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">{</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">i_le</span><span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">l.length</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">l</span> <span class="n">i</span> <span class="n">i_le</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">g</span> <span class="n">i</span> <span class="o">(</span><span class="n">list.nth_le</span> <span class="n">l</span> <span class="n">i</span> <span class="n">i_le</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">mwe</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h_abs</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">):</span>
<span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">))</span> <span class="bp">*</span> <span class="o">((</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)))</span>
  <span class="bp">≤</span> <span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I have an (ugly) proof of the <code>le_map_with_index</code> lemma, but it looks like for some reason (I suppose casts/coercions), I cannot apply it very well to this situation, I can convert from <code>h_abs</code> to the proper required hypothesis easily (and can add it), but a simple <code>apply</code> does not even work with an unification error</p>



<a name="224670350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224670350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224670350">(Jan 31 2021 at 22:45)</a>:</h4>
<p>I would try to convert <code>map_with_index</code> to <code>zip_with</code> and then write some lemmas about how separable functions of <code>zip_with</code> are the same as some combination of <code>zip_with</code> of mapped lists</p>



<a name="224670657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224670657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224670657">(Jan 31 2021 at 22:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224670350">said</a>:</p>
<blockquote>
<p>I would try to convert <code>map_with_index</code> to <code>zip_with</code> and then write some lemmas about how separable functions of <code>zip_with</code> are the same as some combination of <code>zip_with</code> of mapped lists</p>
</blockquote>
<p>Got it, I will try something</p>



<a name="224673137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224673137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224673137">(Jan 31 2021 at 23:59)</a>:</h4>
<p>Almost there! What's the lemma you would use to solve that <code>le</code>-quality?</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.cau_seq</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>
<span class="kn">import</span> <span class="n">analysis.special_functions.pow</span>
<span class="kn">import</span> <span class="n">data.list.indexes</span>

<span class="kd">lemma</span> <span class="n">list.sum_ext_le</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hl</span> <span class="o">:</span> <span class="n">l.length</span> <span class="bp">=</span> <span class="n">l'.length</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">(</span><span class="n">hle</span><span class="o">),</span> <span class="n">l.nth_le</span> <span class="n">i</span> <span class="n">hle</span> <span class="bp">≤</span> <span class="n">l'.nth_le</span> <span class="n">i</span> <span class="o">(</span><span class="n">hl</span> <span class="bp">▸</span> <span class="n">hle</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">l.sum</span> <span class="bp">≤</span> <span class="n">l'.sum</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">IH</span> <span class="n">generalizing</span> <span class="n">l'</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">l'</span> <span class="bp">=</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">list.length_eq_zero</span><span class="o">]</span> <span class="n">using</span> <span class="n">hl.symm</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l'</span> <span class="k">with</span> <span class="n">hd'</span> <span class="n">tl'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">hl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">hl</span><span class="o">,</span>
      <span class="n">simp_rw</span> <span class="n">list.sum_cons</span><span class="o">,</span>
      <span class="n">refine</span> <span class="n">add_le_add</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">nat.zero_lt_succ</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">apply</span> <span class="n">IH</span> <span class="n">hl</span><span class="o">,</span>
        <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">nat.succ_lt_succ</span> <span class="n">hi</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kn">open</span> <span class="n">list</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">zip_with_const_left</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">zip_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">l</span> <span class="n">l'</span> <span class="bp">=</span> <span class="n">take</span> <span class="n">l'.length</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">l'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">zip_with_const_right</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">zip_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="n">l</span> <span class="n">l'</span> <span class="bp">=</span> <span class="n">take</span> <span class="n">l.length</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">l'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">zip_with_separable</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">α'</span> <span class="n">β'</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">α'</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">β'</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α'</span><span class="o">)</span> <span class="o">(</span><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">zip_with</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="n">b</span><span class="o">))</span> <span class="n">l</span> <span class="n">l'</span> <span class="bp">=</span> <span class="n">zip_with</span> <span class="n">f</span> <span class="o">(</span><span class="n">map</span> <span class="n">g</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">map</span> <span class="n">h</span> <span class="n">l'</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">hl</span> <span class="n">generalizing</span> <span class="n">l'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">l'</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hl</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">mwe</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h_abs</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">):</span>
<span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">))</span> <span class="bp">*</span> <span class="o">((</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)))</span>
  <span class="bp">≤</span> <span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)),</span>
    <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">clear</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">map_with_index_eq_enum_map_uncurry</span><span class="o">,</span> <span class="n">enum_eq_zip_range</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">zip_with_separable</span><span class="o">],</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">take</span> <span class="n">l.length</span> <span class="bp">=</span> <span class="n">take</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">pow</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">))</span> <span class="o">(</span><span class="n">range</span> <span class="n">l.length</span><span class="o">))</span><span class="bp">.</span><span class="n">length</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">take_length</span><span class="o">],</span> <span class="n">clear</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">sum_ext_le</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">h_abs</span> <span class="o">(</span><span class="n">l.nth_le</span> <span class="n">i</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">hi</span><span class="o">))</span> <span class="o">(</span><span class="n">nth_le_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="gr">sorry</span> <span class="c1">-- I don't know the right le lemma here</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



<a name="224673145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224673145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224673145">(Jan 31 2021 at 23:59)</a>:</h4>
<p>That's on your <a href="https://github.com/leanprover-community/mathlib/tree/raito-mapwithindex-list">branch#raito-mapwithindex-list</a></p>



<a name="224673361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224673361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224673361">(Feb 01 2021 at 00:03)</a>:</h4>
<p>Wouldn't <code>le_abs_self</code> be the right lemma?</p>



<a name="224673434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224673434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224673434">(Feb 01 2021 at 00:05)</a>:</h4>
<p>Something like, le_trans + le_abs_self + mul_le_mul_left and some simplification of *1</p>



<a name="224674103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224674103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224674103">(Feb 01 2021 at 00:23)</a>:</h4>
<p>Hmm, annoyingly it will require to do case work on <code>b</code> pos with zero, unsure if there is a faster way</p>



<a name="224674106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224674106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224674106">(Feb 01 2021 at 00:23)</a>:</h4>
<p>Thanks a lot though <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> !</p>



<a name="224674172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224674172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224674172">(Feb 01 2021 at 00:25)</a>:</h4>
<p>Also, if you notice, your <code>h_abs</code> can be simplified to <code>a \le 1</code>, because of course <code>a \le abs a</code></p>



<a name="224674249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224674249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224674249">(Feb 01 2021 at 00:27)</a>:</h4>
<p>Indeed, because those are natural integers</p>



<a name="224674337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224674337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224674337">(Feb 01 2021 at 00:29)</a>:</h4>
<p>I mean, that's true for anything <code>abs</code> is defined on: <a href="https://leanprover-community.github.io/mathlib_docs/find/le_abs_self">docs#le_abs_self</a></p>



<a name="224674415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224674415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224674415">(Feb 01 2021 at 00:31)</a>:</h4>
<p>Hmm, then the simplification is not always possible, right?<br>
I mean, <code>a \le 1</code> does not imply <code>abs a \le 1</code> in general under the theorem: <code>a \le abs a</code>, or am I too tired? :D</p>



<a name="224674486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224674486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224674486">(Feb 01 2021 at 00:32)</a>:</h4>
<p>(counterexample: -5 \le 1, though 5 \ge 1 even though -5 \le 5, right?)</p>



<a name="224675181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224675181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224675181">(Feb 01 2021 at 00:48)</a>:</h4>
<p>I mean, here, you're always coercing from <code>nat</code>. So <code>abs (a : \R)</code> must be <code>(a : \R)</code></p>



<a name="224675191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224675191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224675191">(Feb 01 2021 at 00:48)</a>:</h4>
<p>So here is the final proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">mwe</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hle</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">):</span>
<span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">abs</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">))</span> <span class="bp">*</span> <span class="o">((</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)))</span>
  <span class="bp">≤</span> <span class="n">list.sum</span> <span class="o">(</span><span class="n">l.map_with_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)),</span>
    <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span> <span class="n">clear</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">map_with_index_eq_enum_map_uncurry</span><span class="o">,</span> <span class="n">enum_eq_zip_range</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">zip_with_separable</span><span class="o">],</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">take</span> <span class="n">l.length</span> <span class="bp">=</span> <span class="n">take</span> <span class="o">(</span><span class="n">map</span> <span class="o">(</span><span class="n">pow</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">))</span> <span class="o">(</span><span class="n">range</span> <span class="n">l.length</span><span class="o">))</span><span class="bp">.</span><span class="n">length</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">take_length</span><span class="o">],</span> <span class="n">clear</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">sum_ext_le</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">l.nth_le</span> <span class="n">i</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">hi</span><span class="o">),</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">k</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">^</span> <span class="n">i</span> <span class="bp">*</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">this</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">mul_le_mul</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">),</span>
  <span class="n">simpa</span> <span class="n">using</span> <span class="n">hle</span> <span class="n">k</span> <span class="o">(</span><span class="n">nth_le_mem</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="224675213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224675213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224675213">(Feb 01 2021 at 00:49)</a>:</h4>
<p>As you can see, I changed the <code>h_abs</code> to <code>hle</code></p>



<a name="224675263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224675263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224675263">(Feb 01 2021 at 00:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224675181">said</a>:</p>
<blockquote>
<p>I mean, here, you're always coercing from <code>nat</code>. So <code>abs (a : \R)</code> must be <code>(a : \R)</code></p>
</blockquote>
<p>Ah! I completely agree, yes</p>



<a name="224675331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224675331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224675331">(Feb 01 2021 at 00:51)</a>:</h4>
<p>So even in the <code>l.map_with_index</code> lambda, you don't need the <code>abs</code>.</p>



<a name="224675611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224675611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224675611">(Feb 01 2021 at 00:56)</a>:</h4>
<p>Indeed, but this is only true in this "minimum" example, in general, I'm using arbitrary absolute values on which <code>abs a != a</code> even for nat, so I can only bound them through le_abv_self if I'm not wrong</p>



<a name="224675707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224675707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224675707">(Feb 01 2021 at 00:58)</a>:</h4>
<p>Again, feel free to PR any of the lemmas. What was crucial here was to  prove some general lemmas about sums over lists, or about <code>zip_with</code>. The <code>zip_with_separable</code> allowed us to get it to a form where we can throw away oen of the lists. But it can't be a simp lemma because we have (in your branch, at least) <code>map_uncurry_zip_eq_zip_with</code> as a simp lemma. And Jannis's comment here: <a href="https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567509308">https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567509308</a> indicates that it probably shouldn't be! Additionally, he also came up with <code>zip_with_separable</code>, but in reverse:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567508963">https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567508963</a></p>



<a name="224675804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224675804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224675804">(Feb 01 2021 at 01:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F/near/224675707">said</a>:</p>
<blockquote>
<p>Again, feel free to PR any of the lemmas. What was crucial here was to  prove some general lemmas about sums over lists, or about <code>zip_with</code>. The <code>zip_with_separable</code> allowed us to get it to a form where we can throw away oen of the lists. But it can't be a simp lemma because we have (in your branch, at least) <code>map_uncurry_zip_eq_zip_with</code> as a simp lemma. And Jannis's comment here: <a href="https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567509308">https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567509308</a> indicates that it probably shouldn't be! Additionally, he also came up with <code>zip_with_separable</code>, but in reverse:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567508963">https://github.com/leanprover-community/mathlib/pull/5974#discussion_r567508963</a></p>
</blockquote>
<p>Sure thing! Thanks for the comments and insights, I missed the fact that Jannis reviewed the PR, will address those comments tomorrow hopefully</p>



<a name="224726341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224726341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224726341">(Feb 01 2021 at 13:38)</a>:</h4>
<p>Therefore, as we removed the simp attribute on map-uncurry lemma, should I add the simp on <code>zip_with_map</code> <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> <span class="user-mention" data-user-id="256311">@Jannis Limperg</span> ?</p>



<a name="224739996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224739996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224739996">(Feb 01 2021 at 15:17)</a>:</h4>
<p>I'd say yes. It's a bit specialised, but <code>zip_with</code> is not a common symbol so we won't run into performance issues.</p>



<a name="224740203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224740203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224740203">(Feb 01 2021 at 15:18)</a>:</h4>
<p>Alright, will do the change!</p>



<a name="224740315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/How%20to%20work%20on%20base%20representations%20and%20lists%3F/near/224740315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan Lahfa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/How.20to.20work.20on.20base.20representations.20and.20lists.3F.html#224740315">(Feb 01 2021 at 15:19)</a>:</h4>
<p>Done :)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
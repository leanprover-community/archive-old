---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Translation.20*to*.20natural.20language.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html">Translation *to* natural language</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="302985633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/302985633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Fourie <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#302985633">(Oct 08 2022 at 09:06)</a>:</h4>
<p>Hi all, I haven't found any recent discussions on this that have not mostly ended up being focused on the reverse direction. How feasible would it be for there to be a program which could translate a tactics proof into natural language? Or in general translate expressions in lean into (semi-)natural language. How understandable could the results be?</p>
<p>It is just interesting to think that we have essentially a gigantic textbook here if it would be possible to make it readable. I guess each proof  (each definition and theorem, too) may end up being unreasonably detailed and therefore in practice unreadable, but I am curious if anyone has tried and if so what the output ended up looking like? </p>
<p>It seems like committing to the lean library may be easier if you can see in natural language how the library has approached a particular topic.</p>



<a name="302985740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/302985740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#302985740">(Oct 08 2022 at 09:07)</a>:</h4>
<p>We don't have this but some people (including me) are very much interested in making it happen.</p>



<a name="302986516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/302986516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Fourie <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#302986516">(Oct 08 2022 at 09:13)</a>:</h4>
<p>Great, I’ll keep my eye out for any developments then, thanks !</p>



<a name="303030547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303030547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303030547">(Oct 08 2022 at 15:03)</a>:</h4>
<p>Can't Lean Chat just be run in reverse as a first approximation? <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span>  I can't remember your student's name that implemented Lean Chat.</p>



<a name="303030971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303030971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303030971">(Oct 08 2022 at 15:06)</a>:</h4>
<p><span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span>  <span class="user-mention" data-user-id="284997">@Zhangir Azerbayev</span> and <span class="user-mention" data-user-id="121918">@Edward Ayers</span></p>



<a name="303032171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303032171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303032171">(Oct 08 2022 at 15:16)</a>:</h4>
<p><span class="user-mention" data-user-id="547993">@Will Fourie</span> First, if you are not aware, you may want to subscribe to the <a class="stream" data-stream-id="219941" href="/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving">#Machine Learning for Theorem Proving</a> stream.  As for <em>formal-to-informal</em>, while there isn't as much already written on this topic, I would say the same ideas as <em>informal-to-formal</em> apply.  In particular, I see three main possibilities:</p>



<a name="303032186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303032186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303032186">(Oct 08 2022 at 15:16)</a>:</h4>
<p><strong>1. rule based translation</strong>  This is really hard to get right in either direction, but I think there is more possibility for success in the formal-to-informal direction.  Indeed, while I would have to remind myself, there was some work done on this in maybe the early 2000s.  (<a href="http://www.cs.ru.nl/F.Wiedijk/">Freek Wiedijk's website</a> is a great place to go to get a snapshot of that time period.) If I recall, there was works taking Mizar-style proofs and translating them to structured natural language with rules and also reducing the full formal proof to a proof sketch which is an outline of the full proof and is more human readable.  Tom Hales as part of his formal abstract project (which never got off the ground) was interested in making a controlled natural language which was completely formal, but at the same time more human-readable.  (I don't think however it focused on proofs nor was it meant to translate Lean into controlled natural language automatically.)</p>



<a name="303032207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303032207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303032207">(Oct 08 2022 at 15:16)</a>:</h4>
<p><strong>2. machine learning translation</strong> There have been lots of works translating informal math to formal math, although until recently they weren't especially good.  The problem was not that the methods were bad.  There is a lot of work on translation of natural language.  The problem was a lack of data.  However, that is now as of a few months ago, starting to change.  The big change is that folks have realized it is possible to use pre-trained large language models on code like Codex (which powers Github copilot) and use it for auto-formalization.</p>



<a name="303032216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303032216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303032216">(Oct 08 2022 at 15:17)</a>:</h4>
<p>The first paper in this area was <a href="https://arxiv.org/abs/2205.12615">https://arxiv.org/abs/2205.12615</a>.  The idea is simple:  Give the model a few (3-5) examples of the type of translation you have in mind, and then ask it to complete in your example. That paper showed that the model was ok at both informal-to-formal ("auto-formalization") and formal-to-informal ("auto-informalization").  <strong>Actually it was much better at informalization.</strong>  This work has inspired a lot more work on this area.  <span class="user-mention" data-user-id="284997">@Zhangir Azerbayev</span> and <span class="user-mention" data-user-id="121918">@Edward Ayers</span> adapted this to Lean with the <a href="https://marketplace.visualstudio.com/items?itemName=hoskinson-ml.lean-chat-vscode">Lean chat</a> plugin.  (It just does auto-formalization last I checked, but that is just a design choice.)  There are also two more papers in this area as of last week.  See <a class="stream-topic" data-stream-id="219941" href="/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/More.20papers.20on.20autoformalization">#Machine Learning for Theorem Proving &gt; More papers on autoformalization</a>.</p>



<a name="303032237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303032237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303032237">(Oct 08 2022 at 15:17)</a>:</h4>
<p>I should also mention that Codex-powered auto-(in)formalization is really easy to play with.  Just get an OpenAI codex key, and try it out.  To understand exactly how it works, you can look at the code in <a href="https://github.com/zhangir-azerbayev/lean-chat">https://github.com/zhangir-azerbayev/lean-chat</a>, but to be clear, once you construct your prompt with the 3-5 examples you can just play around with it in the Codex online website.</p>



<a name="303032252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303032252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303032252">(Oct 08 2022 at 15:17)</a>:</h4>
<p><strong>3. human translation</strong><br>
Human translation is still the best approach so far.  And the big challenge as I see it is just encouraging users to document their proofs and making tools to make it easier.  These tools could be:</p>
<ul>
<li>Adding comments to the formal proof.  Some comments (namely doc strings) will even show up on the <a href="https://leanprover-community.github.io/mathlib_docs">#docs</a> (e.g. <a href="https://leanprover-community.github.io/mathlib_docs/find/separate_convex_open_set">docs#separate_convex_open_set</a>).</li>
<li>Using <a href="https://github.com/leanprover-community/format_lean">https://github.com/leanprover-community/format_lean</a> or  <a href="https://github.com/leanprover/LeanInk/blob/main/LeanInk/Annotation/Alectryon.lean">https://github.com/leanprover/LeanInk/blob/main/LeanInk/Annotation/Alectryon.lean</a> to mix a Lean file with HTML/markup for a better display.</li>
<li>Using the <a href="https://github.com/PatrickMassot/leanblueprint">lean blueprint tool</a> (see an example in <a href="https://leanprover-community.github.io/sphere-eversion/blueprint/index.html">Sphere Inversion project</a>) to link latex proofs with Lean proofs to document an entire lean project.)</li>
</ul>



<a name="303032638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303032638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Will Fourie <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303032638">(Oct 08 2022 at 15:20)</a>:</h4>
<p>Fantastic! Thank you, I’ve subscribed to the stream and will definitely give codex a look. The human translation links looks helpful too, at least for when I am writing</p>



<a name="303052673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303052673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Zhangir Azerbayev <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303052673">(Oct 08 2022 at 18:50)</a>:</h4>
<p>Few-shot informalization with Codex is much better than formalization. I've done systematic evaluations of Codex's formalization/informalization capabilities on undergraduate-level math (soon to be public), and informalization accuracy is &gt;50%. </p>
<p>Lean chat could be easily extended to also do informalization. I'll talk to <span class="user-mention" data-user-id="121918">@Edward Ayers</span>  and see if we have time to implement this. Alternatively, anyone who has front-end development can open a PR themselves,  <a href="https://github.com/zhangir-azerbayev/lean-chat-vscode">the code is public</a>. </p>
<p>Something else you might be interested is <a href="https://github.com/leanprover-community/doc-gen/pull/168#issuecomment-1221966968">this mathlib doc-gen PR</a> by myself and <span class="user-mention" data-user-id="110596">@Rob Lewis</span> .  It adds a drop-down to every theorem in the mathlib docs that contains a Codex informalization. <a href="http://leanprover-community.github.io/mathlib_docs_demo">Here</a> is a link to the experimental build. Some of the examples are really impressive. <span class="user-mention" data-user-id="110596">@Rob Lewis</span> is there still interest in getting this over the line?</p>



<a name="303057791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303057791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303057791">(Oct 08 2022 at 19:47)</a>:</h4>
<p>I've looked at the file <code>number_theory.legendre_symbol.quadratic_reciprocity</code> and found that in many cases, the informal description is slightly off. Some things I have noticed are</p>
<ul>
<li><code>p % 4 ≠ 3</code> (for <code>p</code> a prime) gets translated into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≡</mo><mn>1</mn><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>4</mn></mrow><annotation encoding="application/x-tex">p \equiv 1 \bmod 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>, even though <code>p = 2</code> is not excluded.</li>
<li>Coercions are not picked up. E.g., a condition <code>(a : zmod p) ≠ 0</code> appears as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>.</li>
<li>Sometimes, an assumption that a prime <code>p</code> is odd is sneaked in, even though it is not there.</li>
<li>Truncated division is rendered as division (as in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(-1)^{p/2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mtight">/2</span></span></span></span></span></span></span></span></span></span></span></span>).</li>
<li>Notation for the Legendre symbol varies (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mi>a</mi><mi>p</mi></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\frac{a}{p}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a/p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a|p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>, the Legendre symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> mod <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>).</li>
<li>Sometimes, the interpretation/definition of the symbol in terms of quadratic (non-)residues is used instead of the symbol.</li>
</ul>
<p>A fairly typical example showing several of these points:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">zmod.legendre_sym_eq_neg_one_iff_not_one</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">nat.prime</span> <span class="n">p</span><span class="o">)]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
<span class="n">zmod.legendre_sym</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">zmod.legendre_sym</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>
<p>Informal translation:<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> be a prime and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> be an integer such that  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>. Then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> is a quadratic residue modulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> is not a quadratic non-residue modulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>.</p>



<a name="303057937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303057937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303057937">(Oct 08 2022 at 19:48)</a>:</h4>
<p>An example I don't really know how to fix:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">zmod.legendre_sym_hom_apply</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">nat.prime</span> <span class="n">p</span><span class="o">)]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">⇑</span><span class="o">(</span><span class="n">zmod.legendre_sym_hom</span> <span class="n">p</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">zmod.legendre_sym</span> <span class="n">p</span> <span class="n">a</span>
</code></pre></div>
<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> be a prime. Then the Legendre symbol is a homomorphism from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>p</mi><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/</span><span class="mord mathnormal">p</span><span class="mord mathbb">Z</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}/2\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/2</span><span class="mord mathbb">Z</span></span></span></span>.</p>



<a name="303058070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303058070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303058070">(Oct 08 2022 at 19:50)</a>:</h4>
<p>One reason could be that Codex "remembers" various versions of the informal statements that it has seen, which are close to, but not completely equivalent to the mathlib versions. E.g., because the mathlib version includes 2, but the textbook versions are usually for odd primes...</p>



<a name="303058294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303058294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303058294">(Oct 08 2022 at 19:54)</a>:</h4>
<p>Statements like the following that do not really have mathematical content seem to be especially bad for this kind of translation.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">mul_char.to_fun_eq_coe</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">R'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid_with_zero</span> <span class="n">R'</span><span class="o">]</span> <span class="o">(</span><span class="n">χ</span> <span class="o">:</span> <span class="n">mul_char</span> <span class="n">R</span> <span class="n">R'</span><span class="o">)</span> <span class="o">:</span>
<span class="n">χ.to_monoid_hom.to_fun</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">χ</span>
</code></pre></div>
<p>"Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> be a commutative monoid and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">R&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> be a commutative monoid with zero. Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo>:</mo><mi>R</mi><mo>→</mo><msup><mi>R</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\chi:R\to R&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">χ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> be a multiplicative character. Then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi></mrow><annotation encoding="application/x-tex">\chi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">χ</span></span></span></span> is a monoid homomorphism if and only if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\chi(1)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">χ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>."</p>
<p>But then it probably does not really make sense to try to give an informal description of this kind of boilerplate...</p>



<a name="303059540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303059540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303059540">(Oct 08 2022 at 20:11)</a>:</h4>
<p><span class="user-mention" data-user-id="284997">@Zhangir Azerbayev</span> <a href="https://leanprover-community.github.io/mathlib_docs_demo/probability/martingale.html"><code>probability.martingale</code></a> doesn't have translations.  Don't know if this means they are still being generated or if this is a bug, but just wanted to let you know.</p>



<a name="303060103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303060103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303060103">(Oct 08 2022 at 20:18)</a>:</h4>
<p>But, I agree it is very impressive!</p>



<a name="303063819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Translation%20%2Ato%2A%20natural%20language/near/303063819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Translation.20*to*.20natural.20language.html#303063819">(Oct 08 2022 at 21:10)</a>:</h4>
<p>I also agree with Michael that it makes some really confusing choices where it just tries to state the well-known mathematical theorem that it thinks is closest to the content in this theorem even if they are really about very different main ideas.  When it is right, it seems amazing, but when it is wrong it can be really confusing because it's translation is a true fact often, and it concerns most of the ideas in the theorem, so it is very believable, even if it isn't helpful at all.  Good thing you add the disclaimer. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
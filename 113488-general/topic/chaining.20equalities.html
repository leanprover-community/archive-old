---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/chaining.20equalities.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html">chaining equalities</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="277650220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277650220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277650220">(Apr 03 2022 at 17:10)</a>:</h4>
<p>Implementation of cool maths notation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a=b=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">structure</span> <span class="n">all_three_are_equal</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">hbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span>
<span class="o">(</span><span class="n">hac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">.</span> <span class="n">tactic.interactive.cc</span><span class="o">)</span>

<span class="kd">notation</span> <span class="n">a</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">b</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">all_three_are_equal</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span>

<span class="k">#check</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">3</span> <span class="c1">-- Prop</span>
</code></pre></div>
<p>Should be fine, right? :-/</p>



<a name="277650328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277650328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277650328">(Apr 03 2022 at 17:13)</a>:</h4>
<p>(My students keep wanting to do it) (hopefully next year I'll be teaching the course in Lean 4)</p>



<a name="277650945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277650945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277650945">(Apr 03 2022 at 17:25)</a>:</h4>
<p>The next thing to do is <code>all_four_are_equal</code>, right? ;)</p>



<a name="277651125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277651125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277651125">(Apr 03 2022 at 17:28)</a>:</h4>
<p>Does this now break the ordinary <code>=</code>?</p>



<a name="277652000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277652000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277652000">(Apr 03 2022 at 17:50)</a>:</h4>
<p>It's interesting how this gives you <code>hac</code> for transitivity.</p>
<p>Something I've thought about is having Lean parse chains of binary relations <code>x1 R1 x2 R2 x3 R3 ...</code> as <code>x1 R1 x2 /\ x2 R2 x3 /\ x3 R3 x4 /\ ...</code>. That doesn't give you a way to get any consequences of transitivity though.</p>



<a name="277652747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277652747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277652747">(Apr 03 2022 at 18:04)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">eq'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="kd">notation</span> <span class="n">x</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">s</span><span class="o">:(</span><span class="n">foldr</span><span class="o">:</span><span class="mi">50</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">)</span> <span class="o">[])</span> <span class="o">:=</span> <span class="n">eq'</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span> <span class="o">}</span>
</code></pre></div>



<a name="277655903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277655903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277655903">(Apr 03 2022 at 19:13)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="c1">-- eq' [1, 1] : Prop</span>
</code></pre></div>
<p>erm...</p>



<a name="277656314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277656314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277656314">(Apr 03 2022 at 19:22)</a>:</h4>
<p>There's precedent in languages to support special constructs like this to only a particular size (like Haskell and tuple notation). Maybe this is ok:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">x1</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">x2</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">x3</span> <span class="o">:=</span> <span class="n">x1</span> <span class="bp">=</span> <span class="n">x2</span> <span class="bp">∧</span> <span class="n">x2</span> <span class="bp">=</span> <span class="n">x3</span>
<span class="kd">notation</span> <span class="n">x1</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">x2</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">x3</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">x4</span> <span class="o">:=</span> <span class="n">x1</span> <span class="bp">=</span> <span class="n">x2</span> <span class="bp">∧</span> <span class="n">x2</span> <span class="bp">=</span> <span class="n">x3</span> <span class="bp">=</span> <span class="n">x4</span>
<span class="kd">notation</span> <span class="n">x1</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">x2</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">x3</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">x4</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">x5</span> <span class="o">:=</span> <span class="n">x1</span> <span class="bp">=</span> <span class="n">x2</span> <span class="bp">∧</span> <span class="n">x2</span> <span class="bp">=</span> <span class="n">x3</span> <span class="bp">=</span> <span class="n">x4</span> <span class="bp">=</span> <span class="n">x5</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- prints as</span>
  <span class="c1">-- h: x = y ∧ y = z</span>
  <span class="n">exact</span> <span class="n">h.1.trans</span> <span class="n">h.2</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p><strong>Edit:</strong> This doesn't work for more than two equalities</p>



<a name="277656318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277656318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277656318">(Apr 03 2022 at 19:22)</a>:</h4>
<p><del>Using <a href="https://leanprover-community.github.io/mathlib_docs/find/list">docs#list</a>.forall₂ would reduce better</del></p>



<a name="277656352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277656352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277656352">(Apr 03 2022 at 19:23)</a>:</h4>
<p>(bad linkifier, <a href="https://leanprover-community.github.io/mathlib_docs/data/list/defs.html#list.forall%E2%82%82">https://leanprover-community.github.io/mathlib_docs/data/list/defs.html#list.forall%E2%82%82</a>)</p>



<a name="277656366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277656366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277656366">(Apr 03 2022 at 19:23)</a>:</h4>
<p>(deleted)</p>



<a name="277656771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277656771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277656771">(Apr 03 2022 at 19:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/chaining.20equalities/near/277655903">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="c1">-- eq' [1, 1] : Prop</span>
</code></pre></div>
<p>erm...</p>
</blockquote>
<p>That's easily fixable:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">eq'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="kd">notation</span> <span class="n">x</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">y</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">s</span><span class="o">:(</span><span class="n">foldr</span><span class="o">:</span><span class="mi">50</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">)</span> <span class="o">[])</span> <span class="o">:=</span> <span class="n">eq'</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>

<span class="k">#check</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span>      <span class="c1">-- 1 = 1 : Prop</span>
<span class="k">#check</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span>  <span class="c1">-- eq' [1, 1, 1] : Prop</span>
</code></pre></div>



<a name="277657024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277657024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277657024">(Apr 03 2022 at 19:36)</a>:</h4>
<p>I guess the question then is how to display <code>eq' [1, 1, 1]</code> as <code>1 = 1 = 1</code> in pp. I'm not sure.</p>



<a name="277657754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277657754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277657754">(Apr 03 2022 at 19:53)</a>:</h4>
<p>Here's the version that reduces nicely:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">eq'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">]</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">rest</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list.foldr</span> <span class="o">(</span><span class="bp">∧</span><span class="o">)</span> <span class="o">(</span><span class="n">eq'</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">rest</span><span class="o">))</span>  <span class="o">(</span><span class="n">list.map</span> <span class="o">((</span><span class="bp">=</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">rest</span><span class="o">))</span>

<span class="kd">notation</span> <span class="n">x</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">s</span><span class="o">:(</span><span class="n">foldr</span><span class="o">:</span><span class="mi">50</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">)</span> <span class="o">[])</span> <span class="o">:=</span> <span class="n">eq'</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">w</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="k">#reduce</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span>
<span class="c1">-- w = x ∧ w = y ∧ w = z ∧ x = y ∧ x = z ∧ y = z</span>
</code></pre></div>



<a name="277657864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277657864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277657864">(Apr 03 2022 at 19:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113488-general/topic/chaining.20equalities/near/277657024">said</a>:</p>
<blockquote>
<p>I guess the question then is how to display <code>eq' [1, 1, 1]</code> as <code>1 = 1 = 1</code> in pp. I'm not sure.</p>
</blockquote>
<p>If you remove <code>import tactic</code> then pp does the right thing</p>



<a name="277658048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658048">(Apr 03 2022 at 19:59)</a>:</h4>
<p>In fact, <code>import data.sym.basic</code> is what breaks the pretty printing</p>



<a name="277658179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658179">(Apr 03 2022 at 20:01)</a>:</h4>
<p><code>notation x ` = ` y ` = ` s:(foldr:50 ` = ` (h t, list.cons h t) []) := eq' (list.cons x $ list.cons y $ s)</code> fixes it, you have to disambiguate the <code>::</code></p>



<a name="277658335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658335">(Apr 03 2022 at 20:05)</a>:</h4>
<p><span class="user-mention" data-user-id="456794">@Patrick Johnson</span>, your definition is probably better than mine simply because it matches how <a href="https://leanprover-community.github.io/mathlib_docs/find/list.tfae">docs#list.tfae</a> is implemented (either that, or we should change <code>tfae</code>)</p>



<a name="277658354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658354">(Apr 03 2022 at 20:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/chaining.20equalities/near/277657754">said</a>:</p>
<blockquote>
<p>Here's the version that reduces nicely:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">eq'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">]</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">rest</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list.foldr</span> <span class="o">(</span><span class="bp">∧</span><span class="o">)</span> <span class="o">(</span><span class="n">eq'</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">rest</span><span class="o">))</span>  <span class="o">(</span><span class="n">list.map</span> <span class="o">((</span><span class="bp">=</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">rest</span><span class="o">))</span>

<span class="kd">notation</span> <span class="n">x</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="n">s</span><span class="o">:(</span><span class="n">foldr</span><span class="o">:</span><span class="mi">50</span> <span class="bp">`</span> <span class="bp">=</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">)</span> <span class="o">[])</span> <span class="o">:=</span> <span class="n">eq'</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">w</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

<span class="k">#reduce</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span>
<span class="c1">-- w = x ∧ w = y ∧ w = z ∧ x = y ∧ x = z ∧ y = z</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Surely "nicely" := "just need w=x, x=y, y=z"?</p>



<a name="277658416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658416">(Apr 03 2022 at 20:06)</a>:</h4>
<p>What's nice for production tends to be less nice for consumption</p>



<a name="277658426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658426">(Apr 03 2022 at 20:07)</a>:</h4>
<p>Probably you want some more recursion magic to convert what you describe into the long version</p>



<a name="277658533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658533">(Apr 03 2022 at 20:09)</a>:</h4>
<p>I guess the version you suggest is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">eq'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">rest</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list.foldr</span> <span class="o">(</span><span class="bp">∧</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">rest</span><span class="o">)</span>
</code></pre></div>
<p>(untested)</p>



<a name="277658773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658773">(Apr 03 2022 at 20:14)</a>:</h4>
<p>Do you not simply want <code>list.chain' (=)</code>?</p>



<a name="277658858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658858">(Apr 03 2022 at 20:16)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.chain'/src">src#list.chain'</a></p>



<a name="277658861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658861">(Apr 03 2022 at 20:17)</a>:</h4>
<p>That's not defeq to <code>and</code></p>



<a name="277658864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277658864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277658864">(Apr 03 2022 at 20:17)</a>:</h4>
<p>Which may or may not matter</p>



<a name="277661628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/chaining%20equalities/near/277661628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/chaining.20equalities.html#277661628">(Apr 03 2022 at 21:19)</a>:</h4>
<p>Here is a proof that our definitions are equivalent.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>Proof</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic.induction</span>

<span class="kd">def</span> <span class="n">eq₁</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>

<span class="kd">def</span> <span class="n">eq₂</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">]</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">rest</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list.foldr</span> <span class="o">(</span><span class="bp">∧</span><span class="o">)</span> <span class="o">(</span><span class="n">eq₂</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">rest</span><span class="o">))</span> <span class="o">(</span><span class="n">list.map</span> <span class="o">((</span><span class="bp">=</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">z</span> <span class="o">::</span> <span class="n">rest</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">eq_of_eq_cons</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">eq₁</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">s</span><span class="o">))</span> <span class="o">:</span> <span class="n">eq₁</span> <span class="n">s</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h</span> <span class="n">a</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ha</span><span class="o">])</span> <span class="n">b</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hb</span><span class="o">])</span>

<span class="kd">lemma</span> <span class="n">foldr_true</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">list.foldr</span> <span class="n">and</span> <span class="n">true</span> <span class="n">s</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">P</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction'</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span> <span class="n">rw</span> <span class="n">list.foldr</span><span class="o">,</span> <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">P</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h₁</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h.1</span> <span class="o">},</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">ih.mp</span> <span class="n">h.2</span> <span class="n">P</span> <span class="n">h₁</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">split</span><span class="o">,</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">ih.mpr</span><span class="o">,</span> <span class="n">rintro</span> <span class="n">P</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h₁</span><span class="o">]</span> <span class="o">}},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">list_mem_cons_dup</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">hd</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list.mem_cons_iff</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">eq_cons_dup</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hd</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">eq₁</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">eq₁</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq₁</span><span class="o">,</span> <span class="n">list_mem_cons_dup</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">foldr_true_z</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">list.foldr</span> <span class="n">and</span> <span class="n">P</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">induction'</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">},</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">ih</span> <span class="n">h.2</span> <span class="o">}}</span>

<span class="kd">lemma</span> <span class="n">eq_aux</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">eq₁</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">list.foldr</span> <span class="n">and</span> <span class="o">(</span><span class="n">eq₁</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">list.map</span> <span class="o">(</span><span class="n">eq</span> <span class="n">x</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction'</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq₁</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">list.map_cons</span><span class="o">,</span> <span class="n">list.foldr_cons</span><span class="o">],</span> <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">h</span> <span class="n">x</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">hd</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">),</span> <span class="k">have</span> <span class="n">h₁</span> <span class="o">:=</span> <span class="n">eq_of_eq_cons</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h₂</span> <span class="o">:=</span> <span class="n">eq_of_eq_cons</span> <span class="n">h₁</span><span class="o">,</span> <span class="k">have</span> <span class="n">h₃</span> <span class="o">:=</span> <span class="n">ih.mp</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">iff_of_true</span> <span class="n">h₂</span> <span class="n">trivial</span> <span class="n">at</span> <span class="n">h₃</span><span class="o">,</span> <span class="n">rw</span> <span class="n">iff_of_true</span> <span class="n">h₁</span> <span class="n">trivial</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">foldr_true</span> <span class="n">at</span> <span class="n">h₃</span> <span class="bp">⊢</span><span class="o">,</span> <span class="n">rintro</span> <span class="n">P</span> <span class="n">hP</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h₃</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">list.mem_map</span> <span class="n">at</span> <span class="n">hP</span> <span class="bp">⊢</span><span class="o">,</span> <span class="n">rcases</span> <span class="n">hP</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">],</span> <span class="n">ext</span><span class="o">,</span> <span class="n">split</span><span class="bp">;</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">x</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">hd</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">hd</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="n">x</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">}},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span> <span class="n">rw</span> <span class="n">eq_cons_dup</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ih.mpr</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h₁</span> <span class="o">:=</span> <span class="n">foldr_true_z</span> <span class="n">h</span><span class="o">,</span> <span class="k">have</span> <span class="n">h₂</span> <span class="o">:=</span> <span class="n">eq_of_eq_cons</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">iff_of_true</span> <span class="n">h₁</span> <span class="n">trivial</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">iff_of_true</span> <span class="n">h₂</span> <span class="n">trivial</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">eq₁_eq₂</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">eq₁</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">eq₂</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction'</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq₁</span><span class="o">,</span> <span class="n">eq₂</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">cases'</span> <span class="n">s</span> <span class="k">with</span> <span class="n">x</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq₁</span><span class="o">,</span> <span class="n">eq₂</span><span class="o">],</span> <span class="o">},</span>
  <span class="n">cases'</span> <span class="n">s</span> <span class="k">with</span> <span class="n">y</span> <span class="n">s</span><span class="o">,</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eq₁</span><span class="o">,</span> <span class="n">eq₂</span><span class="o">],</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h.symm</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">eq₂</span><span class="o">,</span> <span class="bp">←</span><span class="n">ih</span><span class="o">,</span> <span class="n">eq_aux</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>
</div></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
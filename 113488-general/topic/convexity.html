---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/convexity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html">convexity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="316960515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316960515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316960515">(Dec 20 2022 at 14:16)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> in <a href="https://github.com/leanprover-community/mathlib/pull/9058">#9058</a> you generalized the definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/convex">docs#convex</a> to sets in modules over ordered semi-rings. But your definition doesn't seem to ensure that a barycentric combination of elements of a convex set belong to this convex set. Indeed <a href="https://leanprover-community.github.io/mathlib_docs/find/convex.sum_mem">docs#convex.sum_mem</a> assumes scalars form a linearly ordered field (and the obvious proof on paper certainly also requires inverting stuff). Are you sure this is the definition you wanted? If we switch to have <a href="https://leanprover-community.github.io/mathlib_docs/find/convex.sum_mem">docs#convex.sum_mem</a> as the definition (and a lemma saying that over a field it sufficices to check the weak condition), would we loose any convex set you care about?</p>



<a name="316962847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316962847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316962847">(Dec 20 2022 at 14:27)</a>:</h4>
<p>Yes, you're catching this definition mid-(a long) refactor. My idea was to define convex spaces with a primitive operation <code>convex_combination</code>, which would generalise both semimodules and affine spaces.</p>



<a name="316968036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316968036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316968036">(Dec 20 2022 at 14:51)</a>:</h4>
<p>The older thread is <a href="#narrow/stream/113488-general/topic/Convexity.20refactor/near/253162509">here</a></p>



<a name="316971754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316971754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316971754">(Dec 20 2022 at 15:07)</a>:</h4>
<p>I see. It would have been nice to finish this because the current definition is probably not usable at all beyond the field case.</p>



<a name="316972318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316972318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316972318">(Dec 20 2022 at 15:09)</a>:</h4>
<p>I'll try to work around that, but this is digging an even deeper rabbit hole than what I hoped two hours ago <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="316976676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316976676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316976676">(Dec 20 2022 at 15:30)</a>:</h4>
<p>What are your needs? My original goal was to generalise to scalar semifields, which involved generalising to <a href="https://leanprover-community.github.io/mathlib_docs/find/ordered_semiring">docs#ordered_semiring</a> because <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_semifield">docs#linear_ordered_semifield</a> wasn't yet a thing.</p>



<a name="316976777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316976777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316976777">(Dec 20 2022 at 15:30)</a>:</h4>
<p>Now that it is, I wonder whether we even want the non-semifield case.</p>



<a name="316977746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316977746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316977746">(Dec 20 2022 at 15:35)</a>:</h4>
<p>For the record, I just want to add that I may do another convexity refactor at some point if I figure out ways to nicely unify the usual convexity with convexity over non-archimedean fields. But it is not relevant for the current conversation</p>



<a name="316978284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316978284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316978284">(Dec 20 2022 at 15:37)</a>:</h4>
<p>In my use case the ring of scalars is the ring of germs of smooth functions at a point in a manifold.</p>



<a name="316978756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316978756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316978756">(Dec 20 2022 at 15:39)</a>:</h4>
<p>This is subring of <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.germ">docs#filter.germ</a></p>



<a name="316979133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/316979133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#316979133">(Dec 20 2022 at 15:41)</a>:</h4>
<p>The ordered ring instance is missing because people who wrote that file were too focused on ultraproducts so we have <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.germ.linear_ordered_comm_ring">docs#filter.germ.linear_ordered_comm_ring</a>  but not</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">filter.germ.ordered_comm_ring</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ordered_comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">ordered_comm_ring</span> <span class="o">(</span><span class="n">germ</span> <span class="n">l</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add_le_add_left</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="o">⟨</span><span class="n">a</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">⟩</span> <span class="n">hab</span> <span class="o">⟨</span><span class="n">c</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">eventually.mono</span> <span class="n">hab</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">add_le_add_left</span> <span class="n">hx</span> <span class="n">_</span><span class="o">),</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">zero_le_one</span> <span class="o">:=</span>  <span class="n">eventually_of_forall</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">zero_le_one</span><span class="o">),</span>
  <span class="n">mul_nonneg</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintros</span> <span class="o">⟨</span><span class="n">a</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">⟩</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">eventually.mono</span> <span class="o">(</span><span class="n">ha.and</span> <span class="n">hb</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">mul_nonneg</span> <span class="n">hx.1</span> <span class="n">hx.2</span><span class="o">)</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">filter.germ.partial_order</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="o">(</span><span class="n">germ</span> <span class="n">l</span> <span class="n">R</span><span class="o">))}</span>
</code></pre></div>



<a name="317000807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317000807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317000807">(Dec 20 2022 at 17:29)</a>:</h4>
<p>I have some fun exercise for people with the right kind of masochistic bias:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.convex.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="kd">variables</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_smul</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">really_convex_hull</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_smul</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">e</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">w</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">,</span>  <span class="mi">0</span> <span class="bp">≤</span> <span class="n">w</span> <span class="bp">∧</span> <span class="n">support</span> <span class="n">w</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="bp">∑ᶠ</span> <span class="n">x</span><span class="o">,</span> <span class="n">w</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">e</span> <span class="bp">=</span> <span class="bp">∑ᶠ</span> <span class="n">x</span><span class="o">,</span> <span class="n">w</span> <span class="n">x</span> <span class="bp">•</span> <span class="n">x</span><span class="o">}</span>

<span class="kd">variable</span> <span class="o">{</span><span class="bp">𝕜</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">sum_mem_really_convex_hull</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">}</span> <span class="o">{</span><span class="n">w</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">}</span>
  <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">w</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hz</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="n">z</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">z</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">really_convex_hull</span> <span class="bp">𝕜</span> <span class="n">s</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="317001193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317001193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317001193">(Dec 20 2022 at 17:31)</a>:</h4>
<p>The proof on paper is: "What do you mean by proof? Is there anything to prove?", which usually means quite a lot of Lean code.</p>



<a name="317007275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317007275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317007275">(Dec 20 2022 at 18:02)</a>:</h4>
<p>Are you proposing that <code>really_convex_hull</code> replace <code>convex_hull</code>?</p>



<a name="317007571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317007571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317007571">(Dec 20 2022 at 18:03)</a>:</h4>
<p>Because if we're going to use up the community pool of masochistic bias, it would be great to have the affine generalization at the same time, assuming they're not incompatible</p>



<a name="317007713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317007713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317007713">(Dec 20 2022 at 18:04)</a>:</h4>
<p>Yes, I propose some version of <code>really_convex_hull</code> should replace <code>convex_hull</code> (and the analogue change for the definition of <code>convex</code>). This wouldn't be enough to get the affine case as far as I can see, but that would make the current version of <code>convex</code> and <code>convex_hull</code> usable beyond the field case.</p>



<a name="317007803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317007803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317007803">(Dec 20 2022 at 18:05)</a>:</h4>
<p>And I think that proving some form of this lemma will be needed to connect any super abstract version of convexity with something usable in the ordered_ring case.</p>



<a name="317008090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317008090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317008090">(Dec 20 2022 at 18:06)</a>:</h4>
<p>I think my point is that if we did the affine case we'd probably have to throw away that definition and pick a different one (maybe in terms of <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.weighted_vsub">docs#finset.weighted_vsub</a>); so it might be worth solving both problems at once rather than repeating the work</p>



<a name="317008237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317008237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317008237">(Dec 20 2022 at 18:07)</a>:</h4>
<p>What you are describing sounds nice but it is very unlikely to happen in the coming year while I need this lemma now.</p>



<a name="317008311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317008311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317008311">(Dec 20 2022 at 18:07)</a>:</h4>
<p>Mathlib3 now or mathlib4 now?</p>



<a name="317008453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317008453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317008453">(Dec 20 2022 at 18:08)</a>:</h4>
<p>This is in mathlib3.</p>



<a name="317008488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317008488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317008488">(Dec 20 2022 at 18:08)</a>:</h4>
<p>Actually I'm trying to refactor something from the sphere eversion project.</p>



<a name="317024833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317024833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317024833">(Dec 20 2022 at 19:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I assume that I can change <code>[has_smul 𝕜 E]</code> to <code>[module 𝕜 E]</code>? Otherwise I can't prove anything about the sum of <code>w x • x</code>.</p>



<a name="317024872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317024872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317024872">(Dec 20 2022 at 19:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113488-general/topic/convexity/near/316978284">said</a>:</p>
<blockquote>
<p>In my use case the ring of scalars is the ring of germs of smooth functions at a point in a manifold.</p>
</blockquote>
<p>Amazing! I kind of gave up the refactor halfway through because of the lack of need for the extra generality. But if you need it, I'm getting straight back in.</p>



<a name="317025208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317025208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317025208">(Dec 20 2022 at 19:35)</a>:</h4>
<p>Disclaimer: I'm painting my house for the next two weeks so my Lean time won't be much.</p>



<a name="317025427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317025427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317025427">(Dec 20 2022 at 19:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span>: does your use-case need semirings, or would rings be fine?</p>



<a name="317025732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317025732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317025732">(Dec 20 2022 at 19:38)</a>:</h4>
<p>(I ask because <a href="https://leanprover-community.github.io/mathlib_docs/find/add_torsor">docs#add_torsor</a> is currently only defined for <code>add_comm_group</code>, and given the choice I'd rather we prioritize a) your use case b) affine spaces c) semirings instead of a) your use case b) semirings c) affine spaces)</p>



<a name="317025743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317025743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317025743">(Dec 20 2022 at 19:38)</a>:</h4>
<p>If it's only the germs of smooth functions that Patrick mentioned above, then I'm pretty sure rings is good enough.</p>



<a name="317025881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317025881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317025881">(Dec 20 2022 at 19:39)</a>:</h4>
<p>yeah, Patrick is doing mathematics, so semirings are unlikely to be involved :-) (yes yes I know the naturals are a semiring, but he's a topologist)</p>



<a name="317025961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317025961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317025961">(Dec 20 2022 at 19:39)</a>:</h4>
<p>I've reduced it to a lemma which I don't know a good name for, modulo changing <code>has_smul</code> to <code>module</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.convex.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="kd">variables</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="c1">-- changed from original question</span>

<span class="kd">def</span> <span class="n">really_convex_hull</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_smul</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">e</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">w</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">,</span>  <span class="mi">0</span> <span class="bp">≤</span> <span class="n">w</span> <span class="bp">∧</span> <span class="n">support</span> <span class="n">w</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="bp">∑ᶠ</span> <span class="n">x</span><span class="o">,</span> <span class="n">w</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">e</span> <span class="bp">=</span> <span class="bp">∑ᶠ</span> <span class="n">x</span><span class="o">,</span> <span class="n">w</span> <span class="n">x</span> <span class="bp">•</span> <span class="n">x</span><span class="o">}</span>

<span class="kd">variable</span> <span class="o">{</span><span class="bp">𝕜</span><span class="o">}</span>

<span class="c1">-- https://xkcd.com/927/</span>
<span class="kd">lemma</span> <span class="n">finsum.exists_ne_zero_of_sum_ne_zero</span> <span class="o">{</span><span class="n">β</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∑ᶠ</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">finsum_mem_finset_eq_sum</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">finset.exists_ne_zero_of_sum_ne_zero</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑ᶠ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">f</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="n">s</span><span class="o">,</span> <span class="n">g</span> <span class="n">y</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">g</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">sum_mem_really_convex_hull</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">}</span> <span class="o">{</span><span class="n">w</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">}</span>
  <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">w</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hz</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="n">z</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">z</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">really_convex_hull</span> <span class="bp">𝕜</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="o">(</span><span class="bp">∑ᶠ</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">z</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">e</span><span class="o">),</span> <span class="n">w</span> <span class="n">i</span><span class="o">),</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">pi.le_def</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">finsum_nonneg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">finsum_nonneg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hi</span><span class="o">,</span> <span class="n">h₀</span> <span class="n">_</span> <span class="o">(</span><span class="n">finset.mem_of_mem_filter</span> <span class="n">i</span> <span class="n">hi</span><span class="o">)),</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_support</span> <span class="n">at</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">finsum.exists_ne_zero_of_sum_ne_zero</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.mem_filter</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">hz</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">finsum_mem_finset_eq_sum</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">foo</span> <span class="n">z</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">finsum_mem_finset_eq_sum</span><span class="o">,</span> <span class="n">finset.sum_smul</span><span class="o">],</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">foo</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">congr'</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.sum_congr</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.mem_filter</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hy.2</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="317026745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317026745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317026745">(Dec 20 2022 at 19:43)</a>:</h4>
<p>You want <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_eq_zero_iff">docs#finset.sum_eq_zero_iff</a></p>



<a name="317026828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317026828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317026828">(Dec 20 2022 at 19:43)</a>:</h4>
<p>Not for this lemma, right? Oh -- are you responding to Eric?</p>



<a name="317026914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317026914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317026914">(Dec 20 2022 at 19:44)</a>:</h4>
<p>or rather the <code>of_nonneg</code> version (and you're missing the non-negativity assumption in your lemma)</p>



<a name="317027127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317027127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317027127">(Dec 20 2022 at 19:45)</a>:</h4>
<p>No no, I'm responding to you. The more API way to state your lemma is <code>sum ... = 0 iff forall ...</code></p>



<a name="317027348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317027348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317027348">(Dec 20 2022 at 19:46)</a>:</h4>
<p>Are you talking about <code>finsum.exists_ne_zero_of_sum_ne_zero</code>? This needs no non-negativity assumptions.</p>



<a name="317027391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317027391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317027391">(Dec 20 2022 at 19:46)</a>:</h4>
<p>It's not an iff.</p>



<a name="317027593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317027593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317027593">(Dec 20 2022 at 19:47)</a>:</h4>
<p>Ah sorry my phone wouldn't display the unicode. Then you want the contrapositive of <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum_eq_zero">docs#finset.sum_eq_zero</a></p>



<a name="317027697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317027697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317027697">(Dec 20 2022 at 19:48)</a>:</h4>
<p>Oh lol I know exactly that situation, my phone does that too :-/</p>



<a name="317029032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317029032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317029032">(Dec 20 2022 at 19:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.convex.basic</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="kd">variables</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="c1">-- note to Patrick: I needed this at some point</span>

<span class="kd">def</span> <span class="n">really_convex_hull</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_smul</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">e</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">w</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">,</span>  <span class="mi">0</span> <span class="bp">≤</span> <span class="n">w</span> <span class="bp">∧</span> <span class="n">support</span> <span class="n">w</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="bp">∧</span> <span class="bp">∑ᶠ</span> <span class="n">x</span><span class="o">,</span> <span class="n">w</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">e</span> <span class="bp">=</span> <span class="bp">∑ᶠ</span> <span class="n">x</span><span class="o">,</span> <span class="n">w</span> <span class="n">x</span> <span class="bp">•</span> <span class="n">x</span><span class="o">}</span>

<span class="kd">variable</span> <span class="o">{</span><span class="bp">𝕜</span><span class="o">}</span>

<span class="c1">-- https://xkcd.com/927/</span>
<span class="kd">lemma</span> <span class="n">finsum.exists_ne_zero_of_sum_ne_zero</span> <span class="o">{</span><span class="n">β</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∑ᶠ</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">finsum_mem_finset_eq_sum</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">finset.exists_ne_zero_of_sum_ne_zero</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑ᶠ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">f</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="n">s</span><span class="o">,</span> <span class="n">g</span> <span class="n">y</span> <span class="bp">=</span> <span class="bp">∑</span> <span class="n">k</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="n">g</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">finsum_eq_finset_sum_of_support_subset</span> <span class="n">_</span> <span class="o">(</span><span class="k">show</span> <span class="n">_</span> <span class="bp">⊆</span> <span class="bp">↑</span><span class="o">(</span><span class="n">s.image</span> <span class="n">f</span><span class="o">),</span> <span class="k">from</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">finset.sum_image'</span><span class="o">,</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_support</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">finset.exists_ne_zero_of_sum_ne_zero</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
  <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">sum_mem_really_convex_hull</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">}</span> <span class="o">{</span><span class="n">w</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="bp">𝕜</span><span class="o">}</span>
  <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">w</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hz</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">,</span> <span class="n">z</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">z</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">really_convex_hull</span> <span class="bp">𝕜</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="o">(</span><span class="bp">∑ᶠ</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">t.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span><span class="o">,</span> <span class="n">z</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">e</span><span class="o">),</span> <span class="n">w</span> <span class="n">i</span><span class="o">),</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">pi.le_def</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">finsum_nonneg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">finsum_nonneg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hi</span><span class="o">,</span> <span class="n">h₀</span> <span class="n">_</span> <span class="o">(</span><span class="n">finset.mem_of_mem_filter</span> <span class="n">i</span> <span class="n">hi</span><span class="o">)),</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_support</span> <span class="n">at</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">finsum.exists_ne_zero_of_sum_ne_zero</span> <span class="n">he</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.mem_filter</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">hz</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">finsum_mem_finset_eq_sum</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">foo</span> <span class="n">z</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">finsum_mem_finset_eq_sum</span><span class="o">,</span> <span class="n">finset.sum_smul</span><span class="o">],</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">foo</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">congr'</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.sum_congr</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset.mem_filter</span> <span class="n">at</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hy.2</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span>  (note the <code>module</code> change -- is it OK?)</p>



<a name="317035192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317035192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317035192">(Dec 20 2022 at 20:35)</a>:</h4>
<p>Awesome, thank you very much Kevin!</p>



<a name="317035302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317035302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317035302">(Dec 20 2022 at 20:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/convexity/near/317025427">said</a>:</p>
<blockquote>
<p>does your use-case need semirings, or would rings be fine?</p>
</blockquote>
<p>Rings would be fine.</p>



<a name="317058249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317058249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317058249">(Dec 20 2022 at 23:20)</a>:</h4>
<p>(deleted)</p>



<a name="317066726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317066726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317066726">(Dec 21 2022 at 00:47)</a>:</h4>
<p>I think we concluded in one of the past discussions that to cover both the semiring/semifield case (more precisely, the case where the module is only an <code>add_comm_monoid</code> not an <code>add_comm_group</code>) and the <code>add_torsor</code> case, while avoiding diamonds, we'd need both the class for abstract affine combination spaces and the class that inherits from both that and <code>add_torsor</code> for a module and asserts that the two affine combination operations are equal. And then ensure that the instances are set up so that modules get the affine combination operation expressed to be defeq to the version expressed as a linear combination in the obvious way (and only propositionally equal, not defeq, to the version derived from the <code>add_torsor</code> instance for the module over itself).</p>



<a name="317097488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317097488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317097488">(Dec 21 2022 at 07:30)</a>:</h4>
<p>How did we conclude that? Thinking about it yesterday I reached the conclusion that it was enough for <code>affine_space</code> to extend <code>convex_space</code> (and make defaults for the <code>convex_space</code> fields).</p>



<a name="317121141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317121141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317121141">(Dec 21 2022 at 10:04)</a>:</h4>
<p>I was also wondering: Do we want to base convexity on a type of convex combinations? By that I mean a type of finitely supported nonnegative functions whose sum is 1. This is basically <a href="https://leanprover-community.github.io/mathlib_docs/find/std_simplex">docs#std_simplex</a>.</p>



<a name="317121746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317121746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317121746">(Dec 21 2022 at 10:07)</a>:</h4>
<p>The advantage is that operations on<br>
this type encode operations on any space without needing us to supply repetitive nonnegativity and sum = 1 obligations.</p>



<a name="317121835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317121835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317121835">(Dec 21 2022 at 10:08)</a>:</h4>
<p>Oh my, is there some initial object hiding in there?</p>



<a name="317122920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317122920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317122920">(Dec 21 2022 at 10:14)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/Convexity.20refactor/near/253773652">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Convexity.20refactor/near/253773652</a></p>



<a name="317123324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317123324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317123324">(Dec 21 2022 at 10:16)</a>:</h4>
<p>Yeah I'm not believing Yury's argument anymore. If the <code>affine_space</code> instance contains the <code>convex_space</code> one, everything is still defeq.</p>



<a name="317123639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317123639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317123639">(Dec 21 2022 at 10:18)</a>:</h4>
<p>The defeq we lose is between the new primitive <code>convex_combination</code> and <a href="https://leanprover-community.github.io/mathlib_docs/find/affine_space.weighted_vsub">docs#affine_space.weighted_vsub</a>. This in my opinion is better than losing the defeq with <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.sum">docs#finset.sum</a>. But really I think both are breakable without too much trouble.</p>



<a name="317156082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317156082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317156082">(Dec 21 2022 at 13:19)</a>:</h4>
<p>Affine spaces do not need the ring to be ordered and so should not extend anything involving an order on the ring. They can extend a class that has all affine combinations (with sum of weights 1), but not a class that depends on the ring being ordered. (The first step in any case for setting up abstract affine combination spaces is probably to remove the <code>affine_space</code> notation for <code>add_torsor</code>; the vast bulk of the existing affine space API involves vectors and subtraction and genuinely depends on having a torsor rather than just affine combinations.)</p>



<a name="317192157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/convexity/near/317192157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/convexity.html#317192157">(Dec 21 2022 at 16:00)</a>:</h4>
<p>Right, I missed this. And I totally agree that <code>affine_space</code> will mean something different after the refactor and that the rename is basically the first thing we need to do.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
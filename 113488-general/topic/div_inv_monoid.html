---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/div_inv_monoid.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html">div_inv_monoid</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="278406644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/278406644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#278406644">(Apr 09 2022 at 12:02)</a>:</h4>
<p>I feel like <code>div_inv_monoid</code> does not quite fulfill its purpose of common ancestor of <code>group</code> and <code>group_with_zero</code> because <code>div</code> and <code>inv</code> are currently lawless. We still have a fair share of lemmas which are duplicated between both. For example,</p>
<ul>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/inv_one">docs#inv_one</a> vs <a href="https://leanprover-community.github.io/mathlib_docs/find/one_inv">docs#one_inv</a></li>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/one_zpow">docs#one_zpow</a> vs <a href="https://leanprover-community.github.io/mathlib_docs/find/one">docs#one</a>_zpow₀</li>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/group.to_has_involutive_inv">docs#group.to_has_involutive_inv</a> vs <a href="https://leanprover-community.github.io/mathlib_docs/find/group_with_zero.to_has_involutive_inv">docs#group_with_zero.to_has_involutive_inv</a></li>
</ul>
<p>What do people think of making <code>div_inv_monoid</code> stronger and thus potentially more useful for deduplicating lemmas?</p>



<a name="278407502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/278407502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#278407502">(Apr 09 2022 at 12:22)</a>:</h4>
<p>The original motivation was <code>div_eq_mul_inv</code>, so it's not <em>entirely</em> lawless</p>



<a name="279224050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279224050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279224050">(Apr 17 2022 at 14:26)</a>:</h4>
<p>Okay so I will make <code>div_inv_monoid</code> extend <code>has_involutive_inv</code>. While I'm at it, shouldn't we have <code>div_inv_comm_monoid</code>?</p>



<a name="279224072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279224072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279224072">(Apr 17 2022 at 14:27)</a>:</h4>
<p>I am thinking of lemmas like <a href="https://leanprover-community.github.io/mathlib_docs/find/div_eq_inv_mul">docs#div_eq_inv_mul</a></p>



<a name="279224297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279224297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279224297">(Apr 17 2022 at 14:31)</a>:</h4>
<p>Let me also add another motivation to my original message: Pointwise operations (<code>set</code>, <code>finset</code>, <code>filter</code>) make a group <em>except</em> for <code>a / a = 1</code>. This means that we currently</p>
<ul>
<li>duplicate the instances: <a href="https://leanprover-community.github.io/mathlib_docs/find/set.div_inv_monoid">docs#set.div_inv_monoid</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/set.div_inv_monoid'">docs#set.div_inv_monoid'</a> (same for the other two). This is rather minor</li>
<li>lack almost all lemmas relating division and inversion. For example, when <code>s t : finset α</code> and <code>α</code> is a <code>group</code>, it is true that <code>(t / s)⁻¹ = s / t</code> but it is a pain to prove.</li>
</ul>



<a name="279224357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279224357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279224357">(Apr 17 2022 at 14:33)</a>:</h4>
<p><code>div_inv_monoid</code>/<code>div_inv_comm_monoid</code> could help here by being "a group (with zero), except that division doesn't have to bring you back to <code>1</code>".</p>



<a name="279224370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279224370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279224370">(Apr 17 2022 at 14:33)</a>:</h4>
<p>I went through all instances of <code>div_inv_monoid</code> and it seems that nothing relies on the current precise implementation.</p>



<a name="279224703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279224703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279224703">(Apr 17 2022 at 14:41)</a>:</h4>
<p>I agree that <code>div_eq_inv_mul</code> and similar lemmas look like sufficient justification for <code>div_inv_comm_monoid</code></p>



<a name="279224714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279224714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279224714">(Apr 17 2022 at 14:41)</a>:</h4>
<p>Do we already have the group versions of those lemmas?</p>



<a name="279226616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279226616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279226616">(Apr 17 2022 at 15:28)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/div_eq_inv_mul'">docs#div_eq_inv_mul'</a> ?</p>



<a name="279243305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279243305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279243305">(Apr 17 2022 at 22:18)</a>:</h4>
<p>Some thoughts over at <a href="https://github.com/leanprover-community/mathlib/tree/stronger_div_inv_monoid">branch#stronger_div_inv_monoid</a>. I am still figuring which<code>group /</code>group_with_zero<code> lemmas should be turned into axioms of </code>div_inv_monoid<code>. So far I've gone with </code>inv_inv : a⁻¹⁻¹ = a<code> and </code>inv_mul_rev : (a * b)⁻¹ = b⁻¹ * a⁻¹` and it seems to work well.</p>



<a name="279266199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279266199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279266199">(Apr 18 2022 at 07:47)</a>:</h4>
<p>Okay I'm hitting a problem with <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.div_inv_monoid">docs#matrix.div_inv_monoid</a>. Inversion of matrices isn't involutive.</p>



<a name="279266628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279266628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279266628">(Apr 18 2022 at 07:56)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>, is there any way to make this work?</p>



<a name="279266671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279266671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279266671">(Apr 18 2022 at 07:57)</a>:</h4>
<p>I'd encourage you to do the <code>div_inv_comm_monoid</code> change first before going too deep into this second can of worms</p>



<a name="279266731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279266731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279266731">(Apr 18 2022 at 07:58)</a>:</h4>
<p>I mean, are you happy with me nuking <code>matrix.div_inv_monoid</code> into pieces?</p>



<a name="279266756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279266756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279266756">(Apr 18 2022 at 07:59)</a>:</h4>
<p>Given that <code>data.matrix.zpow</code> is a leaf file, this should be fine.</p>



<a name="279266953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279266953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279266953">(Apr 18 2022 at 08:01)</a>:</h4>
<p>It might be worth waiting for <span class="user-mention" data-user-id="238446">@Anne Baanen</span>'s opinion on that kind of thing; originally <code>div_inv_monoid</code> was intended purely to unify the two notations, but with your suggested change it's now not able to do that any more (in this case, for matrices)</p>



<a name="279267041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279267041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279267041">(Apr 18 2022 at 08:02)</a>:</h4>
<p>Maybe the solution is to have both <code>div_inv_class</code> (for the notation) and <code>div_inv_monoid</code> (for the lemma deduplication).</p>



<a name="279267133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279267133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279267133">(Apr 18 2022 at 08:04)</a>:</h4>
<p>I'm not sure about the names, but an additional typeclass would alleviate my specific concern above.</p>



<a name="279267221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279267221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279267221">(Apr 18 2022 at 08:06)</a>:</h4>
<p>If you look at <a href="https://github.com/leanprover-community/mathlib/tree/stronger_div_inv_monoid">branch#stronger_div_inv_monoid</a>, you will also see that I had to manually copy the new fields from <code>div_inv_monoid</code> to a bunch of structures because extending <code>div_inv_monoid</code> would make them have many two redundant fields. Having this notation typeclass would fix this.</p>



<a name="279267223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279267223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279267223">(Apr 18 2022 at 08:06)</a>:</h4>
<p>What about <code>has_lawful_div</code>?</p>



<a name="279267629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279267629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279267629">(Apr 18 2022 at 08:14)</a>:</h4>
<p>For the stronger or weaker notion?</p>



<a name="279267655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279267655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279267655">(Apr 18 2022 at 08:15)</a>:</h4>
<p>The weaker one.</p>



<a name="279267994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279267994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279267994">(Apr 18 2022 at 08:22)</a>:</h4>
<p>Involution of inverse is too strong for matrices. But as we have it defined, inv thrice is inv.</p>



<a name="279268027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279268027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279268027">(Apr 18 2022 at 08:23)</a>:</h4>
<p>Ask Anne, they made the matrix inv work. The zpow is just making its commutation make sense with npow.</p>



<a name="279268661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279268661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279268661">(Apr 18 2022 at 08:36)</a>:</h4>
<p>I think the div_eq_inv_mul is a powerful law, because it implies statements about associativity of various operators. The fact that the matrix semiring admits an inverse that respects this structure is to me, reason enough to have it.</p>



<a name="279269252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279269252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279269252">(Apr 18 2022 at 08:46)</a>:</h4>
<p>It doesn't buy you much, though. You can take an arbitrary <code>inv</code> and derive <code>div</code> from it. Sure, we do get a few lemmas about the interaction of <code>div</code> and <code>mul</code> but that's it.</p>



<a name="279269273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279269273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279269273">(Apr 18 2022 at 08:46)</a>:</h4>
<p><code>matrix</code> actually respects <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.mul_inv_rev">docs#matrix.mul_inv_rev</a>, which is a pretty crucial lemma.</p>



<a name="279270121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279270121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279270121">(Apr 18 2022 at 09:03)</a>:</h4>
<p>Just look at the sheer amount of lemmas I can deduplicate/generalize and convince yourself: <a href="https://github.com/leanprover-community/mathlib/tree/stronger_div_inv_monoid">branch#stronger_div_inv_monoid</a></p>



<a name="279273739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279273739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279273739">(Apr 18 2022 at 10:10)</a>:</h4>
<p>Removing an existing typeclass is an orthogonal discussion to adding a new one</p>



<a name="279273758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279273758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279273758">(Apr 18 2022 at 10:11)</a>:</h4>
<p>(making a typeclass stronger to the point that existing instances are no longer true amounts to removing it and adding a new one with the same name)</p>



<a name="279286853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279286853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279286853">(Apr 18 2022 at 13:34)</a>:</h4>
<p>Okay so I have three propositions, modulo naming:</p>
<ul>
<li>Have a class which just contains the bare minimum for division and inversion and use it in <code>extends</code> clause to avoid copying over all the <code>zpow</code> fields, and add a stronger typeclass<ul>
<li><code>div_inv_class</code> = the current <code>div_inv_monoid</code></li>
<li><code>div_inv_monoid</code> = <code>div_inv_class</code> + <code>has_involutive_inv</code></li>
</ul>
</li>
<li>Moderately strengthen <code>div_inv_monoid</code> and add a stronger typeclass<ul>
<li><code>div_inv_class</code> = the current <code>div_inv_monoid</code> + <code>(a * b)⁻¹ = b⁻¹ * a⁻¹</code></li>
<li><code>div_inv_monoid</code> = <code>div_inv_class</code> + <code>has_involutive_inv</code>. I did not yet manage to prove <code>a * b = 1 → a⁻¹ = b</code> from this, even though all candidate types (yes, even <code>set</code>) in mathlib respect it. If it doesn't hold generally, we might consider adding it as well.</li>
</ul>
</li>
<li>Strengthen <code>div_inv_monoid</code> and make the weaker one a mixin typeclass<ul>
<li><code>div_inv_class</code> = mixin for <code>a / b = a * b⁻¹</code> and eventually the <code>zpow</code> fields. Does that work diamond-wise?</li>
<li><code>div_inv_monoid</code> = the current <code>div_inv_monoid</code> + <code>has_involutive_inv</code>.</li>
</ul>
</li>
</ul>
<p>All three versions do not break any current instance of <code>div_inv_monoid</code>, and actually only one of them (namely <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.div_inv_monoid">docs#matrix.div_inv_monoid</a>) can't be upgraded to the new version of <code>div_inv_monoid</code>.</p>



<a name="279287311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279287311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279287311">(Apr 18 2022 at 13:41)</a>:</h4>
<p>Another possibility for the names is <code>div_inv_monoid</code> and <code>division_monoid</code>.</p>



<a name="279287707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279287707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279287707">(Apr 18 2022 at 13:47)</a>:</h4>
<p>Another name that may or may not be useful is <code>has_distrib_inv</code> to somewhat match <a href="https://leanprover-community.github.io/mathlib_docs/find/has_distrib_neg">docs#has_distrib_neg</a> (although the type of distributivity is quite different)</p>



<a name="279288171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279288171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279288171">(Apr 18 2022 at 13:52)</a>:</h4>
<p>I wouldn't regard these as similar, distributivity is about the interaction of multiplication and addition, but here there is only multiplicative structure. You can see also the form of the axiom <code>neg_mul</code> is different from <code>(a * b)⁻¹ = b⁻¹ * a⁻¹</code> because in <code>neg_mul</code> only one side is negated. It is like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi mathvariant="normal">.</mi><mi>x</mi><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mi>g</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">g.xy = (g.x)y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> versus <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi mathvariant="normal">.</mi><mi>x</mi><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mi>g</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>g</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g.xy = (g.x)(g.y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> again.</p>



<a name="279288231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279288231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279288231">(Apr 18 2022 at 13:53)</a>:</h4>
<p>It's rather left or right commutativity of a unary and a binary functions.</p>



<a name="279288337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279288337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279288337">(Apr 18 2022 at 13:54)</a>:</h4>
<p>... which means that <code>has_distrib_neg</code> might be a misnomer.</p>



<a name="279288488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279288488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279288488">(Apr 18 2022 at 13:56)</a>:</h4>
<p>The name <code>has_distrib_neg</code> seems fine to me, it's the part of distributivity/bilinearity that has to do with negation in each argument.</p>



<a name="279288707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279288707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279288707">(Apr 18 2022 at 13:59)</a>:</h4>
<p>I mean it's not <code>neg</code> itself that is <code>distrib</code>utive, but otherwise it's fine.</p>



<a name="279288885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279288885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279288885">(Apr 18 2022 at 14:01)</a>:</h4>
<p>Oh it depends on whether you think of <code>neg</code> as part of the additive structure or as multiplication by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>; maybe that's what you meant?</p>



<a name="279288913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279288913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279288913">(Apr 18 2022 at 14:01)</a>:</h4>
<p>Yes, kind of</p>



<a name="279289121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279289121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279289121">(Apr 18 2022 at 14:04)</a>:</h4>
<p>Like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>b</mi><mo>=</mo><mo>−</mo><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">-(a + b) = (-1) * (a + b) = (-1) * a + (-1) * b = - a - b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> which now looks like <code>div_inv</code> stuff and not <code>neg_mul</code> yet I used the distributive law to get it</p>



<a name="279290686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279290686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279290686">(Apr 18 2022 at 14:23)</a>:</h4>
<p><code>has_distrib_inv</code> was a dumb suggestion because we need a name for the additive concept <code>-(a + b) = -b + -a</code>, sorry for the distraction.</p>



<a name="279290707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279290707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279290707">(Apr 18 2022 at 14:23)</a>:</h4>
<p>And the additive name is obviously already taken</p>



<a name="279290805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279290805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279290805">(Apr 18 2022 at 14:24)</a>:</h4>
<p>Technically, it's not distributivity, but antidistributivity.</p>



<a name="279298056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279298056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279298056">(Apr 18 2022 at 15:32)</a>:</h4>
<p>I'm hitting something weird... Making <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_add_comm_group_with_top">docs#linear_ordered_add_comm_group_with_top</a> extend <code>has_sub</code> and <code>has_neg</code> instead of <code>sub_neg_monoid</code> and copying over the fields makes Lean reject the default value for <code>sub</code>.</p>



<a name="279643512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279643512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279643512">(Apr 21 2022 at 07:05)</a>:</h4>
<p>Okay so I managed to make version 1 compile. The diff is rather huge, so I will first PR the definition of <code>division_monoid</code>, then the lemma generalizations.</p>



<a name="279651360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279651360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279651360">(Apr 21 2022 at 08:40)</a>:</h4>
<p>It's been a while, hopefully my comments don't lead to too much wasted work!</p>
<p>The definition of <code>div_inv_monoid</code> had the following main motivation: <code>group_with_zero</code> used to assume <code>div</code> would be defined in terms of <code>inv</code> but for <code>fractional_ideal</code> it's the other way around. So we should replace the definitional equality <code>a / b = a * b⁻¹</code> with a propositional one. Since <code>group</code> might have the same issue in the future, I made a superclass of both <code>group</code> and <code>group_with_zero</code> <code>div_inv_monoid</code> carrying a definition of <code>div</code> and <code>inv</code> and a proof <code>div_eq_mul_inv</code>. A few results nicely generalized from <code>group</code>(<code>_with_zero</code>) to <code>div_inv_monoid</code> but the motivation was to remove a technical obstruction to a specific instance, rather than generalizing as many lemmas as possible.</p>
<p>Having said that, I think it's a valuable project to generalize as much as reasonable, so indeed a stronger subclass of <code>group</code> and <code>group_with_zero</code> does make sense.</p>



<a name="279651544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279651544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279651544">(Apr 21 2022 at 08:42)</a>:</h4>
<p>If you could have a look at <a href="https://github.com/leanprover-community/mathlib/tree/stronger_div_inv_monoid">branch#stronger_div_inv_monoid</a> and tell me what you think, I would be grateful!</p>



<a name="279654115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279654115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279654115">(Apr 21 2022 at 09:10)</a>:</h4>
<p>Alright, here's my thoughts on the implementation:</p>
<ul>
<li>Mixins can be useful in specific cases, but they do have a tendency to hurt performance. In particular, the fully unfolded term size of a type determines the worst-case typechecking behaviour. So a long inheritance chain including mixins on a <code>group G</code> instance can really hurt typechecking on <code>s : submonoid G</code>, and even worse on typechecking <code>x : s</code>. Also, we probably don't need to switch often in applications between assuming that inverses are very lawful and only a bit lawful, so mixins probably don't help either.</li>
<li>Naïvely I would assume "monoid with a (partial) inverse operator" is one with a strong specification on the inverse of <code>inv_spec : ∀ a b, a * b = 1 → a⁻¹ = b</code>. As far as I can tell, your code puts that in <code>group</code> still, and in the thread you noted that everything currently already satisfies this axiom. (An example of a <code>division_monoid</code> in your branch that doesn't satisfy <code>inv_spec</code> would be a <code>comm_monoid</code> where <code>inv = id</code>.)</li>
<li>I think we should keep a class isomorphic to <code>div_inv_monoid</code>, since its syntactic role means it can be easily applied to any type with division and inverses, even if those inverses aren't neatly involutive (like matrix (pseudo)inverses).</li>
</ul>



<a name="279654494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279654494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279654494">(Apr 21 2022 at 09:14)</a>:</h4>
<p>So overall I think your branch is going in the right direction, except I would like the <code>inv_spec</code> axiom to be a part of the new class. The name <code>division_monoid</code> I'm not totally convinced of (since mathematicians tend to care more about inverses than division) but I guess it works since it's essentially the meet of <code>group</code> and <code>division_ring</code>.</p>



<a name="279654832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279654832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279654832">(Apr 21 2022 at 09:18)</a>:</h4>
<ul>
<li><code>division_monoid</code> is not a mixin,  though?</li>
<li>If you think this axiom is justified, I will add it. The question now is whether this implies any of <code>inv_mul_rev : ∀ a b, (a * b)⁻¹ = b⁻¹ * a⁻¹</code> or <code>inv_inv : ∀ a, a⁻¹⁻¹ = a</code>. I believe <code>matrix</code> is a counterexample for <code>inv_inv</code>, and I can't see how we could derive <code>inv_mul_rev</code> because we would need some cancellation property to prove  <code>(a * b) * (b⁻¹ * a⁻¹) = 1</code>. One thing I also have to check is whether <code>filter</code> respects <code>inv_spec</code>.</li>
<li>Does that mean you do not want to have both <code>div_inv_monoid</code> and <code>division_monoid</code>? because this is a problem for classes currently extending <code>div_inv_monoid</code> as we do not want to clutter their declarations with the redundant <code>inv_mul_rev</code> and <code>inv_inv</code>.</li>
<li>I also thought about <code>inversion_monoid</code>, but I quite like the parallel with <code>division_ring</code> indeed.</li>
</ul>



<a name="279655354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279655354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279655354">(Apr 21 2022 at 09:25)</a>:</h4>
<ul>
<li>Indeed! I was trying to respond to some questions on mixins upthread.</li>
<li>I agree that neither follows from <code>inv_spec</code>, for example if you take the naturals then <code>neg_spec</code> only says <code>- 0 = 0</code> and leaves <code>neg</code> totally unspecified otherwise. But if <code>filter</code> also satisfies <code>inv_spec</code> then I don't see that adding it as a new axiom (alongside <code>inv_inv</code> and <code>inv_mul_rev</code>) will cause any problems, while providing a better base for the group axioms.</li>
<li>I wanted to say that keeping <code>div_inv_monoid</code> as it is, like you have done, seems like the correct approach to me. Sorry if that was unclear.</li>
</ul>



<a name="279655520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279655520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279655520">(Apr 21 2022 at 09:26)</a>:</h4>
<p>Fancy! I will figure out the <code>filter</code> conundrum and add <code>inv_spec</code> then! (do you think there's a better name for it?)</p>



<a name="279655619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279655619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279655619">(Apr 21 2022 at 09:27)</a>:</h4>
<p>For groups it's called <a href="https://leanprover-community.github.io/mathlib_docs/find/eq_inv_of_mul_eq_one">docs#eq_inv_of_mul_eq_one</a> so let's use that.</p>



<a name="279711054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279711054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279711054">(Apr 21 2022 at 17:15)</a>:</h4>
<p>Okay so I managed to prove that <code>inv_eq_of_mul_eq_one</code> on <code>α</code> implies <code>inv_eq_of_mul_eq_one</code> on <code>set α</code>/<code>finset α</code>, but it was harder than I thought! When multiplication is cancellable, you can show that <code>s</code> and <code>t</code> are singletons and then <code>s⁻¹ = t</code> is pretty obvious, but of course a <code>group_with_zero</code> isn't cancellative.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">t</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_inv</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span> <span class="n">inv_eq_of_mul_eq_one</span> <span class="o">(</span><span class="n">h.subset</span> <span class="bp">$</span> <span class="n">mem_image2_of_mem</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hst</span> <span class="o">:</span> <span class="o">(</span><span class="n">s</span> <span class="bp">*</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="o">:=</span> <span class="n">h.symm.subst</span> <span class="n">one_nonempty</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">ha</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">ha</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hst.of_image2_right</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="bp">←</span><span class="n">inv_inv</span> <span class="n">a</span><span class="o">,</span> <span class="n">H</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hst.of_image2_left</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="o">[</span><span class="bp">←</span><span class="n">H</span> <span class="n">hb</span> <span class="n">ha</span><span class="o">,</span> <span class="n">inv_inv</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279827656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279827656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279827656">(Apr 22 2022 at 14:01)</a>:</h4>
<p>But <code>H</code> together with <code>hst</code> still are telling you that <code>s</code> and <code>t</code> are singletons, right?</p>



<a name="279827941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/279827941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#279827941">(Apr 22 2022 at 14:03)</a>:</h4>
<p>Hmm... You're right. I will try proving the earlier lemma without using cancellability.</p>



<a name="280794806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/280794806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#280794806">(May 01 2022 at 13:35)</a>:</h4>
<p>Update: <code>filter</code> <strong>is</strong> a <code>division_monoid</code>! I will now open the PR.</p>



<a name="280798457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/280798457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#280798457">(May 01 2022 at 14:57)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/13860">#13860</a></p>



<a name="281509264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/281509264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#281509264">(May 07 2022 at 00:50)</a>:</h4>
<p>Here's the second bit of the refactor: <a href="https://github.com/leanprover-community/mathlib/pull/14000">#14000</a>. It introduces new <code>division_monoid</code> lemmas to replace the <code>group</code> and <code>group_with_zero</code> ones (but leaves the deletion of those to the next PR).</p>



<a name="281509274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/div_inv_monoid/near/281509274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/div_inv_monoid.html#281509274">(May 07 2022 at 00:51)</a>:</h4>
<p>I tried my best to make it as straightforward as possible.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
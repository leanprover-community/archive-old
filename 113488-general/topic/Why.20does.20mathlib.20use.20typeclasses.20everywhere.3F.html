---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html">Why does mathlib use typeclasses everywhere?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="238635881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238635881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238635881">(May 13 2021 at 15:19)</a>:</h4>
<p>Why does mathlib use typeclasses everywhere? <br>
I'm looking at mathlib seriously for the first time and have odd feelings about the design. There's probably a whole history behind it that I can't really figure out..<br>
If I had to do design a math library myself, I would probably start by not using typeclasses at all. I would use only structures and functions because its so easy to think with just them.<br>
I think typeclasses make sense in software programming contexts, where you start by modeling requirements at high level using abstract types, and you can decide later what implementation you want to plug in or out. Now it's not obvious to me why they are so useful in a proof library. I think you'd want to have a unique canonical representation for a given math concept, and some functions/theorems directly defined on it. I'm not sure why you want to abstract behavior so much.<br>
I have the impression that the main point of typeclasses in mathlib is to make some parameters and conversions implicit in order to make the code shorter. Mathlib design seems to assume that if it's shorter to write, it must be more simple. But is it really simpler to make information implicit if it becomes a hard problem to reconstruct it?<br>
I feel like there is too much effort in making things look extremely short often to the detriment of readability. On the one hand, tactics are really great because they automate work that's hard to do by hand, and it's usually clear what they do. On the other hand, typeclasses remove some boilerplate that would be easy to write by hand, but now it's hard to understand what instance is used where.<br>
I might sound crazy but I think I'd prefer converting inputs and passing instances explicitly every time i call a lemma in a proof. It's really a one time job, unlike in software programming where client requirements move all the time.<br>
When I glance at the chat discussions, and papers about lean, there seems to have been a lot of effort spent on performance problems with instance resolution, with unintended diamonds and cycles, with design choices about bundled definitions, about the hierarchy... Surely I can find a lot about why typeclasses are causing problems, but actually I can't find much about why having them is so great/why not having them is so bad.<br>
Now i'm certainly inexperienced and ignorant of all the history, I'm just throwing naive random thoughts as a newcomer. Were there past attempts at designing a mathlib without typeclasses? Are there papers/historical discussions/ list of examples on the usefulness of typeclasses in proof libraries?</p>



<a name="238636849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238636849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238636849">(May 13 2021 at 15:25)</a>:</h4>
<p><span class="user-mention" data-user-id="403214">@Michael Jam</span> If I have a field <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>, and I want to apply a lemma to it about (additive) groups, then Lean can automatically figure out that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> is also an additive group. Thanks to typeclasses.<br>
I'm very happy that I don't have to remind it of that fact all the time. And I'm also happy that I don't have to reprove every lemma for groups also for rings, commutative rings, division rings, fields, etc...</p>



<a name="238637375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238637375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238637375">(May 13 2021 at 15:29)</a>:</h4>
<p>yes well it's what I have a hard time being convinced of... I have the feeling you pay a high price for  using them.  I don't think I'd mind writing a function to convert a structure to another and adding them lazily as needed.</p>



<a name="238638723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238638723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238638723">(May 13 2021 at 15:40)</a>:</h4>
<p>Michael, you get a very biased view by only reading messages here. People talk about instance searches here only when they encounter issues. But this hiding millions of uses where everything works perfectly smoothly. The overall outcome is this system works incredibly well.</p>



<a name="238638859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238638859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238638859">(May 13 2021 at 15:41)</a>:</h4>
<p>And no major formalized math library operates without an analogous system (there are technical differences, but they are irrelevant to this conversation).</p>



<a name="238639121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238639121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238639121">(May 13 2021 at 15:43)</a>:</h4>
<p>I don't know how to say it without sounding rude, so apologize in advance, but I think you're underestimating the complexity of mathematics. Carrying around explicit arguments would be a nightmare. Maybe Mario can do it in metamath, but that doesn't prove anything, and the goal of our work is not to make sure only Mario can use a proof assistant.</p>



<a name="238639153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238639153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238639153">(May 13 2021 at 15:43)</a>:</h4>
<p>Yes I understand. People write a lot more about what they have to complain about, than about what they are happy with. But I wonder if it's really that much an advantage to not convert structures explicitly. Do you spend that big of a fraction of your time using lean, calling different lemmas on different representations of a same structure?</p>



<a name="238639449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238639449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238639449">(May 13 2021 at 15:45)</a>:</h4>
<p>I also think you spend way too much time trying to map what you understand from Haskell and programming in in general to theorem proving. I fear your messages don't make any sense because of this discrepancy.</p>



<a name="238639665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238639665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238639665">(May 13 2021 at 15:47)</a>:</h4>
<p>Yes I talk with zero experience, so I might be very wrong. I'm just curious in case you have more explicit or quantitative arguments. I know I'm gonna attract a lot of negative comments, but its a fast way to learn</p>



<a name="238639793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238639793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238639793">(May 13 2021 at 15:48)</a>:</h4>
<p>Zero experience would probably easier actually. You seem to have experience with other things that bias your view in the wrong direction.</p>



<a name="238639880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238639880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238639880">(May 13 2021 at 15:49)</a>:</h4>
<p>And I think trying to use Lean and mathlib the way it's written would be a faster way to learn than writing long messages that may sound like you wonder why people here are so stupid.</p>



<a name="238639910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238639910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238639910">(May 13 2021 at 15:49)</a>:</h4>
<p>(Although I'm very ready to believe this is not what you mean)</p>



<a name="238640619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238640619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238640619">(May 13 2021 at 15:54)</a>:</h4>
<p>I'm very interested in Lean. Unfortunately I can't deep dive in it before the summer. I like socratic questioning. But i guess it often sounds like socratic irony... It's probably too early for me to ask questions then</p>



<a name="238643797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238643797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> YaÃ«l Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238643797">(May 13 2021 at 16:16)</a>:</h4>
<p>Just wanted to point out that writing proofs is most definitely <strong>not</strong> a one-time job. You reuse stuff everywhere, all the time. People push mathlib in all directions and we are very happy when we don't have to deal with the implicit lower level maths.</p>



<a name="238643940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238643940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238643940">(May 13 2021 at 16:17)</a>:</h4>
<p>I think it's just a question of scale. Explicit dictionary passing works okay -- perhaps better in some ways -- for small examples, but it becomes a huge PITA  if you're working with bigger class hierarchies. Same for tactics versus proof terms. And scale issues are almost impossible to appreciate without experience because we always tend to think in small examples.</p>



<a name="238644566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238644566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238644566">(May 13 2021 at 16:23)</a>:</h4>
<p><span class="user-mention" data-user-id="403214">@Michael Jam</span> How large do you think that the typeclass hierarchy of mathlib is? How many edges does that graph have? (I'm not even talking about the transitive closure. But if you chaining <code>A -&gt; B -&gt; C -&gt; D -&gt; E</code> explicitly is of course another big way to hamper readability.)</p>



<a name="238644801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238644801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238644801">(May 13 2021 at 16:25)</a>:</h4>
<p>I would write a function that does that chain once. And save it somewhere. I would not add all possible conversions, but I would add them lazily as needed over time</p>



<a name="238645048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238645048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238645048">(May 13 2021 at 16:27)</a>:</h4>
<p>Sure, that's why I'm asking how many actual edges you think there currently are. (Not the transitive closure. But I'm warning that the number of edges is a lower bound for what we actually need in practice.)</p>



<a name="238645229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238645229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238645229">(May 13 2021 at 16:29)</a>:</h4>
<p>Probably way too many, that's why i'm suggesting to add them lazily, but how many are actually used in proofs? It cannot be that much longer than the number of proofs, or is it?</p>



<a name="238645483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238645483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238645483">(May 13 2021 at 16:31)</a>:</h4>
<p>How many proofs do you think there are in mathlib <span aria-label="shock" class="emoji emoji-1f628" role="img" title="shock">:shock:</span></p>



<a name="238645614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238645614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238645614">(May 13 2021 at 16:32)</a>:</h4>
<p>probably a huge number... If you write a proof does it take a big fraction of your time writing the proof to add those conversions? if not already existing</p>



<a name="238645670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238645670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238645670">(May 13 2021 at 16:32)</a>:</h4>
<p>We currently have  54576 theorems in mathlib and a bit more than 6000 instances.</p>



<a name="238645822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238645822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238645822">(May 13 2021 at 16:34)</a>:</h4>
<p>Adding those explicit conversions would impact readability of <em>statements</em> (and proofs) massively. Lots of statements that now show the essence of the theorem in 1 line, would suddenly become several lines long, and hide the essence somewhere in the middle.</p>



<a name="238645873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238645873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238645873">(May 13 2021 at 16:34)</a>:</h4>
<p>Proofs would become a lot more painful.</p>



<a name="238645983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238645983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238645983">(May 13 2021 at 16:35)</a>:</h4>
<p>Anyway, I think the best way to find out that you replicate mathlibs algebraic hierarchy in a way that doesn't use typeclasses.</p>



<a name="238646285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238646285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238646285">(May 13 2021 at 16:37)</a>:</h4>
<p>Yes later I want to try to make a small dissenting mathlib to see how it feels. I'm not completely convinced by my approach either, it would be an interesting experiment, if it wasn't done in that past.</p>



<a name="238646446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238646446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238646446">(May 13 2021 at 16:39)</a>:</h4>
<p>No! You shouldn't make it small.</p>



<a name="238646462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238646462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238646462">(May 13 2021 at 16:39)</a>:</h4>
<p>As Jannis pointed out, for small examples your approach works fine.</p>



<a name="238646583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238646583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238646583">(May 13 2021 at 16:40)</a>:</h4>
<p>I would think you want a hierarchy with a couple of hundred non-trivial edges, at least.</p>



<a name="238646631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238646631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238646631">(May 13 2021 at 16:40)</a>:</h4>
<p>The 6000 instances that I quoted above are ones that are not auto-generated.</p>



<a name="238646652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238646652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238646652">(May 13 2021 at 16:40)</a>:</h4>
<p>In reality there are many more.</p>



<a name="238646825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238646825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238646825">(May 13 2021 at 16:42)</a>:</h4>
<p>I have the feeling conversions could be done more cleanly with where clauses. But where does not seem very flexible in lean currently</p>



<a name="238647123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238647123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238647123">(May 13 2021 at 16:44)</a>:</h4>
<p>Now that I think about it, perhaps the explicit style I'm suggesting could be automatically generated from the current math lib? It feels possible</p>



<a name="238647124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238647124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238647124">(May 13 2021 at 16:44)</a>:</h4>
<p>It would be really great if there was a prolog-like database that knew about a whole bunch of such conversions, and a bit of automation that would query the prolog-like database to automatically chain them together, and construct those where clauses whenever needed.</p>



<a name="238647258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238647258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238647258">(May 13 2021 at 16:45)</a>:</h4>
<p>It would be nice to convert the whole mathlib to typeclass-less mathlibs in different styles manipulating the AST.</p>



<a name="238647342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238647342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238647342">(May 13 2021 at 16:46)</a>:</h4>
<p>just to see what we get</p>



<a name="238648178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238648178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Jam <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238648178">(May 13 2021 at 16:52)</a>:</h4>
<p>I'm not sure about the prolog like database. It feels too much like typeclasses. I want to keep explicitness</p>



<a name="238650936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238650936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238650936">(May 13 2021 at 17:12)</a>:</h4>
<p>I think it's great to ask questions like this (even though I am convinced typeclasses provide far, far more value than they cost). I think a cheap way to get some sense of what they're doing for us is just to use <code>set_option pp.implicit true</code> and look at the results.</p>



<a name="238651079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238651079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238651079">(May 13 2021 at 17:13)</a>:</h4>
<p>To take a concrete example, I just randomly picked the file <code>abel_ruffini.lean</code>, inserted <code>set_option pp.implicit true</code> at the top of the file and navigated to <a href="https://github.com/leanprover-community/mathlib/blob/c5faeade6bc667a77c0c91961da3dbefb96671d6/src/field_theory/abel_ruffini.lean#L82">this line</a> in VS code.</p>



<a name="238651214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238651214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238651214">(May 13 2021 at 17:14)</a>:</h4>
<p>This shows allows me to see what the hypothesis <code>hq : is_solvable (q.map (algebra_map F p.splitting_field)).gal</code>  looks like with all the implicit parameters filled in. Here's what you get:</p>



<a name="238651226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238651226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238651226">(May 13 2021 at 17:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">is_solvable</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">map</span> <span class="n">F</span> <span class="n">p.splitting_field</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring</span> <span class="n">F</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="n">F</span> <span class="n">_inst_1</span><span class="o">))))</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">p.splitting_field</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring</span> <span class="n">p.splitting_field</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="n">p.splitting_field</span> <span class="o">(</span><span class="bp">@</span><span class="n">splitting_field.field</span> <span class="n">F</span> <span class="n">_inst_1</span> <span class="n">p</span><span class="o">))))</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">p.splitting_field</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="n">F</span> <span class="n">_inst_1</span><span class="o">)))</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">p.splitting_field</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring</span> <span class="n">p.splitting_field</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="n">p.splitting_field</span> <span class="o">(</span><span class="bp">@</span><span class="n">splitting_field.field</span> <span class="n">F</span> <span class="n">_inst_1</span> <span class="n">p</span><span class="o">))))</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">splitting_field.algebra</span> <span class="n">F</span> <span class="n">_inst_1</span> <span class="n">p</span><span class="o">))</span>
     <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">gal</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">gal.group</span> <span class="n">p.splitting_field</span> <span class="o">(</span><span class="bp">@</span><span class="n">splitting_field.field</span> <span class="n">F</span> <span class="n">_inst_1</span> <span class="n">p</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">map</span> <span class="n">F</span> <span class="n">p.splitting_field</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring</span> <span class="n">F</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="n">F</span> <span class="n">_inst_1</span><span class="o">))))</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">p.splitting_field</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring</span> <span class="n">p.splitting_field</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="n">p.splitting_field</span> <span class="o">(</span><span class="bp">@</span><span class="n">splitting_field.field</span> <span class="n">F</span> <span class="n">_inst_1</span> <span class="n">p</span><span class="o">))))</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">p.splitting_field</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="n">F</span> <span class="n">_inst_1</span><span class="o">)))</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">p.splitting_field</span>
              <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring</span> <span class="n">p.splitting_field</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="n">p.splitting_field</span> <span class="o">(</span><span class="bp">@</span><span class="n">splitting_field.field</span> <span class="n">F</span> <span class="n">_inst_1</span> <span class="n">p</span><span class="o">))))</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">splitting_field.algebra</span> <span class="n">F</span> <span class="n">_inst_1</span> <span class="n">p</span><span class="o">))</span>
        <span class="n">q</span><span class="o">))</span>
</code></pre></div>



<a name="238651532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238651532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238651532">(May 13 2021 at 17:16)</a>:</h4>
<p>Notwithstanding the fact that the formalisation of Abel-Ruffini is an absolutely amazing achievement, this is still very elementary mathematics and already look at how large the term with implicit parameters displayed is.</p>



<a name="238653847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238653847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238653847">(May 13 2021 at 17:34)</a>:</h4>
<p><span class="user-mention" data-user-id="403214">@Michael Jam</span> Another reason why I think typeclasses are really great: they allow us to use the notation <code>x + y</code> in lots of different contexts. Whether <code>x</code> and <code>y</code> are integers, real numbers, elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mn>37</mn><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z/37\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/37</span><span class="mord mathbb">Z</span></span></span></span> or live in some abstract vector space.<br>
I think this is very important.</p>



<a name="238659152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238659152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238659152">(May 13 2021 at 18:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F/near/238647124">said</a>:</p>
<blockquote>
<p>It would be really great if there was a prolog-like database that knew about a whole bunch of such conversions, and a bit of automation that would query the prolog-like database to automatically chain them together, and construct those where clauses whenever needed.</p>
</blockquote>
<p>I see what you did there...</p>



<a name="238659775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238659775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238659775">(May 13 2021 at 18:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="240862">Oliver Nash</span> <a href="#narrow/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F/near/238651532">said</a>:</p>
<blockquote>
<p>Notwithstanding the fact that the formalisation of Abel-Ruffini is an absolutely amazing achievement, this is still very elementary mathematics and already look at how large the term with implicit parameters displayed is.</p>
</blockquote>
<p>I have mixed feelings about arguments of this form. While it's true that if you look at the terms that lean produces using typeclass inference that it would be hell to write that yourself, this isn't really a fair comparison because in the alternate world you would have short names for the relevant transitive instances. As Patrick alluded to, Metamath does things a little bit differently, and it basically boils down to having shortcut instances for common paths and using the lemma once per proof. When proofs are long this is a reasonable option since it is a small fraction of the full proof, but it is not incompatible with a prolog like proof search for these lemmas.</p>



<a name="238659957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238659957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238659957">(May 13 2021 at 18:23)</a>:</h4>
<p>Ultimately, the reason lean and mathlib use typeclasses so extensively is because lean was literally designed to use typeclasses as the hammer to solve every problem. It has a huge home field advantage compared to alternatives that are more verbose and less automatic.</p>



<a name="238695147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238695147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238695147">(May 13 2021 at 23:15)</a>:</h4>
<p>I'm not sure I know of a language that does this, but it might be interesting to explore resolving typeclasses by using a distance metric rather than priorities.  The idea would be rather than requiring programmers to pick a priority for the class (and higher priorities are chosen first), you assign a cost to using the class.  This would encourage the solver to take advantage of instances that provide path compression without requiring users to explicitly assign a global priority to each instance.</p>



<a name="238715267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Why%20does%20mathlib%20use%20typeclasses%20everywhere%3F/near/238715267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Why.20does.20mathlib.20use.20typeclasses.20everywhere.3F.html#238715267">(May 14 2021 at 03:56)</a>:</h4>
<p>Ooh, that sounds quite interesting. Using Dijkstra on the hierarchy (-;</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
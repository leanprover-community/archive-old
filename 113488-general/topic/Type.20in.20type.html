---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Type.20in.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html">Type in type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="233041033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233041033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233041033">(Apr 03 2021 at 23:34)</a>:</h4>
<p>My son tells me that the type of type is type in python. I asked him if nat was equal to int in python and he said there wasn't a nat, but that int == string was false. I told him that if the type of type was type then he could probably prove that false was equal to true anyway. But I don't know the proof in lean. How do I prove false from Type : Type? This is Giraud's paradox right?</p>



<a name="233041275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233041275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233041275">(Apr 03 2021 at 23:39)</a>:</h4>
<p>Yes this is girard's paradox. It's a little hard to construct in lean because <code>Type : Type</code> doesn't typecheck</p>



<a name="233041362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233041362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233041362">(Apr 03 2021 at 23:41)</a>:</h4>
<p>I don't know any very easy proof. The usual proof is to construct something equivalent to ordinals and run the burali-forti paradox on the result</p>



<a name="233041430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233041430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233041430">(Apr 03 2021 at 23:42)</a>:</h4>
<p>I found <a href="http://www.cs.cmu.edu/~kw/research/hurkens95tlca.elf">http://www.cs.cmu.edu/~kw/research/hurkens95tlca.elf</a>, although you have to read LF to follow it</p>



<a name="233043047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233043047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233043047">(Apr 04 2021 at 00:14)</a>:</h4>
<p>(Things in Python get quite fun when you also consider <code>type</code> is an instance (== term) and subclass of <code>object</code>, and <code>object</code> is an instance of <code>type</code>)</p>



<a name="233043293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233043293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233043293">(Apr 04 2021 at 00:20)</a>:</h4>
<p>If there were a <code>nat</code> in python though, it would not be equal to <code>int</code>. (E.g. there's a rational number type, and it's not equal to <code>int</code>.) In general the default in Python is objects compare for equality by identity by default, and it'd be silly to consider <code>int</code> and rational (or nat) equal to each other under the language semantics, there wouldn't be a reason to.</p>



<a name="233043424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233043424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233043424">(Apr 04 2021 at 00:22)</a>:</h4>
<p>We have an abstract base class (== gross version of a typeclass) that is the base of the number hierarchy: <a href="https://docs.python.org/3/library/numbers.html#numbers.Number">https://docs.python.org/3/library/numbers.html#numbers.Number</a> -- so you are free to do <code>class Natural(numbers.Number)</code> if you truly felt like it.</p>



<a name="233044380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233044380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233044380">(Apr 04 2021 at 00:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kd">noncomputable theory</span>
<span class="kd">constant</span> <span class="n">pi</span> <span class="o">:</span> <span class="o">(</span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">lam</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">pi</span> <span class="n">A</span>
<span class="kd">constant</span> <span class="n">app</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">pi</span> <span class="n">A</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span>
<span class="kd">@[simp]</span> <span class="kd">axiom</span> <span class="n">beta</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">app</span> <span class="o">(</span><span class="n">lam</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">pi</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">app</span><span class="o">⟩</span>

<span class="kn">namespace</span> <span class="n">girard</span>

<span class="kd">def</span> <span class="n">univ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">pi</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">τ</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">univ</span><span class="o">))</span> <span class="o">:</span> <span class="n">univ</span> <span class="o">:=</span>
<span class="n">lam</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">f</span><span class="o">,</span> <span class="o">{</span><span class="n">p</span> <span class="bp">|</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">univ</span> <span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">app</span> <span class="n">x</span> <span class="n">_</span> <span class="n">f</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">p</span><span class="o">}</span> <span class="bp">∈</span> <span class="n">T</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">σ</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">univ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">univ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">app</span> <span class="n">S</span> <span class="n">_</span> <span class="n">τ</span>

<span class="kd">@[simp]</span> <span class="kd">theorem</span> <span class="n">τ_σ_def</span> <span class="o">(</span><span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">σ</span> <span class="o">(</span><span class="n">τ</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">univ</span> <span class="bp">|</span> <span class="n">τ</span> <span class="o">(</span><span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="bp">∈</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">σ</span><span class="o">,</span> <span class="n">τ</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">paradox</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="k">let</span> <span class="n">ω</span> <span class="o">:</span> <span class="n">univ</span> <span class="o">:=</span> <span class="n">τ</span> <span class="o">{</span><span class="n">p</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">univ</span><span class="o">,</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">σ</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">p</span><span class="o">},</span>
  <span class="k">let</span> <span class="n">δ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">univ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">set</span> <span class="n">univ</span><span class="o">,</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">σ</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">τ</span> <span class="o">(</span><span class="n">σ</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">p</span><span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">σ</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">p</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ω</span> <span class="bp">∈</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">d</span><span class="o">,</span> <span class="n">d</span> <span class="n">ω</span> <span class="n">_</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">ω</span><span class="o">],</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">d</span> <span class="o">(</span><span class="n">τ</span> <span class="o">(</span><span class="n">σ</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">this</span> <span class="n">δ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">e</span> <span class="n">f</span><span class="o">,</span> <span class="n">f</span> <span class="n">δ</span> <span class="n">e</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">f</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">τ</span> <span class="o">(</span><span class="n">σ</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">p</span><span class="o">}</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">τ_σ_def</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="o">{</span><span class="n">y</span> <span class="bp">|</span> <span class="n">τ</span> <span class="o">(</span><span class="n">σ</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">p</span><span class="o">}</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">ω</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">girard</span>
</code></pre></div>



<a name="233044415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233044415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233044415">(Apr 04 2021 at 00:45)</a>:</h4>
<p>I can't honestly say I understand the proof, but it typechecks</p>



<a name="233047498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233047498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233047498">(Apr 04 2021 at 01:45)</a>:</h4>
<p>Here's one way you can do this in Lean without new constants: We can show that Type isn't small, ie it's not possible for a type to be equivalent to Type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.small</span>

<span class="kd">lemma</span> <span class="n">cast_helper</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">yx</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">cast</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">A</span> <span class="n">yx</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">subst</span> <span class="n">yx</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">no_type_in_type</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">small.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">introI</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">pi</span> <span class="o">:</span> <span class="o">(</span><span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">shrink</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">f</span> <span class="o">((</span><span class="n">equiv_shrink</span> <span class="kt">Type</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">y</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">lam</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">pi</span> <span class="n">A</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">p</span> <span class="n">t</span><span class="o">,</span> <span class="n">p</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">app</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span><span class="o">},</span> <span class="n">pi</span> <span class="n">A</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">A</span> <span class="n">p</span> <span class="n">t</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">eq.mpr</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">A</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">(</span><span class="n">equiv_shrink</span> <span class="kt">Type</span> <span class="n">t</span><span class="o">)),</span>
    <span class="n">apply</span> <span class="o">((</span><span class="n">equiv_shrink</span> <span class="kt">Type</span><span class="o">)</span><span class="bp">.</span><span class="n">left_inv</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">beta</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">app</span> <span class="o">(</span><span class="n">lam</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">A</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">cast</span> <span class="n">_</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">cast_helper</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">},</span>

  <span class="c1">-- insert Mario's proof here</span>
<span class="kd">end</span>
</code></pre></div>
<p>From here the environment has the constants and axioms in Mario's proof and that should then go through</p>



<a name="233047557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233047557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233047557">(Apr 04 2021 at 01:46)</a>:</h4>
<p>And in contrast we have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">type_in_type_one</span> <span class="o">:</span> <span class="n">small.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">small_self</span> <span class="kt">Type</span>
</code></pre></div>



<a name="233047695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233047695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233047695">(Apr 04 2021 at 01:49)</a>:</h4>
<p>I added this in <a href="https://github.com/leanprover-community/mathlib/issues/7026">#7026</a>, using a structure for the axioms so that we don't have to add false axioms to mathlib</p>



<a name="233066659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233066659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233066659">(Apr 04 2021 at 08:36)</a>:</h4>
<p>This is great -- thanks to both of you. I've seen Girard's paradox mentioned a few times but the references I've seen usually just mention that it's some kind of standard diagonal argument without giving further details.</p>



<a name="233070556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233070556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233070556">(Apr 04 2021 at 10:04)</a>:</h4>
<p>Here's a simple (?) argument. Any  <code>α : Type</code> embeds in the type <code>K := Σ α : Type, α</code> of pointed types via <code>a =&gt; (_, a)</code>. This is injective by UIP. If <code>Type</code> itself is small, then so is <code>K</code>. So <code>set K</code> embeds in <code>K</code>, contradicting Cantor</p>



<a name="233135170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233135170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233135170">(Apr 05 2021 at 04:16)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span> Actually I've been thinking about how to prove this by cantor for a while, it's surprisingly tricky. In particular, I don't think Girard follows directly from Cantor, and Bhavik's statement about smallness of <code>Type</code> might be provable by cantor but I haven't found a way yet. I don't think this proof works, because the assumptions aren't enough to know that <code>K</code> exists with the required properties. (It might be, if you actually change the type theory so that <code>K : Type</code>, but with only Bhavik's bijection assumption I don't think this is enough.) In particular, "If <code>Type</code> itself is small, then so is <code>K</code>" is intuitively obvious but has no easy proof</p>



<a name="233135451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233135451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233135451">(Apr 05 2021 at 04:22)</a>:</h4>
<p>In set theory, this is relatively straightforward, since the equivalent of <code>Type</code> will be a universe which is a superset of any of its members, so one can conclude <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">K\subseteq U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>∈</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">K\in U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> and hence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> is larger than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>. But type theory universes are not transitive sets, and so there might be only a few types that are themselves quite large. In lean, we know the set of types has to be at least as large as the set of all cardinals, which we know is large using some of Cantor's other observations, but I think a proof along these lines boils down to the burali-forti paradox so probably isn't any simpler than <code>girard.paradox</code> above</p>



<a name="233136265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233136265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233136265">(Apr 05 2021 at 04:39)</a>:</h4>
<p>actually, nevermind, that proof actually does go through</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">not_small_type</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">⟨⟨</span><span class="n">S</span><span class="o">,</span> <span class="o">⟨</span><span class="n">e</span><span class="o">⟩⟩⟩</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">K</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="n">α</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">e.symm</span> <span class="n">α</span> <span class="k">in</span>
  <span class="bp">@</span><span class="n">function.cantor_injective</span> <span class="n">K</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">⟨</span><span class="n">e</span> <span class="o">(</span><span class="n">set</span> <span class="n">K</span><span class="o">),</span> <span class="n">cast</span> <span class="o">(</span><span class="n">e.3</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a</span><span class="o">⟩)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">e</span><span class="o">,</span> <span class="o">(</span><span class="n">cast_inj</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">$</span> <span class="n">eq_of_heq</span> <span class="o">(</span><span class="n">sigma.mk.inj</span> <span class="n">e</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>



<a name="233137731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233137731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233137731">(Apr 05 2021 at 05:09)</a>:</h4>
<p>Very nice!</p>
<p>Golfed slightly from there, and with the last line made perhaps a bit clearer:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">not_small_type</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">⟨⟨</span><span class="n">S</span><span class="o">,</span> <span class="o">⟨</span><span class="n">e</span><span class="o">⟩⟩⟩</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">K</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="n">α</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">e.symm</span> <span class="n">α</span> <span class="k">in</span>
  <span class="bp">@</span><span class="n">function.cantor_injective</span> <span class="n">K</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">cast</span> <span class="o">(</span><span class="n">e.left_inv</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a</span><span class="o">⟩)</span>
    <span class="o">(</span><span class="n">sigma_mk_injective.comp</span> <span class="bp">$</span> <span class="o">(</span><span class="n">cast_bijective</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">injective</span><span class="o">)</span>
</code></pre></div>



<a name="233138645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233138645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Greg Price <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233138645">(Apr 05 2021 at 05:28)</a>:</h4>
<p>Or for such a nice proof, perhaps it's worth letting it stretch out a bit and giving a few more labels to things, in the interest of making it easy to see what's happening. Here's a version in that direction:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">not_small_type</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="o">⟨⟨(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">),</span> <span class="o">⟨(</span><span class="n">repr</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="bp">≃</span> <span class="n">S</span><span class="o">)⟩⟩⟩,</span>
<span class="k">let</span> <span class="n">K</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="n">α</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">repr.symm</span> <span class="n">α</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">sK</span> <span class="o">:=</span> <span class="n">repr</span> <span class="o">(</span><span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="k">in</span>
<span class="n">function.cantor_injective</span>
  <span class="o">(</span><span class="n">sigma.mk</span> <span class="n">sK</span> <span class="bp">∘</span> <span class="n">cast</span> <span class="o">(</span><span class="n">repr.left_inv</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span>
  <span class="o">(</span><span class="n">sigma_mk_injective.comp</span> <span class="o">(</span><span class="n">cast_bijective</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">injective</span><span class="o">)</span>
</code></pre></div>



<a name="233138684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233138684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233138684">(Apr 05 2021 at 05:29)</a>:</h4>
<p>There's another version of this on the Girard PR btw</p>



<a name="233149615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233149615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233149615">(Apr 05 2021 at 08:34)</a>:</h4>
<p>Nice! Here's another version, using some lemmas not yet in <code>small.lean</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.small</span>
<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">instance</span> <span class="n">small.sigma</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨⟨</span><span class="bp">Σ</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">shrink</span> <span class="n">α</span><span class="o">,</span> <span class="n">shrink</span> <span class="o">(</span><span class="n">β</span> <span class="o">((</span><span class="n">equiv_shrink</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a'</span><span class="o">)),</span>
  <span class="o">⟨</span><span class="n">equiv.sigma_congr</span> <span class="o">(</span><span class="n">equiv_shrink</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">equiv_shrink</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">))⟩⟩⟩</span>

<span class="kd">instance</span> <span class="n">small.set</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨⟨</span><span class="n">set</span> <span class="o">(</span><span class="n">shrink</span> <span class="n">α</span><span class="o">),</span> <span class="o">⟨</span><span class="n">equiv.set.congr</span> <span class="o">(</span><span class="n">equiv_shrink</span> <span class="n">α</span><span class="o">)⟩⟩⟩</span>

<span class="kd">theorem</span> <span class="n">not_small_type</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">introI</span><span class="o">,</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">function.cantor_injective</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">equiv_shrink</span> <span class="n">_</span> <span class="n">x</span><span class="o">⟩),</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="o">}</span>
</code></pre></div>



<a name="233160042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233160042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233160042">(Apr 05 2021 at 11:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> <a href="#narrow/stream/113488-general/topic/Type.20in.20type/near/233149615">said</a>:</p>
<blockquote>
<p>Nice! Here's another version, using some lemmas not yet in <code>small.lean</code></p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.small</span>
<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">instance</span> <span class="n">small.sigma</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨⟨</span><span class="bp">Σ</span> <span class="n">a'</span> <span class="o">:</span> <span class="n">shrink</span> <span class="n">α</span><span class="o">,</span> <span class="n">shrink</span> <span class="o">(</span><span class="n">β</span> <span class="o">((</span><span class="n">equiv_shrink</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">a'</span><span class="o">)),</span>
  <span class="o">⟨</span><span class="n">equiv.sigma_congr</span> <span class="o">(</span><span class="n">equiv_shrink</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">equiv_shrink</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">))⟩⟩⟩</span>

<span class="kd">instance</span> <span class="n">small.set</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨⟨</span><span class="n">set</span> <span class="o">(</span><span class="n">shrink</span> <span class="n">α</span><span class="o">),</span> <span class="o">⟨</span><span class="n">equiv.set.congr</span> <span class="o">(</span><span class="n">equiv_shrink</span> <span class="n">α</span><span class="o">)⟩⟩⟩</span>

<span class="kd">theorem</span> <span class="n">not_small_type</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">small.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">introI</span><span class="o">,</span> <span class="n">apply</span> <span class="bp">@</span><span class="n">function.cantor_injective</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">equiv_shrink</span> <span class="n">_</span> <span class="n">x</span><span class="o">⟩),</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="o">}</span>
</code></pre></div><br>
</p>
</blockquote>
<p>If these first two aren't in small.lean I think they're worth a PR</p>



<a name="233164389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20in%20type/near/233164389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20in.20type.html#233164389">(Apr 05 2021 at 12:15)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7042">#7042</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
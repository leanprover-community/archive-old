---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html">what is the name of +?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="210864616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210864616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210864616">(Sep 22 2020 at 12:48)</a>:</h4>
<p>For the sake of demonstration I would like to simplify expressions involving +, eg.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">add</span><span class="o">]</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>

<p>but this doesn't work How do I refer to add? It is defined in init.core</p>



<a name="210864856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210864856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210864856">(Sep 22 2020 at 12:51)</a>:</h4>
<p><code>has_add.add</code></p>



<a name="210864859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210864859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210864859">(Sep 22 2020 at 12:51)</a>:</h4>
<p><code>has_add.add</code>, or more conveniently <code>(+)</code></p>



<a name="210866019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210866019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210866019">(Sep 22 2020 at 13:00)</a>:</h4>
<p>Hmm,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">has_add.add</span><span class="o">],</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>

<p>doesn't work for me (it doesn't reduce). But</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[(</span><span class="bp">+</span><span class="o">),</span><span class="n">nat.add</span><span class="o">],</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>

<p>does work.</p>



<a name="210866180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210866180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Carl Friedrich Bolz-Tereick <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210866180">(Sep 22 2020 at 13:01)</a>:</h4>
<p>typo, maybe?: <code>has_add.add</code> (not <code>,</code>)</p>



<a name="210866213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210866213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210866213">(Sep 22 2020 at 13:01)</a>:</h4>
<p>And <code>,</code> at the end of the line</p>



<a name="210866448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210866448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Carl Friedrich Bolz-Tereick <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210866448">(Sep 22 2020 at 13:03)</a>:</h4>
<p>conservation of punctuation ;-)</p>



<a name="210871580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210871580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210871580">(Sep 22 2020 at 13:46)</a>:</h4>
<p>Also, don't unfold definitions!</p>



<a name="210881638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210881638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210881638">(Sep 22 2020 at 14:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/210871580">said</a>:</p>
<blockquote>
<p>Also, don't unfold definitions!</p>
</blockquote>
<p>How do you explain your students what is going on if you don't reduce definitions?</p>



<a name="210882001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210882001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210882001">(Sep 22 2020 at 14:57)</a>:</h4>
<p>You can just tell them that it's defined recursively, so it comes with two "axioms" m + 0 = m and m + (n + 1) = (m + n) + 1</p>



<a name="210884057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210884057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210884057">(Sep 22 2020 at 15:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271218">Thorsten Altenkirch</span> <a href="#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/210881638">said</a>:</p>
<blockquote>
<p>How do you explain your students what is going on if you don't reduce definitions?</p>
</blockquote>
<p>fwiw you can see (and use) the unfolded forms without actually unfolding it by printing the definition's prefix. The output of<code>#print prefix nat.add</code> will include the lemmas : </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">nat.add.equations._eqn_1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a.add</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">nat.add.equations._eqn_2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">a.add</span> <span class="n">b.succ</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a.add</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span>
</code></pre></div>



<a name="210884082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210884082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210884082">(Sep 22 2020 at 15:08)</a>:</h4>
<p>But I don't even have to apply these "axioms" which are actually just the definition.</p>



<a name="210888973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210888973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210888973">(Sep 22 2020 at 15:39)</a>:</h4>
<p>This is what I mentioned <a href="#narrow/stream/113489-new-members/topic/band.2C.20bor/near/210763945">earlier</a> about lean automatically generating a basic API for every definition. Please don't use defeq if you can avoid it. Yes you can prove these by refl but that's bad practice because it makes your proof sensitive to the definition</p>



<a name="210889675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210889675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210889675">(Sep 22 2020 at 15:44)</a>:</h4>
<p>and to stress: these equation lemmas are not always true by refl. They are for simple structural recursions but there are definitions you can write where refl doesn't work</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">log2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span>
    <span class="k">have</span> <span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">nat.div_lt_self</span> <span class="n">h</span> <span class="n">dec_trivial</span><span class="o">,</span>
    <span class="n">log2</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="k">else</span> <span class="mi">0</span>

<span class="k">#print</span> <span class="n">log2.equations._eqn_1</span>
<span class="c1">-- theorem log2.equations._eqn_1 : ∀ (n : ℕ), log2 n = ite (0 &lt; n) (log2 (n / 2) + 1) 0 :=</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">log2</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">ite</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">log2</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="210890164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210890164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210890164">(Sep 22 2020 at 15:48)</a>:</h4>
<p>If you actually really want to see the definition you will get something impenetrable for a beginner</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">log2</span> <span class="bp">=</span> <span class="n">has_well_founded.wf.fix</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
    <span class="n">id_rhs</span> <span class="o">((</span><span class="bp">Π</span> <span class="o">(</span><span class="n">_y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">has_well_founded.r</span> <span class="n">_y</span> <span class="n">_x</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_F</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">_y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">has_well_founded.r</span> <span class="n">_y</span> <span class="n">_x</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">),</span>
        <span class="n">dite</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">_x</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">_x</span><span class="o">),</span>
            <span class="k">have</span> <span class="n">this</span> <span class="o">:</span> <span class="n">_x</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">_x</span><span class="o">,</span> <span class="k">from</span> <span class="n">nat.div_lt_self</span> <span class="n">h</span> <span class="n">dec_trivial</span><span class="o">,</span>
            <span class="n">_F</span> <span class="o">(</span><span class="n">_x</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="n">this</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
          <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">_x</span><span class="o">),</span> <span class="mi">0</span><span class="o">)))</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="210890325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210890325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210890325">(Sep 22 2020 at 15:49)</a>:</h4>
<p>the whole point of equation lemmas is so that the equation compiler is allowed to generate these horrendous terms without them getting in the way of proving simple properties about the definition</p>



<a name="210891006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210891006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210891006">(Sep 22 2020 at 15:54)</a>:</h4>
<p>Ok, I can see your point. However, <code>nat.add.equations._eqn_1 </code> is quite a mouth full compared to <code>refl</code>.</p>



<a name="210891083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210891083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210891083">(Sep 22 2020 at 15:54)</a>:</h4>
<p>that's why you write <code>rw nat.add</code> instead</p>



<a name="210891139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210891139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210891139">(Sep 22 2020 at 15:55)</a>:</h4>
<p>Certainly when using well founded recursion you don't want to use the actual definition.</p>



<a name="210891155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210891155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210891155">(Sep 22 2020 at 15:55)</a>:</h4>
<p>when you use the name of a definition directly in <code>rw</code>, it means "rewrite with one of the equation lemmas for the definition"</p>



<a name="210891291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210891291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210891291">(Sep 22 2020 at 15:56)</a>:</h4>
<p>Even for structural recursions the compilation is not at all what you would expect, and I don't think we want to guarantee the equation lemmas are defeq although they generally are</p>



<a name="210891910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210891910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210891910">(Sep 22 2020 at 16:00)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">add</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">a_1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="n">nat.brec_on</span> <span class="n">a_1</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">_F</span> <span class="o">:</span> <span class="n">nat.below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">a_1</span><span class="o">),</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">_F</span> <span class="o">:</span> <span class="n">nat.below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">a_1</span><span class="o">),</span>
          <span class="bp">@</span><span class="n">nat.cases_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">nat.below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">a_1</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_F</span> <span class="o">:</span> <span class="n">nat.below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span><span class="o">)</span> <span class="mi">0</span><span class="o">),</span> <span class="n">id_rhs</span> <span class="n">ℕ</span> <span class="n">a</span><span class="o">)</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a_1</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">_F</span> <span class="o">:</span> <span class="n">nat.below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">a_1</span><span class="o">)),</span> <span class="n">id_rhs</span> <span class="n">ℕ</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">_F.fst.fst</span><span class="o">))</span>
            <span class="n">_F</span><span class="o">)</span>
         <span class="n">a_1</span>
         <span class="n">_F</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">delta</span> <span class="n">add</span> <span class="n">add._main</span><span class="bp">;</span> <span class="n">refl</span>
</code></pre></div>

<p>In this case I can't even use <code>rfl</code> to prove it because the definition <code>add._main</code> is marked irreducible. Lean is really strongly trying to encourage you not to do this</p>



<a name="210892078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892078">(Sep 22 2020 at 16:01)</a>:</h4>
<p>Ok, just tried it. Here is the <em>bad</em> proof with <code>refl</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">add_succ_lem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n'</span> <span class="n">ih</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">congr_arg</span> <span class="n">succ</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">ih</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">,</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span> <span class="n">m'</span> <span class="n">ih</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">lneutr</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="n">succ</span> <span class="n">m'</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m'</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">add_succ_lem</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m'</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">congr_arg</span> <span class="n">succ</span> <span class="n">ih</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">m'</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>

<p>but if I replace <code>refl</code> as you suggest:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">,</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span> <span class="n">m'</span> <span class="n">ih</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">lneutr</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="n">succ</span> <span class="n">m'</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m'</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">add_succ_lem</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m'</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">congr_arg</span> <span class="n">succ</span> <span class="n">ih</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">m'</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rewrite</span> <span class="n">nat.add</span>
<span class="kd">end</span>
</code></pre></div>

<p>It doesn't work?</p>



<a name="210892196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892196">(Sep 22 2020 at 16:01)</a>:</h4>
<p>By the way, <code>delta</code> is a tactic which unfolds anything along the primitive delta reduction. You usually don't want to do this for equation compiler definitions because the result is big and scary as you can see</p>



<a name="210892324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892324">(Sep 22 2020 at 16:02)</a>:</h4>
<p>um can you <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> that example?</p>



<a name="210892342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892342">(Sep 22 2020 at 16:02)</a>:</h4>
<p>what's <code>lneutr</code></p>



<a name="210892428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892428">(Sep 22 2020 at 16:03)</a>:</h4>
<p>sorry <a href="/user_uploads/3121/LSJWBMWWL8aFppvFVtlwO_dj/nat.lean">nat.lean</a></p>



<a name="210892476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892476">(Sep 22 2020 at 16:03)</a>:</h4>
<p>eh, code blocks are better than uploads</p>



<a name="210892577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892577">(Sep 22 2020 at 16:04)</a>:</h4>
<p>also I assume the example is just missing one theorem, so you don't need the whole file</p>



<a name="210892593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892593">(Sep 22 2020 at 16:04)</a>:</h4>
<p>that's the M in <a href="https://leanprover-community.github.io/mwe.html">#mwe</a></p>



<a name="210892628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892628">(Sep 22 2020 at 16:04)</a>:</h4>
<p>Yes, I forgot that I used lneutr.</p>



<a name="210892664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892664">(Sep 22 2020 at 16:04)</a>:</h4>
<p>Here's an mwe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">nat</span>
<span class="kd">lemma</span> <span class="n">add_succ_lem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">theorem</span> <span class="n">lneutr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">,</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span> <span class="n">m'</span> <span class="n">ih</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">lneutr</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="n">succ</span> <span class="n">m'</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m'</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">add_succ_lem</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m'</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">congr_arg</span> <span class="n">succ</span> <span class="n">ih</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">m'</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>



<a name="210892735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892735">(Sep 22 2020 at 16:05)</a>:</h4>
<p>Fair enough.</p>



<a name="210892854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892854">(Sep 22 2020 at 16:06)</a>:</h4>
<p>You can't just use <code>rw nat.add</code> here because you have to unfold <code>+</code> too</p>



<a name="210892890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892890">(Sep 22 2020 at 16:06)</a>:</h4>
<p>Usually we write manual equation lemmas in terms of <code>+</code> for this case</p>



<a name="210892916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210892916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210892916">(Sep 22 2020 at 16:06)</a>:</h4>
<p>but in this case you can first unfold + then nat.add:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">,</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span> <span class="n">m'</span> <span class="n">ih</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">lneutr</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="n">succ</span> <span class="n">m'</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m'</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">add_succ_lem</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m'</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">congr_arg</span> <span class="n">succ</span> <span class="n">ih</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">m'</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">dsimp</span> <span class="o">[(</span><span class="bp">+</span><span class="o">)]</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">nat.add</span>
<span class="kd">end</span>
</code></pre></div>



<a name="210893014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210893014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210893014">(Sep 22 2020 at 16:07)</a>:</h4>
<p>so the official way to do this would be to <code>rw add_succ</code></p>



<a name="210893069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210893069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210893069">(Sep 22 2020 at 16:08)</a>:</h4>
<p>where</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">add_succ</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="210893264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210893264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210893264">(Sep 22 2020 at 16:09)</a>:</h4>
<p>and yes you can argue that using rfl here is a double standard, but as long as it is sufficiently close to the definition you can consider it within the API barrier, like the proof of <code>add.equations._eqn_1</code> itself</p>



<a name="210893559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210893559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210893559">(Sep 22 2020 at 16:11)</a>:</h4>
<p>OK this is a good point (explicitly referring to definitions instead of refl). It is a shame that lean just copied the syntax declaration from Coq instead of agda whose mixfix definitions work much more smoothly.</p>



<a name="210893652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210893652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210893652">(Sep 22 2020 at 16:11)</a>:</h4>
<p>indeed, it is a bit unfortunate that <code>+</code> is considered a separate definition from <code>nat.add</code>, at least in these cases</p>



<a name="210893816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210893816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210893816">(Sep 22 2020 at 16:12)</a>:</h4>
<p>In other cases it is an advantage since it makes it easier to state generic theorems that match by typeclass inference, for example <code>add_assoc</code> which is a theorem about additive semigroups and unifies with the nat case</p>



<a name="210894370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/210894370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#210894370">(Sep 22 2020 at 16:16)</a>:</h4>
<p>I'm not familiar with agda. Does it have an analogue of <code>add_assoc</code> that works for natural numbers and also random other additive semigroups?</p>



<a name="211008028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211008028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211008028">(Sep 23 2020 at 14:06)</a>:</h4>
<p>Afaict the Agda stdlib has a structure ("record") for semigroups and an instance of that structure for naturals with addition. Not sure whether the thing is ready to use as a type class. The stdlib does not overload <code>+</code>, so <code>n + m</code> only works for naturals <code>n</code> and <code>m</code>. In general, the library is not really focused on mathematics, which shows in design decisions like this.</p>



<a name="211009227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211009227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211009227">(Sep 23 2020 at 14:14)</a>:</h4>
<p><span class="user-mention" data-user-id="271218">@Thorsten Altenkirch</span> if the price to pay for getting + to work the way you want it to is that you can't use + to add e.g. vectors in a vector space over an arbitrary field, that's not a price that mathematicians are going to be willing to pay.</p>



<a name="211031681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211031681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211031681">(Sep 23 2020 at 16:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211009227">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="271218">Thorsten Altenkirch</span> if the price to pay for getting + to work the way you want it to is that you can't use + to add e.g. vectors in a vector space over an arbitrary field, that's not a price that mathematicians are going to be willing to pay.</p>
</blockquote>
<p>Where did I suggest this?  I completely agree that mathematical conventions and notations should be reflected and rationalised in a system like Lean. Having said this not every notational convention is good, e.g. the use of variables in conventional Mathematics is often confusing.</p>



<a name="211031808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211031808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211031808">(Sep 23 2020 at 16:59)</a>:</h4>
<p>heh you know how to find interesting battles to pick</p>



<a name="211031916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211031916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211031916">(Sep 23 2020 at 17:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="256311">Jannis Limperg</span> <a href="#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211008028">said</a>:</p>
<blockquote>
<p>Afaict the Agda stdlib has a structure ("record") for semigroups and an instance of that structure for naturals with addition. Not sure whether the thing is ready to use as a type class. The stdlib does not overload <code>+</code>, so <code>n + m</code> only works for naturals <code>n</code> and <code>m</code>. In general, the library is not really focused on mathematics, which shows in design decisions like this.</p>
</blockquote>
<p>Indeed, agda has got a mechanism for instance arguments and this can be used to implement overloading. The standard library is quite old and should be refactored along those lines.</p>



<a name="211031979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211031979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211031979">(Sep 23 2020 at 17:01)</a>:</h4>
<p>lean 3 has a mechanism for overloading but it's not very good</p>



<a name="211032028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211032028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211032028">(Sep 23 2020 at 17:01)</a>:</h4>
<p>the notation typeclass approach scales better, at least with the current implementation</p>



<a name="211033403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211033403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211033403">(Sep 23 2020 at 17:11)</a>:</h4>
<p>Here is a description of Agda's mechanism: <a href="https://agda.readthedocs.io/en/v2.5.2/language/instance-arguments.html#instance-resolution">https://agda.readthedocs.io/en/v2.5.2/language/instance-arguments.html#instance-resolution</a><br>
It should be possible to design a library which better reflects Mathematical practice. Indeed, I think the use of mixfix notation is orthogonal and actually would help here.</p>



<a name="211034875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211034875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211034875">(Sep 23 2020 at 17:22)</a>:</h4>
<p>In many ways the syntax of lean seems antiquated to me, it seems influenced by Coq which already was cumbersome. For example the syntax of pattern matching is weird, why not writing the definitional equations you mean. Also I do think that a syntax which is aware of intention as it is available not only in Haskell but also in Python is preferable. I have already mentioned the Agda's mixfix syntax which is much more flexible and avoids the "notation" directives and the extra step to have to unfold notations.</p>



<a name="211035477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211035477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211035477">(Sep 23 2020 at 17:27)</a>:</h4>
<p>We all have our hopes up for Lean 4. It should be a lot better in this respect. (But I don't know enough to make a solid statement.)</p>



<a name="211045154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211045154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211045154">(Sep 23 2020 at 18:41)</a>:</h4>
<p>I think that agda has too many notations though, it makes things hard to read when they are overused</p>



<a name="211045218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211045218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211045218">(Sep 23 2020 at 18:41)</a>:</h4>
<p>In particular I don't think it is a good idea to have the only name of a certain operation be an unpronounceable symbol</p>



<a name="211045232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211045232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211045232">(Sep 23 2020 at 18:41)</a>:</h4>
<p>"the operator formerly known as bind"</p>



<a name="211045370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211045370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211045370">(Sep 23 2020 at 18:42)</a>:</h4>
<blockquote>
<p>For example the syntax of pattern matching is weird, why not writing the definitional equations you mean.</p>
</blockquote>
<p>Can you elaborate?</p>



<a name="211046064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211046064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211046064">(Sep 23 2020 at 18:48)</a>:</h4>
<p>probably the Haskell style <code>map f (x :: xs) = f x :: map f xs</code> rather than all the <code>|</code> stuff</p>



<a name="211046505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211046505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211046505">(Sep 23 2020 at 18:51)</a>:</h4>
<p>FWIW, as a long-time Haskell programmer (and GHC developer) and now Lean user, I find Agda's pattern matching syntax pretty difficult to understand, especially the <code>with</code> or whatever thing</p>



<a name="211046764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211046764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211046764">(Sep 23 2020 at 18:53)</a>:</h4>
<p>I wouldn't be opposed to sticking the name of the defined function left of the patterns</p>



<a name="211047140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211047140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211047140">(Sep 23 2020 at 18:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271218">Thorsten Altenkirch</span> <a href="#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211034875">said</a>:</p>
<blockquote>
<p>and the extra step to have to unfold notations.</p>
</blockquote>
<p>It's not the notation that causes the extra unfolding step (use of notation is equivalent to its definition in most contexts), it's the indirection through a type class.</p>



<a name="211056586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211056586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211056586">(Sep 23 2020 at 20:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="271218">Thorsten Altenkirch</span> <a href="#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211034875">said</a>:</p>
<blockquote>
<p>For example the syntax of pattern matching is weird, why not writing the definitional equations you mean</p>
</blockquote>
<p>I would find that quite misleading - pattern matching equations are <em>not</em> identical to the definitional equations of a function because of their sequential semantics. If I write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">not</span> <span class="n">True</span> <span class="bp">=</span> <span class="n">False</span>
<span class="n">not</span> <span class="n">b</span>    <span class="bp">=</span> <span class="n">True</span>
</code></pre></div>

<p>it doesn't follow that <code>not b = True</code>.</p>
<blockquote>
<p>Also I do think that a syntax which is aware of intention as it is available not only in Haskell but also in Python is preferable</p>
</blockquote>
<p>I am assuming you mean "indentation", though intention-aware syntax would be even better :) . We are embracing light indentation awareness in Lean 4 (in the sense that no one should accidentally be able to get it wrong), but full-on awareness a la Haskell has always struck me as far too controversial and confusing for beginners to copy. Indentation should help people, not hinder them.</p>



<a name="211056984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211056984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211056984">(Sep 23 2020 at 20:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211056586">said</a>:</p>
<blockquote>
<p>I would find that quite misleading - pattern matching equations are <em>not</em> identical to the definitional equations of a function because of their sequential semantics.</p>
</blockquote>
<p>Agda warns in this case (if an equation is not definitional) and has an option to forbid it outright.</p>



<a name="211057288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211057288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211057288">(Sep 23 2020 at 20:22)</a>:</h4>
<p>Then I'll gladly take the more concise syntax. Lean is trying to be a programming language as well after all.</p>



<a name="211059002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211059002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211059002">(Sep 23 2020 at 20:37)</a>:</h4>
<blockquote>
<p>We are embracing light indentation awareness in Lean 4 (in the sense that no one should accidentally be able to get it wrong)</p>
</blockquote>
<p>Could you elaborate? AFAIK in lean 3 the only indentation awareness is the relatively recent addition of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">file</span>
<span class="n">user_cmd</span>
</code></pre></div>

<p>vs</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">file</span>
 <span class="n">another_file</span>
</code></pre></div>



<a name="211059961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211059961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211059961">(Sep 23 2020 at 20:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211057288">said</a>:</p>
<blockquote>
<p>Then I'll gladly take the more concise syntax. Lean is trying to be a programming language as well after all.</p>
</blockquote>
<p>Oh yeah absolutely. I think Lean's pattern matching syntax is pretty much a straight upgrade over Agda's. No need to repeat a function name <code>n</code> times.</p>



<a name="211101861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211101861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211101861">(Sep 24 2020 at 08:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Right now it's that</p>
<ul>
<li>all <code>match</code> branches need to have the same indentation level</li>
<li>all <code>do</code> and tactic block items (of a single block) need to have the same indentation level</li>
</ul>
<p>See e.g. <a href="https://github.com/leanprover/lean4/blob/6fe8a0e1793a2e75ca6c655fee8e6d090c2dc370/src/Init/Core.lean#L1139-L1142">https://github.com/leanprover/lean4/blob/6fe8a0e1793a2e75ca6c655fee8e6d090c2dc370/src/Init/Core.lean#L1139-L1142</a></p>



<a name="211105408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20the%20name%20of%20%2B%3F/near/211105408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F.html#211105408">(Sep 24 2020 at 09:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211056586">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="271218">Thorsten Altenkirch</span> <a href="#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211034875">said</a>:</p>
<blockquote>
<p>For example the syntax of pattern matching is weird, why not writing the definitional equations you mean</p>
</blockquote>
<p>I would find that quite misleading - pattern matching equations are <em>not</em> identical to the definitional equations of a function because of their sequential semantics. If I write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">not</span> <span class="n">True</span> <span class="bp">=</span> <span class="n">False</span>
<span class="n">not</span> <span class="n">b</span>    <span class="bp">=</span> <span class="n">True</span>
</code></pre></div>

<p>it doesn't follow that <code>not b = True</code>.</p>
<blockquote>
<p>Also I do think that a syntax which is aware of intention as it is available not only in Haskell but also in Python is preferable</p>
</blockquote>
<p>I am assuming you mean "indentation", though intention-aware syntax would be even better :) . We are embracing light indentation awareness in Lean 4 (in the sense that no one should accidentally be able to get it wrong), but full-on awareness a la Haskell has always struck me as far too controversial and confusing for beginners to copy. Indentation should help people, not hinder them.</p>
</blockquote>
<p>You would get a warning in agda.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/reasoning.20with.20strings.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html">reasoning with strings</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="225832166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225832166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225832166">(Feb 10 2021 at 13:02)</a>:</h4>
<p>I can't make progress with the following goals, maybe I am missing something to reason with strings. Any idea? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="mi">5</span> <span class="n">goals</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">i.δ</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="bp">∅</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="bp">∅</span>
<span class="bp">⊢</span> <span class="n">n</span> <span class="bp">∈</span> <span class="o">{</span><span class="mi">1</span><span class="o">}</span>

<span class="n">n</span> <span class="o">:</span> <span class="n">i.δ</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">ir</span> <span class="o">{</span><span class="n">id</span> <span class="o">:=</span> <span class="s2">"hasChild"</span><span class="o">}</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="bp">∅</span>
<span class="bp">⊢</span> <span class="bp">¬</span><span class="s2">"hasChild"</span> <span class="bp">=</span> <span class="s2">"hasChild"</span>

<span class="n">n</span> <span class="o">:</span> <span class="n">i.δ</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">ir</span> <span class="o">{</span><span class="n">id</span> <span class="o">:=</span> <span class="s2">"hasChild"</span><span class="o">}</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">ic</span> <span class="o">{</span><span class="n">id</span> <span class="o">:=</span> <span class="s2">"man"</span><span class="o">}</span>
<span class="bp">⊢</span> <span class="bp">¬</span><span class="s2">"man"</span> <span class="bp">=</span> <span class="s2">"woman"</span>

<span class="n">n</span> <span class="o">:</span> <span class="n">i.δ</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">ir</span> <span class="o">{</span><span class="n">id</span> <span class="o">:=</span> <span class="s2">"hasChild"</span><span class="o">}</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">ic</span> <span class="o">{</span><span class="n">id</span> <span class="o">:=</span> <span class="s2">"man"</span><span class="o">}</span>
<span class="bp">⊢</span> <span class="bp">¬</span><span class="s2">"man"</span> <span class="bp">=</span> <span class="s2">"man"</span><span class="n">a</span>

<span class="n">n</span> <span class="o">:</span> <span class="n">i.δ</span>
<span class="bp">⊢</span> <span class="n">n</span> <span class="bp">∈</span> <span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">interp</span> <span class="n">i</span> <span class="o">(</span><span class="n">Every</span> <span class="o">(</span><span class="n">Role.Atomic</span> <span class="o">{</span><span class="n">id</span> <span class="o">:=</span> <span class="s2">"hasChild"</span><span class="o">})</span> <span class="o">(</span><span class="n">Atomic</span> <span class="o">{</span><span class="n">id</span> <span class="o">:=</span> <span class="s2">"man"</span><span class="o">}))</span>
</code></pre></div>
<p>I am trying to formalize the basic idea of the interpretation of a description logic called ALC. Complete code at <a href="https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L100">https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L100</a></p>



<a name="225840621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225840621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225840621">(Feb 10 2021 at 14:11)</a>:</h4>
<p><code>dec_trivial</code> will prove things like <code>¬"man" = "woman"</code>. Unless you're redefined negation, I hope you can't prove <code>¬"hasChild" = "hasChild"</code>!</p>



<a name="225843128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225843128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225843128">(Feb 10 2021 at 14:27)</a>:</h4>
<p><code>h1</code> before that goal looks like it could provide <code>b ∈ ∅</code> which is false, so it may be provable after all.</p>



<a name="225852213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225852213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225852213">(Feb 10 2021 at 15:26)</a>:</h4>
<p>I changed my code for using inductive types instead of strings. With this new formalization, I made some progress. But I am now in a situation that may suggest the interpretation of concepts should be changed... My current open goal is below. It is clear that for n=1 and b=2, hypothesis h1 is true. I can even instantiate h1 to h2 with the right number. But now I have a true hypothesis that doesn't depend on the <code>n=1</code>... </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∈</span> <span class="o">{(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)}</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∈</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">},</span>
<span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">∈</span> <span class="o">{(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)}</span> <span class="bp">→</span> <span class="mi">2</span> <span class="bp">∈</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">}</span>
<span class="bp">⊢</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>
<p><a href="https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L106">https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L106</a> is the open goal. Another question is how <code>finish</code> magically solves the goal below in <a href="https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L117">https://github.com/arademaker/alc-lean/blob/master/src/alc.lean#L117</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">n</span> <span class="n">n2</span> <span class="o">:</span> <span class="n">i.δ</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
<span class="n">hb</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">4</span> <span class="bp">∧</span> <span class="n">n2</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">,</span>
<span class="n">hb1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">4</span>
<span class="bp">⊢</span> <span class="n">false</span>
</code></pre></div>



<a name="225856128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225856128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225856128">(Feb 10 2021 at 15:52)</a>:</h4>
<p>Your second question can be answered with <code>show_term</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">show_term</span> <span class="o">{</span><span class="n">finish</span><span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="225856343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225856343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225856343">(Feb 10 2021 at 15:53)</a>:</h4>
<p>Looking at that messy output, it turns out that <code>exact nat.one_ne_bit0 _ h</code> is the short proof (<a href="https://leanprover-community.github.io/mathlib_docs/find/nat.one_ne_bit0">docs#nat.one_ne_bit0</a>)</p>



<a name="225857816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225857816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225857816">(Feb 10 2021 at 16:01)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="310045">@Eric Wieser</span> , but quite unnatural, right?</p>



<a name="225858253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225858253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225858253">(Feb 10 2021 at 16:02)</a>:</h4>
<p>Well, you could also prove it by repeatedly subtracting until you have succ_ne_zero. as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">nat.succ_ne_zero</span> <span class="n">_</span> <span class="o">(</span><span class="n">nat.succ_injective</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
</code></pre></div>
<p>I'm not sure what you mean by unnatural.</p>



<a name="225860637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225860637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225860637">(Feb 10 2021 at 16:11)</a>:</h4>
<p>For your first question: <code>h2</code> is trivially true and the goal isn't provable, e.g. evaluate it at <code>n = 3</code>. For your second question: <code>norm_num at hb1</code></p>



<a name="225862742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225862742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225862742">(Feb 10 2021 at 16:19)</a>:</h4>
<p>Also, <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>?</p>



<a name="225862921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225862921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225862921">(Feb 10 2021 at 16:19)</a>:</h4>
<p>oh there's a link at the end</p>



<a name="225865497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225865497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225865497">(Feb 10 2021 at 16:29)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span>
  <span class="n">interp</span> <span class="n">i</span> <span class="o">(</span><span class="n">Every</span> <span class="o">(</span><span class="n">Role.Atomic</span> <span class="n">ar.hasChild</span><span class="o">)</span> <span class="o">(</span><span class="n">Concept.Atomic</span> <span class="n">ac.man</span><span class="o">))</span> <span class="bp">=</span> <span class="o">({</span><span class="mi">4</span><span class="o">}</span><span class="bp">ᶜ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">interp</span><span class="o">,</span> <span class="n">r_interp</span><span class="o">,</span> <span class="n">ir</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">H</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">H</span> <span class="mi">3</span><span class="o">,</span> <span class="n">revert</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">norm_num</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span> <span class="n">_</span> <span class="o">(⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span><span class="bp">|</span><span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩),</span> <span class="o">{</span><span class="n">norm_num</span><span class="o">},</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="n">rfl</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="225865726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225865726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225865726">(Feb 10 2021 at 16:30)</a>:</h4>
<p>However this probably isn't the theorem you wanted to prove</p>



<a name="225865845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225865845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225865845">(Feb 10 2021 at 16:31)</a>:</h4>
<p>but I don't know enough about your description logic to suggest fixes</p>



<a name="225866428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225866428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225866428">(Feb 10 2021 at 16:33)</a>:</h4>
<p>Also you have too many things marked <code>reducible</code>. None of those definitions should be reducible; definitions by pattern matching should never be reducible</p>



<a name="225867602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225867602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225867602">(Feb 10 2021 at 16:39)</a>:</h4>
<blockquote>
<p>None of those definitions should be reducible; definitions by pattern matching should never be reducible</p>
</blockquote>
<p>Why's that?</p>



<a name="225867660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225867660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225867660">(Feb 10 2021 at 16:39)</a>:</h4>
<p>Because the only thing it can reduce to is an equation compiler mess</p>



<a name="225868145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225868145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225868145">(Feb 10 2021 at 16:42)</a>:</h4>
<p>Actually, looking at your definitions, it seems like this result is correct: <code>Every hasChild man</code> seems to mean the collection of all people such that every child of theirs is a man, and since the men are <code>2,4</code>, the women are <code>1,3</code> and <code>2</code> is a child of <code>1</code> and <code>3</code> a child of <code>4</code>, the only person for which the predicate fails is <code>4</code> (all the nonbinaries at &gt;4 have no children so the concept is also satisfied for them)</p>



<a name="225868964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225868964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225868964">(Feb 10 2021 at 16:46)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="310045">@Eric Wieser</span> I don't understand the <code>bit0</code>, I didn't find any documentation about it. Besides that, it seems that the fact that 1=4 is also should not depend on a bit representation of naturals. In other words, the second proof you suggest  is entirely in the level of abstraction that I would expect: naturals, successor, the fact that succ is injective etc. </p>
<p>BTW, what is <code>succ.inj</code> in the theorem <code>succ_injective</code>? I didn't find the definition of it (go to definition didn't find it).  But yes, thank you so much for helping me to make sense of this (now obvious!) proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
 <span class="c1">-- if succ 0 = succ 3 then 0 = 3 because succ is injective</span>
 <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.succ_injective</span> <span class="n">h</span><span class="o">),</span>
 <span class="n">apply</span> <span class="n">nat.succ_ne_zero</span> <span class="n">_</span> <span class="n">h1.symm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="225869243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225869243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225869243">(Feb 10 2021 at 16:47)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/bit0">docs#bit0</a> has a "&gt; equations" toggle you can expand</p>



<a name="225869362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225869362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225869362">(Feb 10 2021 at 16:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225867660">said</a>:</p>
<blockquote>
<p>Because the only thing it can reduce to is an equation compiler mess</p>
</blockquote>
<p>Is this really true?  I still remember the time when unification produced brec_on, but this has been fixed a long long time ago now.</p>



<a name="225869449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225869449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225869449">(Feb 10 2021 at 16:48)</a>:</h4>
<p><code>succ.inj</code> is autogenerated - all inductive type constructors are axiomatically injective (I think?)</p>



<a name="225869605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225869605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225869605">(Feb 10 2021 at 16:49)</a>:</h4>
<blockquote>
<p>it seems that the fact that 1=4 is also should not depend on a bit representation of naturals.</p>
</blockquote>
<p>Lean is proof-irrelevant - facts are never dependent on how you choose to prove them</p>



<a name="225869797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225869797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225869797">(Feb 10 2021 at 16:50)</a>:</h4>
<p>But if you choose to prove equality of naturals using bit0/bit1 instead of zero/succ, you only need <code>log2 n</code> steps instead of <code>n</code> steps to do so</p>



<a name="225870581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225870581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225870581">(Feb 10 2021 at 16:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225869362">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225867660">said</a>:</p>
<blockquote>
<p>Because the only thing it can reduce to is an equation compiler mess</p>
</blockquote>
<p>Is this really true?  I still remember the time when unification produced brec_on, but this has been fixed a long long time ago now.</p>
</blockquote>
<p>Not really, it seems that lean will just ignore the <code>@[reducible]</code> marker in this case instead of providing a brec_on</p>



<a name="225870663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225870663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225870663">(Feb 10 2021 at 16:55)</a>:</h4>
<p>my point is mostly that the annotation does not make any sense</p>



<a name="225870901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225870901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225870901">(Feb 10 2021 at 16:57)</a>:</h4>
<p>I will reiterate <span class="user-mention silent" data-user-id="110596">Rob Lewis</span> 's point that the correct way to prove <code>1 != 4</code> is <code>norm_num</code>. it handles all this bit0 stuff for you and doesn't suffer from any exponential time issues like <code>dec_trivial</code></p>



<a name="225871195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225871195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225871195">(Feb 10 2021 at 16:58)</a>:</h4>
<p>Yes you can prove it directly using <code>nat.one_ne_bit0</code> but that's just what norm_num uses under the hood, users shouldn't need to interact with numerals on this level of abstraction</p>



<a name="225874441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225874441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225874441">(Feb 10 2021 at 17:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/reasoning.20with.20strings/near/225869797">said</a>:</p>
<blockquote>
<p>But if you choose to prove equality of naturals using bit0/bit1 instead of zero/succ, you only need <code>log2 n</code> steps instead of <code>n</code> steps to do so</p>
</blockquote>
<p>Interesting, I saw the equations, but still, they don't make sense for me. Maybe I am missing the context. How/Why/When they are used.</p>



<a name="225874536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225874536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225874536">(Feb 10 2021 at 17:21)</a>:</h4>
<p>It's expensive to express numerals in a unary system: <code>4 = 1 + 1 + 1 + 1</code>. It is more efficient to say that <del><code>4 = bit0 (bit1 0)</code></del> <code>4 = bit0 (bit0 1)</code></p>



<a name="225874605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/reasoning%20with%20strings/near/225874605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/reasoning.20with.20strings.html#225874605">(Feb 10 2021 at 17:21)</a>:</h4>
<p>actually <code>bit0 (bit0 1)</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
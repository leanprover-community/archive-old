---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Generalized.20rewriting.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html">Generalized rewriting</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="211513775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211513775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211513775">(Sep 28 2020 at 16:13)</a>:</h4>
<p>How can I get <code>rewrite</code> tactic working with a setoid? In Coq, I usually define an instance of <code>Setoid</code> and also add new morphisms with <code>Add Parametric Morphism</code>.  What am I supposed to do in Lean? I have defined an instance of <code>Setoid</code>, but when I'm trying to use rewrite tactic I get an error: <code>rewrite tactic failed, lemma is not an equality nor a iff state</code>.</p>



<a name="211514884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211514884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211514884">(Sep 28 2020 at 16:23)</a>:</h4>
<p>I'm not sure what feature you're looking for, but I don't think it exists.</p>



<a name="211515337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211515337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211515337">(Sep 28 2020 at 16:27)</a>:</h4>
<p>I suspect the Lean equivalent is just to work with the quotient type.</p>



<a name="211515671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211515671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211515671">(Sep 28 2020 at 16:29)</a>:</h4>
<p>Like Reid says, Lean does not support generalised rewriting a la Coq. Using a quotient instead of a setoid would probably be the idiomatic solution. If you don't want to do that, you'll have to reason with your equivalence relation directly, Agda-style.</p>



<a name="211518252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211518252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211518252">(Sep 28 2020 at 16:49)</a>:</h4>
<p>That is unfortunate, that generalized rewriting is not supported. However, I do not know how quotients work, they might be a better way of doing what I'm doing.</p>



<a name="211521454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211521454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211521454">(Sep 28 2020 at 17:13)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients</a><br>
Basically, we never use <code>setoid</code> other than to form <code>quotient</code>s, and then I guess what Coq calls "generalized rewriting" just becomes ordinary rewriting.</p>



<a name="211522009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211522009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211522009">(Sep 28 2020 at 17:17)</a>:</h4>
<p>And instead of proving theorems like <code>a ≈ b</code> I would rather prove <code>⟦a⟧ = ⟦b⟧</code>.</p>



<a name="211522067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211522067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211522067">(Sep 28 2020 at 17:17)</a>:</h4>
<p>I have done some quick testing and it seems to work as I would expect.</p>



<a name="211523848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211523848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211523848">(Sep 28 2020 at 17:31)</a>:</h4>
<p>Speaking only for myself, I prefer using quotients to using generalized rewriting. With quotients, when you define <code>f</code> in terms of a quotient type and if you look at the internal representation, you have to prove that it preserves the equivalence relation. Then, you can define <code>g</code> in terms of <code>f</code> and you don't have anything to prove unless you use the internals of the quotient. With generalized rewriting, you have to prove that both <code>f</code> and <code>g</code> are valid morphisms. The proof for <code>g</code> is easy but it still means that you need one proof per function that you use. I find quotients to be more modular.</p>



<a name="211525182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211525182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211525182">(Sep 28 2020 at 17:43)</a>:</h4>
<p>I got into a problem when I know that a function is a valid morphism but is not defined in terms of the quotient. I know that <code>⟦f y⟧ = ⟦z⟧</code>,  <code>⟦g x⟧ = ⟦y⟧ </code> and that <code>f</code> is a valid morphism. How can I easily prove that <code>⟦f (g x)⟧ = ⟦z⟧</code>?</p>
<p>Complete example: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span>
<span class="kd">constant</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span>
<span class="kd">constant</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span>
<span class="kd">constant</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span>
<span class="kd">constant</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">fy</span> <span class="o">:</span> <span class="bp">⟦</span><span class="n">f</span> <span class="n">y</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="n">z</span><span class="bp">⟧</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">gx</span> <span class="o">:</span> <span class="bp">⟦</span><span class="n">g</span> <span class="n">x</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="n">y</span><span class="bp">⟧</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">fmor</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⟦</span><span class="n">x</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="n">y</span><span class="bp">⟧</span> <span class="bp">→</span> <span class="bp">⟦</span><span class="n">f</span> <span class="n">x</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="n">f</span> <span class="n">y</span><span class="bp">⟧</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">fgx</span> <span class="o">:</span> <span class="bp">⟦</span><span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="n">z</span><span class="bp">⟧</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">rewrite</span> <span class="n">gx</span><span class="o">,</span> <span class="c1">-- how to get this working?</span>
<span class="n">rewrite</span> <span class="n">fy</span><span class="o">,</span>
<span class="n">refl</span>
<span class="kd">end</span>
</code></pre></div>



<a name="211525344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211525344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211525344">(Sep 28 2020 at 17:45)</a>:</h4>
<p>Don't use <code>f</code> directly, but rather <code>quotient.map f</code></p>



<a name="211525724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211525724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211525724">(Sep 28 2020 at 17:48)</a>:</h4>
<p>e.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.quot</span>

<span class="kd">constant</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span>
<span class="kd">constant</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span>
<span class="kd">constant</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span>
<span class="kd">constant</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span>
<span class="kd">constant</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">fmor'</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≈</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">≈</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">f'</span> <span class="o">:=</span> <span class="n">quotient.map</span> <span class="n">f</span> <span class="n">fmor'</span>

<span class="kd">lemma</span> <span class="n">fy</span> <span class="o">:</span> <span class="n">f'</span> <span class="bp">⟦</span><span class="n">y</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="n">z</span><span class="bp">⟧</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kd">lemma</span> <span class="n">gx</span> <span class="o">:</span> <span class="bp">⟦</span><span class="n">g</span> <span class="n">x</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="n">y</span><span class="bp">⟧</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kd">lemma</span> <span class="n">fgx</span> <span class="o">:</span> <span class="n">f'</span> <span class="bp">⟦</span><span class="n">g</span> <span class="n">x</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="n">z</span><span class="bp">⟧</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">rewrite</span> <span class="n">gx</span><span class="o">,</span>
<span class="n">rewrite</span> <span class="n">fy</span>
<span class="kd">end</span>
</code></pre></div>



<a name="211525798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211525798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211525798">(Sep 28 2020 at 17:48)</a>:</h4>
<p>I'm afraid that in my application this is not possible or very cumbersome, but I will think about it more.</p>



<a name="211526085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211526085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211526085">(Sep 28 2020 at 17:51)</a>:</h4>
<p>Generally we would work entirely with <code>f'</code> and wouldn't bother making <code>f</code> and <code>fmor'</code> into top-level definitions, unless they were rather complicated.</p>



<a name="211526702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211526702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211526702">(Sep 28 2020 at 17:56)</a>:</h4>
<p>The problem is that I care about <code>f</code>. I really care about the actual representative, but usually prove theorems only about its equivalence class.</p>



<a name="211526941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211526941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211526941">(Sep 28 2020 at 17:58)</a>:</h4>
<p>I often work with functions like <code>(compose f (compose g h))</code>. When I want to prove something I would have to convert it to <code>(compose f' (compose g' h'))</code></p>



<a name="211787341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211787341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211787341">(Sep 30 2020 at 16:35)</a>:</h4>
<p>I'm really struggling with this. As an example I want to prove that <code>(f∘f∘f)[x] ≈ f[f[f[x]]]</code> by  subsequently applying <code>compose.app {...} : (f∘g)[x] ≈ f[g[x]]</code>. I would like the proof to be <code>repeat {rewrite compose.app}</code>, but I do not know how to do this. Currently I have to manually invoke transitivity of <code>≈</code> over <code>f[(f∘f)[x]])</code>.</p>
<p>Complete example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">reserve</span> <span class="kd">infixr</span> <span class="bp">`</span> <span class="bp">⟶</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span>
<span class="kd">reserve</span> <span class="kd">infixr</span> <span class="bp">`</span> <span class="bp">×</span> <span class="bp">`</span>  <span class="o">:</span> <span class="mi">60</span>
<span class="kd">reserve</span> <span class="kd">infixr</span> <span class="bp">`</span> <span class="bp">∘</span> <span class="bp">`</span>  <span class="o">:</span> <span class="mi">60</span>
<span class="kd">reserve</span> <span class="kd">infix</span>  <span class="bp">`</span> <span class="bp">≅</span> <span class="bp">`</span>  <span class="o">:</span> <span class="mi">26</span>

<span class="c1">--- Types</span>

<span class="kd">inductive</span> <span class="n">type</span>
<span class="bp">|</span> <span class="n">sym</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">type</span>
<span class="bp">|</span> <span class="n">op</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">type</span>

<span class="kd">def</span> <span class="n">type.fspace</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">:</span> <span class="n">type</span> <span class="o">:=</span> <span class="n">type.op</span> <span class="s2">"fspace"</span> <span class="n">X</span> <span class="n">Y</span>
<span class="kd">infixr</span> <span class="bp">⟶</span> <span class="o">:=</span> <span class="n">type.fspace</span>

<span class="c1">--- Expressions</span>

<span class="kd">inductive</span> <span class="n">Expr</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">sym</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">Expr</span> <span class="n">T</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">:</span> <span class="n">Expr</span> <span class="o">(</span><span class="n">X</span> <span class="bp">⟶</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">Y</span>

<span class="kd">notation</span> <span class="n">f</span> <span class="o">[</span> <span class="n">x</span> <span class="o">]</span> <span class="o">:=</span> <span class="n">Expr.app</span> <span class="n">f</span> <span class="n">x</span>

<span class="kd">instance</span> <span class="n">type.coercion_to_Type</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="n">type</span> <span class="o">:=</span> <span class="n">has_coe_to_sort.mk</span> <span class="kt">Type</span> <span class="n">Expr</span>

<span class="c1">--- Equality: Postulate an existence of equality</span>

<span class="kd">constant</span> <span class="n">ceq</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">infix</span> <span class="bp">≅</span> <span class="o">:=</span> <span class="n">ceq</span>
<span class="kd">@[refl]</span>  <span class="kd">axiom</span> <span class="n">ceq.refl</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≅</span> <span class="n">x</span>
<span class="kd">@[symm]</span>  <span class="kd">axiom</span> <span class="n">ceq.symm</span>  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≅</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≅</span> <span class="n">x</span>
<span class="kd">@[trans]</span> <span class="kd">axiom</span> <span class="n">ceq.trans</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≅</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≅</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">≅</span> <span class="n">z</span>

<span class="kd">def</span> <span class="n">ceq.iseqv</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="o">(</span><span class="bp">@</span><span class="n">ceq</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="n">split</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ceq.refl</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ceq.symm</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ceq.trans</span> <span class="kd">end</span>
<span class="kd">instance</span> <span class="n">type.setoid</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">type</span><span class="o">)</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">setoid.mk</span> <span class="n">ceq</span> <span class="n">ceq.iseqv</span>

<span class="c1">--- Postulate function extensionality and all functions are proper</span>

<span class="kd">axiom</span> <span class="n">ceq.ext</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">f'</span> <span class="o">:</span> <span class="n">X</span><span class="bp">⟶</span><span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">f</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="bp">≈</span> <span class="n">f'</span><span class="o">[</span><span class="n">x</span><span class="o">])</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">≈</span> <span class="n">f'</span>
<span class="kd">axiom</span> <span class="n">ceq.mor</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">f'</span> <span class="o">:</span> <span class="n">X</span><span class="bp">⟶</span><span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">x'</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≈</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">≈</span> <span class="n">f'</span> <span class="bp">→</span> <span class="n">f</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="bp">≈</span> <span class="n">f'</span><span class="o">[</span><span class="n">x'</span><span class="o">]</span>

<span class="c1">--- Composition combinator</span>

<span class="kd">def</span> <span class="n">compose</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">}</span> <span class="o">:=</span> <span class="n">Expr.sym</span> <span class="o">((</span><span class="n">X</span><span class="bp">⟶</span><span class="n">Y</span><span class="o">)</span><span class="bp">⟶</span><span class="o">(</span><span class="n">Y</span><span class="bp">⟶</span><span class="n">Z</span><span class="o">)</span><span class="bp">⟶</span><span class="o">(</span><span class="n">X</span><span class="bp">⟶</span><span class="n">Z</span><span class="o">))</span> <span class="s2">"compose"</span>

<span class="kd">notation</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">compose</span><span class="o">[</span><span class="n">g</span><span class="o">][</span><span class="n">f</span><span class="o">]</span>

<span class="kd">axiom</span> <span class="n">compose.app</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">X</span><span class="bp">⟶</span><span class="n">Y</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">Y</span><span class="bp">⟶</span><span class="n">Z</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">g</span><span class="o">)[</span><span class="n">x</span><span class="o">]</span> <span class="bp">≈</span> <span class="n">f</span><span class="o">[</span><span class="n">g</span><span class="o">[</span><span class="n">x</span><span class="o">]]</span>

<span class="c1">--- What I want to prove the following</span>

<span class="kd">lemma</span> <span class="kd">example</span><span class="bp">.</span><span class="n">compose</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">type</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span><span class="bp">⟶</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span><span class="bp">∘</span><span class="n">f</span><span class="bp">∘</span><span class="n">f</span><span class="o">)[</span><span class="n">x</span><span class="o">]</span> <span class="bp">≈</span> <span class="n">f</span><span class="o">[</span><span class="n">f</span><span class="o">[</span><span class="n">f</span><span class="o">[</span><span class="n">x</span><span class="o">]]]</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="o">(</span><span class="n">ceq.trans</span> <span class="n">_</span> <span class="o">(</span><span class="n">f</span><span class="o">[(</span><span class="n">f</span><span class="bp">∘</span><span class="n">f</span><span class="o">)[</span><span class="n">x</span><span class="o">]])</span> <span class="n">_</span><span class="o">),</span> <span class="n">apply</span> <span class="n">compose.app</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ceq.mor</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">compose.app</span><span class="o">,</span> <span class="n">repeat</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span>
<span class="kd">end</span>

<span class="c1">--- The ideal proof should be  "repeat {rewrite compose.app}"</span>
</code></pre></div>



<a name="211813787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211813787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211813787">(Sep 30 2020 at 20:12)</a>:</h4>
<p><code>rw</code> only rewrites along equalities, not along general equivalence relations.</p>



<a name="211818543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211818543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211818543">(Sep 30 2020 at 20:49)</a>:</h4>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#equiv_rw">tactic#equiv_rw</a> (specifically for <code>equiv</code>s), but I've never used it before.</p>



<a name="211880989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211880989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211880989">(Oct 01 2020 at 08:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Generalized.20rewriting/near/211813787">said</a>:</p>
<blockquote>
<p><code>rw</code> only rewrites along equalities, not along general equivalence relations.</p>
</blockquote>
<p>I'm aware of this. My the problem is basically how can I state <code>(f∘f∘f)[x] ≈ f[f[f[x]]]</code> and <code>(f∘g)[x] ≈ f[g[x]]</code> with quotients and equalities such that the proof can be <code>repeat {rewrite compose.app}</code>.</p>



<a name="211881095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/211881095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#211881095">(Oct 01 2020 at 08:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113488-general/topic/Generalized.20rewriting/near/211818543">said</a>:</p>
<blockquote>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#equiv_rw">tactic#equiv_rw</a> (specifically for <code>equiv</code>s), but I've never used it before.</p>
</blockquote>
<p>Nice, I will try that once I manage to install mathlib successfully.</p>



<a name="214992627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/214992627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#214992627">(Oct 29 2020 at 16:30)</a>:</h4>
<p>I hope it's okay to bring back this older thread, but I just want to make sure I understand: If I make an equivalence relation like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.set</span> <span class="n">data.stream</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">stream</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">inf_word</span> <span class="o">(</span><span class="n">AP</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="n">stream</span> <span class="o">(</span><span class="n">set</span> <span class="n">AP</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">formulae</span> <span class="o">(</span><span class="n">AP</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">T</span> <span class="o">:</span> <span class="n">formulae</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">AP</span><span class="o">)</span> <span class="o">:</span> <span class="n">formulae</span>
<span class="bp">|</span> <span class="n">conj</span> <span class="o">(</span><span class="bp">Φ₁</span> <span class="bp">Φ₂</span> <span class="o">:</span> <span class="n">formulae</span><span class="o">)</span> <span class="o">:</span> <span class="n">formulae</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">(</span><span class="bp">Φ</span> <span class="o">:</span> <span class="n">formulae</span><span class="o">)</span> <span class="o">:</span> <span class="n">formulae</span>

<span class="kd">def</span> <span class="n">words</span> <span class="o">{</span><span class="n">AP</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="bp">Φ</span> <span class="o">:</span> <span class="n">formula</span> <span class="n">AP</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">inf_word</span> <span class="n">AP</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">σ</span> <span class="bp">|</span> <span class="n">true</span><span class="o">}</span> <span class="c1">-- in reality, set of words which satisfy Φ</span>

<span class="kd">def</span> <span class="n">my_equiv</span> <span class="o">{</span><span class="n">AP</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="bp">Φ</span> <span class="bp">Ψ</span><span class="o">:</span> <span class="n">formula</span> <span class="n">AP</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">words</span> <span class="bp">Φ</span> <span class="bp">=</span> <span class="n">words</span> <span class="bp">Ψ</span>
</code></pre></div>

<p>and I want to be able to use <code>rw</code> on goals/hypotheses of the form <code>my_equiv Φ Ψ</code>, should I be registering  <code>formula</code> as a quotient?</p>
<p>Or more precisely defining a quotient type over formula I guess</p>



<a name="214993734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/214993734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#214993734">(Oct 29 2020 at 16:38)</a>:</h4>
<p>yes, you define a quotient of <code>formula</code> and then use <code>rw</code> on the resulting type</p>



<a name="214993792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generalized%20rewriting/near/214993792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Logan Murphy <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Generalized.20rewriting.html#214993792">(Oct 29 2020 at 16:38)</a>:</h4>
<p>Great, thank you Mario!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/how.20zfc.20works.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html">how zfc works</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="245169288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245169288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245169288">(Jul 07 2021 at 12:10)</a>:</h4>
<p>well people keep talking about zfc... and I've read the axioms but I still can't understand how it models mathematics... any resources? thanks in advance</p>



<a name="245169558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245169558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245169558">(Jul 07 2021 at 12:13)</a>:</h4>
<p>from my perspective, ZFC is like a dystopian world where people are only allowed to talk about sets and discussions about other things are only allowed if they can be described in terms of sets... but my idea of the ZFC world is still very vague...</p>



<a name="245170782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245170782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245170782">(Jul 07 2021 at 12:24)</a>:</h4>
<p>You could just as well say the same thing about type theory if you replace "sets" with "types"</p>



<a name="245170835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245170835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245170835">(Jul 07 2021 at 12:25)</a>:</h4>
<p>Sets are the primitive notion in ZFC. They have no definition, they just are axiomatized to have certain properties that amount to "there are enough sets for anything you could ever need"</p>



<a name="245170992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245170992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245170992">(Jul 07 2021 at 12:27)</a>:</h4>
<p>and then you just build whatever notions you need with that as the substrate. You very quickly stop thinking in terms of sets because that's not the topic of discussion, in the same way that we don't make a big deal about how mathematics is made of words</p>



<a name="245176602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245176602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245176602">(Jul 07 2021 at 13:10)</a>:</h4>
<p>so... I have a more concrete question now. the axiom of infinity asserts that there is a set that contains every natural number in the von Neumann encoding and possibly other garbage elements... how can I extract the set of natural numbers from the axiom of infinity then? and how can I prove that induction holds?</p>



<a name="245176778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245176778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245176778">(Jul 07 2021 at 13:12)</a>:</h4>
<p>the set of natural numbers is itself a natural number right?</p>



<a name="245176854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245176854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245176854">(Jul 07 2021 at 13:12)</a>:</h4>
<p>and its name is omega or aleph null...</p>



<a name="245176870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245176870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245176870">(Jul 07 2021 at 13:12)</a>:</h4>
<p>omega isn't a natural number it's an ordinal</p>



<a name="245177107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245177107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245177107">(Jul 07 2021 at 13:14)</a>:</h4>
<p>you can probably make up some predicate to extract the non-junk, i'd go for something like (off the top of my head, not guaranteeing correctness):</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi mathvariant="normal">∀</mi><mi>s</mi><mo>∈</mo><mi>x</mi><mo separator="true">,</mo><mi>s</mi><mo>∈</mo><mi>X</mi><mo>∧</mo><mi mathvariant="normal">∀</mi><mi>s</mi><mi>t</mi><mo>∈</mo><mi>x</mi><mo separator="true">,</mo><mi>s</mi><mo>=</mo><mi>t</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex"> \{  x \in X\ |\ \forall s \in x, s \in X \land \forall s t \in x, s = t \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord">∀</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">}</span></span></span></span></p>



<a name="245178051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178051">(Jul 07 2021 at 13:22)</a>:</h4>
<p>I don't think that works, you are defining all the singleton subsets of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> but that might not be countable if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> is some arbitrary infinite set</p>



<a name="245178207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178207">(Jul 07 2021 at 13:23)</a>:</h4>
<p>what other singleton subsets can there be? any non-finite ones are ruled out by regularity, no? or am I missing something</p>



<a name="245178320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178320">(Jul 07 2021 at 13:23)</a>:</h4>
<p>The usual approach is to define what it means for a set to be "inductive", i.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∈</mo><mi>X</mi><mo>∧</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>X</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0\in X\wedge (\forall x\in X, S(x)\in X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> (the axiom of infinity asserts that an inductive set exists), and then you take the intersection of all inductive sets to get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span> (which exists because it is a subset of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>)</p>



<a name="245178384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178384">(Jul 07 2021 at 13:24)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span> is in fact not composed of singleton sets</p>



<a name="245178444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178444">(Jul 07 2021 at 13:24)</a>:</h4>
<p>I see, big oops then</p>



<a name="245178456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178456">(Jul 07 2021 at 13:24)</a>:</h4>
<p>that explains why I'm so confused by the predicate</p>



<a name="245178485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178485">(Jul 07 2021 at 13:24)</a>:</h4>
<p><span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="245178605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178605">(Jul 07 2021 at 13:25)</a>:</h4>
<p>If I recall correctly, you also need to do this to get the power set from the power set axiom.</p>



<a name="245178738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178738">(Jul 07 2021 at 13:26)</a>:</h4>
<p>and the union axiom. It's a common trick to simplify all the axioms to unidirectional versions in the presence of the subset axiom</p>



<a name="245178777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178777">(Jul 07 2021 at 13:26)</a>:</h4>
<p>does it work for Zermelo ordinals Mario? that's what I was thinking of, not the VN ones</p>



<a name="245178860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178860">(Jul 07 2021 at 13:27)</a>:</h4>
<p>ahh I see what I've done, I've created a horrific mixture of both</p>



<a name="245178867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178867">(Jul 07 2021 at 13:27)</a>:</h4>
<p>that's terrifying and bad</p>



<a name="245178885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178885">(Jul 07 2021 at 13:27)</a>:</h4>
<p>It depends on how the axiom of infinity is stated. The usual statement contains an explicit reference to VN successor</p>



<a name="245178994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245178994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245178994">(Jul 07 2021 at 13:28)</a>:</h4>
<p>but if you swapped it out for a zermelo successor then you could do the same thing with zermelo ordinals</p>



<a name="245179488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245179488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245179488">(Jul 07 2021 at 13:31)</a>:</h4>
<p>wait, that's confusing. how can the axiom of infinity be stated with zermelo ordinals then?</p>



<a name="245179546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245179546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245179546">(Jul 07 2021 at 13:31)</a>:</h4>
<p>and can that be shown to be equivalent to the VN version</p>



<a name="245179563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245179563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245179563">(Jul 07 2021 at 13:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="270523">Huỳnh Trần Khanh</span> <a href="#narrow/stream/113488-general/topic/how.20zfc.20works/near/245176602">said</a>:</p>
<blockquote>
<p>and how can I prove that induction holds?</p>
</blockquote>
<p>Given the intersection definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span>, the induction theorem falls out naturally. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> holds and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall x,(P(x)\to P(S(x)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)))</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>ω</mi><mi mathvariant="normal">∣</mi><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x\in \omega|P(x)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)}</span></span></span></span> is an inductive set, so therefore <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>⊆</mo><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>ω</mi><mi mathvariant="normal">∣</mi><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\omega\subseteq \{x\in \omega|P(x)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)}</span></span></span></span> and hence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> holds for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>ω</mi></mrow><annotation encoding="application/x-tex">x\in\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span></p>



<a name="245180058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245180058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245180058">(Jul 07 2021 at 13:34)</a>:</h4>
<p>I've been using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> so far to talk about the successor function. VN ordinals use <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S(x)=x\cup \{x\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mclose">}</span></span></span></span>, and zermelo ordinals use <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S(x)=\{x\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mclose">}</span></span></span></span>. All the theory is the same for either one, since all you need to make the argument work is for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> to be injective and not have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> in the range</p>



<a name="245180328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245180328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245180328">(Jul 07 2021 at 13:36)</a>:</h4>
<p>For technical reasons VN ordinals turn out to be more convenient once you start doing more advanced set theory (VN successor of a transitive set is also transitive)</p>



<a name="245197545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245197545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245197545">(Jul 07 2021 at 15:22)</a>:</h4>
<p>alright so it seems that I can play the Natural Number Game in ZFC... how about this? <a href="https://github.com/leanprover-community/mathlib/tree/master/archive/miu_language">https://github.com/leanprover-community/mathlib/tree/master/archive/miu_language</a> how can this be modeled in ZFC? like I mean the inductive predicate that tells whether or not a given string is derivable...</p>



<a name="245197718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245197718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245197718">(Jul 07 2021 at 15:23)</a>:</h4>
<p>I don't even know how to define a list in ZFC!</p>



<a name="245198324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245198324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245198324">(Jul 07 2021 at 15:27)</a>:</h4>
<p>You could encode <code>[a,b,c,d]</code> as <code>{{a}, {a,b}, {a,b,c}, {a,b,c,d}}</code>, or something like that.</p>



<a name="245199209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245199209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245199209">(Jul 07 2021 at 15:32)</a>:</h4>
<p>although it's rather defined as <code>{{a}, {a, {{b}, {b, {{c}, {c, d}}}</code> because we want to define it by induction using the pair</p>



<a name="245199235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245199235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245199235">(Jul 07 2021 at 15:32)</a>:</h4>
<p>As with every definition in maths, you should take it very seriously, but, in Johan's encoding -- which normally goes under the name of Kuratowski's encoding,  I remember that I had to think hard about the case in which there are repetitions among the elements of the list.  In particular, you may want to define ordered <em>pairs</em> first, and then proceed to longer lists.</p>



<a name="245200198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245200198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245200198">(Jul 07 2021 at 15:38)</a>:</h4>
<p>Ooh, I guess I messed up, right? With repeated elements you my encoding doesn't work.</p>



<a name="245200367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245200367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245200367">(Jul 07 2021 at 15:39)</a>:</h4>
<p>so. many. subtleties. how can I construct stuff in ZFC without subtly messing stuff up, when even working mathematicians on here still get things wrong</p>



<a name="245200715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245200715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245200715">(Jul 07 2021 at 15:42)</a>:</h4>
<p>hmm I'll check back later for answers to my questions, also are there any resources to help me learn this stuff without having to ask like 998244353 questions for every single thing I want to do in ZFC</p>
<p>like a website or something that teaches ZFC stuff</p>



<a name="245200874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245200874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245200874">(Jul 07 2021 at 15:43)</a>:</h4>
<p>thanks in advance, as usual. I have to go to bed <span aria-label="in bed" class="emoji emoji-1f6cc" role="img" title="in bed">:in_bed:</span></p>



<a name="245202039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245202039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245202039">(Jul 07 2021 at 15:51)</a>:</h4>
<p>You can read "Naive Set Theory" by Halmos</p>



<a name="245202084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245202084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245202084">(Jul 07 2021 at 15:51)</a>:</h4>
<p>Note that the "mess up" is with the <em>encoding</em>, not with the concept!  No mathematician should ever make a mistake with lists with repeated entries, except possibly in their definition!</p>



<a name="245209878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245209878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245209878">(Jul 07 2021 at 16:51)</a>:</h4>
<p>I think it would be interesting to make a ZFC natural number game in Lean using the ZFC naturals</p>



<a name="245209947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245209947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245209947">(Jul 07 2021 at 16:51)</a>:</h4>
<p>Of course once you've established recursion I guess it'll just reduce to the same thing</p>



<a name="245231311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245231311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245231311">(Jul 07 2021 at 19:35)</a>:</h4>
<p>Why isn't there foundational pluralism in mathematics like there is in computer science? E.g. in CS/software engineering there are myriad programming languages (some of which I guess correspond to formal logics) and people typically choose the foundation (language) that is best suited to a particular problem. In mathematics there is just one de facto foundation/language, ZFC with FOL.  But I imagine that some mathematical problems are more easily stated or solved in some other foundational system.</p>



<a name="245231946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245231946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245231946">(Jul 07 2021 at 19:40)</a>:</h4>
<p>ZFC is more of a theoretical foundation than a practical one.  For the practical side, yes, there are a Myriad of options.</p>



<a name="245232215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245232215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245232215">(Jul 07 2021 at 19:42)</a>:</h4>
<p>I don't agree that ZFC is comparable to languages. More like x86, or binary.</p>



<a name="245232725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245232725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245232725">(Jul 07 2021 at 19:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="270523">Huỳnh Trần Khanh</span> <a href="#narrow/stream/113488-general/topic/how.20zfc.20works/near/245200367">said</a>:</p>
<blockquote>
<p>so. many. subtleties. how can I construct stuff in ZFC without subtly messing stuff up, when even working mathematicians on here still get things wrong</p>
</blockquote>
<p>The same way you do any formally intricate definition: you prove theorems about the stuff proving the key properties you expect. If you don't do this it's no better than an untested computer program.</p>
<p><span class="user-mention silent" data-user-id="270523">Huỳnh Trần Khanh</span> <a href="#narrow/stream/113488-general/topic/how.20zfc.20works/near/245200715">said</a>:</p>
<blockquote>
<p>hmm I'll check back later for answers to my questions, also are there any resources to help me learn this stuff without having to ask like 998244353 questions for every single thing I want to do in ZFC</p>
<p>like a website or something that teaches ZFC stuff</p>
</blockquote>
<p>This is actually a very good use for the <a href="http://us.metamath.org/mpeuni/opth.html">metamath website</a>, which has fully worked out and hyperlinked proofs of all these facts from the axioms of ZFC</p>



<a name="245232971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245232971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245232971">(Jul 07 2021 at 19:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/113488-general/topic/how.20zfc.20works/near/245232215">said</a>:</p>
<blockquote>
<p>I don't agree that ZFC is comparable to languages. More like x86, or binary.</p>
</blockquote>
<p>ZFC itself, perhaps not, but ZFC + conservative extensions for definitions can certainly raise the level of discourse to traditional mathematical argumentation</p>



<a name="245233012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245233012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245233012">(Jul 07 2021 at 19:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243102">Brandon Brown</span> <a href="#narrow/stream/113488-general/topic/how.20zfc.20works/near/245231311">said</a>:</p>
<blockquote>
<p>Why isn't there foundational pluralism in mathematics like there is in computer science? E.g. in CS/software engineering there are myriad programming languages (some of which I guess correspond to formal logics) and people typically choose the foundation (language) that is best suited to a particular problem. In mathematics there is just one de facto foundation/language, ZFC with FOL.  But I imagine that some mathematical problems are more easily stated or solved in some other foundational system.</p>
</blockquote>
<p>I think that the reason is that practically mathematicians don't care at all about foundations. Someone told us that it is ZFC, maybe with the continuum hypothesis, but we really don't care doing "standard" mathematics.</p>



<a name="245233373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245233373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245233373">(Jul 07 2021 at 19:52)</a>:</h4>
<p>I'm not sure it's an exact parallel, but I see a sort of church-turing thesis for mathematical foundations: once you get past a certain very low bar all theories become interconvertible (modulo adding axioms to match up the consistency strengths of the source and target systems). Mathematics is presented using an implicit background foundation that fails to commit to any of these equivalent systems, and if pressed people will pick one like ZFC but that doesn't mean they were thinking about it at all before you ask the question</p>



<a name="245233673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245233673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245233673">(Jul 07 2021 at 19:54)</a>:</h4>
<p>ZFC has the advantage that it is really simple to define, which makes it appealing for metalogical analysis / "set theory". Type theory is more complex but comes with advantages for automation (e.g. type checking), so it is more common among computer proof assistants</p>



<a name="245235501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245235501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245235501">(Jul 07 2021 at 20:08)</a>:</h4>
<p>Also, I think the stack is a lot larger in maths. Going with the PL analogy, Lurie wrote a "library" on higher topos theory. It's several thousand pages. If you want to use a language that is different from his, but you want to use higher topos theory, you first need to port that library.</p>
<p>As pointed out above, in practice informal maths is foundation-agnostic. But when you start formalizing, this library porting becomes a serious issue.</p>



<a name="245270673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245270673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245270673">(Jul 08 2021 at 04:19)</a>:</h4>
<p>wait I'm extremely confused... why is the Naive Set Theory book titled so? it describes ZFC...</p>



<a name="245270724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245270724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245270724">(Jul 08 2021 at 04:20)</a>:</h4>
<p>ZFC is not naive by any stretch of the imagination...</p>



<a name="245270737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245270737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245270737">(Jul 08 2021 at 04:21)</a>:</h4>
<p>I haven't looked at the book in detail but it probably means that it isn't dealing at the edges of the system where you have to worry about how ZFC avoids the contradictions in unrestricted comprehension</p>



<a name="245270742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245270742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245270742">(Jul 08 2021 at 04:21)</a>:</h4>
<p>Note that a lot of category theory is also "naive" in this sense - there are universe issues to be handled, but as long as you don't test the limits you can kind of pretend they don't exist</p>



<a name="245270816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245270816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245270816">(Jul 08 2021 at 04:23)</a>:</h4>
<p>I am reminded of a certain formal system that shall not be named, which implemented naive set theory, and the solution the developers had for avoiding contradictions was to simply not write down the russell set</p>



<a name="245275152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245275152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245275152">(Jul 08 2021 at 06:02)</a>:</h4>
<p>The title of Halmos's book is sort of a joke -- it rigorously goes through the axioms of ZFC, and the only thing that's "naive" is the intended audience with regards to knowledge of foundations, and also it doesn't go into detail about things like what exactly is a logical formula.  (It definitely expects mathematical maturity though.)</p>



<a name="245275421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245275421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245275421">(Jul 08 2021 at 06:09)</a>:</h4>
<p>Halmos explains the axiom of restricted comprehension (here called the axiom of specification, which he helpfully tells you is often referred to as Aussonderungsaxiom), then shortly after proves "there is no universe", mentioning how in pre-axiomatic approaches the Russell paradox would arise.</p>



<a name="245276130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20zfc%20works/near/245276130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20zfc.20works.html#245276130">(Jul 08 2021 at 06:22)</a>:</h4>
<p>Actually, he explains the title in the preface.  More accurately, "it is naive in that the language and notation are those of ordinary informal (but formalizable) mathematics," and also that it works with set theory as if there were a single theory of sets.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
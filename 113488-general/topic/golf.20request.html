---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/golf.20request.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golf.20request.html">golf request</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="292280640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golf%20request/near/292280640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golf.20request.html#292280640">(Aug 06 2022 at 21:44)</a>:</h4>
<p>I need the following result when showing that for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebra of finite type, then a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-module is finitely presented if it is finitely presented over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>. (following <a href="https://stacks.math.columbia.edu/tag/0561">stacks#0561</a>)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.mv_polynomial</span>
<span class="kn">import</span> <span class="n">linear_algebra.smodeq</span>

<span class="kd">lemma</span> <span class="n">exists_smodeq_of_X_exists_smodeq</span> <span class="o">{</span><span class="n">I</span> <span class="n">J</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">I</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
   <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">submodule</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">J</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">I</span> <span class="bp">→</span> <span class="n">mv_polynomial</span> <span class="n">J</span> <span class="n">R</span><span class="o">))</span>
   <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">,</span> <span class="n">pi.single</span> <span class="n">i</span> <span class="o">(</span><span class="n">X</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≡</span> <span class="n">C</span> <span class="bp">∘</span> <span class="n">r</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">])</span> <span class="o">:</span>
   <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≡</span> <span class="n">C</span> <span class="bp">∘</span> <span class="n">r</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">]</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>The informal proof is just "By applying the relations given in <code>h</code>, we can inductively lower the degree of the polynomials", and I have a lean proof of it in <a href="https://github.com/leanprover-community/mathlib/pull/15901">#15901</a>. However, the proof seems to be unreasonably long, and I wonder if there is a better approach to it?</p>



<a name="292306134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golf%20request/near/292306134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golf.20request.html#292306134">(Aug 07 2022 at 08:01)</a>:</h4>
<p><span class="user-mention" data-user-id="439483">@Andrew Yang</span> <br>
Here's a golf:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.mv_polynomial</span>
<span class="kn">import</span> <span class="n">linear_algebra.smodeq</span>

<span class="kd">lemma</span> <span class="n">smul_mem_induction</span> <span class="o">{</span><span class="n">R</span> <span class="n">M</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">add_submonoid</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">∈</span> <span class="n">N</span><span class="o">),</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">subsemiring.closure</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">∈</span> <span class="n">N</span><span class="o">),</span> <span class="n">a</span> <span class="bp">•</span> <span class="n">m</span> <span class="bp">∈</span> <span class="n">N</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">apply</span> <span class="n">subsemiring.closure_induction</span> <span class="n">ha</span> <span class="n">hs</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">rw</span> <span class="n">zero_smul</span><span class="o">,</span> <span class="n">exact</span> <span class="n">N.zero_mem</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span><span class="o">,</span> <span class="n">rw</span> <span class="n">one_smul</span><span class="o">,</span> <span class="n">exact</span> <span class="n">id</span> <span class="o">},</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span> <span class="n">m</span> <span class="n">hm</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">add_smul</span><span class="o">,</span> <span class="n">exact</span> <span class="n">N.add_mem</span> <span class="o">(</span><span class="n">hx</span> <span class="n">m</span> <span class="n">hm</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="n">m</span> <span class="n">hm</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">mul_smul</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hx</span> <span class="n">_</span> <span class="o">(</span><span class="n">hy</span> <span class="n">m</span> <span class="n">hm</span><span class="o">)</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kn">open</span> <span class="n">mv_polynomial</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="n">J</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">I</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">I</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">submodule</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">J</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">I</span> <span class="bp">→</span> <span class="n">mv_polynomial</span> <span class="n">J</span> <span class="n">R</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">smodeq_C_add_submonoid</span> <span class="o">:</span> <span class="n">add_submonoid</span> <span class="o">(</span><span class="n">I</span> <span class="bp">→</span> <span class="n">mv_polynomial</span> <span class="n">J</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≡</span> <span class="n">C</span> <span class="bp">∘</span> <span class="n">r</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">]},</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="o">⟨</span><span class="n">rx</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">ry</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">rx</span> <span class="bp">+</span> <span class="n">ry</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">hx.add</span> <span class="n">hy</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">C_add</span> <span class="o">}⟩,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">smodeq.refl</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">C_0</span> <span class="o">}⟩</span> <span class="o">}</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">p</span><span class="o">}</span>
<span class="kd">lemma</span> <span class="n">mem_smodeq_C_add_submonoid_of_smodeq</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≡</span> <span class="n">y</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">])</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="n">smodeq_C_add_submonoid</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">smodeq_C_add_submonoid</span> <span class="n">p</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">h.symm.trans</span> <span class="n">hx</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">h.trans</span> <span class="n">hy</span><span class="o">⟩⟩</span>

<span class="c">/-</span><span class="cm"> compiles in about 8 seconds -/</span>
<span class="kd">lemma</span> <span class="n">exists_smodeq_of_X_exists_smodeq</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">,</span> <span class="n">pi.single</span> <span class="n">i</span> <span class="o">(</span><span class="n">X</span> <span class="n">j</span><span class="o">)</span> <span class="bp">≡</span> <span class="n">C</span> <span class="bp">∘</span> <span class="n">r</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">])</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≡</span> <span class="n">C</span> <span class="bp">∘</span> <span class="n">r</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">rw</span> <span class="n">pi_eq_sum_univ</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">finset.sum_induction</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span><span class="o">,</span> <span class="n">m</span> <span class="bp">≡</span> <span class="n">C</span> <span class="bp">∘</span> <span class="n">r</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">])</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">i</span> <span class="bp">-</span><span class="o">,</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">xi</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span><span class="o">,</span> <span class="n">pi.single</span> <span class="n">i</span> <span class="n">xi</span> <span class="bp">≡</span> <span class="n">C</span> <span class="bp">∘</span> <span class="n">r</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">this</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">),</span> <span class="n">use</span> <span class="n">r</span><span class="o">,</span> <span class="n">convert</span> <span class="n">hr</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">rw</span> <span class="n">pi.single_apply</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pi.smul_apply</span><span class="o">,</span> <span class="n">algebra.id.smul_eq_mul</span><span class="o">,</span> <span class="n">mul_boole</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">intro</span> <span class="n">xi</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">xi</span> <span class="bp">∈</span> <span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">algebra.mem_top</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">adjoin_range_X</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mul_one</span> <span class="n">xi</span><span class="o">,</span> <span class="bp">←</span> <span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">pi.single_smul'</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">smul_mem_induction</span> <span class="o">(</span><span class="n">smodeq_C_add_submonoid</span> <span class="n">p</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">this</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">pi.single</span> <span class="n">i</span> <span class="mi">1</span><span class="o">,</span> <span class="n">convert</span> <span class="n">smodeq.refl</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pi.single_apply</span><span class="o">,</span> <span class="n">apply_ite</span> <span class="n">C</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">C_1</span><span class="o">,</span> <span class="n">C_0</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">x</span> <span class="o">(⟨</span><span class="n">s</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span><span class="bp">|</span><span class="o">⟨</span><span class="n">j</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩)</span> <span class="n">m</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">use</span> <span class="n">s</span> <span class="bp">•</span> <span class="n">r</span><span class="o">,</span> <span class="n">convert</span> <span class="n">hr.smul</span> <span class="n">_</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">C_mul</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_smodeq_C_add_submonoid_of_smodeq</span> <span class="o">(</span><span class="n">hr.smul</span> <span class="bp">$</span> <span class="n">X</span> <span class="n">j</span><span class="o">),</span>
          <span class="n">pi_eq_sum_univ</span> <span class="o">(</span><span class="n">C</span> <span class="bp">∘</span> <span class="n">r</span><span class="o">),</span> <span class="n">finset.smul_sum</span><span class="o">],</span>
        <span class="n">apply</span> <span class="n">sum_mem</span><span class="o">,</span> <span class="n">rintro</span> <span class="n">i</span> <span class="bp">-</span><span class="o">,</span>
        <span class="n">obtain</span> <span class="o">⟨</span><span class="n">r'</span><span class="o">,</span> <span class="n">hr'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">use</span> <span class="n">r</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">r'</span><span class="o">,</span>
        <span class="n">convert</span> <span class="n">hr'.smul</span> <span class="o">(</span><span class="n">C</span> <span class="bp">$</span> <span class="n">r</span> <span class="n">i</span><span class="o">)</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pi.single_apply</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">pi.smul_apply</span><span class="o">,</span>
            <span class="n">algebra.id.smul_eq_mul</span><span class="o">,</span> <span class="n">mul_boole</span><span class="o">,</span> <span class="n">mul_ite</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">],</span>
          <span class="n">rw</span> <span class="o">[</span><span class="n">mul_one</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">],</span> <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">@</span><span class="n">eq_comm</span> <span class="n">_</span> <span class="n">i</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">C_mul</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">a</span> <span class="n">b</span> <span class="o">⟨</span><span class="n">ra</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">rb</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩,</span> <span class="n">use</span> <span class="n">ra</span> <span class="bp">+</span> <span class="n">rb</span><span class="o">,</span> <span class="n">convert</span> <span class="n">ha.add</span> <span class="n">hb</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">C_add</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="mi">0</span><span class="o">,</span> <span class="n">convert</span> <span class="n">smodeq.refl</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">C_0</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="292335139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golf%20request/near/292335139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golf.20request.html#292335139">(Aug 07 2022 at 19:20)</a>:</h4>
<p><span class="user-mention" data-user-id="439483">@Andrew Yang</span> <br>
Turns out this is not specific to <code>mv_polynomial</code> and any algebra over R works; I think maybe you can prove the <a href="https://stacks.math.columbia.edu/tag/0561">stacks#0561</a> result using the following directly without going through <code>mv_polynomial</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.subalgebra.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.smodeq</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">I</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">A</span> <span class="o">(</span><span class="n">I</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)}</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">algebra_map_comp_smul</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">r</span> <span class="bp">•</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">r</span> <span class="bp">•</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">∘</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">funext</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_mul</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">exists_smodeq_of_X_exists_smodeq</span> <span class="o">[</span><span class="n">finite</span> <span class="n">I</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">I</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">,</span> <span class="n">pi.single</span> <span class="n">i</span> <span class="n">x</span> <span class="bp">≡</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">∘</span> <span class="n">r</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">])</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">algebra.adjoin</span> <span class="n">R</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≡</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">∘</span> <span class="n">r</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">]</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">comp_left</span> <span class="n">I</span><span class="o">)</span><span class="bp">.</span><span class="n">srange.to_add_submonoid.smodeq_closure</span> <span class="n">p</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">q</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">R</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≡</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">∘</span> <span class="n">r</span> <span class="o">[</span><span class="n">SMOD</span> <span class="n">p</span><span class="o">]</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">rotate</span><span class="o">,</span> <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">hr</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="o">⟩</span> <span class="o">},</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">hr</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="n">casesI</span> <span class="n">nonempty_fintype</span> <span class="n">I</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hq</span><span class="o">,</span> <span class="n">pi_eq_sum_univ_single</span> <span class="n">x</span><span class="o">],</span>
  <span class="n">refine</span> <span class="bp">@</span><span class="n">finset.sum_induction</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">q.add_mem</span><span class="o">)</span> <span class="n">q.zero_mem</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">apply</span> <span class="n">subsemiring.smul_mem_of_mem_closure</span> <span class="n">q</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">hx</span> <span class="n">i</span><span class="o">)</span><span class="bp">;</span> <span class="n">simp_rw</span> <span class="n">hq</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">pi.single</span> <span class="n">i</span> <span class="mi">1</span><span class="o">,</span> <span class="n">convert</span> <span class="n">smodeq.refl</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pi.single_apply</span><span class="o">,</span> <span class="n">apply_ite</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">),</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">map_one</span><span class="o">,</span> <span class="n">map_zero</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="n">a</span> <span class="o">(⟨</span><span class="n">r'</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="bp">|</span> <span class="n">ha</span><span class="o">)</span> <span class="n">m</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">r'</span> <span class="bp">•</span> <span class="n">r</span><span class="o">,</span> <span class="n">rw</span> <span class="n">algebra_map_comp_smul</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hr.smul</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hq</span><span class="o">,</span> <span class="n">add_submonoid.mem_smodeq_closure_of_smodeq</span> <span class="n">_</span> <span class="o">(</span><span class="n">hr.smul</span> <span class="n">a</span><span class="o">),</span>
      <span class="n">pi_eq_sum_univ_single</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">∘</span> <span class="n">r</span><span class="o">),</span> <span class="n">finset.smul_sum</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">sum_mem</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">i</span> <span class="bp">-</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">r'</span><span class="o">,</span> <span class="n">hr'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">i</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hq</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">r</span> <span class="n">i</span> <span class="bp">•</span> <span class="n">r'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">smul_comm</span><span class="o">,</span> <span class="bp">←</span> <span class="n">pi.single_smul'</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">algebra_map_comp_smul</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">hr'.smul</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="292337396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/golf%20request/near/292337396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Luisitoon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/golf.20request.html#292337396">(Aug 07 2022 at 20:12)</a>:</h4>
<p>Hi, all! I am Luis from Barcelona! I am just trying to run Lean 3 on Debian-based Linux (Ubuntu) with VS Code and the Lean Infoview shows me the following error: "excessive memory consumption detected at expression traversal (potential solution: increase memory consumption threshold)". Have you ever got across this error? Everything is fine but this... (I have both Windows and Ubuntu on the laptop, everything runs perfectly on Windows, but not on Ubuntu...)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
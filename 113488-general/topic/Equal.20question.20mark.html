---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Equal.20question.20mark.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html">Equal question mark</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="230836178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230836178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Phiroc <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230836178">(Mar 18 2021 at 09:46)</a>:</h4>
<p>Hello,<br>
Does anyone know what the Lean equivalent of the Coq =? operator (<a href="https://coq.inria.fr/library/Coq.Init.Nat.html">https://coq.inria.fr/library/Coq.Init.Nat.html</a>) is?<br>
Many thanks.</p>



<a name="230837154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230837154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230837154">(Mar 18 2021 at 09:56)</a>:</h4>
<p>Do you mean a <code>bool</code> valued equality operator?</p>



<a name="230837160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230837160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230837160">(Mar 18 2021 at 09:56)</a>:</h4>
<p>You're asking about boolean equality on nats? In Lean we have this <code>decidable</code> typeclass which I think means that we can avoid this definition completely.</p>



<a name="230837165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230837165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230837165">(Mar 18 2021 at 09:56)</a>:</h4>
<p>We don't do it that way: <code>=</code> is <code>Prop</code> valued.</p>



<a name="230837175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230837175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230837175">(Mar 18 2021 at 09:56)</a>:</h4>
<p>and then as Kevin says :-)</p>



<a name="230837213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230837213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230837213">(Mar 18 2021 at 09:57)</a>:</h4>
<p><code>def nat.beq (m n : ℕ) := if m = n then tt else ff</code> . This compiles because equality on nats is decidable. But why would you need it in Lean? What is it used for in Coq? (I know very little about theorem provers in general, I should say)</p>



<a name="230837320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230837320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Phiroc <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230837320">(Mar 18 2021 at 09:58)</a>:</h4>
<p>I’ll give you an example from Sofware Foundations in a sec</p>



<a name="230837373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230837373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Phiroc <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230837373">(Mar 18 2021 at 09:58)</a>:</h4>
<p>Theorem plus_1_neq_0 : ∀ n : nat,<br>
  (n + 1) =? 0 = false.<br>
Proof.<br>
  intros n. destruct n as [| n'] eqn:E.</p>
<p>- reflexivity.<br>
  - reflexivity. Qed.<br>
Cf. <a href="https://softwarefoundations.cis.upenn.edu/lf-current/Basics.html">https://softwarefoundations.cis.upenn.edu/lf-current/Basics.html</a></p>



<a name="230837384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230837384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230837384">(Mar 18 2021 at 09:59)</a>:</h4>
<p>Also, if equality is decidable, it can be implicitly converted to bool (but as said, it's not idiomatic)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">b</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">3</span>
<span class="k">#print</span> <span class="n">b</span> <span class="c1">-- to_bool (2 = 3)</span>
<span class="k">#reduce</span> <span class="n">b</span> <span class="c1">-- ff</span>
</code></pre></div>



<a name="230837753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230837753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230837753">(Mar 18 2021 at 10:02)</a>:</h4>
<p>The example you give just makes me more confused. Why is it not just more sensible to prove <code>n + 1 ≠ 0</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">theorem</span> <span class="n">plus_one_ne_zeto</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I'm asking "what is the point of having a boolean equality" and your response is "because then we can prove theorems that involve boolean equalities, giving us twice as many theorems". I was hoping for a better answer in some sense.</p>



<a name="230838385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230838385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Phiroc <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230838385">(Mar 18 2021 at 10:07)</a>:</h4>
<p>I’m a newbie. I don’t know why they use that operator in the SF book. Let me think about it.</p>



<a name="230838407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230838407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230838407">(Mar 18 2021 at 10:07)</a>:</h4>
<p>aah, I see: is the point that after induction you can prove the result with <code>refl</code>? Such proofs are discouraged in Lean because we ran into situations where clever rewrites would do the job more quickly than laboriously reducing complex terms and checking for definitional equality. I think it might be a cultural issue here -- the mathlib community is not really focused on constructivism.</p>



<a name="230838852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230838852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Phiroc <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230838852">(Mar 18 2021 at 10:11)</a>:</h4>
<p>Although I am only at the beginning of the book, I’ve noticed that the Lean tactics to the SF theorems and exercises are often simpler than those provided by the authors.</p>



<a name="230838933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230838933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230838933">(Mar 18 2021 at 10:12)</a>:</h4>
<p>OK if you're not an expert then I will just leave you with the following comment. There is a <em>type</em> called <code>bool</code> with two terms <code>tt</code> and <code>ff</code> in Lean. I don't think I've ever used it. There is also a <em>Universe</em> called <code>Prop</code> which has a much richer structure, but if you believe in the law of the excluded middle and propositional extensionality then <code>Prop</code> and <code>bool</code> biject with each other. This proves that they are interchangeable unless you are a constructivist who does not believe in LEM. In Coq they take constructivism very seriously so perhaps have a prop-valued equality and a bool-valued one too. In mathlib, the biggest Lean development, we do not take constructivism particularly seriously, and the constructivists have the <code>decidable</code> typeclass which is doing the explicit translation between <code>Prop</code> and <code>bool</code> in cases where it can be done, but it's just more convenient when doing nonconstructive stuff to work in <code>Prop</code> because it is a richer environment, being  a universe and not just a type.</p>



<a name="230839112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230839112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Phiroc <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230839112">(Mar 18 2021 at 10:13)</a>:</h4>
<p>What is « constructivism »?</p>



<a name="230839454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Equal%20question%20mark/near/230839454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Equal.20question.20mark.html#230839454">(Mar 18 2021 at 10:16)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Intuitionistic_logic">https://en.wikipedia.org/wiki/Intuitionistic_logic</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
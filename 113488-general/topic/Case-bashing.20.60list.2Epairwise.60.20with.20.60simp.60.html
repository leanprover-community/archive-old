---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html">Case-bashing `list.pairwise` with `simp`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="211279304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211279304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211279304">(Sep 25 2020 at 16:15)</a>:</h4>
<p>Could this be a simp lemma?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">forall_or_imp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">q</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span><span class="o">,</span>

  <span class="k">have</span> <span class="n">ra</span> <span class="o">:=</span> <span class="n">a_1</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">ra</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">ra</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">qx</span><span class="o">,</span> <span class="n">a_1</span> <span class="n">x</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">qx</span><span class="o">)⟩,</span>
  <span class="n">cases</span> <span class="n">a_2</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">a_1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">a_2</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">a_1</span><span class="o">,</span> <span class="n">solve_by_elim</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="211279744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211279744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211279744">(Sep 25 2020 at 16:18)</a>:</h4>
<p>try <code>simp [or_imp_distrib]</code>?</p>



<a name="211279960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211279960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211279960">(Sep 25 2020 at 16:21)</a>:</h4>
<p>I think I need to take a step back here. Why is <code>simp</code> producing a less simple result than <code>simp [-list.mem_cons_iff]</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">list.pairwise.nil</span>

<span class="sd">/--</span>
<span class="sd">Fails with:</span>
<span class="sd">⊢ (R i₁ i₂ ∧ R i₁ i₃) ∧ R i₂ i₃ ↔</span>
<span class="sd">    (∀ (a' : α), a' = i₂ ∨ a' = i₃ → R i₁ a') ∧ R i₂ i₃ -/</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">i₁</span> <span class="n">i₂</span> <span class="n">i₃</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">R</span> <span class="n">i₁</span> <span class="n">i₂</span> <span class="bp">∧</span> <span class="n">R</span> <span class="n">i₁</span> <span class="n">i₃</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">R</span> <span class="n">i₂</span> <span class="n">i₃</span> <span class="bp">↔</span> <span class="o">[</span><span class="n">i₁</span><span class="o">,</span> <span class="n">i₂</span><span class="o">,</span> <span class="n">i₃</span><span class="o">]</span><span class="bp">.</span><span class="n">pairwise</span> <span class="n">R</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span>

<span class="sd">/-- succeeds, list.mem_cons_iff would not match the final goal anyway -/</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">i₁</span> <span class="n">i₂</span> <span class="n">i₃</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">R</span> <span class="n">i₁</span> <span class="n">i₂</span> <span class="bp">∧</span> <span class="n">R</span> <span class="n">i₁</span> <span class="n">i₃</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">R</span> <span class="n">i₂</span> <span class="n">i₃</span> <span class="bp">↔</span> <span class="o">[</span><span class="n">i₁</span><span class="o">,</span> <span class="n">i₂</span><span class="o">,</span> <span class="n">i₃</span><span class="o">]</span><span class="bp">.</span><span class="n">pairwise</span> <span class="n">R</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">-</span><span class="n">list.mem_cons_iff</span><span class="o">]</span>
</code></pre></div>



<a name="211280657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211280657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211280657">(Sep 25 2020 at 16:26)</a>:</h4>
<p><code>squeeze_simp</code> reveals the difference is</p>
<div class="codehilite" data-code-language="Diff"><pre><span></span><code> example {α : Type} {R : α → α → Prop} {i₁ i₂ i₃ : α} : (R i₁ i₂ ∧ R i₁ i₃) ∧ R i₂ i₃ ↔ [i₁, i₂, i₃].pairwise R :=
 by {
   simp only [list.not_mem_nil, and_true, forall_prop_of_false, list.pairwise.nil, forall_eq, not_false_iff, list.pairwise_cons, forall_true_iff,
<span class="gd">-      list.mem_cons_iff, list.mem_singleton, and_self],</span>
<span class="gi">+      list.ball_cons],</span>
 }
</code></pre></div>

<p>Is <code>list.ball_cons</code> somehow lower priority than <code>list.mem_cons_iff</code>?</p>



<a name="211283476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211283476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211283476">(Sep 25 2020 at 16:48)</a>:</h4>
<p>just a sanity check--<code>forall_mem_cons</code> is the same as <code>ball_cons</code> modulo binder types and being a simp lemma or not, right?</p>



<a name="211283629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211283629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211283629">(Sep 25 2020 at 16:49)</a>:</h4>
<p>Let's check...: <a href="https://leanprover-community.github.io/mathlib_docs/find/list.forall_mem_cons">docs#list.forall_mem_cons</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/list.ball_cons">docs#list.ball_cons</a></p>



<a name="211283848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211283848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211283848">(Sep 25 2020 at 16:51)</a>:</h4>
<p>It looks like the problem is that <code>list.ball_cons</code> is a simp lemma whose LHS is not in simp-normal form (it can be rewritten by <a href="https://leanprover-community.github.io/mathlib_docs/find/list.mem_cons_iff">docs#list.mem_cons_iff</a>, which is another simp lemma)</p>



<a name="211283907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211283907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211283907">(Sep 25 2020 at 16:51)</a>:</h4>
<p>Which presumably the linter misses because it's part of core and not mathlib?</p>



<a name="211284284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211284284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211284284">(Sep 25 2020 at 16:54)</a>:</h4>
<p>I'm a bit confused because I thought that <code>simp</code> generally operates from the outside in, so it should apply <code>list.ball_cons</code> before <code>list.mem_cons_iff</code> anyways</p>



<a name="211292663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211292663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211292663">(Sep 25 2020 at 18:03)</a>:</h4>
<p>I'm quite sure simp operates from the inside out.</p>



<a name="211292797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211292797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211292797">(Sep 25 2020 at 18:04)</a>:</h4>
<p>Yes, see e.g. <a href="#narrow/stream/113488-general/topic/Simp.20normal.20form/near/188829903">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simp.20normal.20form/near/188829903</a></p>



<a name="211309111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211309111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211309111">(Sep 25 2020 at 19:49)</a>:</h4>
<p>So is the conclusion is that the lean core simp lemma is bad?</p>



<a name="211309736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211309736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211309736">(Sep 25 2020 at 19:54)</a>:</h4>
<p>Hmm, I see. Well, in any case this ordering is not something that can be affected by priorities.</p>



<a name="211317901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211317901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211317901">(Sep 25 2020 at 21:05)</a>:</h4>
<p>I think the thing to do is:</p>
<ul>
<li>Remove the bad simp lemma from core</li>
<li>Add the simp lemma I have above so that the lemma in core is just <code>by simp</code> anyway.</li>
</ul>



<a name="211317967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211317967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211317967">(Sep 25 2020 at 21:06)</a>:</h4>
<p>Will try next week</p>



<a name="211326521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211326521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211326521">(Sep 25 2020 at 22:48)</a>:</h4>
<p>I ran the <code>simp_nf</code> linter on core, here is the output:<br>
<a href="https://github.com/leanprover-community/mathlib/runs/1167546135">https://github.com/leanprover-community/mathlib/runs/1167546135</a><br>
I couldn't find the offending lemma in there (but maybe it's one of the other simp linters that finds it?) <br>
If you are fixing core, it would be great if you also fix some of the other lemmas caught by the linter.</p>



<a name="211326538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211326538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211326538">(Sep 25 2020 at 22:48)</a>:</h4>
<p>I'm now running other linters also on core (but not the ones that produce output in mathlib): <a href="https://github.com/leanprover-community/mathlib/runs/1168317987">https://github.com/leanprover-community/mathlib/runs/1168317987</a></p>



<a name="211326943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211326943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211326943">(Sep 25 2020 at 22:54)</a>:</h4>
<p>Looks like you'll want to remove the <code>-T100000</code> here <a href="https://github.com/leanprover-community/mathlib/blob/master/.github/workflows/build.yml#L54">https://github.com/leanprover-community/mathlib/blob/master/.github/workflows/build.yml#L54</a></p>



<a name="211329978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211329978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211329978">(Sep 25 2020 at 23:47)</a>:</h4>
<p>I don't think we should remove any involved simp lemmas</p>



<a name="211330042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211330042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211330042">(Sep 25 2020 at 23:48)</a>:</h4>
<p>It's not ideal, but I think it is better to have a non-confluent set of simp lemmas than to have a weak set</p>



<a name="211330066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211330066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211330066">(Sep 25 2020 at 23:48)</a>:</h4>
<p>the real problem here is that we use <code>\forall x \in l, p x</code> to represent the operator one might write as <code>all p l</code></p>



<a name="211330094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211330094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211330094">(Sep 25 2020 at 23:49)</a>:</h4>
<p>This operator is in some sense dual to <code>list.mem</code>, defined using and instead of or</p>



<a name="211348790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211348790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211348790">(Sep 26 2020 at 08:11)</a>:</h4>
<p>The <code>simp_nf</code>does not check confluence, but whether other simp lemmas first simplify a subexpression of the LHS before this simp lemma has a chance of firing. Therefore, all positives of the <code>simp_nf</code> lemmas are simp lemmas that never fire. See <a href="https://leanprover-community.github.io/mathlib_docs/notes.html#simp-normal%20form">https://leanprover-community.github.io/mathlib_docs/notes.html#simp-normal%20form</a></p>



<a name="211351106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211351106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211351106">(Sep 26 2020 at 09:16)</a>:</h4>
<p>Never fire unless the overlapping lemma is excluded via <code>-</code>, as in my example</p>



<a name="211358733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211358733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211358733">(Sep 26 2020 at 12:53)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> I'm not exactly sure who you are responding to, but it is not true that <code>list.mem_cons_iff'</code> never fires. It is non-confluent but the LHS is in simp normal form</p>



<a name="211358787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211358787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211358787">(Sep 26 2020 at 12:54)</a>:</h4>
<p>the problem is that while the LHS of <code>list.mem_cons_iff'</code> itself is in simp normal form, there are instantiations of the LHS (with simp normal terms) that are not in simp normal form</p>



<a name="211358810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211358810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211358810">(Sep 26 2020 at 12:55)</a>:</h4>
<p>I think <code>list.ball_cons</code> is the lemma in question</p>



<a name="211358850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211358850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211358850">(Sep 26 2020 at 12:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="k">#print</span> <span class="n">list.bex_cons</span> <span class="c">/-</span><span class="cm"> Left-hand side simplifies from</span>
<span class="cm">  ∃ (x : α) (H : x ∈ a :: l), p x</span>
<span class="cm">to</span>
<span class="cm">  ∃ (x : α), (x = a ∨ x ∈ l) ∧ p x</span>
<span class="cm">using</span>
<span class="cm">  [exists_prop, list.mem_cons_iff]</span>
<span class="cm">Try to change the left-hand side to the simplified term!</span>
<span class="cm"> -/</span>
<span class="k">#print</span> <span class="n">list.ball_cons</span> <span class="c">/-</span><span class="cm"> simp can prove this:</span>
<span class="cm">  by simp only [list.mem_cons_iff, list.forall_mem_cons']</span>
<span class="cm">One of the lemmas above could be a duplicate.</span>
<span class="cm">If that's not the case try reordering lemmas or adding @[priority].</span>
<span class="cm"> -/</span>
</code></pre></div>



<a name="211358859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211358859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211358859">(Sep 26 2020 at 12:56)</a>:</h4>
<p>oh, that's just <code>list.mem_cons_iff</code> by another name</p>



<a name="211358863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211358863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211358863">(Sep 26 2020 at 12:56)</a>:</h4>
<p>maybe the "simp can prove this" linter caught it first?</p>



<a name="211358877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211358877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211358877">(Sep 26 2020 at 12:57)</a>:</h4>
<p>Exactly</p>



<a name="211358946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211358946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211358946">(Sep 26 2020 at 12:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60/near/211358859">said</a>:</p>
<blockquote>
<p>oh, that's just <code>list.mem_cons_iff</code> by another name</p>
</blockquote>
<p>Can we remove one of the names to make this less confusing?</p>



<a name="211359032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211359032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211359032">(Sep 26 2020 at 13:00)</a>:</h4>
<p>To be fair, this is a cross-repo simp incoherence, so it's not like we can point a finger at any particular lemma</p>



<a name="211359039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211359039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211359039">(Sep 26 2020 at 13:00)</a>:</h4>
<p>we could unset the simp attribute from those lemmas in <code>data.list.basic</code></p>



<a name="211359060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211359060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211359060">(Sep 26 2020 at 13:01)</a>:</h4>
<p>That's a good idea- what's the syntax for removing an attribute?</p>



<a name="211359071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211359071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211359071">(Sep 26 2020 at 13:01)</a>:</h4>
<p><code>attribute [-simp] list.ball_cons</code></p>



<a name="211359073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211359073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211359073">(Sep 26 2020 at 13:02)</a>:</h4>
<p>actually you might not be able to</p>



<a name="211359115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211359115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211359115">(Sep 26 2020 at 13:02)</a>:</h4>
<p>I don't think that works for non-local unsets</p>



<a name="211359459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211359459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211359459">(Sep 26 2020 at 13:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60/near/211283476">said</a>:</p>
<blockquote>
<p>just a sanity check--<code>forall_mem_cons</code> is the same as <code>ball_cons</code> modulo binder types and being a simp lemma or not, right?</p>
</blockquote>
<p>Opened <a href="https://github.com/leanprover-community/mathlib/issues/4279">#4279</a> to make this obvious from the source code</p>



<a name="211359912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211359912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211359912">(Sep 26 2020 at 13:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60/near/211279304">said</a>:</p>
<blockquote>
<p>Could this be a simp lemma?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">forall_eq_or_imp</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">q</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">q</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>

</blockquote>
<p>Opened <a href="https://github.com/leanprover-community/mathlib/issues/4281">#4281</a> to find out.</p>



<a name="211382407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211382407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211382407">(Sep 26 2020 at 20:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60/near/211358733">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> I'm not exactly sure who you are responding to, but it is not true that <code>list.mem_cons_iff'</code> never fires. It is non-confluent but the LHS is in simp normal form</p>
</blockquote>
<p>I was responding to you, under the assumption you were responding to me. :-) <br>
I agree that we should not remove simp lemmas just to keep things confluent, but we should remove simp lemmas in core flagged by the linter.</p>



<a name="211383712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Case-bashing%20%60list.pairwise%60%20with%20%60simp%60/near/211383712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Case-bashing.20.60list.2Epairwise.60.20with.20.60simp.60.html#211383712">(Sep 26 2020 at 21:35)</a>:</h4>
<p>What's the right way to deal with core having a simp lemma from <code>A -&gt; C</code> and mathlib introducing two new ones from <code>A -&gt; B</code> and <code>B -&gt; C</code>? Put both new lemmas in core? Remove the annotation retroactively in mathlib?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
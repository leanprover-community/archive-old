---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Fix.20induction.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html">Fix induction</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="272344730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272344730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272344730">(Feb 18 2022 at 00:35)</a>:</h4>
<p>Looking at the recursion principle for the fixpoint operator <a href="https://leanprover-community.github.io/mathlib_docs/find/fix_induction">docs#fix_induction</a>, we have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fix_induction</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→.</span> <span class="n">β</span> <span class="bp">⊕</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a'</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a'</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">a''</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a''</span> <span class="bp">→</span> <span class="n">sum.inr</span> <span class="n">a''</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a''</span><span class="o">)</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span>
</code></pre></div>
<p>It seems like an easier to understand and more useful principle would be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">inheriting_from_chains</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→.</span> <span class="n">β</span> <span class="bp">⊕</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hbase</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a_final</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">sum.inl</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a_final</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_final</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hind</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a_0</span> <span class="n">a_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">sum.inr</span> <span class="n">a_1</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a_0</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_1</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_0</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span>
</code></pre></div>
<p>But I'm finding it hard to prove the latter from the former. Is there a particular reason why the latter isn't provided?</p>



<a name="272344836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272344836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272344836">(Feb 18 2022 at 00:37)</a>:</h4>
<p>This is a very <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> question.</p>



<a name="272344973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272344973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272344973">(Feb 18 2022 at 00:38)</a>:</h4>
<p>Yeah, I guess I'm thrown for a loop by this forall within an implication within a forall in a hypothesis. I have a hard time even getting it straight in my head what the first lemma is saying.</p>



<a name="272345004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345004">(Feb 18 2022 at 00:39)</a>:</h4>
<p>Note that I've edited it to remove the reuse of the variable <code>a</code>.</p>



<a name="272345012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345012">(Feb 18 2022 at 00:39)</a>:</h4>
<p>I remember writing the docstring for that recursor. Although I didn't end up saying much, I think I understood it at some point.</p>



<a name="272345285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345285">(Feb 18 2022 at 00:42)</a>:</h4>
<p>Okay so the problem I see with your recursor is that it requires too strong of an hypothesis. It asks for stuff about branches that never fix.</p>



<a name="272345357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345357">(Feb 18 2022 at 00:44)</a>:</h4>
<p>Ok, can you give me an example of something you can prove with the first one but not the second?</p>



<a name="272345429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345429">(Feb 18 2022 at 00:44)</a>:</h4>
<p>No, the opposite.</p>



<a name="272345504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345504">(Feb 18 2022 at 00:45)</a>:</h4>
<p>Or are you telling you managed to prove <code>inheriting_from_chains</code> from <code>fix_induction</code>? I think that's impossible.</p>



<a name="272345573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345573">(Feb 18 2022 at 00:46)</a>:</h4>
<p>I haven't managed to prove the second one, but I think it's true and I want it</p>



<a name="272345622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345622">(Feb 18 2022 at 00:47)</a>:</h4>
<p>At first I thought I would be able to prove it from <code>induction_fix</code> by just using a bunch of apply statements, but somehow I can't</p>



<a name="272345634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345634">(Feb 18 2022 at 00:47)</a>:</h4>
<p>Argh sorry I am the one who is confused. <code>inheriting_from_chains</code> is certainly true, but you can't prove <code>fix_induction</code> from it.</p>



<a name="272345670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345670">(Feb 18 2022 at 00:47)</a>:</h4>
<p>Ok, I believe you but I don't see why</p>



<a name="272345715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345715">(Feb 18 2022 at 00:48)</a>:</h4>
<p>I think Bolton wants to go the other way round, Yael</p>



<a name="272345736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345736">(Feb 18 2022 at 00:48)</a>:</h4>
<p>Yeah, and I think this is possible.</p>



<a name="272345767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345767">(Feb 18 2022 at 00:48)</a>:</h4>
<p>Right, I would like to prove inheriting _from_chains using fix_induction</p>



<a name="272345846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272345846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272345846">(Feb 18 2022 at 00:49)</a>:</h4>
<p>Hmm, maybe I need to use <code>mem_fix_iff</code>?</p>



<a name="272346002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272346002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272346002">(Feb 18 2022 at 00:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">inheriting_predicates</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→.</span> <span class="n">β</span> <span class="bp">⊕</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hbase</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a_final</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">sum.inl</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a_final</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_final</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hind</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a_0</span> <span class="n">a_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">sum.inr</span> <span class="n">a_1</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a_0</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_1</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_0</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">fix_induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a'</span> <span class="n">hba'</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">clear</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_fix_iff</span> <span class="n">at</span> <span class="n">hba'</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hba'</span><span class="o">,</span><span class="c1">-- induction tactic failed, recursor 'or.dcases_on' can only eliminate into Prop</span>

<span class="kd">end</span>
</code></pre></div>



<a name="272346119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272346119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272346119">(Feb 18 2022 at 00:52)</a>:</h4>
<p>You have <code>lemma ... : C a</code> but <code>C : α → Sort*</code>--is that what you wanted?</p>



<a name="272346143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272346143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272346143">(Feb 18 2022 at 00:53)</a>:</h4>
<p>Well, I don't really care about proving it for Sorts, let me switch to Prop</p>



<a name="272346151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272346151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272346151">(Feb 18 2022 at 00:53)</a>:</h4>
<p>Probably <code>C : α → Prop</code>, because it won't be able to construct data anymore anyway.</p>



<a name="272346545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272346545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272346545">(Feb 18 2022 at 00:58)</a>:</h4>
<p><del>This is as far as I get</del> Got it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">inheriting_predicates</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→.</span> <span class="n">β</span> <span class="bp">⊕</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hbase</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a_final</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">sum.inl</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a_final</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_final</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hind</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a_0</span> <span class="n">a_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">sum.inr</span> <span class="n">a_1</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a_0</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_1</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_0</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">fix_induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a'</span> <span class="n">hba'</span> <span class="n">H</span><span class="o">,</span>
  <span class="c1">-- clear H,</span>
  <span class="n">rw</span> <span class="n">mem_fix_iff</span> <span class="n">at</span> <span class="n">hba'</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hba'</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">hbase</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hba'</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">hba'</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hind</span> <span class="n">a'</span> <span class="n">hba'_w</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hba'_h.left</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hba'_h.right</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hba'_h.left</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="272347275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272347275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272347275">(Feb 18 2022 at 01:08)</a>:</h4>
<p>(I'm dumb, you actually do need H)</p>



<a name="272347642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272347642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272347642">(Feb 18 2022 at 01:14)</a>:</h4>
<p>Now for my own edification: Why is it impossible to prove <code>fix_induction</code> from <code>inheriting_from_chains</code>?</p>



<a name="272347672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272347672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272347672">(Feb 18 2022 at 01:15)</a>:</h4>
<p>Or is it only that <code>inheriting</code> uses Prop?</p>



<a name="272348574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272348574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272348574">(Feb 18 2022 at 01:29)</a>:</h4>
<p>I think they are equivalent</p>



<a name="272350094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272350094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272350094">(Feb 18 2022 at 01:52)</a>:</h4>
<p>Proving the reverse direction is annoying because you don't have the <code>b ∈ f.fix a'</code> assumption in the hypotheses</p>



<a name="272350505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272350505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272350505">(Feb 18 2022 at 01:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.pfun</span>

<span class="kn">namespace</span> <span class="n">pfun</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">@[elab_as_eliminator]</span>
<span class="kd">def</span> <span class="n">inheriting_from_chains</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→.</span> <span class="n">β</span> <span class="bp">⊕</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hbase</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a_final</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">sum.inl</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a_final</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_final</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hind</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a_0</span> <span class="n">a_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">sum.inr</span> <span class="n">a_1</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a_0</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_1</span> <span class="bp">-&gt;</span> <span class="n">C</span> <span class="n">a_0</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">fix_induction</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a'</span> <span class="n">h</span> <span class="n">ih</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">e</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="n">a'</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="o">(</span><span class="n">dom_of_mem_fix</span> <span class="n">h</span><span class="o">)</span> <span class="k">with</span> <span class="n">b'</span> <span class="n">a''</span><span class="bp">;</span> <span class="n">replace</span> <span class="n">e</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a'</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">b'</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="n">h''</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h''</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_fix_iff.1</span> <span class="n">h</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">part.mem_unique</span> <span class="n">e</span> <span class="n">h''</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="n">subst</span> <span class="n">this</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hbase</span> <span class="n">_</span> <span class="n">e</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a''</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="n">h''</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h''</span><span class="o">,</span> <span class="n">e'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_fix_iff.1</span> <span class="n">h</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">part.mem_unique</span> <span class="n">e</span> <span class="n">h''</span><span class="o">,</span> <span class="n">exact</span> <span class="n">e'</span> <span class="o">},</span>
    <span class="n">refine</span> <span class="n">hind</span> <span class="n">_</span> <span class="n">_</span> <span class="n">e</span> <span class="o">(</span><span class="n">ih</span> <span class="n">_</span> <span class="n">this</span> <span class="n">e</span><span class="o">)</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">@[elab_as_eliminator]</span>
<span class="kd">def</span> <span class="n">fix_induction'</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→.</span> <span class="n">β</span> <span class="bp">⊕</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a'</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a'</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">a''</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a''</span> <span class="bp">→</span> <span class="n">sum.inr</span> <span class="n">a''</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a''</span><span class="o">)</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span> <span class="n">revert</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">inheriting_from_chains</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a'</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a'</span> <span class="n">a''</span> <span class="n">h</span> <span class="n">ih</span> <span class="n">h'</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">H</span> <span class="n">_</span> <span class="o">(</span><span class="n">mem_fix_iff.2</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">h</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a₂</span> <span class="n">_</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">cases</span> <span class="n">part.mem_unique</span> <span class="n">h</span> <span class="n">h₂</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">H</span> <span class="n">_</span> <span class="n">h'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a₂</span> <span class="n">h₂</span> <span class="n">e</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">cases</span> <span class="n">part.mem_unique</span> <span class="n">h</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="n">h''</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h''</span><span class="o">,</span> <span class="n">e'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_fix_iff.1</span> <span class="n">h'</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">part.mem_unique</span> <span class="n">h</span> <span class="n">h''</span><span class="o">,</span> <span class="n">exact</span> <span class="n">e'</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">pfun</span>
</code></pre></div>



<a name="272350565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272350565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272350565">(Feb 18 2022 at 01:59)</a>:</h4>
<p>There should probably be a simpler to use version of <code>mem_fix_iff</code> in the case where you know <code>f</code> has a next element</p>



<a name="272351058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Fix%20induction/near/272351058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Fix.20induction.html#272351058">(Feb 18 2022 at 02:05)</a>:</h4>
<p>Here's a version that adds the fix assumption in <code>inheriting_from_chains</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.pfun</span>

<span class="kn">namespace</span> <span class="n">pfun</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">@[elab_as_eliminator]</span>
<span class="kd">def</span> <span class="n">inheriting_from_chains</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→.</span> <span class="n">β</span> <span class="bp">⊕</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hbase</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a_final</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">sum.inl</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a_final</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a_final</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hind</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a_0</span> <span class="n">a_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a_1</span> <span class="bp">→</span> <span class="n">sum.inr</span> <span class="n">a_1</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a_0</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a_1</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a_0</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">fix_induction</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a'</span> <span class="n">h</span> <span class="n">ih</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">e</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="n">a'</span><span class="o">)</span><span class="bp">.</span><span class="n">get</span> <span class="o">(</span><span class="n">dom_of_mem_fix</span> <span class="n">h</span><span class="o">)</span> <span class="k">with</span> <span class="n">b'</span> <span class="n">a''</span><span class="bp">;</span> <span class="n">replace</span> <span class="n">e</span> <span class="o">:</span> <span class="n">_</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a'</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">b'</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="n">h''</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h''</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_fix_iff.1</span> <span class="n">h</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">part.mem_unique</span> <span class="n">e</span> <span class="n">h''</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="n">subst</span> <span class="n">this</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hbase</span> <span class="n">_</span> <span class="n">e</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a''</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">obtain</span> <span class="n">h''</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">h''</span><span class="o">,</span> <span class="n">e'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_fix_iff.1</span> <span class="n">h</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">part.mem_unique</span> <span class="n">e</span> <span class="n">h''</span><span class="o">,</span> <span class="n">exact</span> <span class="n">e'</span> <span class="o">},</span>
    <span class="n">refine</span> <span class="n">hind</span> <span class="n">_</span> <span class="n">_</span> <span class="n">this</span> <span class="n">e</span> <span class="o">(</span><span class="n">ih</span> <span class="n">_</span> <span class="n">this</span> <span class="n">e</span><span class="o">)</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">@[elab_as_eliminator]</span>
<span class="kd">def</span> <span class="n">fix_induction'</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→.</span> <span class="n">β</span> <span class="bp">⊕</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a'</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a'</span> <span class="bp">→</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">a''</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">f.fix</span> <span class="n">a''</span> <span class="bp">→</span> <span class="n">sum.inr</span> <span class="n">a''</span> <span class="bp">∈</span> <span class="n">f</span> <span class="n">a'</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a''</span><span class="o">)</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">a'</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">inheriting_from_chains</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a'</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a'</span> <span class="n">a''</span> <span class="n">h'</span> <span class="n">h</span> <span class="n">ih</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">H</span> <span class="n">_</span> <span class="o">(</span><span class="n">mem_fix_iff.2</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">h</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a₂</span> <span class="n">_</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">cases</span> <span class="n">part.mem_unique</span> <span class="n">h</span> <span class="n">h₂</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">H</span> <span class="n">_</span> <span class="o">(</span><span class="n">mem_fix_iff.2</span> <span class="o">(</span><span class="n">or.inr</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a₂</span> <span class="n">h₂</span> <span class="n">e</span><span class="o">,</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">cases</span> <span class="n">part.mem_unique</span> <span class="n">h</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">ih</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">pfun</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
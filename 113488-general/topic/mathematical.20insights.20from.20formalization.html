---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/mathematical.20insights.20from.20formalization.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html">mathematical insights from formalization</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="314065113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314065113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314065113">(Dec 05 2022 at 15:53)</a>:</h4>
<p>On Wednesday, I'll be giving a talk in a Mathematical Components workshop (<a href="https://mathcomp-schools.gitlabpages.inria.fr/2022-12-school/">https://mathcomp-schools.gitlabpages.inria.fr/2022-12-school/</a>). I expect that many of the participants will be from the computer science community, and since there have historically been tensions between the mathematical and computer science communities over formalization, I'd like to take the opportunity to say something about how mathematicians think differently from computer scientists.</p>
<p>One difference I have noticed is that when computer scientists review a formalization paper, they expect to hear a lot about the encodings, representations, and formalization tricks that were used -- the "design decisions." Mathematicians tend to focus instead on the mathematical insights when they write papers about formalization. To computer scientists, that often looks like they are just repeating standard and well-known mathematical definitions and theorems.</p>
<p>I'd like to give a list of examples of mathematical insights that have come out of formalization, or, least, formalization insights that have more of a mathematical flavor than a computer science one. Below is the list I came up with. I am curious to hear what others think of the list, and what they might add.</p>
<ul>
<li>Filters are the right way to deal with topological limits.</li>
<li>The Bochner integral and the Frechet derivative are just the right level of generality.</li>
<li>Uniform spaces are useful (generalizing both metric spaces and topological groups).</li>
<li>Embeddings and homomorphic images often work better than subsets and substructures.</li>
<li>There are lots of ways of formalizing the notion of a sheaf. Some work better than others.</li>
<li>If K is a field extension of F, it is often better to treat K as an F-algebra (especially with towers of extensions).</li>
<li>It's possible to unify real and complex inner product spaces with the right type class.</li>
<li>Semilinear maps are a useful generalization of linear maps and conjugate linear maps.</li>
<li>Manifolds with corners are better than manifolds with boundary.</li>
</ul>
<p>Note that I am not claiming that these originated with Lean. Filters were used by Hölzl, Immler, and Huffmann in Isabelle, and also by Beeson and Wiedijk in the context of a algebra system; the idea goes back to Bourbaki. In Lean, we also took the Bochner integral and the Frechet derivative from Isabelle, as well as the <code>is_R_or_C</code> type class.</p>



<a name="314065441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314065441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314065441">(Dec 05 2022 at 15:55)</a>:</h4>
<p>The Commelin complex? Although iirc that was found to have alredy been discovered before</p>



<a name="314066011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314066011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314066011">(Dec 05 2022 at 15:58)</a>:</h4>
<p>Meta-formalization: how about the impact of CI/CD for communication of results, both internal and external? This topic, in my mind, rhymes with the impact of LaTeX.</p>



<a name="314066651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314066651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314066651">(Dec 05 2022 at 16:01)</a>:</h4>
<p>I will also talk about LTE, and quote Scholze on an insight he had from the formalization. And I will also say a lot about the controlled chaos of the Lean community and how well it works.</p>



<a name="314067535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314067535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314067535">(Dec 05 2022 at 16:04)</a>:</h4>
<p>I would remove</p>
<ul>
<li>If <code>K</code> is a field extension of <code>F</code>, it is often better to treat <code>K</code> as an <code>F</code>-algebra (especially with towers of extensions)</li>
</ul>
<p>This is surely true, but it has nothing to do with formalization, it's just something we all know, even if often we write proofs at the blackboard like <code>F</code> is a subset of <code>K</code> (for example I've discussed how to do this in teaching before having heard abut Lean). It's like the fact that <code>ℕ</code> is not a subset of <code>ℤ</code>, we know it, and when Lean recalls it to us it's only annoying, not useful.</p>



<a name="314067591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314067591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314067591">(Dec 05 2022 at 16:05)</a>:</h4>
<p>IIRC <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> has been working with others on cleaning up something involving manifolds or differential geometry or something like that -- does anyone know the details?</p>



<a name="314068403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314068403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314068403">(Dec 05 2022 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113488-general/topic/mathematical.20insights.20from.20formalization/near/314067535">said</a>:</p>
<blockquote>
<p>I would remove</p>
<ul>
<li>If <code>K</code> is a field extension of <code>F</code>, it is often better to treat <code>K</code> as an <code>F</code>-algebra (especially with towers of extensions)</li>
</ul>
<p>This is surely true, but it has nothing to do with formalization, it's just something we all know, even if often we write proofs at the blackboard like <code>F</code> is a subset of <code>K</code> (for example I've discussed how to do this in teaching before having heard abut Lean). It's like the fact that <code>ℕ</code> is not a subset of <code>ℤ</code>, we know it, and when Lean recalls it to us it's only annoying, not useful.</p>
</blockquote>
<p>I disagree with this. It is very much not obvious to what degree you can take seriously the assertion that field extensions are always subset relations and work everything into that framework. It clearly works for paper mathematics, so why not in the computer? For systems like lean where literal subsetting isn't really an option it doesn't matter that much, but if you are working in a ZFC based system it is a very real possibility to do things in this way.</p>



<a name="314068421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314068421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314068421">(Dec 05 2022 at 16:08)</a>:</h4>
<p>Riccardo, a long time ago I saw Kevin Buzzard give a talk about the difficulties of mediating between Q[sqrt2][sqrt3] and Q[sqrt 3][sqrt 2] and Q[sqrt 2, sqrt 3]. My understanding is that it took Baanen and others some experimentation to come up with a nice way of doing class field theory. Most of the examples I listed involve things that are well known from a mathematical standpoint. The insights are that they are a good way of organizing and presenting the material, especially from the point of view of formalization.</p>



<a name="314069288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314069288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314069288">(Dec 05 2022 at 16:12)</a>:</h4>
<p>Maybe I was not clear: I am not saying extensions should be considered as inclusions, but quite the opposite.</p>
<p>The difference with, say, filters is that we're able to talk about limits without using filters, and formalization force us to have a more general notion. I don't think anyone has seriously tried to study field theory using inclusions.</p>



<a name="314069711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314069711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314069711">(Dec 05 2022 at 16:14)</a>:</h4>
<p>No I understood that. What I'm saying is that extensions as inclusions is a very obvious thing if you look at the way paper mathematics is done, and it is a hard won lesson to discover that it's not a good idea.</p>



<a name="314069735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314069735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314069735">(Dec 05 2022 at 16:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/mathematical.20insights.20from.20formalization/near/314068403">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/113488-general/topic/mathematical.20insights.20from.20formalization/near/314067535">said</a>:</p>
<blockquote>
<p>I would remove</p>
<ul>
<li>If <code>K</code> is a field extension of <code>F</code>, it is often better to treat <code>K</code> as an <code>F</code>-algebra (especially with towers of extensions)</li>
</ul>
<p>This is surely true, but it has nothing to do with formalization, it's just something we all know, even if often we write proofs at the blackboard like <code>F</code> is a subset of <code>K</code> (for example I've discussed how to do this in teaching before having heard abut Lean). It's like the fact that <code>ℕ</code> is not a subset of <code>ℤ</code>, we know it, and when Lean recalls it to us it's only annoying, not useful.</p>
</blockquote>
<p>I disagree with this. It is very much not obvious to what degree you can take seriously the assertion that field extensions are always subset relations and work everything into that framework. It clearly works for paper mathematics, so why not in the computer? For systems like lean where literal subsetting isn't really an option it doesn't matter that much, but if you are working in a ZFC based system it is a very real possibility to do things in this way.</p>
</blockquote>
<p>I don't think "it clearly works on paper". It works because we are good in filling the holes when reading mathematics. If Lean were able to do the same, then I would say <em>this</em> is a good thing</p>



<a name="314069906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314069906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314069906">(Dec 05 2022 at 16:15)</a>:</h4>
<p>It definitely works on paper. Every field extension is isomorphic to a subset, so everything transfers and you're done</p>



<a name="314070223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314070223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314070223">(Dec 05 2022 at 16:16)</a>:</h4>
<p>Sure, it's the "everything transfers" part that we are very good in doing. In any case I agree that in Lean it would be much more painful to transfer everything.</p>



<a name="314070697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314070697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314070697">(Dec 05 2022 at 16:19)</a>:</h4>
<p>but you don't know to focus on that part of the claim unless you have some formalization experience under your belt already</p>



<a name="314071087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314071087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314071087">(Dec 05 2022 at 16:20)</a>:</h4>
<p>this "do what I mean, not what I say" business is very tricky for formalizers who aren't experts already</p>



<a name="314082743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314082743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314082743">(Dec 05 2022 at 17:14)</a>:</h4>
<p>Here is a quick personal story (and a shameless plug): A little while ago I formalized the proof of a somewhat technical result from my area of research here: <a href="https://github.com/adamtopaz/lean-acl-pairs">https://github.com/adamtopaz/lean-acl-pairs</a><br>
The primary goal of this formalization was to prove the result in the following file: <br>
<a href="https://github.com/adamtopaz/lean-acl-pairs/blob/master/src/main_theorem.lean">https://github.com/adamtopaz/lean-acl-pairs/blob/master/src/main_theorem.lean</a><br>
The proof was based on an argument I wrote down in an earlier paper which was very explicit (and hence amenable to formalization).<br>
Already when I wrote that explicit argument I realized that there was something new that could be done in another context, and it was a complete triviality to formalize this new theorem based on the other parts that were already formalized. <br>
The new theorem is formalized here: <a href="https://github.com/adamtopaz/lean-acl-pairs/blob/master/src/main_theorem_char.lean">https://github.com/adamtopaz/lean-acl-pairs/blob/master/src/main_theorem_char.lean</a><br>
and I even wrote a tiny paper about this "new" result here: <a href="https://raw.githubusercontent.com/adamtopaz/CoeffAltPairs/main/main.pdf">https://raw.githubusercontent.com/adamtopaz/CoeffAltPairs/main/main.pdf</a></p>
<p>It's not quite correct to say that the formalization was the catalyst needed for this new theorem, but rather the <em>proof</em> that was formalizable made it possible.</p>



<a name="314085510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314085510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314085510">(Dec 05 2022 at 17:27)</a>:</h4>
<p>Adam, that's a good story. I will likely repeat it to others, if you don't mind.</p>



<a name="314086004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314086004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314086004">(Dec 05 2022 at 17:29)</a>:</h4>
<p>Another mini-example: Over the summer of 2022, <span class="user-mention" data-user-id="488744">@Jack McKoen</span> and I formalized some  results about valuation rings (which made it to mathlib). We then started thinking about formalizing a theorem called "the approximation theorem for independent valuations" which involves some understanding of the topology on fields induced by valuations. In true mathlib fashion, we started with arbitrary rings as opposed to fields, and realized that something nontrivial could indeed be done in this more general context (this also involves some compatibility with uniform structures on rings). I haven't seen any such results in the literature, especially not anything that relates such topologies on rings to uniform structures. So in this case, I would say that the formalization process (or rather the natural boundaries suggested/enforced by mathlib) did indeed contribute to some genuinely new mathematical insight (even though this new mathematics is still "work in progress").</p>



<a name="314086333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314086333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314086333">(Dec 05 2022 at 17:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> sure, I don't mind!</p>



<a name="314091384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314091384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314091384">(Dec 05 2022 at 17:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110865">Jeremy Avigad</span> <a href="#narrow/stream/113488-general/topic/mathematical.20insights.20from.20formalization/near/314065113">said</a>:</p>
<blockquote>
<p>I'd like to give a list of examples of mathematical insights that have come out of formalization, or, least, formalization insights that have more of a mathematical flavor than a computer science one. Below is the list I came up with. I am curious to hear what others think of the list, and what they might add.</p>
</blockquote>
<p>You need to be really careful about this because for almost any example people will tell you this was already known and has nothing to do with formalization. </p>
<blockquote>
<ul>
<li>Filters are the right way to deal with topological limits.</li>
</ul>
</blockquote>
<p>It's a lot more than this in mathlib.</p>
<blockquote>
<ul>
<li>The Bochner integral and the Frechet derivative are just the right level of generality.</li>
</ul>
</blockquote>
<p>For Frechet derivative this is clear to anyone working in pure math. I learned about Bochner integration in mathlib, but clearly a lot of people know about it.</p>
<blockquote>
<ul>
<li>Uniform spaces are useful (generalizing both metric spaces and topological groups).</li>
</ul>
</blockquote>
<p>Of course Bourbaki knew this in the 40s but I think it's safe to say that the average mathematician has never heard of uniform spaces.</p>
<blockquote>
<ul>
<li>Embeddings and homomorphic images often work better than subsets and substructures.</li>
</ul>
</blockquote>
<p>Again this is will known, especially from a categorical point of view, but indeed you need to take it much more seriously when formalizing.</p>
<blockquote>
<ul>
<li>There are lots of ways of formalizing the notion of a sheaf. Some work better than others.</li>
</ul>
</blockquote>
<p>This is really vague.</p>
<blockquote>
<ul>
<li>If K is a field extension of F, it is often better to treat K as an F-algebra (especially with towers of extensions).</li>
</ul>
</blockquote>
<p>Again, this is well known but indeed you need to take it much more seriously when formalizing. And I disagree with Mario that seing all extensions as subset is viable on paper.</p>
<blockquote>
<ul>
<li>It's possible to unify real and complex inner product spaces with the right type class.</li>
</ul>
</blockquote>
<p>Here you can easily claim that people think it should be doable on paper but it's never done.</p>
<blockquote>
<ul>
<li>Semilinear maps are a useful generalization of linear maps and conjugate linear maps.</li>
</ul>
</blockquote>
<p>Said like this people will think it's well known. The very nice work of Heather, Rob and Frédéric is really about making this doable in Lean.</p>
<blockquote>
<ul>
<li>Manifolds with corners are better than manifolds with boundary.</li>
</ul>
</blockquote>
<p>Again, this is well known but indeed you need to take it much more seriously when formalizing.</p>



<a name="314093065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314093065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314093065">(Dec 05 2022 at 18:05)</a>:</h4>
<p>One thing that I think is typical of using a proof assistant is using more "induction principle". For instance on paper we would never state <a href="https://leanprover-community.github.io/mathlib_docs/find/is_compact.induction_on">docs#is_compact.induction_on</a> or <a href="https://github.com/leanprover-community/sphere-eversion/blob/1cb67c3c208d9a3b64dc28bfaecf3bde47dad399/src/to_mathlib/partition.lean#L250-L254">exists_cont_mdiff_of_convex</a>. There are also nice examples in the Galois theory paper.</p>



<a name="314109608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314109608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314109608">(Dec 05 2022 at 19:33)</a>:</h4>
<p>Regarding the idea that a field extension K/F is an F-algebra I agree with Jeremy and I still remember the time when we were <em>stuck</em> on this. People who want to see me whingeing can search for the old <a href="#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/188403964">algebra is not scaling for me</a> thread in <a class="stream" data-stream-id="116395" href="/#narrow/stream/116395-maths">#maths</a>. If you want to do basic stuff about ring or field extensions K/F then you can choose: either F is a type (so K is an F-algebra) or F is a term (F is a subring of K). Mathematically these are both the same, and you can develop the theory in either setting. When things get interesting is when you're formalising MSc level commutative algebra and you have rings <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊂</mo><mi>B</mi><mo>⊂</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A\subset B \subset C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> and some technical statement like the Artin-Tate lemma whose proof involves constructing a sub-A-algebra B_0 of B. It's at this point you realise that your design decisions now really matter. You want C to be an A-module and B to be a subring of C and B to be an A-algebra etc etc all at the same time and you can't have all of these things at the same time. Riccardo you're wrong when you say that nobody tried to study field theory using inclusions. Me and Kenny were thinking about this a lot in 2018-19 and at that time we were really stuck about how to make everything work at once. In the Coq odd order paper they make everything a term! They have a big universal group and all groups are subgroups of this group. This worked great for them but it doesn't work in ring theory because given two groups you can always find a bigger group containing both of them (namely the direct product) but the same is not true for rings (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is not a subring of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> because the 1s don't match). For homogeneity reasons the next solution to try is making everything a type but here you have problems because you want too many things to be algebras over too many other things all at the same time. Then Kenny invented <code>algebra_tower</code> and all of a sudden we were back on track. Then Eric came along and invented <code>is_scalar_tower</code> and now today here we all are thinking that MSc level commutative algebra is easy because we've forgotten the pain of 2018 when we were still very unsure about whether <code>algebra</code> or <code>subring</code> was the best approach and both of them had problems.</p>



<a name="314109819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314109819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314109819">(Dec 05 2022 at 19:34)</a>:</h4>
<p>Thanks, Patrick. The last comment is very helpful. </p>
<p>I'll try to make it clear that I am not claiming that these insights are new mathematics. Rather, I want to say that we are learning something about how to organize mathematics to make it formalizable.</p>



<a name="314109891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314109891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> tica <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314109891">(Dec 05 2022 at 19:34)</a>:</h4>
<p>(deleted)</p>



<a name="314110195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314110195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314110195">(Dec 05 2022 at 19:36)</a>:</h4>
<p><span class="user-mention" data-user-id="570115">@tica</span> you're in the wrong thread; this is a discussion about mathematical insights from formalisation. Can you please start a new thread perhaps in <a class="stream" data-stream-id="116395" href="/#narrow/stream/116395-maths">#maths</a> ?</p>



<a name="314111101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314111101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314111101">(Dec 05 2022 at 19:42)</a>:</h4>
<p>Regarding Patrick's comments -- it's almost certainly true that if it's at undergraduate level then it's been tried before, because I would imagine everything has been tried before. No doubt formalising topology using open sets has been tried before, no doubt the Riemann integral has been tried before, no doubt semilinear maps have been tried before. It's not about the definition having been tried before. It's about a fundamental definition having a <em>huge</em> amount of material being built on top of it and seeing if it withstands the strain. </p>
<p>Having said that, it might be the case that mathematicians are simply not particularly <em>interested</em> in these design decisions, so they choose not to stress them. For example Oliver had to make a bunch of design decisions in his Lie algebra paper but as a mathematician his instinct is to actually devote most of his time talking about how he's found a new and more conceptual way of thinking about Engel's theorem, because to people like him and me this abstraction is kind of cute and interesting, whereas talking about non-associative algebras is just some foundational thing that "we all know now that we can do in Lean" because Lean has already proved its worth when it comes to formalising mathematics.</p>



<a name="314112147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314112147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314112147">(Dec 05 2022 at 19:48)</a>:</h4>
<p>The very fact that we're having this discussion is probably a proof that formalization can teach something about field extensions, but I am a little bit surprised: of course very often I think like the smaller field is a subset of the big one, but if I ad to write an algebra book I have the impression that I would have defined things using algebras, even before having heard about formalization. Just because there is no way <code>K</code> is a subset of <code>K[x]/p</code>. I really feel like the situation for <code>ℕ</code> and <code>ℤ</code>: do you think formalization makes <em>more</em> clear wrt paper math that there is only a "canonical" map, rather than a real inclusion?</p>



<a name="314112670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314112670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314112670">(Dec 05 2022 at 19:51)</a>:</h4>
<p>With this slide in my talk (which has now grown to two slides), I only want to make the case that these are insights worth documenting at least to the formalization community. The tendency I want to counter is to discount the value of a paper because it is "just a repeat of the mathematics" and doesn't spend enough time "describing the formalization."</p>
<p>The question as to the <em>mathematical</em> value of these insights, and as to the mathematical value of formalization in general, is a much bigger one. Johan made a great case for formalization in his <a href="http://www.fields.utoronto.ca/talks/Abstract-Formalities">Fields Medal Symposium talk</a>. Here I am taking on the simpler task of trying to communicate to formalizers from a CS background what formalizers from a math background tend to find interesting and useful.</p>



<a name="314118274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314118274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314118274">(Dec 05 2022 at 20:27)</a>:</h4>
<p>Another example of an implementation issue is the way complexes of objects in an abelian category are dealt with in LTE. Because we have this problem about A(n+1-1) and A(n) not being defeq if n is an int we tried several implementations and eventually decided on having maps A(i) -&gt; A(j) for all i and j. I think Floris tried something else in his thesis but that was in a univalent setting which didn't have the problems we have in vanilla DTT. Paulson claims that the same problems would not exist in simple type theory.</p>



<a name="314118618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314118618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314118618">(Dec 05 2022 at 20:29)</a>:</h4>
<p>Riccardo regarding the "obvious" idea that everything needs to be a type -- the problem with that is that you can't make C and B both A-algebras and C a B-algebra all at the same time until you have the idea of the implementation of <code>is_scalar_tower</code>, something which still looks totally counterintuitive to me -- it's a statement about heterogeneous associativity and it took a while to be discovered.</p>



<a name="314120085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314120085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314120085">(Dec 05 2022 at 20:39)</a>:</h4>
<p>I am not saying it's easy to implement this in a formal language, I just mean that the situation in pen and paper math is pretty clear, a field extension is a ring hom <code>K → L</code>.</p>



<a name="314136977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314136977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314136977">(Dec 05 2022 at 22:30)</a>:</h4>
<p>Just my 2c: In my opinion, one of the <em>main points</em> of Galois theory is to view a field extension as a morphism of fields and not just an inclusion!</p>



<a name="314143020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314143020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314143020">(Dec 05 2022 at 23:10)</a>:</h4>
<p>I totally agree with all of this however none of this means that the best way to do it in lean is with types. I'm sure you'd also agree that one of the main points of complexes is that you have maps from A(n) to A(n+1) and that's not what we're doing.</p>



<a name="314143464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314143464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314143464">(Dec 05 2022 at 23:13)</a>:</h4>
<p>Personally I feel that the trick we have with complexes with <code>d i j</code> going from <code>A_i</code> to <code>A_j</code> with <code>i,j</code> arbitrary (with some other axioms) is very far from the end of the story. Sure, it works (and LTE is good evidence that it works well enough), but I still don't think it's close to the optimal approach.</p>



<a name="314143794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314143794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314143794">(Dec 05 2022 at 23:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/mathematical.20insights.20from.20formalization/near/314109608">said</a>:</p>
<blockquote>
<p>Then Eric came along and invented <code>is_scalar_tower</code> and now today here we all are thinking that MSc level commutative algebra is easy</p>
</blockquote>
<p>Do you mean <span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> ? I certainly pushed for it to be used everywhere, but I can't take credit for it</p>



<a name="314148533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314148533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314148533">(Dec 06 2022 at 00:00)</a>:</h4>
<p>I think that the Bochner integral is good is well-known to most people working in functional analysis/spectral theory. About the Fréchet derivative I think this is not as clear as you state it since there are areas of math that need Fréchet space valued derivatives.<br>
As for the manifolds with corners, this is also very well-known in certain analysis communities (some of my research is about analysis on manifolds with corners), the simple reason is that  if you want to analyze differential operators on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, then you are usually looking at the Schwartz kernel, which is a function on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \times X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, which is a proper manifold with corners if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> is a manifold with boundary.</p>



<a name="314179052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314179052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314179052">(Dec 06 2022 at 06:50)</a>:</h4>
<p>I think another issue is the following: this thread is full of people going "of course you do Galois theory like this, of course you do integrals like this, of course you do manifolds like this" but the point is that we are <em>professional mathematicians</em> and this is what was missing from the story. Before 2017 you could count the number of professional mathematicians in this area on the fingers of one hand.</p>
<p>By the way In one of Lang's books (Algebra?) he does Galois theory by replacing all field extensions K -&gt; L with subfields K subset L' with L' defined to be the disjoint union of K and the things in L but not the image of K. Hindsight is a wonderful thing.</p>



<a name="314207137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314207137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314207137">(Dec 06 2022 at 10:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/mathematical.20insights.20from.20formalization/near/314143794">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/mathematical.20insights.20from.20formalization/near/314109608">said</a>:</p>
<blockquote>
<p>Then Eric came along and invented <code>is_scalar_tower</code> and now today here we all are thinking that MSc level commutative algebra is easy</p>
</blockquote>
<p>Do you mean <span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> ? I certainly pushed for it to be used everywhere, but I can't take credit for it</p>
</blockquote>
<p>As far as I remember and can tell from Zulip and Git history, Kenny wrote the first implementation of <code>is_algebra_tower</code> (<a href="https://github.com/leanprover-community/mathlib/pull/3272">#3272</a>) based on some of Johan's suggestions, which ultimately derive from Markus' diagram chasing tactic. AFAICT implementing it as a class is Kenny's innovation. Our current <code>is_scalar_tower</code> class was a slight modification done by me (<a href="https://github.com/leanprover-community/mathlib/pull/3717">#3717</a>,  <a href="https://github.com/leanprover-community/mathlib/pull/3785">#3785</a>) based on my own experience and Kenny's recommendations. Certainly Eric Wieser should be remembered for spending a lot of effort trying to popularize its usage.</p>



<a name="314208130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314208130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314208130">(Dec 06 2022 at 10:35)</a>:</h4>
<p>Oh this explains where the "algebra tower" terminology comes from in various docstrings / filenames, despite the fact that everything is now much more general than that. Thanks for the archaeology!</p>



<a name="314217308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314217308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314217308">(Dec 06 2022 at 11:31)</a>:</h4>
<p>Sorry <span class="user-mention" data-user-id="238446">@Anne Baanen</span> ! I seem to have misattributed the insight. Yes, it used to be called <code>algebra_tower</code> and only worked for rings</p>



<a name="314229433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314229433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tyler Josephson ⚛️ <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314229433">(Dec 06 2022 at 12:47)</a>:</h4>
<p>Though science and engineering applications sound like they might be outside the scope of what you’re speaking about, we’ve found the following neat benefit of formalization.</p>
<p>We wrote down proofs that the kinematic equations follow from the calculus-based definitions of the equations of motion (<a href="https://arxiv.org/abs/2210.12150">https://arxiv.org/abs/2210.12150</a>). First year undergrads in Physics do these derivations with pencil and paper. But after we formalized them, <span class="user-mention" data-user-id="474115">@Max Bobbin</span> realized that our proof need not assume that time was real - we could try more general types. Just go to the front of the proof, change time’s type to be the complex numbers, and most of the proofs still closed.</p>



<a name="314239791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314239791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Sánchez Terraf <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314239791">(Dec 06 2022 at 13:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110865">Jeremy Avigad</span> <a href="#narrow/stream/113488-general/topic/mathematical.20insights.20from.20formalization/near/314065113">said</a>:</p>
<blockquote>
<p>I'd like to give a list of examples of mathematical insights that have come out of formalization, or, least, formalization insights that have more of a mathematical flavor than a computer science one. Below is the list I came up with. I am curious to hear what others think of the list, and what they might add.</p>
</blockquote>
<p>A bit of a truism because of its generality, but that might resonate with CS people, is that working in any formal system restricts the way things can be proved, like in the case of constructive approaches they are very fond of (avoiding EM, AC).</p>
<p>In the spirit of formalization (but actually a little of a reversal, like the beginning of one of Adam's examples) I wrote detailed  proofs of the basic theory of cofinality of ordinals that confined induction/recursion to a single application in one lemma. I later formalized that proof, and that was convenient since I was working in Isabelle/ZF, where handling well-founded recursion was inconvenient.</p>
<p>The takeaway is that formalization may always inspire looking for the key lemma.</p>



<a name="314253812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314253812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314253812">(Dec 06 2022 at 14:55)</a>:</h4>
<p>Many thanks to everyone for this feedback. Among other things, it got me to realize that initially I was somewhat confusedly asking two separate questions at once: (1) What are the insights from formalization that are of interest to mathematicians who formalize mathematics? (2) What are the insights from formalization that might be of broader mathematical interest?</p>
<p>Maybe there isn't a sharp line between the two questions, but this discussion has provided responses to both. It is helpful for thinking about how to communicate our work to others.</p>



<a name="314258703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314258703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314258703">(Dec 06 2022 at 15:18)</a>:</h4>
<p>I guess I'll also add the thought that the reason that there isn't a sharp line between the two questions is that there isn't a sharp line between discovery and exposition, i.e. between coming up with new mathematical ideas and figuring out how to organize the knowledge we have and make it precise. Both are part of mathematics.</p>
<p>Mathematicians will bristle at the claim that <code>is_scalar_tower</code> is a real mathematical discovery, on the grounds that it is trivial and implicit in what they have been doing all along. We need to recognize this, but also emphasize the importance of finding the right ways to make our intuitions precise.</p>



<a name="314259218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314259218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314259218">(Dec 06 2022 at 15:21)</a>:</h4>
<p>One example I encountered (that is also a shameless plug) comes from formalizing the convolution of two functions (<a href="https://arxiv.org/abs/2210.07693">https://arxiv.org/abs/2210.07693</a>, pp 10-11). <br>
You want your definition of convolution to be able to express the smoothening of a multivariate function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup><mo>→</mo><msup><mi mathvariant="double-struck">R</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">f : \mathbb{R}^n \to \mathbb{R}^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> using some bump function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>:</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup><mo>→</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\varphi : \mathbb{R}^n \to \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span>. In this case, the convolution is defined to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>φ</mi><mo>∗</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo>∫</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">(\varphi*f)(x)=\int \varphi(t)f(x-t)dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.3061em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span> (with scalar multiplication inside the integral). </p>
<p>We can then compute partial derivatives of such a convolution. Under appropriate conditions on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> we can compute e.g.<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi mathvariant="normal">∂</mi><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="false">(</mo><mi>φ</mi><mo>∗</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>φ</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac><mo>∗</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\frac{\partial}{\partial x_i}(\varphi*f)= \frac{\partial\varphi}{\partial x_i}*f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3252em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3773em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.<br>
It would also be nice to have a formula for the total derivative of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>∗</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\varphi*f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>. We would like to write that <br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>φ</mi><mo>∗</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>D</mi><mi>φ</mi><mo>∗</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">D(\varphi*f)=D\varphi*f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span><br>
except that the right-hand side doesn't type-check: how do we even define the convolution of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>φ</mi></mrow><annotation encoding="application/x-tex">D\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">φ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>? Neither of them is scalar-valued, so we cannot multiply the function values <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>φ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D\varphi(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x-t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>. </p>
<p>This is why the mathlib definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/convolution">docs#convolution</a> takes two vector-valued functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>:</mo><mi>G</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">\varphi: G \to E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>G</mi><mo>→</mo><msup><mi>E</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f : G \to E&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> and a (continuous) bilinear map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>:</mo><mi>E</mi><mo>→</mo><msup><mi>E</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">L : E \to E&#x27; \to F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> to "multiply" the values (here <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>E</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">E&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> are normed spaces, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is a Banach space). Then the definition of convolution is<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>φ</mi><msub><mo>∗</mo><mi>L</mi></msub><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∫</mo><mi>t</mi></msub><mi>L</mi><mo stretchy="false">(</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">(\varphi*_Lf)(x)=\int_t L(\varphi(t),f(x-t))dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1608em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0747em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">φ</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">))</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span><br>
and we can then compute (under suitable hypotheses)<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>φ</mi><msub><mo>∗</mo><mi>L</mi></msub><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>D</mi><mi>φ</mi><msub><mo>∗</mo><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mi>f</mi></mrow><annotation encoding="application/x-tex">D(\varphi*_Lf)=D\varphi*_{L&#x27;}f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span><br>
where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">L&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is defined by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>A</mi><mi>v</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L&#x27;(A,x,v)=L(Av,x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.<br>
(<a href="https://leanprover-community.github.io/mathlib_docs/find/has_compact_support.has_fderiv_at_convolution_left/src">src#has_compact_support.has_fderiv_at_convolution_left</a>)</p>



<a name="314259431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314259431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314259431">(Dec 06 2022 at 15:22)</a>:</h4>
<p>I have not seen any textbook use this approach. All the ones I consulted (with <span class="user-mention" data-user-id="110031">@Patrick Massot</span>) only compute partial derivatives, and avoid writing the total derivative.</p>



<a name="314260184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314260184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314260184">(Dec 06 2022 at 15:26)</a>:</h4>
<p>Nice!</p>



<a name="314277865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314277865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314277865">(Dec 06 2022 at 16:52)</a>:</h4>
<p>Another example that I like very much comes from <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> 's work on the sphere as manifold. From the paper&amp;pencil perspective, the "easiest" thing to do is to only fix two charts, one around the North Pole and one around the South, and then check that everything glues. Her insight is that fixing charts at every point of the sphere actually works better: it makes everything more natural (no poles any more <span aria-label="penguin" class="emoji emoji-1f427" role="img" title="penguin">:penguin:</span> means no choice), adds very little burden — or no burden at all — to the theory, but it is not the usual way things are presented. Her slides <a href="https://leanprover-community.github.io/lt2021/slides/Macbeth-slides.pdf">here</a> are very clear.</p>



<a name="314287220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314287220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314287220">(Dec 06 2022 at 17:37)</a>:</h4>
<p>In fact I got this idea from a <a href="#narrow/stream/116395-maths/topic/Normed.20spaces/near/197859621">comment</a> of <span class="user-mention" data-user-id="110031">@Patrick Massot</span> about projective space.</p>



<a name="314700293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314700293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nilesh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314700293">(Dec 08 2022 at 15:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="424214">Tyler Josephson ⚛️</span> <a href="#narrow/stream/113488-general/topic/mathematical.20insights.20from.20formalization/near/314229433">said</a>:</p>
<blockquote>
<p>First year undergrads in Physics do these derivations with pencil and paper. But after we formalized them, <span class="user-mention silent" data-user-id="474115">Max Bobbin</span> realized that our proof need not assume that time was real - we could try more general types. Just go to the front of the proof, change time’s type to be the complex numbers, and most of the proofs still closed.</p>
</blockquote>
<p>Oh, this is very interesting. Has someone attempted to formalize high-school or undergraduate physics? Laws of motion, gravitation, electromagnetism etc?</p>



<a name="314723912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314723912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tyler Josephson ⚛️ <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314723912">(Dec 08 2022 at 17:15)</a>:</h4>
<p><span class="user-mention" data-user-id="509007">@Nilesh</span> I’ve only found isolated projects, like refs 20 and 21 in our manuscript. But I’m working on laying the groundwork to start a Xena project-like program to teach UG’s how to formalize science and engineering theories, and build a “SciLib” database like mathlib.</p>



<a name="314740148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314740148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314740148">(Dec 08 2022 at 18:17)</a>:</h4>
<p>FYI: <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> has a project called SciLean, but I think it's more geared toward scientific computation rather than "science and engineering theories", but I could be wrong.</p>



<a name="314745469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314745469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tyler Josephson ⚛️ <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314745469">(Dec 08 2022 at 18:42)</a>:</h4>
<p><span class="user-mention" data-user-id="197836">@Jireh Loreaux</span> <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> These go hand-in-hand! We can formally prove theories, and we can write scientific computing software that rigorously corresponds to said theories. I’d love to write statistical mechanics proofs, and then write SciLean software for molecular dynamics that provably simulates the canonical ensemble, for example.</p>



<a name="314750409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314750409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sina <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314750409">(Dec 08 2022 at 19:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="424214">Tyler Josephson ⚛️</span> <a href="#narrow/stream/113488-general/topic/mathematical.20insights.20from.20formalization/near/314745469">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="197836">Jireh Loreaux</span> <span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> These go hand-in-hand! We can formally prove theories, and we can write scientific computing software that rigorously corresponds to said theories. I’d love to write statistical mechanics proofs, and then write SciLean software for molecular dynamics that provably simulates the canonical ensemble, for example.</p>
</blockquote>
<p>Is there a tutorial on installing and <strong>using</strong> SciLean? How has been your experience with it?</p>



<a name="314769735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314769735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tyler Josephson ⚛️ <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314769735">(Dec 08 2022 at 20:55)</a>:</h4>
<p>We haven’t used it directly yet, but you can ask <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> any questions you may have!</p>



<a name="314882330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathematical%20insights%20from%20formalization/near/314882330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mathematical.20insights.20from.20formalization.html#314882330">(Dec 09 2022 at 12:18)</a>:</h4>
<p>I wrote few things <a href="https://lecopivo.github.io/SciLean/build/doc/SciLean.html">here</a>. Unfortunately, the library is not practically usable yet and still in heavy development. Some core pieces will have to change so I'm postponing writing any tutorials.</p>
<p>To stay on the topic, when working on symbolic/automatic differentiation I have realized few things:</p>
<ul>
<li>Partial derivative notation is often abused and used ambiguously for example Euler Lagrange equation is usually written in nonsensical way. I had to come up with a notation that can be fully formalized. Now it is much easier for me to understand the normal notation and spot if there is a mistake/ambiguity.</li>
<li>Differential operator zoo:  differential, partial derivative, derivative in a direction, total derivative, gradient, ... what is the exact relation between those? My realization is that all can be defined with differential and transposition. In particular, to define gradient you need to do transposition thus it make sense only if you have inner product.</li>
<li>The main difference between symbolic and automatic differentiation is in how you handle let bindings.</li>
<li>To differentiate a solution of an ODE w.r.t. the initial condition you need to solve its adjoint ODE. Discretizing this adjoint ODE gives you something very similar as discretizing the original ODE and applying back propagation.</li>
<li>Adjoint connects together some basic functions on arrays. Example: adjoint of element acces of an array is Kronecker delta or adjoint of dropping an element of an array is pushing a zero element to an array.</li>
</ul>
<p>I'm not claiming these are any new insights and often they stem from my ignorance/laziness studying literature properly. But I have found out that if I want to understand something properly it is often useful and faster to write it down in Lean, get the types right and distill the core of the problem in the process.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html">splitting decidable (a /\ b \/ c /\ ...)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="212175432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212175432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212175432">(Oct 03 2020 at 14:44)</a>:</h4>
<p>If my goal is something like <code>decidable (a /\ (b \/ c) /\ ...)</code>,  how can I quickly split that into separate goals for <code>decidable a</code> and <code>decidable b \/ c</code>, etc?</p>



<a name="212175444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212175444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212175444">(Oct 03 2020 at 14:45)</a>:</h4>
<p>Try <code>decidable_and</code>? No idea if it's there but that's what I'd call it</p>



<a name="212176099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212176099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212176099">(Oct 03 2020 at 15:02)</a>:</h4>
<p>Because <code>decidable</code> is a type class, we can find many definitions with that type using <code>#print instances</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">instances</span> <span class="n">decidable</span>
<span class="c1">-- xor.decidable : Π {p q : Prop} [_inst_1 : decidable p] [_inst_2 : decidable q], decidable (xor p q)</span>
<span class="c1">-- iff.decidable : Π {p q : Prop} [_inst_1 : decidable p] [_inst_2 : decidable q], decidable (p ↔ q)</span>
<span class="c1">-- implies.decidable : Π {p q : Prop} [_inst_1 : decidable p] [_inst_2 : decidable q], decidable (p → q)</span>
<span class="c1">-- not.decidable : Π {p : Prop} [_inst_1 : decidable p], decidable (¬p)</span>
<span class="c1">-- or.decidable : Π {p q : Prop} [_inst_1 : decidable p] [_inst_2 : decidable q], decidable (p ∨ q)</span>
<span class="c1">-- and.decidable : Π {p q : Prop} [_inst_1 : decidable p] [_inst_2 : decidable q], decidable (p ∧ q)</span>
<span class="c1">-- decidable.false : decidable false</span>
<span class="c1">-- decidable.true : decidable true</span>
</code></pre></div>

<p>This tells us that <code>and.decidable</code> is what you're looking for</p>



<a name="212182854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212182854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212182854">(Oct 03 2020 at 18:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span>  I would have thought that, but it doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∧</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">and.decidable</span><span class="o">,</span> <span class="c1">-- "failed to synthesize type class instance"</span>
<span class="kd">end</span>
</code></pre></div>



<a name="212183315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183315">(Oct 03 2020 at 18:12)</a>:</h4>
<p><a href="https://groups.google.com/g/lean-user/c/M1iWWt4kqUQ/m/f5GVSb1DAQAJ">This post from 2017</a> seems to indicate that you can't use <code>decidable</code> like that because it's a type class, not a normal predicate? But that may be outdated and/or incorrect</p>



<a name="212183504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183504">(Oct 03 2020 at 18:16)</a>:</h4>
<p>You can use it like this:</p>
<div class="codehilite" data-code-language="Clean"><pre><span></span><code><span class="n">theorem</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">Π</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nc">Prop</span><span class="p">),</span><span class="w"> </span><span class="n">decidable</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="err">∧</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="n">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">intros</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">have</span><span class="w"> </span><span class="n">h₀</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">decidable</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">sorry</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">have</span><span class="w"> </span><span class="n">h₁</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">decidable</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">sorry</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">resetI</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">apply_instance</span><span class="p">,</span><span class="w"></span>
<span class="n">end</span><span class="w"></span>
</code></pre></div>



<a name="212183525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183525">(Oct 03 2020 at 18:16)</a>:</h4>
<p><code>resetI</code> will add <code>h₀</code> and <code>h₁</code> to the instance cache</p>



<a name="212183646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183646">(Oct 03 2020 at 18:19)</a>:</h4>
<p><code>decidable</code> is a type class and meant to be used in type class-y ways. What are you really trying to do?</p>



<a name="212183693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183693">(Oct 03 2020 at 18:20)</a>:</h4>
<p>Normally you shouldn't end up with <code>decidable</code> goals at all</p>



<a name="212183698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183698">(Oct 03 2020 at 18:20)</a>:</h4>
<p>Either use <code>classical</code> or write the instances you need</p>



<a name="212183702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183702">(Oct 03 2020 at 18:20)</a>:</h4>
<p>One trick I sometimes use when I want lean to not infer a typeclass is <code>refine @and.decidable _ _ (id _) (id _)</code></p>



<a name="212183783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183783">(Oct 03 2020 at 18:22)</a>:</h4>
<p>It seems like a mistake that lean will infer instances even if you write <code>@foo ... _</code>, but I can see that many things will break if this changes. It would be nice if there was a mode that allowed this to be "no really" explicit</p>



<a name="212183804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183804">(Oct 03 2020 at 18:23)</a>:</h4>
<p>Lean 4 has a distinction between <code>_</code> and <code>?</code> (I think that's the syntax), which maybe would apply here too</p>



<a name="212183812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183812">(Oct 03 2020 at 18:23)</a>:</h4>
<p>with one meaning "infer" and the other meaning "make a new goal"</p>



<a name="212183967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183967">(Oct 03 2020 at 18:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> I'm trying to show a predicate is decidable... What should the goal be, if not "decidable"?</p>



<a name="212183990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212183990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212183990">(Oct 03 2020 at 18:28)</a>:</h4>
<p>If so you are writing a program and probably shouldn't be using tactics until you get to the proof part</p>



<a name="212184035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212184035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212184035">(Oct 03 2020 at 18:28)</a>:</h4>
<p>then normally the proof would be some variant of <code>by { dunfold [...], apply_instance }</code> or use <code>decidable_of_iff</code></p>



<a name="212184054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212184054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212184054">(Oct 03 2020 at 18:29)</a>:</h4>
<p>But if your predicate has lots of ands and ors in it you should probably be doing what Simon showed. Assuming <code>by apply_instance</code> alone doesn't work, add the necessary instances to the context with <code>haveI</code> and then use <code>apply_instance</code></p>



<a name="212184116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212184116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212184116">(Oct 03 2020 at 18:30)</a>:</h4>
<p>this mostly only comes up for recursive predicates. For nonrecursive predicates Reid's suggestion is the best</p>



<a name="212184124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212184124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212184124">(Oct 03 2020 at 18:30)</a>:</h4>
<p>Here's what I'm working with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">val</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">car</span> <span class="o">:</span> <span class="n">val</span><span class="o">)</span> <span class="o">(</span><span class="n">cdr</span><span class="o">:</span> <span class="n">val</span><span class="o">),</span> <span class="n">val</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">fn2</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">fn2</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">fn2</span>
<span class="bp">|</span> <span class="n">car</span>  <span class="o">:</span> <span class="n">fn2</span>
<span class="bp">|</span> <span class="n">cdr</span>  <span class="o">:</span> <span class="n">fn2</span>
<span class="bp">|</span> <span class="n">nil</span>  <span class="o">:</span> <span class="n">fn2</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">car</span> <span class="n">cdr</span> <span class="o">:</span> <span class="n">fn2</span><span class="o">)</span> <span class="o">:</span> <span class="n">fn2</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">fn2</span><span class="o">)</span> <span class="o">:</span> <span class="n">fn2</span>
<span class="bp">|</span> <span class="n">prec</span> <span class="o">(</span><span class="n">z_case</span> <span class="n">s_case</span> <span class="o">:</span> <span class="n">fn2</span><span class="o">)</span> <span class="o">:</span> <span class="n">fn2</span>

<span class="kd">inductive</span> <span class="n">typed</span> <span class="o">:</span> <span class="n">fn2</span> <span class="bp">-&gt;</span> <span class="n">val</span> <span class="bp">-&gt;</span> <span class="n">val</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">fn2.zero</span> <span class="n">val.nil</span> <span class="n">val.nat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">fn2.succ</span> <span class="n">val.nat</span> <span class="n">val.nat</span>
<span class="bp">|</span> <span class="n">car</span> <span class="o">{</span><span class="n">tcar</span> <span class="n">tcdr</span> <span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">fn2.car</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">)</span> <span class="n">tcar</span>
<span class="bp">|</span> <span class="n">cdr</span> <span class="o">{</span><span class="n">tcar</span> <span class="n">tcdr</span> <span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">fn2.cdr</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">)</span> <span class="n">tcdr</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{</span><span class="n">t</span><span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">fn2.nil</span> <span class="n">t</span> <span class="n">val.nil</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">{</span><span class="n">car</span> <span class="n">cdr</span> <span class="o">:</span> <span class="n">fn2</span><span class="o">}</span>
    <span class="o">(</span><span class="n">tcar_t</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">car</span> <span class="n">tin</span> <span class="n">tcar</span><span class="o">)</span>
    <span class="o">(</span><span class="n">tcdr_t</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">cdr</span> <span class="n">tin</span> <span class="n">tcdr</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">typed</span> <span class="o">(</span><span class="n">fn2.cons</span> <span class="n">car</span> <span class="n">cdr</span><span class="o">)</span> <span class="n">tin</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tint</span> <span class="n">tout</span><span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">fn2</span><span class="o">}</span>
    <span class="o">(</span><span class="n">f_t</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">f</span> <span class="n">tint</span> <span class="n">tout</span><span class="o">)</span>
    <span class="o">(</span><span class="n">g_t</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">g</span> <span class="n">tin</span> <span class="n">tint</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">typed</span> <span class="o">(</span><span class="n">fn2.comp</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="n">tin</span> <span class="n">tout</span>
<span class="bp">|</span> <span class="n">prec</span> <span class="o">{</span><span class="n">trest</span> <span class="n">tout</span><span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">{</span><span class="n">z_case</span> <span class="n">s_case</span> <span class="o">:</span> <span class="n">fn2</span><span class="o">}</span>
    <span class="o">(</span><span class="n">z_t</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">z_case</span> <span class="n">trest</span> <span class="n">tout</span><span class="o">)</span>
    <span class="o">(</span><span class="n">s_t</span> <span class="o">:</span> <span class="n">typed</span> <span class="n">s_case</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">val.nat</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tout</span> <span class="n">trest</span><span class="o">))</span> <span class="n">tout</span><span class="o">):</span>
    <span class="n">typed</span> <span class="o">(</span><span class="n">fn2.prec</span> <span class="n">z_case</span> <span class="n">s_case</span><span class="o">)</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">val.nat</span> <span class="n">trest</span><span class="o">)</span> <span class="n">tout</span>

<span class="n">mk_iff_of_inductive_prop</span> <span class="n">typed</span> <span class="n">typed_iff</span>

<span class="kd">@[instance]</span> <span class="kd">def</span> <span class="n">typed.decidable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fn2</span><span class="o">)</span> <span class="o">(</span><span class="n">tin</span> <span class="n">tout</span> <span class="o">:</span> <span class="n">val</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">typed</span> <span class="n">f</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
</code></pre></div>



<a name="212184131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212184131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212184131">(Oct 03 2020 at 18:30)</a>:</h4>
<p>Trying to show that whether a type assignment is correct or not is decidable.</p>



<a name="212184201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212184201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212184201">(Oct 03 2020 at 18:32)</a>:</h4>
<p>The top level should be a recursion using the equation compiler</p>



<a name="212184305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212184305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212184305">(Oct 03 2020 at 18:35)</a>:</h4>
<p>writing it out in a forward way will work, but it's so duplicative of the definition of <code>typed</code> that it seems like metaprogramming should surely be better, right? I guess not if you say so</p>



<a name="212184616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212184616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212184616">(Oct 03 2020 at 18:43)</a>:</h4>
<p>Eh, actually some of this is a bit annoying, metaprogramming is better</p>



<a name="212184625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212184625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212184625">(Oct 03 2020 at 18:43)</a>:</h4>
<p>I don't actually know how to prove <code>false</code> in the cases that don't match any constructor.</p>



<a name="212184626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212184626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212184626">(Oct 03 2020 at 18:43)</a>:</h4>
<p>actually it is better to phrase this as a function from fn to its type</p>



<a name="212185023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212185023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212185023">(Oct 03 2020 at 18:53)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fn2.typecheck</span> <span class="o">:</span> <span class="n">fn2</span> <span class="bp">→</span> <span class="n">val</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">val</span>
<span class="bp">|</span> <span class="n">fn2.zero</span> <span class="n">val.nil</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">val.nat</span>
<span class="bp">|</span> <span class="n">fn2.succ</span> <span class="n">val.nat</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">val.nat</span>
<span class="bp">|</span> <span class="n">fn2.car</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">tcar</span>
<span class="bp">|</span> <span class="n">fn2.cdr</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">tcdr</span>
<span class="bp">|</span> <span class="n">fn2.nil</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">val.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">fn2.cons</span> <span class="n">car</span> <span class="n">cdr</span><span class="o">)</span> <span class="n">tin</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">tcar</span> <span class="bp">←</span> <span class="n">car.typecheck</span> <span class="n">tin</span><span class="o">,</span>
  <span class="n">tcdr</span> <span class="bp">←</span> <span class="n">cdr.typecheck</span> <span class="n">tin</span><span class="o">,</span>
  <span class="n">return</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">fn2.comp</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="n">tin</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">tint</span> <span class="bp">←</span> <span class="n">g.typecheck</span> <span class="n">tin</span><span class="o">,</span>
  <span class="n">f.typecheck</span> <span class="n">tint</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">fn2.prec</span> <span class="n">z_case</span> <span class="n">s_case</span><span class="o">)</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">val.nat</span> <span class="n">trest</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">tout</span> <span class="bp">←</span> <span class="n">z_case.typecheck</span> <span class="n">trest</span><span class="o">,</span>
  <span class="n">tout'</span> <span class="bp">←</span> <span class="n">s_case.typecheck</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">val.nat</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tout</span> <span class="n">trest</span><span class="o">)),</span>
  <span class="n">guard</span> <span class="o">(</span><span class="n">tout'</span> <span class="bp">=</span> <span class="n">tout</span><span class="o">),</span>
  <span class="n">return</span> <span class="n">tout</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kd">theorem</span> <span class="n">fn2.typecheck_iff</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fn2</span><span class="o">}</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tout</span> <span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">typed</span> <span class="n">f</span> <span class="n">tin</span> <span class="n">tout</span> <span class="bp">↔</span> <span class="n">f.typecheck</span> <span class="n">tin</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">tout</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">instance</span> <span class="n">typed.decidable</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fn2</span><span class="o">)</span> <span class="o">(</span><span class="n">tin</span> <span class="n">tout</span> <span class="o">:</span> <span class="n">val</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">typed</span> <span class="n">f</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">decidable_of_iff'</span> <span class="n">_</span> <span class="n">fn2.typecheck_iff</span>
</code></pre></div>



<a name="212185826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212185826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212185826">(Oct 03 2020 at 19:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">fn2.typecheck_iff</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">fn2</span><span class="o">}</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tout</span> <span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">typed</span> <span class="n">f</span> <span class="n">tin</span> <span class="n">tout</span> <span class="bp">↔</span> <span class="n">f.typecheck</span> <span class="n">tin</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">tout</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">induction</span> <span class="n">h</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span><span class="bp">;</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">fn2.typecheck</span><span class="o">,</span> <span class="bp">*</span><span class="o">,</span> <span class="n">return</span><span class="o">,</span> <span class="n">pure</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">f</span> <span class="n">generalizing</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">,</span>
    <span class="n">iterate</span> <span class="mi">5</span> <span class="o">{{</span> <span class="n">cases</span> <span class="n">tin</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">typed_iff</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">fn2.typecheck</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">]</span> <span class="o">}},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">fn2.typecheck</span><span class="o">],</span>
      <span class="n">rintro</span> <span class="n">a</span> <span class="n">h1</span> <span class="n">b</span> <span class="n">h2</span> <span class="o">⟨⟩,</span>
      <span class="n">constructor</span><span class="bp">;</span> <span class="n">solve_by_elim</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">fn2.typecheck</span><span class="o">],</span>
      <span class="n">rintro</span> <span class="n">a</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
      <span class="n">constructor</span><span class="bp">;</span> <span class="n">solve_by_elim</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">tin</span> <span class="k">with</span> <span class="n">car</span> <span class="n">trest</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">fn2.typecheck</span><span class="o">]</span> <span class="o">},</span>
      <span class="n">cases</span> <span class="n">car</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">fn2.typecheck</span><span class="o">],</span>
      <span class="n">rintro</span> <span class="n">a</span> <span class="n">h1</span> <span class="n">b</span> <span class="n">h2</span> <span class="o">⟨⟩</span> <span class="o">⟨⟩,</span>
      <span class="n">constructor</span><span class="bp">;</span> <span class="n">solve_by_elim</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="212185844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/splitting%20decidable%20%28a%20/%5C%20b%20%5C/%20c%20/%5C%20...%29/near/212185844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/splitting.20decidable.20(a.20.2F.5C.20b.20.5C.2F.20c.20.2F.5C.20.2E.2E.2E).html#212185844">(Oct 03 2020 at 19:15)</a>:</h4>
<p><span class="user-mention" data-user-id="344960">@Hunter Freyer</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
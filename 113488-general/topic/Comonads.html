---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Comonads.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html">Comonads</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273363413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273363413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273363413">(Feb 26 2022 at 21:17)</a>:</h4>
<p>Hi all.</p>
<p>I was wondering how one might go about defining comonads in Lean, in a way compatible with/analogous to how monads are defined. Any thoughts?</p>



<a name="273364731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273364731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273364731">(Feb 26 2022 at 21:47)</a>:</h4>
<p>When you say, "how monads are defined", do you mean <a href="https://leanprover-community.github.io/mathlib_docs/find/monad">docs#monad</a> as a programming language concept, that is a type class which may or may not be lawful (obey the monad axioms), such as the <code>tactic</code> and <code>io</code> monads?  Or monads as a mathematical definition in category theory, i.e. <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.monad">docs#category_theory.monad</a>?</p>



<a name="273364921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273364921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273364921">(Feb 26 2022 at 21:51)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.comonad">docs#category_theory.comonad</a> (if you want the categorical def)</p>



<a name="273365124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273365124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273365124">(Feb 26 2022 at 21:56)</a>:</h4>
<p>I assume you mean the category theory definition, but if you want comonads as a programming language concept, here is an article on how to do it in Haskell: <a href="https://bartoszmilewski.com/2017/01/02/comonads/">https://bartoszmilewski.com/2017/01/02/comonads/</a></p>



<a name="273365754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273365754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273365754">(Feb 26 2022 at 22:06)</a>:</h4>
<p>(It would be a fun project for someone to translate the code in that book, <a href="https://github.com/hmemcpy/milewski-ctfp-pdf/">Category Theory for Programmers</a>, from Haskell to Lean(4).  There already is a Scala translation.)</p>



<a name="273392947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273392947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273392947">(Feb 27 2022 at 09:23)</a>:</h4>
<p>Yeah, I meant the programming language concept!</p>



<a name="273400201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273400201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273400201">(Feb 27 2022 at 12:09)</a>:</h4>
<p>Is the tactic monad not lawful? My opinion of it just diminished a little</p>



<a name="273400272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273400272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273400272">(Feb 27 2022 at 12:10)</a>:</h4>
<p>It is a shame that there are these words like monad and topos and ring which mean different things to different communities. It impairs communication.</p>



<a name="273403469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273403469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273403469">(Feb 27 2022 at 13:24)</a>:</h4>
<p>I think the tactic monad is lawful, if you ignore things like <code>tactic.unsafe_run_io</code> which allow for tactics that are not pure-functional</p>



<a name="273403497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273403497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273403497">(Feb 27 2022 at 13:25)</a>:</h4>
<p>well, equality of haskell functions is always a bit of sleight of hand since there are plenty of effects in functional programs like allocation</p>



<a name="273403554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273403554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273403554">(Feb 27 2022 at 13:26)</a>:</h4>
<p>and you can't really take back a <code>RealWorld</code> token in an IO computation once you've used it in an IO function to change the state of the world</p>



<a name="273411485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273411485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273411485">(Feb 27 2022 at 16:15)</a>:</h4>
<p>Kevin, I think you parsed Jason's comment in a way different than what was intended: "programming language concept ... such as the <code>tactic</code> and <code>io</code> monads", but I could be wrong.</p>



<a name="273414390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273414390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273414390">(Feb 27 2022 at 17:12)</a>:</h4>
<p>Yes.  It was ambiguous.  I didn’t mean to pick on the <code>tactic</code> monad.  Nonetheless, the first time I saw the monad class and it’s description in Programming in Lean, I was very confused because there was no mention of the axioms.  I think the reality is that one wants monads to be as close to lawful as possible, but in real programming edge cases do come through sometimes.  One example in the more mathematical side of Lean is the Giry monad which is only lawful if you consider measurable functions.</p>



<a name="273481385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273481385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273481385">(Feb 28 2022 at 12:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> <a href="#narrow/stream/113488-general/topic/Comonads/near/273365754">said</a>:</p>
<blockquote>
<p>(It would be a fun project for someone to translate the code in that book, <a href="https://github.com/hmemcpy/milewski-ctfp-pdf/">Category Theory for Programmers</a>, from Haskell to Lean(4).  There already is a Scala translation.)</p>
</blockquote>
<p>I was reading this. The tricky thing I found is that in Lean, (programming) monads are defined in terms of extending applicative functors. But it's not clear to me what a "coapplicative" functor would be or how that should be defined, or even if it's right to do it that way.</p>



<a name="273481558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273481558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273481558">(Feb 28 2022 at 12:28)</a>:</h4>
<p>(Also: this is more of a general category-theory question, but in that, fmap in the comonad is just, well, fmap. But I was wondering - how come it doesn't become covariant, so that you don't have <code>fmap : (a -&gt; b) -&gt; f b -&gt; f a</code>?</p>



<a name="273483285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273483285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273483285">(Feb 28 2022 at 12:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330967">Wrenna Robson</span> <a href="#narrow/stream/113488-general/topic/Comonads/near/273481385">said</a>:</p>
<blockquote>
<p>I was reading this. The tricky thing I found is that in Lean, (programming) monads are defined in terms of extending applicative functors. But it's not clear to me what a "coapplicative" functor would be or how that should be defined, or even if it's right to do it that way.</p>
</blockquote>
<p>This is a feature of the category of sets--a general monad isn't applicative (= lax monoidal).</p>



<a name="273483339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273483339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273483339">(Feb 28 2022 at 12:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330967">Wrenna Robson</span> <a href="#narrow/stream/113488-general/topic/Comonads/near/273481558">said</a>:</p>
<blockquote>
<p>(Also: this is more of a general category-theory question, but in that, fmap in the comonad is just, well, fmap. But I was wondering - how come it doesn't become covariant, so that you don't have <code>fmap : (a -&gt; b) -&gt; f b -&gt; f a</code>?</p>
</blockquote>
<p>A comonad is a monad on the opposite category, so both source and target are reversed = it's still a functor on the original category.</p>



<a name="273483361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273483361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273483361">(Feb 28 2022 at 12:45)</a>:</h4>
<p>Aha, right.</p>



<a name="273483422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273483422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273483422">(Feb 28 2022 at 12:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Comonads/near/273483285">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="330967">Wrenna Robson</span> <a href="#narrow/stream/113488-general/topic/Comonads/near/273481385">said</a>:</p>
<blockquote>
<p>I was reading this. The tricky thing I found is that in Lean, (programming) monads are defined in terms of extending applicative functors. But it's not clear to me what a "coapplicative" functor would be or how that should be defined, or even if it's right to do it that way.</p>
</blockquote>
<p>This is a feature of the category of sets--a general monad isn't applicative (= lax monoidal).</p>
</blockquote>
<p>Right, but "monad" in the programming sense in Lean <em>is</em> always applicative?</p>



<a name="273483557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273483557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273483557">(Feb 28 2022 at 12:47)</a>:</h4>
<p>because monad there is specialized to Type (= Set)</p>



<a name="273484222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273484222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273484222">(Feb 28 2022 at 12:53)</a>:</h4>
<p>comonads are also specialized, but they are monads on Set^op--and Set^op behaves very differently from Set</p>



<a name="273484374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273484374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273484374">(Feb 28 2022 at 12:54)</a>:</h4>
<p>Aha - thank you.</p>



<a name="273484429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273484429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273484429">(Feb 28 2022 at 12:55)</a>:</h4>
<p><code>Control.Monad</code> is Haskell appears to have some sort of <code>ComonadApply</code> class, but in light of what you've said I'm sceptical of it. <a href="https://hackage.haskell.org/package/comonad-5.0.8/docs/Control-Comonad.html#t:ComonadApply">https://hackage.haskell.org/package/comonad-5.0.8/docs/Control-Comonad.html#t:ComonadApply</a></p>



<a name="273484516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273484516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273484516">(Feb 28 2022 at 12:56)</a>:</h4>
<p>So, you should not in general expect comonads (in the programming sense) to be formally dual to monads (in the programming sense)</p>



<a name="273484531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273484531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273484531">(Feb 28 2022 at 12:56)</a>:</h4>
<p>right</p>



<a name="273484682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Comonads/near/273484682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Comonads.html#273484682">(Feb 28 2022 at 12:57)</a>:</h4>
<p>That is confusing!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
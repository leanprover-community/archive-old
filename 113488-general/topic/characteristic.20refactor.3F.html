---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/characteristic.20refactor.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html">characteristic refactor?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="233298056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233298056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233298056">(Apr 06 2021 at 10:38)</a>:</h4>
<p>Issue <a href="https://github.com/leanprover-community/mathlib/issues/4688">#4688</a> asks for the characteristic of a (semi)ring to be refactored. Unifying the definition of <code>char_p</code> and <code>char_zero</code>. In <a href="https://github.com/leanprover-community/mathlib/issues/6753">#6753</a> Damiano has recently suggested that it would make sense to redefine <code>ring_char</code> in terms of <code>add_order_of (1 : R)</code>. I had similar thoughts, but since this would be a major refactor, I wanted to ask for opinions whether this is desirable at all and what the concrete suggestion would be. </p>
<p>Like I said, I would imagine that <code>ring_char R = add_order_of (1 : R)</code> and then one could let <code>char_p R p</code> be the class defined by the condition <code>(h : ring_char R = p)</code>. <code>char_zero</code> would then not exist separatly but be the special case <code>char_p R 0</code>. </p>
<p>(I assume that another option would be to work with something like <code>[fact(ring_char R = p)]</code> but I assumed this was ruled out before since <code>char_p</code> is used a lot). </p>
<p>What do you think? Are there any suggestions how to make this more managable?</p>



<a name="233298309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233298309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233298309">(Apr 06 2021 at 10:41)</a>:</h4>
<p>I think this refactor is a good idea. For the transition, my first suggestion would be to do it in multiple steps: change the definition of <code>char_p</code>, change the definition of <code>char_zero</code>, replace usages of <code>char_zero</code> with <code>char_p 0</code>.</p>



<a name="233298494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233298494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233298494">(Apr 06 2021 at 10:43)</a>:</h4>
<p>As long as you keep a definition <a href="https://leanprover-community.github.io/mathlib_docs/find/char_p.cast_eq_zero_iff">docs#char_p.cast_eq_zero_iff</a>, I expect that you will only need to tweak the instance definitions, no usages.</p>



<a name="233298659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233298659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233298659">(Apr 06 2021 at 10:45)</a>:</h4>
<p><code>add_order_of 1</code> doesn't work for <code>add_monoid</code>s, right? So we do not satisfy point 2 of <a href="https://github.com/leanprover-community/mathlib/issues/4688">#4688</a>.</p>



<a name="233299184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233299184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233299184">(Apr 06 2021 at 10:51)</a>:</h4>
<p>I quickly thought about this and was wondering how to define the "order" of an element <code>a</code> in a <code>semigroup/monoid</code>.  I probably would define it to be the smallest gap between two repeated values of the iterated operation of the element on itself:<br>
the sequence<br>
<code>a</code>, <code>a.a</code>, <code>a.a.a</code>,... <br>
either</p>
<ul>
<li>never repeats itself, in which case the order would be zero, or</li>
<li>repeats a value at some point and the gap between the first repeated values would be the order.</li>
</ul>
<p>It seems to me that this should be a reasonable definition, but I have no experience of working with something like this mathematically.  It might be that someone doing dynamics has a better idea, given that the one outlined above is related to pre-periodic points.</p>



<a name="233299531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233299531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233299531">(Apr 06 2021 at 10:54)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> Of course it has to be <code>[add_monoid R] [has_one R]</code>, but this is anyway the minimal assumptions one can put to make sense of <code>ring_char</code>, whatever the definition is. Thanks to previous PRs this definition would typecheck.</p>



<a name="233299736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233299736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233299736">(Apr 06 2021 at 10:57)</a>:</h4>
<p>I was just wondering whether the supremum of <code>add_order_of</code> would work 1) as another definition, and 2) have a useful meaning outside of semirings.</p>



<a name="233299905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233299905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233299905">(Apr 06 2021 at 10:59)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> At the moment <code>add_order_of a</code> is defined to be the smallest positive number such that <code>n \smul\N a=0</code> if it exists and <code>0</code> otherwise. There is a suggestion by Yury to redefine it in terms of <a href="https://leanprover-community.github.io/mathlib_docs/find/function.minimal_period">docs#function.minimal_period</a>, so that <code>to_additive</code> works in more cases and some statements are for free from the general theory, but I guess this refactor could be done independently or first (I don't imagine it to be terribly difficult. I've changed the definition of <code>order_of</code> before and not that much breaks, the API is pretty robust.)</p>



<a name="233300145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233300145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233300145">(Apr 06 2021 at 11:01)</a>:</h4>
<p>Ok, using <code>add_order_of</code> for now sounds like a good plan.  I am not really sure that I know good examples of semirings where <code>minimal_period</code> would give me more leverage than <code>add_order_of</code>!</p>



<a name="233300261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233300261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233300261">(Apr 06 2021 at 11:03)</a>:</h4>
<p>Also, I think that <code>add_order_of</code> is relatively "new" as a definition in mathilb.  Working with it may also start showing how useful it is in practice.</p>



<a name="233300424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233300424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233300424">(Apr 06 2021 at 11:04)</a>:</h4>
<p>Indeed, it is <a href="https://github.com/leanprover-community/mathlib/issues/6770">#6770</a>, merged 5 days ago.</p>



<a name="233313647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233313647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233313647">(Apr 06 2021 at 12:59)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> Your supremum definition makes sense if we want to generalise to non-unital rings.</p>



<a name="233315883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233315883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233315883">(Apr 06 2021 at 13:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="317890">Julian Külshammer</span> <a href="#narrow/stream/113488-general/topic/characteristic.20refactor.3F/near/233313647">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> Your supremum definition makes sense if we want to generalise to non-unital rings.</p>
</blockquote>
<p>We still don't have <a href="https://github.com/leanprover-community/mathlib/pull/6786">these</a> <span aria-label="cry" class="emoji emoji-1f622" role="img" title="cry">:cry:</span></p>



<a name="233329894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233329894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233329894">(Apr 06 2021 at 14:40)</a>:</h4>
<p><span class="user-mention" data-user-id="240862">@Oliver Nash</span> That's a pity, but for me the question is, how to redefine <code>ring_char</code> so that when they arrive, it is only a matter of replacing <code>semiring</code> by <code>non_unital_semiring</code> in a few places. To me this feels more natural than defining it for <code>[add_monoid R] [has_one R]</code> for which I know no example.</p>



<a name="233444788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233444788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233444788">(Apr 07 2021 at 07:30)</a>:</h4>
<p>Dear All,</p>
<p>I have been experimenting with the definition and it seems that what is below can be made to work.  Following Anne's suggestion, it seems to make sense to define the "characteristic" of an <code>add_monoid R</code> as the smallest natural number <code>n</code> such that <code>∀ a : R, n • a = 0</code>, or <code>0</code> if the set of such <code>n</code>s is empty.</p>
<p>This is also called, I believe, the exponent, at least in the case of a (commutative) group.  So, should we define <code>exponent R</code>?</p>
<p>What I started with is playing around with the "annihilating set" for all of <code>R</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.iterate_hom</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">ann</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="o">((</span><span class="bp">+</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">ann_exists</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">ann</span> <span class="n">R</span> <span class="bp">=</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="o">((</span><span class="bp">+</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>
<p>NB: the elements of <code>ann R</code> are <em>one less</em> than what I would call the annihilator!  Thus, the exponent would have to be defined as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">exponent</span> <span class="n">R</span> <span class="bp">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">ann</span> <span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">(</span><span class="n">min</span> <span class="o">(</span><span class="n">ann</span> <span class="n">R</span><span class="o">))</span> <span class="bp">+</span> <span class="mi">1</span>
</code></pre></div>
<p>but written in a way that works in Lean.</p>



<a name="233444836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233444836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233444836">(Apr 07 2021 at 07:30)</a>:</h4>
<p>In my experiments, I have started to prove that <code>ann (zmod n)</code> contains <code>n - 1</code> and, so far, it has not been too rough.</p>



<a name="233444946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233444946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233444946">(Apr 07 2021 at 07:32)</a>:</h4>
<p>I also proved with little effort that, if <code>R</code> is a <code>semiring</code>, then the "annihilator of 1" annihilates the whole <code>semiring</code>.</p>



<a name="233445153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233445153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233445153">(Apr 07 2021 at 07:34)</a>:</h4>
<p>By natural number you mean positive integer?</p>



<a name="233447281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233447281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233447281">(Apr 07 2021 at 07:55)</a>:</h4>
<p>Why <code>(+ a)^[n] n</code> and not <code>n \smul a</code> or <code>n \smul\N a</code>?</p>



<a name="233447299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233447299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233447299">(Apr 07 2021 at 07:55)</a>:</h4>
<p>That would eliminate the off-by-one error you observed!</p>



<a name="233447411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233447411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233447411">(Apr 07 2021 at 07:56)</a>:</h4>
<p>Here is a further expansion (I only now read Kevin and Eric's comments).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.basic</span>
<span class="kn">import</span> <span class="n">algebra.iterate_hom</span>

<span class="kn">section</span> <span class="n">char</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">ann</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="o">((</span><span class="bp">+</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">ann_exists</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">ann</span> <span class="n">R</span> <span class="bp">=</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="o">((</span><span class="bp">+</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">zmod.pred_eq_neg_one</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span> <span class="o">:</span> <span class="o">((</span><span class="n">n.pred</span><span class="o">)</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">casesI</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">lt_irrefl</span> <span class="mi">0</span> <span class="n">h.1</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">add_eq_zero_iff_eq_neg.mp</span> <span class="o">(</span><span class="n">zmod.nat_cast_self'</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">zmod_pred_ann</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">∈</span> <span class="n">ann</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_left_iterate</span><span class="o">,</span> <span class="n">nsmul_eq_mul</span><span class="o">,</span> <span class="bp">←</span> <span class="n">nat.pred_eq_sub_one</span><span class="o">,</span> <span class="n">zmod.pred_eq_neg_one</span><span class="o">,</span>
    <span class="n">neg_mul_eq_neg_mul_symm</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">add_left_neg</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">not_ann</span> <span class="o">{</span><span class="n">k</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span> <span class="o">(</span><span class="n">kn</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">add_eq_zero_iff_eq_neg</span><span class="o">,</span> <span class="bp">←</span> <span class="n">nat.cast_one</span><span class="o">,</span> <span class="bp">←</span> <span class="n">nat.cast_add</span><span class="o">,</span> <span class="n">zmod.nat_coe_zmod_eq_zero_iff_dvd</span><span class="o">],</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="o">⟩,</span>
  <span class="n">cases</span> <span class="n">j</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">k.succ_pos</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">hj</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat.lt_asymm</span> <span class="n">this</span> <span class="n">this</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">nk</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">le_trans</span> <span class="n">_</span> <span class="n">hj.ge</span><span class="o">,</span>
    <span class="n">nth_rewrite</span> <span class="mi">0</span> <span class="bp">←</span> <span class="n">mul_one</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">mul_le_mul_left</span> <span class="n">h.1</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="n">nat.succ_pos</span> <span class="n">_</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">kn</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">nat.add_lt_of_lt_sub_right</span> <span class="n">kn</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">lt_irrefl</span> <span class="n">n</span> <span class="o">(</span><span class="n">nk.trans_lt</span> <span class="n">kn</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">zmod_not_ann</span> <span class="o">{</span><span class="n">k</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span> <span class="o">(</span><span class="n">kn</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">∉</span> <span class="n">ann</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_one</span><span class="o">,</span> <span class="n">add_eq_zero_iff_eq_neg</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">not_ann</span> <span class="n">kn</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="233447492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233447492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233447492">(Apr 07 2021 at 07:57)</a>:</h4>
<p>Kevin, yes, I meant positive integer!  The "off-by-one" thing confused me!  Although, it seems that Eric's suggestion will make this better!</p>



<a name="233447563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233447563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233447563">(Apr 07 2021 at 07:58)</a>:</h4>
<p>Anyway, I now have to meet students: I will be quiet for a while!</p>



<a name="233449719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233449719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233449719">(Apr 07 2021 at 08:17)</a>:</h4>
<p>I did some experiments with <code>minimal_period</code> and my conclusion was that I'd like to introduce the predicate <code>is_of_finite_order</code> which seems similar to your findings. I can push around lunch tiime.</p>



<a name="233458447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/233458447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#233458447">(Apr 07 2021 at 09:39)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7082">#7082</a> shows the status of the minimal_period refactor right now. Comments welcome, keep in mind it is in an early stage.</p>



<a name="234056703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234056703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234056703">(Apr 11 2021 at 15:59)</a>:</h4>
<p>According to the strategy which <span class="user-mention" data-user-id="238446">@Anne Baanen</span> and <span class="user-mention" data-user-id="321459">@Damiano Testa</span> suggested, after <a href="https://github.com/leanprover-community/mathlib/issues/7082">#7082</a> gets hopefully merged, the next natural step would be to define the exponent of a group (or a monoid). Again we would want that this makes sense for infinite groups. The exponent of a group is the lcm of all the orders of elements of a group. This is a potentially infinite set. As far as I can see, there is only the lcm of a multiset and a finset. Would it make sense to define the lcm of an infinite set as 0 and otherwise as the lcm of the corresponding finset? It looks a bit like what was done for finprod/finsum recently.</p>



<a name="234057040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234057040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234057040">(Apr 11 2021 at 16:04)</a>:</h4>
<p>These adjectives "lowest" and "highest" are really unfortunate. The "lowest" common multiple of a bunch of naturals should be the unique natural which is a multiple of all of them and which divides all the other naturals which are a multiple of all of them, ie the lowest under the divisibility relation. This is what is always used in practice. So I completely agree that 0 is a good choice here.</p>



<a name="234060959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234060959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234060959">(Apr 11 2021 at 17:09)</a>:</h4>
<p>I would have made the same choice: if the <code>set</code> of orders is not finite, define the <code>exponent</code> as zero.  Clearly no finite group will have exponent zero, so, that should also cause no confusion with mathematicians!</p>



<a name="234533394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234533394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234533394">(Apr 14 2021 at 16:45)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> , you had asked to be reminded about PR <a href="https://github.com/leanprover-community/mathlib/issues/7082">#7082</a>, which I am doing now.  However, do not feel pressured to look at it: I can understand that it is not a priority!</p>
<p>As a side note, I have also made sure that the PR is compatible with Sébastien's refactor.</p>



<a name="234533799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234533799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234533799">(Apr 14 2021 at 16:48)</a>:</h4>
<p>[I thought that it built successfully, but now CI seems to still be going at it.  However, it is in the final Linting/Testing stage]</p>



<a name="234538169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234538169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234538169">(Apr 14 2021 at 17:14)</a>:</h4>
<p>Thank you for the reminder!</p>



<a name="234822051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234822051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234822051">(Apr 16 2021 at 09:26)</a>:</h4>
<p>Any comments on the following definition of exponent of a group before I start proving stuff about it?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset.gcd</span>
<span class="kn">import</span> <span class="n">data.set.finite</span>
<span class="kn">import</span> <span class="n">data.nat.gcd</span>
<span class="kn">import</span> <span class="n">group_theory.order_of_element</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_cancel_monoid_with_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">gcd_monoid</span> <span class="n">M</span><span class="o">]</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">set.lcm</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">S.finite</span> <span class="k">then</span> <span class="n">finset.lcm</span> <span class="n">h.to_finset</span> <span class="n">id</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">exponent</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">lcm</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="bp">∃</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">order_of</span> <span class="n">x</span> <span class="o">}</span>
</code></pre></div>



<a name="234822171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234822171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234822171">(Apr 16 2021 at 09:27)</a>:</h4>
<p>Hmm, I guess that works. But I would probably have used <code>nat.find</code>.</p>



<a name="234822338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234822338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234822338">(Apr 16 2021 at 09:28)</a>:</h4>
<p>Something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">exponent_exists</span> <span class="o">:</span> <span class="bp">\</span><span class="n">ex</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">\</span><span class="n">all</span> <span class="n">g</span><span class="o">,</span> <span class="n">n</span> <span class="bp">\</span><span class="n">bu</span> <span class="n">g</span> <span class="bp">=</span> <span class="mi">0</span>

<span class="kd">def</span> <span class="n">exponent</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">exponent_exists</span> <span class="k">then</span> <span class="n">nat.find</span> <span class="n">h</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>



<a name="234823045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234823045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234823045">(Apr 16 2021 at 09:34)</a>:</h4>
<p>With your definition, you will also need to develop an API for <code>set.lcm</code>. Which is fine, of course. <code>nat.find</code> has 3 lemmas, that's it's total API. So that's maybe also quite minimalistic.</p>



<a name="234823097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234823097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234823097">(Apr 16 2021 at 09:34)</a>:</h4>
<p>That also makes sense. The equivalence of both would be one of the first things to prove.</p>



<a name="234823163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234823163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234823163">(Apr 16 2021 at 09:35)</a>:</h4>
<p>Your approach also has the advantage that I already know all the <code>nat.find</code> API :-)</p>



<a name="234823493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234823493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234823493">(Apr 16 2021 at 09:37)</a>:</h4>
<p>Pasting your code in my lean asks for the <code>lcm</code> to really be a <code>set.lcm</code>: is this not happening for you?</p>



<a name="234823562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234823562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234823562">(Apr 16 2021 at 09:38)</a>:</h4>
<p>I guess <code>open set</code> is missing</p>



<a name="234823805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234823805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234823805">(Apr 16 2021 at 09:40)</a>:</h4>
<p>Sorry, I changed a few things last minute before pasting. I had <code>namespace set</code> there before, but I guess <code>set.exponent</code> doesn't make much sense.</p>



<a name="234823903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234823903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234823903">(Apr 16 2021 at 09:41)</a>:</h4>
<p>Ok, no worries! I also do not want to sidetrack the discussion: I was simply trying to understand whether there was something funny with my copy of Lean.  Issue settled!</p>



<a name="234824000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234824000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234824000">(Apr 16 2021 at 09:42)</a>:</h4>
<p>On the side of definitions, I think that I prefer Johan's version: you probably do not need to assume that <code>M</code> is a <code>comm_cancel_monoid_with_zero</code> with that...</p>



<a name="234824185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234824185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234824185">(Apr 16 2021 at 09:43)</a>:</h4>
<p>Although I would change <code>n &lt; 0</code> for <code>0 &lt; n</code>...</p>



<a name="234824195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234824195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234824195">(Apr 16 2021 at 09:43)</a>:</h4>
<p>I don't, <code>nat</code> is the <code>comm_cancel_monoid_with_zero</code>, <code>G</code> is just a monoid.</p>



<a name="234824729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234824729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234824729">(Apr 16 2021 at 09:47)</a>:</h4>
<p>Ah, sorry!  I had missed this!  However, to define exponents with Johan's formulation, you no longer need to define the <code>set.lcm</code>, which I think is a plus.</p>



<a name="234825095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234825095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234825095">(Apr 16 2021 at 09:50)</a>:</h4>
<p>I agree, although it might be good to have it anyway to show the equivalence.</p>



<a name="234825763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234825763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234825763">(Apr 16 2021 at 09:56)</a>:</h4>
<p>I certainly think that the equivalence should be there, but the definition of <code>exponent</code> should not need the definition of <code>set.lcm</code>, in my opinion.</p>



<a name="234830238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/234830238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#234830238">(Apr 16 2021 at 10:32)</a>:</h4>
<p>A more uniform way of defining the lcm of a set <code>s</code> of integers (or indexed family) is to pick a generator of the ideal given by intersecting the principal ideals from <code>s</code></p>



<a name="236299508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/characteristic%20refactor%3F/near/236299508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/characteristic.20refactor.3F.html#236299508">(Apr 27 2021 at 08:20)</a>:</h4>
<p>The two waves of refactors, with <code>nat</code> and <code>int</code> have washed over PR <a href="https://github.com/leanprover-community/mathlib/issues/7082">#7082</a>.  I believe that I have resolved all conflicts and CI is checking this right now.</p>
<p>In case someone wants to take a look at this PR, I would be very grateful!  In particular, I will ping <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> , who had expressed interested in this refactor!</p>
<p>Thanks a lot!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
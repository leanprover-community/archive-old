---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html">what is (17 : fin 2)?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="226199560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20%2817%20%3A%20fin%202%29%3F/near/226199560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Kontorovich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html#226199560">(Feb 12 2021 at 21:39)</a>:</h4>
<p>Why doesn't Lean just tell me this is nonsense? It won't accept (banana : fin 2) but it's accepting 17, and I don't know what that's supposed to mean. (Will Lean 4 be any different in this respect?) Just curious, thanks!</p>



<a name="226201458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20%2817%20%3A%20fin%202%29%3F/near/226201458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html#226201458">(Feb 12 2021 at 21:57)</a>:</h4>
<p>Does <code>#eval</code> work?</p>



<a name="226201489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20%2817%20%3A%20fin%202%29%3F/near/226201489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html#226201489">(Feb 12 2021 at 21:57)</a>:</h4>
<p>Anyway it's defined with wrapping arithmetic, so it is <code>1</code></p>



<a name="226201545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20%2817%20%3A%20fin%202%29%3F/near/226201545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html#226201545">(Feb 12 2021 at 21:58)</a>:</h4>
<p>There is a PR in the pipes to change it to saturating arithmetic but it will still be <code>1</code> in that case</p>



<a name="226201655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20%2817%20%3A%20fin%202%29%3F/near/226201655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html#226201655">(Feb 12 2021 at 21:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">(</span><span class="mi">17</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">-- 1</span>
</code></pre></div>



<a name="226201835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20%2817%20%3A%20fin%202%29%3F/near/226201835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html#226201835">(Feb 12 2021 at 22:00)</a>:</h4>
<p>As for why lean doesn't say it's nonsense, it's because numerals in lean desugar to applications of the <code>bit0</code> and <code>bit1</code> functions that are defined on anything with a <code>1</code> and a <code>+</code></p>



<a name="226201900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20%2817%20%3A%20fin%202%29%3F/near/226201900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html#226201900">(Feb 12 2021 at 22:00)</a>:</h4>
<p>this approach doesn't leave any room for saying that some numerals are okay and others are not, you either get all numerals or none</p>



<a name="226202164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20%2817%20%3A%20fin%202%29%3F/near/226202164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html#226202164">(Feb 12 2021 at 22:03)</a>:</h4>
<p>as for whether lean 4 will change things, it's not clear. The approach is different - there is a class <code>OfNat A n</code> that inhabits each particular numeral, so in principle we could have instances <code>OfNat (fin 17) 0</code> , ...<code>OfNat (fin 17) 16</code> with no more, and then you will only be able to use these numerals, but it's not yet clear how to get families of instances parameterized by decidable arithmetic predicates like this (we would want <code>instance (h : m &lt; n) : OfNat (fin n) m</code> here but that needs typeclass inference to prove <code>m &lt; n</code> somehow).</p>



<a name="226262430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20%2817%20%3A%20fin%202%29%3F/near/226262430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html#226262430">(Feb 13 2021 at 19:26)</a>:</h4>
<p>Lean 4 has less room to "somehow prove something" in type class search as it is no longer supposed to invoke the tactic framework. The only option that I know of is to use an instance of <code>Fact (n &lt; m)</code></p>



<a name="226272289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/what%20is%20%2817%20%3A%20fin%202%29%3F/near/226272289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/what.20is.20(17.20.3A.20fin.202).3F.html#226272289">(Feb 13 2021 at 22:23)</a>:</h4>
<p>Well it doesn't need to invoke "tactics" per se, there are a bunch of monads now, we just need the relevant one to have extensible rules, possibly with a caveat that any extensions need to be pure-functional and possibly some other properties, and the user is responsible for any slowdown that results. Lean 3 can't call tactics either, and especially when it comes to dealing with kernel literals the alternative to "computed instances" is a sort of prolog-programming in instance search which is almost guaranteed to have worse performance and probably a worse result too (a needlessly complicated instance term coming out, that affects downstream elaboration).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
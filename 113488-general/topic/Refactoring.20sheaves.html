---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Refactoring.20sheaves.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html">Refactoring sheaves</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="289724799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289724799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289724799">(Jul 15 2022 at 13:15)</a>:</h4>
<p>Now that sheaves over sites has a rich and useful API, I think it is increasingly favorable that we switch the "official definition" of sheaves over topological spaces to be the one in terms of grothendieck topologies. This switch was also briefly discussed in <a href="#narrow/stream/116395-maths/topic/Meromorphic.20functions">this topic</a>. The main pros are </p>
<ol>
<li>The <code>X.Sheaf C</code> category is now defeq to <code>(opens.grothendieck_topology X).Sheaf C</code>, so that functors between categories of sheaves over sites (and other categorical results) could be specialized onto topological spaces without the abundant equivalences.</li>
<li>It allows sheaves over spaces to value in arbitrary categories that doesn't have all products.</li>
</ol>
<p>Some changes / cons are</p>
<ol>
<li>(I saw someone mention this elsewhere) People would need to know what sites are before using it. But this could be solved by sufficient documentation.</li>
<li>For <code>F : X.sheaf C</code>, <code>F.1</code> now has the type of a functor, and we need <code>F.presheaf</code> to access the dot notation, but I think writing out the explicit projection is favored in mathlib nonetheless. </li>
<li><code>X.sheaf C</code> is no longer a subtype of <code>X.presheaf C</code>, but following the arguments of making <code>Sheaf</code> not a subtype, I think this is a conscious and appreciated change.</li>
</ol>
<p>There is also a draft PR <a href="https://github.com/leanprover-community/mathlib/pull/15384">#15384</a> which builds but still fails lint (mainly because <code>[has_products C]</code> is no longer nessecary) and lacks documentation if one would like to see how the switch went.</p>



<a name="289789130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289789130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam van G <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289789130">(Jul 15 2022 at 22:07)</a>:</h4>
<p>From my experience with <span class="user-mention" data-user-id="391579">@Jake Levinson</span> formalizing some things this past week, I think it is really important, if such a refactoring is made, that there is a <em>very</em> good API that allows someone who doesn't know what a site is to pretend they are working with a topological space, with the "backend" doing the work of creating the relevant site,  canonical Grothendieck topology on that site, showing that a sheaf in the topology sense is the same as a sheaf in the Grothendieck sense, etc.</p>



<a name="289789768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289789768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam van G <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289789768">(Jul 15 2022 at 22:14)</a>:</h4>
<p>On a related, but different topic, also regarding the appropriate level of generality in the definition of sheaf: we ran into quite some trouble with forgetful functors and the category <code>C</code>. I am worried that con (3) in Andrew's comment above might lead to similar problems but I may be wrong, I can't truly assess that.<br>
In our PR <a href="https://github.com/leanprover-community/mathlib/pull/15398">#15398</a> we tried to address this by introducing some notation, but with limited success. If anyone who knows the category theory part of the library better than we do can show how to make the transition from object of C to underlying set <a href="https://github.com/leanprover-community/mathlib/pull/15398#discussion_r922520725">here</a> and <a href="https://github.com/leanprover-community/mathlib/pull/15398#discussion_r922521056">here</a> less painful, that would be great.</p>



<a name="289789929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289789929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam van G <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289789929">(Jul 15 2022 at 22:16)</a>:</h4>
<p>Tagging <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="110087">@Scott Morrison</span>  <span class="user-mention" data-user-id="496319">@Nikolas Kuhn</span> in case they want to weigh in (my point of view may very well be too naive or I may be misunderstanding how to use the category part of the library correctly)</p>



<a name="289789939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289789939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289789939">(Jul 15 2022 at 22:16)</a>:</h4>
<p><span class="user-mention" data-user-id="411579">@Sam van G</span> can you explain what troubles you are referring to with forgetful functors?</p>



<a name="289790014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289790014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam van G <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289790014">(Jul 15 2022 at 22:17)</a>:</h4>
<p>It is explained in detail in Jake's two comments on our PR: <a href="https://github.com/leanprover-community/mathlib/pull/15398/files">https://github.com/leanprover-community/mathlib/pull/15398/files</a></p>



<a name="289790386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289790386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289790386">(Jul 15 2022 at 22:22)</a>:</h4>
<p>Hmmm.... it seems that you're not really using the <code>whiskering</code> api we have set up for sheaves.</p>



<a name="289790428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289790428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289790428">(Jul 15 2022 at 22:23)</a>:</h4>
<p>We still don't have the general notion of stalks for sheaves on sites (e.g. w.r.t. topos-theoretic points, or something similar)</p>



<a name="289790440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289790440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289790440">(Jul 15 2022 at 22:23)</a>:</h4>
<p>That's one important point that's missing from the sheaves-on-sites part of the library</p>



<a name="289790651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289790651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289790651">(Jul 15 2022 at 22:26)</a>:</h4>
<p>I could definitely believe that we overlooked or misunderstood part of the API. (I remember seeing the word <code>whiskering</code> but not knowing what it meant.)</p>



<a name="289790705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289790705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289790705">(Jul 15 2022 at 22:27)</a>:</h4>
<p>That said, everything seemed to work fine until those last two lines of the proof, when we weren’t able to easily deal with the <code>(forget C).map</code> applications.</p>



<a name="289791490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289791490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289791490">(Jul 15 2022 at 22:38)</a>:</h4>
<p>We have a good API for filtered colimits of concrete categories. presumably that would help here.</p>



<a name="289792194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289792194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289792194">(Jul 15 2022 at 22:48)</a>:</h4>
<p>That's pretty cool notation!</p>



<a name="289792365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289792365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289792365">(Jul 15 2022 at 22:50)</a>:</h4>
<p>Okay, your last 4 lines </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">change</span> <span class="o">(((</span><span class="n">forget</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">_</span><span class="o">)</span> <span class="bp">≫</span> <span class="o">((</span><span class="n">forget</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">_</span><span class="o">))</span> <span class="n">s</span> <span class="bp">=</span>
<span class="o">(((</span><span class="n">forget</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">_</span><span class="o">)</span> <span class="bp">≫</span> <span class="o">((</span><span class="n">forget</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">_</span><span class="o">))</span> <span class="n">s</span><span class="o">,</span>

<span class="n">rw</span> <span class="bp">←</span> <span class="o">(</span><span class="n">forget</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">map_comp</span><span class="o">,</span>
<span class="n">rw</span> <span class="bp">←</span> <span class="o">(</span><span class="n">forget</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">map_comp</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">T.naturality</span><span class="o">,</span>
</code></pre></div>
<p>can be changed to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">dsimp</span> <span class="o">[</span><span class="n">map_on_sections</span><span class="o">,</span> <span class="n">restrict_along</span><span class="o">],</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">comp_apply</span><span class="o">,</span> <span class="n">nat_trans.naturality</span><span class="o">],</span>
</code></pre></div>



<a name="289793017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289793017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289793017">(Jul 15 2022 at 23:00)</a>:</h4>
<p>And your last few lines in the other direction can be proved using </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">map_on_sections</span><span class="o">,</span> <span class="n">forget_map_eq_coe</span><span class="o">]</span> <span class="n">at</span> <span class="n">h_eq</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">h_eq</span><span class="o">,</span>
<span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Top.presheaf.germ</span><span class="o">],</span>
<span class="k">let</span> <span class="n">ι'</span> <span class="o">:</span> <span class="o">(⟨</span><span class="n">V</span><span class="o">,</span><span class="n">hxV</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">open_nhds</span> <span class="n">x</span><span class="o">)</span> <span class="bp">⟶</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span><span class="n">hxU</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ι</span><span class="o">,</span>
<span class="n">erw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">limits.colimit.w</span> <span class="n">_</span> <span class="n">ι'.op</span><span class="o">,</span> <span class="n">comp_apply</span><span class="o">],</span> <span class="n">refl</span><span class="o">,</span>
</code></pre></div>



<a name="289793166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289793166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289793166">(Jul 15 2022 at 23:02)</a>:</h4>
<p>It seems that there is some API missing here. The API around <code>germ</code> is done for any category <code>C</code> essentially by using the colimit api, but now you're using it on elements when you have a concrete category, so there is some back-and-forth that needs to happen when you apply a composition of moprhisms.</p>



<a name="289793373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289793373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289793373">(Jul 15 2022 at 23:05)</a>:</h4>
<p>Awesome! We’ll make those edits. If you can think of any API additions you think we should add in this same PR, we’d be happy to extend it.</p>



<a name="289793382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289793382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289793382">(Jul 15 2022 at 23:05)</a>:</h4>
<p><span class="user-mention" data-user-id="411579">@Sam van G</span></p>



<a name="289793393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289793393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289793393">(Jul 15 2022 at 23:06)</a>:</h4>
<p>One sec I think I can clean up the second block</p>



<a name="289793531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289793531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289793531">(Jul 15 2022 at 23:07)</a>:</h4>
<p>Okay here's the complete proof with the new finishing lines</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Being locally surjective is equivalent to being surjective on stalks. -/</span>
<span class="kd">lemma</span> <span class="n">locally_surjective_iff_surjective_on_stalks</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">ℱ</span> <span class="bp">⟶</span> <span class="bp">𝒢</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_locally_surjective</span> <span class="n">T</span> <span class="bp">↔</span> <span class="n">is_surjective_on_stalks</span> <span class="n">T</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intro</span> <span class="n">hT</span><span class="o">,</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> human proof:</span>
<span class="cm">    Let g ∈ Γₛₜ 𝒢 x be a germ. Represent it on an open set U ⊆ X</span>
<span class="cm">    as ⟨t, U⟩. By local surjectivity, pass to a smaller open set V</span>
<span class="cm">    on which there exists s ∈ Γ_ ℱ V mapping to t |_ V.</span>
<span class="cm">    Then the germ of s maps to g -/</span>

    <span class="c1">-- Let g ∈ Γₛₜ 𝒢 x be a germ.</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">g</span><span class="o">,</span>
    <span class="c1">-- Represent it on an open set U ⊆ X as ⟨t, U⟩.</span>
    <span class="n">rcases</span> <span class="bp">𝒢.</span><span class="n">germ_exist</span> <span class="n">x</span> <span class="n">g</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="c1">-- By local surjectivity, pass to a smaller open set V</span>
    <span class="c1">-- on which there exists s ∈ Γ_ ℱ V mapping to t |_ V.</span>
    <span class="n">rcases</span> <span class="n">hT</span> <span class="n">U</span> <span class="n">t</span> <span class="n">x</span> <span class="n">hxU</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">ι</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">h_eq</span><span class="o">⟩,</span>

    <span class="c1">-- Then the germ of s maps to g.</span>
    <span class="n">use</span> <span class="o">(</span><span class="n">forget</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">ℱ.germ</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hxV</span><span class="o">⟩)</span> <span class="n">s</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">Top.presheaf.stalk_functor_map_germ_apply</span> <span class="n">V</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hxV</span><span class="o">⟩</span> <span class="n">T</span> <span class="n">s</span><span class="o">,</span>

    <span class="c1">-- New finish</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">map_on_sections</span><span class="o">,</span> <span class="n">forget_map_eq_coe</span><span class="o">]</span> <span class="n">at</span> <span class="n">h_eq</span><span class="o">,</span>
    <span class="n">erw</span> <span class="o">[</span><span class="n">h_eq</span><span class="o">,</span> <span class="bp">←</span> <span class="n">comp_apply</span><span class="o">,</span> <span class="bp">𝒢.</span><span class="n">germ_res</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>

  <span class="o">{</span> <span class="c">/-</span><span class="cm"> human proof:</span>
<span class="cm">    Let U be an open set, t ∈ Γ ℱ U a section, x ∈ U a point.</span>
<span class="cm">    By surjectivity on stalks, the germ of t is the image of</span>
<span class="cm">    some germ f ∈ Γₛₜ ℱ x. Represent f on some open set V ⊆ X as ⟨s, V⟩.</span>
<span class="cm">    Then there is some possibly smaller open set x ∈ W ⊆ V ∩ U on which</span>
<span class="cm">    we have T(s) |_ W = t |_ W. -/</span>
    <span class="n">intros</span> <span class="n">U</span> <span class="n">t</span> <span class="n">x</span> <span class="n">hxU</span><span class="o">,</span>

    <span class="n">set</span> <span class="n">t_x</span> <span class="o">:=</span> <span class="o">(</span><span class="n">forget</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">𝒢.</span><span class="n">germ</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hxU</span><span class="o">⟩)</span> <span class="n">t</span> <span class="k">with</span> <span class="n">ht_x</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">s_x</span><span class="o">,</span> <span class="n">hs_x</span> <span class="o">:</span> <span class="o">(</span><span class="n">T</span> <span class="n">_ₛₜ</span> <span class="n">x</span><span class="o">)</span> <span class="n">s_x</span> <span class="bp">=</span> <span class="n">t_x</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hT</span> <span class="n">x</span> <span class="n">t_x</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">ℱ.germ_exist</span> <span class="n">x</span> <span class="n">s_x</span><span class="o">,</span>
    <span class="c1">-- rfl : ℱ.germ x s = s_x</span>
    <span class="k">have</span> <span class="n">key_W</span> <span class="o">:=</span> <span class="bp">𝒢.</span><span class="n">germ_eq</span> <span class="n">x</span> <span class="n">hxV</span> <span class="n">hxU</span> <span class="o">(</span><span class="n">T</span> <span class="n">_</span><span class="bp">*</span> <span class="n">s</span><span class="o">)</span> <span class="n">t</span>
      <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">hs_x</span><span class="o">,</span>
            <span class="n">symmetry</span><span class="o">,</span>
            <span class="n">convert</span> <span class="n">Top.presheaf.stalk_functor_map_germ_apply</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s</span><span class="o">,</span> <span class="o">}),</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">W</span><span class="o">,</span> <span class="n">hxW</span><span class="o">,</span> <span class="n">hWV</span><span class="o">,</span> <span class="n">hWU</span><span class="o">,</span> <span class="n">h_eq</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">key_W</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">W</span><span class="o">,</span> <span class="n">hWU</span><span class="o">,</span> <span class="n">hxW</span><span class="o">,</span> <span class="o">⟨</span><span class="n">s</span> <span class="bp">|</span><span class="n">_</span> <span class="n">hWV</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩⟩,</span>
    <span class="n">convert</span> <span class="n">h_eq</span><span class="o">,</span>

    <span class="c1">-- New finish</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">map_on_sections</span><span class="o">,</span> <span class="n">restrict_along</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span> <span class="n">comp_apply</span><span class="o">,</span> <span class="n">nat_trans.naturality</span><span class="o">],</span>
    <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>Using <code>erw</code> is not ideal -- that usually means that there is some missing <code>dsimp</code> lemma.</p>



<a name="289794556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289794556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289794556">(Jul 15 2022 at 23:21)</a>:</h4>
<p>Hmm... on second thought it looks like all these defs/notations are just preventing the appropriate simp lemmas from firing.</p>



<a name="289794638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289794638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam van G <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289794638">(Jul 15 2022 at 23:22)</a>:</h4>
<p>Thanks Adam!! This is already a huge improvement.</p>



<a name="289794729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289794729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam van G <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289794729">(Jul 15 2022 at 23:23)</a>:</h4>
<p>Re your last comment, I may remember wrong and am not on computer right now but I <em>think</em> at one point yesterday <span class="user-mention" data-user-id="391579">@Jake Levinson</span> and I had the same thought and tried to just copy in the definitions for the notations and it did not help. Will check this later.</p>



<a name="289794839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289794839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289794839">(Jul 15 2022 at 23:25)</a>:</h4>
<p>Should we mark those definitions <code>reducible</code> or something?</p>



<a name="289794942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289794942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289794942">(Jul 15 2022 at 23:26)</a>:</h4>
<p>I think the best approach would be to make the notation directly using the existing API without making any new defs</p>



<a name="289794950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289794950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289794950">(Jul 15 2022 at 23:26)</a>:</h4>
<p>I'm no expert in making notation, so hopefully someone else can help with that</p>



<a name="289795111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289795111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289795111">(Jul 15 2022 at 23:29)</a>:</h4>
<p>Oh I see. We can experiment a bit, defining the notation directly. The notation definitely made parts of the proof easier to think through, so it would be nice to keep it in some form.</p>



<a name="289795143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289795143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289795143">(Jul 15 2022 at 23:29)</a>:</h4>
<p>I agree the notation is very nice, but I think having working <code>simp</code> lemmas would be nicer ;)</p>



<a name="289795206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289795206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289795206">(Jul 15 2022 at 23:30)</a>:</h4>
<p>it would be great if we can have both!</p>



<a name="289795548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289795548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289795548">(Jul 15 2022 at 23:35)</a>:</h4>
<p>Here's a version of the file with all the notation and defs removed (plus some tricks using instances for concrete categories):<br>
<a href="https://gist.github.com/adamtopaz/802c0ad2491ef63e37b0d040d85e9eef">https://gist.github.com/adamtopaz/802c0ad2491ef63e37b0d040d85e9eef</a></p>



<a name="289797878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289797878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289797878">(Jul 16 2022 at 00:17)</a>:</h4>
<p><span class="user-mention" data-user-id="411579">@Sam van G</span> Regarding your first comment, Is an iff rewriting the new sheaf condition with the old sheaf condition enough?<br>
If one really doesn't want to go near sites, one could rewrite it whenever they really want to use the sheaf condition.</p>



<a name="289798144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289798144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289798144">(Jul 16 2022 at 00:22)</a>:</h4>
<p>I think the bigger issue would be with sheafification.</p>



<a name="289798276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289798276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289798276">(Jul 16 2022 at 00:25)</a>:</h4>
<p>By this, do you mean that people working on sheaves over spaces would want sheafifications with a better underlying implementation?</p>



<a name="289798706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289798706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289798706">(Jul 16 2022 at 00:35)</a>:</h4>
<p>I just mean that the current def of the non-sites shrafification uses this disjoint union of stalks. So if someone wants to rely on this precise construction, they would have to deal with isomorphisms to go back and forth with the site-theoretic definition</p>



<a name="289798761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289798761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289798761">(Jul 16 2022 at 00:36)</a>:</h4>
<p>It's not that bad though. I don't think we have any defeq abuse in this part of the library.</p>



<a name="289798777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289798777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289798777">(Jul 16 2022 at 00:37)</a>:</h4>
<p>In any case, I'm 100% in favor  of the refactor that you suggested (obviously ;-) )</p>



<a name="289799376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289799376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam van G <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289799376">(Jul 16 2022 at 00:52)</a>:</h4>
<p>It is fundamental for algebraic geometry to be able to switch seamlessly between sheaf-as-functor-on-opens and sheaf-as-bundle-of-stalks. If this requires passing through an isomorphism every time you do it, I am worried it would add a layer of complication to the already pretty complicated API. So for being able to do some algebraic geometry, I personally would be more interested in making the existing sheaf on space more easily usable before trying to generalize.<br>
As an alternative option, couldn’t one begin by making a separate notion called <code>sheaf_on_site</code>, leaving the current notion of sheaf on space untouched, and then prove that the current notion is a special case of the newly defined <code>sheaf_on_site</code>? (This may be a somewhat non trivial exercise in itself.)</p>



<a name="289799436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289799436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289799436">(Jul 16 2022 at 00:52)</a>:</h4>
<p>The non-sites sheafification only applies to Types, and it has little API, so I don't think people should be encouraged to use that.<br>
In most cases people only only want a left adjoint to the forgetful functor, and in cases where people need the description on elements, knowing that the to sheafification map <code>is_locally_surjective</code> should be enough.</p>



<a name="289799612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289799612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289799612">(Jul 16 2022 at 00:56)</a>:</h4>
<p>The alternative approach is probably the current approach?<br>
The current approach is that A presheaf is a functor on opens, and <code>is_sheaf</code> is a predicate on it.<br>
A sheaf is just a bundled functor with the <code>is_sheaf</code> predicate.<br>
We have a definition of sheaves on sites and sheaf on spaces, the difference is that the <code>is_sheaf</code> is different, but the presheaf is the same thing.</p>
<p>What I am proposing is replacing the <code>is_sheaf</code> of spaces with the equivalent <code>is_sheaf</code> of sites. The functor should remain unchanged.</p>



<a name="289799613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289799613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam van G <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289799613">(Jul 16 2022 at 00:56)</a>:</h4>
<p>I’m not so sure about that, it seems to me that there are several other local properties of sheaves beyond just local surjectivity that will require speaking about the description on stalks on the Set/Type level.<br>
But I will now leave it to others with more experience in (formalizations of) algebraic geometry to comment on that.</p>



<a name="289799629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289799629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289799629">(Jul 16 2022 at 00:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="411579">Sam van G</span> <a href="#narrow/stream/113488-general/topic/Refactoring.20sheaves/near/289799376">said</a>:</p>
<blockquote>
<p>As an alternative option, couldn’t one begin by making a separate notion called <code>sheaf_on_site</code>, leaving the current notion of sheaf on space untouched, and then prove that the current notion is a special case of the newly defined <code>sheaf_on_site</code>? (This may be a somewhat non trivial exercise in itself.)</p>
</blockquote>
<p>See <a href="https://leanprover-community.github.io/mathlib_docs/find/Top.presheaf.Sheaf_spaces_equiv_sheaf_sites">docs#Top.presheaf.Sheaf_spaces_equiv_sheaf_sites</a></p>



<a name="289799679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289799679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289799679">(Jul 16 2022 at 00:58)</a>:</h4>
<p>We already have a substantial API around stalks of sheaves independent of the sheafification stuff, and I believe that is enough?</p>



<a name="289799713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289799713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289799713">(Jul 16 2022 at 00:59)</a>:</h4>
<p>Do we have the sheafification adjunction for the topological sheafification? I don''t see it in <code>topology/sheaves/sheafify</code></p>



<a name="289799769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289799769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289799769">(Jul 16 2022 at 01:00)</a>:</h4>
<p>If we have that, then we would get the isomorphism with the site-theoretic sheafification (compatibly with the adjunction) for free</p>



<a name="289799795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289799795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289799795">(Jul 16 2022 at 01:01)</a>:</h4>
<p>No we don't. That file is all we have got for topological sheafifications, and no other file imports it.</p>



<a name="289808291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289808291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289808291">(Jul 16 2022 at 04:45)</a>:</h4>
<p>Maybe that could be another short-term goal.</p>



<a name="289809850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289809850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289809850">(Jul 16 2022 at 05:25)</a>:</h4>
<p>My stance is that we wouldn't need two versions of sheafification, but others may very well disagree.<br>
IMHO an isomorphism as sheaves between them as a sanity check suffices.<br>
I think the isomorphism would be more easily shown by</p>
<ol>
<li>the descent of an injective presheaf morphism onto its sheafification is injective.</li>
<li>If <code>f &gt;&gt; g</code> is surjective, then so is <code>g</code>.</li>
<li>An injective and surjective morphism between sheaves is bijective. </li>
<li>The topological sheafification map is both injective and surjective.<br>
Also, the first three results are all useful and important on its own.</li>
</ol>



<a name="289896539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289896539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289896539">(Jul 17 2022 at 18:01)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> , thanks so much for those nice proofs. I'm still fiddling with the file to get the hang of what you did. When I make a new commit, how do I acknowledge you? In the commit message I guess?</p>
<p>Regarding notation: those two lines</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">concrete_category.has_coe_to_fun</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">concrete_category.has_coe_to_sort</span>
</code></pre></div>
<p>definitely make things easier to read and write. Is there a way to also coerce <code>opens X</code> into <code>(opens X).op</code>? or coerce the sheaf-related functions to take objects and morphisms from <code>opens X</code>? I imagine this is some broader question about contravariant functors, so maybe there's some reason why this isn't doable. But, it is confusing to have to write <code>.op</code> everywhere.</p>
<p>On another note, I think it can be easy to forget how illegible these extra layers of abstraction and notation are, after you've gotten used to them. Actually, the reason <span class="user-mention" data-user-id="411579">@Sam van G</span> and I introduced those other notations in the first place is because, after reading <code>topology/presheaf.lean</code> and <code>stalks.lean</code> and so on, we still couldn't figure out how to write down the relevant variables for <code>is_locally_surjective</code> (which after all involved all the main sheaf-related objects: sections, germs, restriction maps, induced maps). We definitely found <code>s : (forget C).map (ℱ.obj (op U))</code> harder to read than <code>s : Γ_ ℱ U</code>, never mind a statement involving several of these objects. I think it would have been harder still if we had also had to unpack from sheaves on sites to sections on open sets.</p>
<p>Generalizing to Grothendieck topologies might well make it easier to prove more categorical facts about sheaves. But will it make it harder to (e.g.) describe the structure sheaves and modules of varieties and schemes? What about proving local properties by passing to a local ring and using Nakayama's lemma? Or doing some kind of local calculation involving actual polynomials?</p>
<p>I can recognize that presumably all of this stuff would be recoverable by specializing back to the ordinary Zariski topology, and I don't want to get in your way in developing this part of the library. Still, I am probably not the only algebraic geometer who barely knows what a Grothendieck topology is, so it would at least make it harder for me to use this library.</p>



<a name="289897339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289897339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289897339">(Jul 17 2022 at 18:21)</a>:</h4>
<p>No matter the sheaf condition is stated in terms of sieves or open covers, a presheaf will always be a <code>(opens X)ᵒᵖ ⥤ C</code>, and this refactor won't any difference in manipulating the elements on the presheaf. By checking the diff of the draft PR <a href="https://github.com/leanprover-community/mathlib/pull/15384">#15384</a>, I think it should be evident that this PR is not as intrusive as you seem to imagine.</p>



<a name="289897637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289897637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289897637">(Jul 17 2022 at 18:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="391579">Jake Levinson</span> <a href="#narrow/stream/113488-general/topic/Refactoring.20sheaves/near/289896539">said</a>:</p>
<blockquote>
<p>When I make a new commit, how do I acknowledge you? In the commit message I guess?</p>
</blockquote>
<p>Oh, don't worry about it. I was happy to help!</p>
<p>The issue with op is indeed annoying, but there is really no good way around it (as far as I know). You may just need to learn to live with <code>op</code> and <code>unop</code>. </p>
<p>We have the sheaf condition in terms of multiequalizers which should reduce directly to the usual sheaf condition on topological spaces. Maybe I'll try to write down a PR doing this later today.</p>



<a name="289897662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/289897662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#289897662">(Jul 17 2022 at 18:28)</a>:</h4>
<p>On the other hand, the I agree that the type signatures are not that illegible. I think an idea worth exploring is to make a <code>has_sections</code> type class that enables a notation like <code>Γ(_, _)</code> so that we could write <code>Γ(ℱ, U)</code> for sheaves and presheaves, as well as <code>Γ(X, U)</code> for ringed spaces and schemes etc In place of <code>foo.presheaf.obj (op bar)</code></p>



<a name="290003890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/290003890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#290003890">(Jul 18 2022 at 18:18)</a>:</h4>
<p>I have tried to write a bit on functoriality of sheafification. I managed to show that sheafification is functorial, but my proof isn't very nice. Here's what I added in <code>topology/sheafify.lean</code> (<a href="https://github.com/leanprover-community/mathlib/blob/d8974a346b09e05ad7f36c8200037521b7e076f6/src/topology/sheaves/sheafify.lean#L129">https://github.com/leanprover-community/mathlib/blob/d8974a346b09e05ad7f36c8200037521b7e076f6/src/topology/sheaves/sheafify.lean#L129</a>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">F</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">X</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">sheafify_map</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">⟶</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">F.sheafify</span> <span class="bp">⟶</span> <span class="n">G.sheafify</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">f</span><span class="o">,</span>
    <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">stalk_functor</span> <span class="n">_</span> <span class="n">x.1</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">T</span> <span class="o">(</span><span class="n">f.1</span> <span class="n">x</span><span class="o">),</span>
     <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">begin</span>
      <span class="n">obtain</span> <span class="o">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">ι</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f'</span><span class="o">,</span> <span class="n">hf'</span><span class="o">⟩⟩</span> <span class="o">:=</span> <span class="n">f.2</span> <span class="n">x</span><span class="o">,</span>
        <span class="c1">-- notice that ι : V ⟶ unop U, I'm not sure why the API is mixing</span>
        <span class="c1">-- (opens X) and (opens X)ᵒᵖ here...</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">ι</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="n">T.app</span> <span class="n">_</span> <span class="n">f'</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x'</span><span class="o">,</span>
      <span class="kd">begin</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">subtype.val_eq_coe</span><span class="o">]</span> <span class="n">at</span> <span class="bp">⊢</span> <span class="n">hf'</span><span class="o">,</span> <span class="n">rw</span> <span class="n">hf'</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">stalk_functor_map_germ_apply</span> <span class="n">V</span> <span class="n">x'</span> <span class="n">T</span> <span class="n">f'</span><span class="o">,</span>
      <span class="kd">end</span><span class="o">⟩,</span>
    <span class="kd">end</span><span class="o">⟩,</span>
  <span class="n">naturality'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">res</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">category_theory.types_comp_apply</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">change</span> <span class="n">_</span> <span class="bp">=</span> <span class="o">(</span><span class="n">stalk_functor</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">x.val</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">T</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">congr</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">sheafify_id</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">X.presheaf</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">v</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">sheafify_map</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">F</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">𝟙</span> <span class="n">F.sheafify</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">U</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">sheafify_map</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">sheafify_comp</span> <span class="o">{</span><span class="n">F</span> <span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="n">X.presheaf</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">v</span><span class="o">)}</span> <span class="o">(</span><span class="n">T1</span> <span class="o">:</span> <span class="n">F</span> <span class="bp">⟶</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">T2</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">⟶</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sheafify_map</span> <span class="o">(</span><span class="n">T1</span> <span class="bp">≫</span> <span class="n">T2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">sheafify_map</span> <span class="n">T1</span> <span class="bp">≫</span> <span class="n">sheafify_map</span> <span class="n">T2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">U</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">sheafify_map</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">sheafification</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">X</span> <span class="bp">⥤</span> <span class="n">sheaf</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">X</span><span class="o">,</span> <span class="n">F.sheafify</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">F</span> <span class="n">G</span> <span class="n">T</span><span class="o">,</span> <span class="n">sheafify_map</span> <span class="n">T</span><span class="o">,</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="n">sheafify_id</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">T1</span> <span class="n">T2</span><span class="o">,</span> <span class="n">sheafify_comp</span> <span class="n">T1</span> <span class="n">T2</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>
<p>It took me a while to figure out how to formulate the objects in question, and at some point I also found myself with a mix of <code>opens X</code> and <code>(opens X)ᵒᵖ</code>objects, which is a sign that I am using the API wrong. I guess I am still trying to write with sets and functions rather than the categorical language.</p>
<p>With this the adjunction shouldn't be too bad either, since the lemma <code>sheafify_stalk_iso</code> should make it easy to show that when <code>G</code> is a sheaf, the natural map <code>G ⟶ G.1.sheafify</code>is an isomorphism.</p>



<a name="290004592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/290004592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#290004592">(Jul 18 2022 at 18:25)</a>:</h4>
<p>I'm imagining that the adjunction would be formulated as <code>T : F ⟶ G.1</code> becomes something like <code>(sheafify_map T) ≫ (G.sheafify_equiv.to_inv_fun) : F.sheafify ⟶ G</code> and conversely <code>T : F.sheafify ⟶ G</code> just goes to <code>F.to_sheafify ≫ T : F ⟶ G.1</code>.</p>



<a name="290189431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Refactoring%20sheaves/near/290189431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Refactoring.20sheaves.html#290189431">(Jul 20 2022 at 03:16)</a>:</h4>
<p>The refactor <a href="https://github.com/leanprover-community/mathlib/pull/15384">#15384</a> is now ready for review.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html">✔ class synonyms</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="264207950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264207950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264207950">(Dec 08 2021 at 19:33)</a>:</h4>
<p>Is there a good way to make a class which is just the intersection of two other classes?  For example here I have two classes:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">class</span> <span class="n">left_unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span> <span class="n">left_unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
  <span class="o">(</span> <span class="n">left_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">left_unit</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>

<span class="kd">class</span> <span class="n">right_unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span> <span class="n">right_unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
  <span class="o">(</span> <span class="n">right_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">a</span> <span class="n">right_unit</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>
</code></pre></div>
<p>Now since most things are both left and right unital, you get really tired of writing <code>left_unital</code>, and <code>right_unital</code> every-time you want to say that something is both.  So I would like to make a new class <code>unital</code> which encompasses both of them.  I can do:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">left_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">[</span><span class="n">right_unital</span> <span class="n">bin</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">left_right_unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">left_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">[</span><span class="n">right_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">:</span> <span class="n">unital</span> <span class="n">bin</span> <span class="o">:=</span>
  <span class="o">⟨⟩</span>
</code></pre></div>
<p>But the compiler seems to have issues with inference here, and very few things using this new class compile at all.  Now in Haskell I can do something like</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="cm">{-# Language ConstraintKinds #-}</span>
<span class="kr">type</span> <span class="kt">Unital</span> <span class="n">a</span> <span class="ow">=</span>
  <span class="p">(</span> <span class="kt">LeftUnital</span> <span class="n">a</span>
  <span class="p">,</span> <span class="kt">RightUnital</span> <span class="n">a</span>
  <span class="p">)</span>
</code></pre></div>
<p>where <code>unital</code> isn't really a class of it's own it's just a synonym for the two.  Is there a best practice or idiomatic way to do this?</p>



<a name="264208444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264208444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264208444">(Dec 08 2021 at 19:36)</a>:</h4>
<p>There are several ways to do it, with different consequences in terms of how much memory things take up internally. If this is just for a small project you could do <code>set_option old_structure_cmd true</code>, define a class <code>has_bin</code> which is just <code>bin</code>, let <code>left_unital</code> and <code>right_unital</code> both extend it, and then let <code>unital</code> extend both.</p>



<a name="264208671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264208671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264208671">(Dec 08 2021 at 19:38)</a>:</h4>
<p>Oh sorry I've just seen that you've not bundled <code>bin</code> so what I said above was inaccurate -- in your case can't you just let <code>unital</code> <code>extend</code> <code>left_unital</code> and <code>right_unital</code>?</p>



<a name="264208957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264208957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264208957">(Dec 08 2021 at 19:40)</a>:</h4>
<p>When I do that it seems to have trouble synthesizing the constituent instances every time I use it.  For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">unit</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">left_unit</span> <span class="n">bin</span>
</code></pre></div>
<p>Has errors trying to synthesize both, and works fine when I split it up into requiring both separately.  Maybe this is not how I should invoke it?</p>



<a name="264209882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264209882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264209882">(Dec 08 2021 at 19:47)</a>:</h4>
<div class="spoiler-block"><div class="spoiler-header">
<p>A complete mwe in case I am misunderstanding your suggestion</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">test</span>
<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">class</span> <span class="n">left_unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span> <span class="n">left_unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
  <span class="o">(</span> <span class="n">left_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">left_unit</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>

<span class="kn">open</span> <span class="n">left_unital</span>

<span class="kd">class</span> <span class="n">right_unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span> <span class="n">right_unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
  <span class="o">(</span> <span class="n">right_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">a</span> <span class="n">right_unit</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>

<span class="kn">open</span> <span class="n">right_unital</span>

<span class="kd">class</span> <span class="n">unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">left_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">[</span><span class="n">right_unital</span> <span class="n">bin</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">left_right_unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">left_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">[</span><span class="n">right_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">:</span> <span class="n">unital</span> <span class="n">bin</span> <span class="o">:=</span>
  <span class="o">⟨⟩</span>

<span class="kd">def</span> <span class="n">unit</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">left_unit</span> <span class="n">bin</span>

<span class="kd">end</span> <span class="n">test</span>
</code></pre></div>
</div></div>



<a name="264210454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264210454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264210454">(Dec 08 2021 at 19:51)</a>:</h4>
<p>Ah I am misunderstanding there is an <code>extends</code> keyword which does that.  I don't know what I was doing, but it wasn't extending.</p>



<a name="264210461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264210461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264210461">(Dec 08 2021 at 19:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="448275">É Olive</span> has marked this topic as resolved.</p>



<a name="264233876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264233876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264233876">(Dec 08 2021 at 23:03)</a>:</h4>
<p>For the record, what you are doing is called "unbundled typeclasses", which work fine in principle, but you need to include all the parameters to <code>unital</code> when you reference it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">test</span>
<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">class</span> <span class="n">left_unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span> <span class="n">left_unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
  <span class="o">(</span> <span class="n">left_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">left_unit</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>

<span class="kn">open</span> <span class="n">left_unital</span>

<span class="kd">class</span> <span class="n">right_unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span> <span class="n">right_unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
  <span class="o">(</span> <span class="n">right_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">a</span> <span class="n">right_unit</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>

<span class="kn">open</span> <span class="n">right_unital</span>

<span class="kd">class</span> <span class="n">unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">left_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">[</span><span class="n">right_unital</span> <span class="n">bin</span><span class="o">]</span>

<span class="kd">instance</span> <span class="n">left_right_unital</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">left_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">[</span><span class="n">right_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">:</span> <span class="n">unital</span> <span class="n">bin</span> <span class="o">:=</span>
  <span class="o">⟨⟩</span>

<span class="kd">def</span> <span class="n">unit</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">left_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">[</span><span class="n">right_unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">[</span><span class="n">unital</span> <span class="n">bin</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="n">left_unit</span> <span class="n">bin</span>

<span class="kd">end</span> <span class="n">test</span>
</code></pre></div>
<p>There are some technical reasons that <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> suggested to "bundle" <code>bin</code> into your classes, as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">test</span>
<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">class</span> <span class="n">left_unital</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span> <span class="n">left_unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
<span class="o">(</span> <span class="n">left_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">left_unit</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>

<span class="kn">open</span> <span class="n">left_unital</span>

<span class="kd">class</span> <span class="n">right_unital</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span> <span class="n">right_unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
<span class="o">(</span> <span class="n">right_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">a</span> <span class="n">right_unit</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>

<span class="kn">open</span> <span class="n">right_unital</span>

<span class="c1">-- For the conjunction we have two options:</span>
<span class="c1">-- Easy but slow on Mathlib's scale:</span>
<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>
<span class="kd">class</span> <span class="n">unital</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">left_unital</span> <span class="n">α</span><span class="o">,</span> <span class="n">right_unital</span> <span class="n">α</span>

<span class="c1">-- More work but is faster for computing (at least, that's what they told me)</span>
<span class="kd">class</span> <span class="n">unital'</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">left_unital</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span> <span class="n">right_unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
<span class="o">(</span> <span class="n">right_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">a</span> <span class="n">right_unit</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>
<span class="kd">instance</span> <span class="n">unital'.to_right_unital</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">unital</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">right_unital</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">bin</span> <span class="o">:=</span> <span class="n">left_unital.bin</span><span class="o">,</span>
  <span class="n">right_unit</span> <span class="o">:=</span> <span class="n">right_unit</span><span class="o">,</span>
  <span class="n">right_id</span> <span class="o">:=</span> <span class="n">right_id</span> <span class="o">}</span>

<span class="c1">-- Making the following an instance will cause a loop `unital → left_unital → unital → ...`,</span>
<span class="c1">-- So we'll have to make `unital` instances manually.</span>
<span class="kd">def</span> <span class="n">left_right_unital</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">left_unital</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">right_unital</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">@</span><span class="n">left_unital.bin</span> <span class="n">α</span> <span class="n">_</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">right_unital.bin</span> <span class="n">α</span> <span class="n">_</span><span class="o">)</span> <span class="o">:</span> <span class="n">unital</span> <span class="n">α</span> <span class="o">:=</span>
<span class="gr">sorry</span> <span class="c1">-- exercise for the reader :-)</span>

<span class="kd">def</span> <span class="n">unit</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">unital</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">left_unit</span>

<span class="kd">end</span> <span class="n">test</span>
</code></pre></div>
<p>Reason 1 is that unbundled definitions cause an exponential growth in the size of expressions in certain circumstances (e.g. if you define a <code>unital ((+) : ℤ^n → ℤ^n → ℤ^n)</code> instance by recursion on <code>n</code>.)</p>
<p>Reason 2 is that it becomes really hard to automatically apply lemmas like <code>right_id</code>: it has the shape <code>?f ?a right_unit = ?a</code>, where <code>?f</code> is an arbitrary function, this is extremely underdetermined!</p>



<a name="264234104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264234104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264234104">(Dec 08 2021 at 23:06)</a>:</h4>
<p>So in practice, the mathlib community uses bundled instances whenever new notation is introduced (like your <code>bin</code>, <code>left_unit</code>, <code>right_unit</code>), and tries to do so when it doesn't cause too much extra work.</p>



<a name="264234239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264234239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264234239">(Dec 08 2021 at 23:07)</a>:</h4>
<p>To be clear, I'm not saying you have to change your approach! Just wanted to warn you where the issues lie.</p>



<a name="264238472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264238472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264238472">(Dec 08 2021 at 23:56)</a>:</h4>
<p>Yeah, I've noticed some issues with the unbundled definitions, including a rather nasty resolution loop.  But (correct me if I'm wrong) it seems that I need to unbundle them if I say want to define multiple instances over a structure, e.g. for a non-abelian group G and G^op.  It also just from a mathematical standpoint that unital is a property of a function rather than of a type, and I am want to value prettiness over efficiency.  I'm going to try to continue like this and see at least how feasible it is, I may already be meeting it's end before I'm even done with groups.</p>



<a name="264249198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264249198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264249198">(Dec 09 2021 at 02:31)</a>:</h4>
<p>I feel like a broken record saying this, but you can also just not use type classes at all (and instead use <code>structure</code>, say).</p>



<a name="264329476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264329476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264329476">(Dec 09 2021 at 16:47)</a>:</h4>
<p>How would I use structures here?  If I understand structures they are basically records.  I feel like I would need like row polymorphism.  Is there any resource on how these can be used properly to emulate classes?</p>



<a name="264338548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264338548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264338548">(Dec 09 2021 at 17:46)</a>:</h4>
<p>Use <code>structure</code> instead of <code>class</code>, and explicit arguments instead of <code>[]</code> ones</p>



<a name="264341513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264341513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264341513">(Dec 09 2021 at 18:05)</a>:</h4>
<p>Hm.  there's no way to enforce uniqueness on the structures though right?  That's kind of the point it would seem.</p>



<a name="264343429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264343429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264343429">(Dec 09 2021 at 18:16)</a>:</h4>
<p>Why does that matter?</p>



<a name="264343863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264343863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264343863">(Dec 09 2021 at 18:19)</a>:</h4>
<p>I'd like to be able to distinguish between defining fields and derived fields.  Like for example when I define group <code>neg</code> should be dependent on other fields not independent.</p>



<a name="264344023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264344023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264344023">(Dec 09 2021 at 18:20)</a>:</h4>
<p>There are other issues with <code>structure</code> anyway.  I think I'll go back to classes for now, but maybe in the long term I need to switch over to something more mathematically oriented than Lean.</p>



<a name="264350583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264350583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264350583">(Dec 09 2021 at 19:04)</a>:</h4>
<p>You know that a field can have a default value, right? That way you can have a derived field, if I understand what you mean by that</p>



<a name="264350687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264350687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264350687">(Dec 09 2021 at 19:05)</a>:</h4>
<p>Classes are structures, just with an extra attribute turned on. They are just made available to the typeclass search and cache system when that attribute is on.</p>



<a name="264352764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264352764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264352764">(Dec 09 2021 at 19:20)</a>:</h4>
<p>I just don't think either option is really working.  I'm kind of tired with working with lean at this point tbh.  I'm just going to switch over to Agda which lets me do what I want without pain.</p>



<a name="264354099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264354099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264354099">(Dec 09 2021 at 19:31)</a>:</h4>
<p>What makes agda "more mathematically oriented than lean" to you? From my perspective there seems to be a huge amount of the type of mathematics you are looking at successfully formalized in lean</p>



<a name="264355001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264355001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264355001">(Dec 09 2021 at 19:38)</a>:</h4>
<p>My feeling is that Agda is more rooted in type theory.  I'm sure Lean is justified in type theory but Agda seems to put the mathematics first which makes constructing feel more mathematical.  he existing formalizations seem like they are tweaked so that they play nice with Lean's quirks.  I'm obviously not unbiased here, I like Agda quite a bit more than Lean so it's only natural that I find making things in Agda more straightforward in general.</p>



<a name="264358002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264358002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264358002">(Dec 09 2021 at 20:00)</a>:</h4>
<p>I'm struggling to work out what behavior you want here. What was unsatisfactory with the <code>class unital (bin) extends left_unital bin, right_unital bin</code> suggestion earlier?</p>



<a name="264358162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264358162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264358162">(Dec 09 2021 at 20:00)</a>:</h4>
<p>(and can you make a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> to demonstrate what you consider to be awkward)</p>



<a name="264360674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264360674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264360674">(Dec 09 2021 at 20:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/.E2.9C.94.20class.20synonyms/near/264358162">said</a>:</p>
<blockquote>
<p>(and can you make a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> to demonstrate what you consider to be awkward)</p>
</blockquote>
<p>So with the <code>structure</code> I keep running into diamond inheritance problems.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>mwe</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">structure</span> <span class="n">magma</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span> <span class="n">bin</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">)</span>

<span class="kn">open</span> <span class="n">magma</span>

<span class="kd">structure</span> <span class="n">left_unital</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">magma</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="o">(</span> <span class="n">unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
  <span class="o">(</span> <span class="n">left_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">unit</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>

<span class="kd">structure</span> <span class="n">right_unital</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">magma</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="o">(</span> <span class="n">unit</span> <span class="o">:</span> <span class="n">α</span> <span class="o">)</span>
  <span class="o">(</span> <span class="n">right_id</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">bin</span> <span class="n">a</span> <span class="n">unit</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">)</span>

<span class="kd">lemma</span> <span class="n">unit_eq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">left_unital</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">right_unital</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">left.unit</span> <span class="bp">=</span> <span class="n">right.unit</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">conv</span>
    <span class="o">{</span> <span class="n">to_rhs</span>
    <span class="o">,</span> <span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">left.left_id</span> <span class="o">(</span><span class="n">right.unit</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">,</span> <span class="n">conv</span>
    <span class="o">{</span> <span class="n">to_lhs</span>
    <span class="o">,</span> <span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">right.right_id</span> <span class="o">(</span><span class="n">left.unit</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>
</div></div>
<p>Of course this specific one I can resolve it by getting rid of the magma.  However when I get up to loop, monoid etc, I start getting diamond inheritance that is much more difficult to resolve.</p>
<p>I'll try to produce a mwe for the class issues I was running into, but a big struggle with classes was just the notational hassle.</p>



<a name="264421646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264421646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264421646">(Dec 10 2021 at 09:32)</a>:</h4>
<p>The statement of <code>unit_eq</code> is false because the two <code>bin</code>s don't agree, which I guess is what you're saying is your problem</p>



<a name="264421728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264421728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264421728">(Dec 10 2021 at 09:33)</a>:</h4>
<p>Either you need to add a <code>left.bin = right.bin</code> hypothesis, or you need to change <code>left_unital</code> and <code>right_unital</code> to take <code>bin</code> as part of the type, as you did in your earlier posts</p>



<a name="264523492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264523492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> É Olive <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264523492">(Dec 10 2021 at 23:26)</a>:</h4>
<p>Hm.  Adding <code>bin</code> to the type was what I meant by "getting rid of the magma", I just set it up like that for the purposes of mwe.  But <code>left.bin=right.bin</code> is interesting.  I've already moved over to Agda though so I probably won't be switching back.</p>



<a name="264527208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%E2%9C%94%20class%20synonyms/near/264527208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.E2.9C.94.20class.20synonyms.html#264527208">(Dec 11 2021 at 00:06)</a>:</h4>
<p>What does your version of that <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> in agda look like?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
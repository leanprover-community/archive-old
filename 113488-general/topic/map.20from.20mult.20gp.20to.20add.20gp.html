---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html">map from mult gp to add gp</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271703529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271703529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271703529">(Feb 12 2022 at 18:44)</a>:</h4>
<p>OK so it's finally happened. Kummer theory relates the additive group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>1</mn></msup><mo stretchy="false">(</mo><mi>K</mi><mo separator="true">,</mo><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>n</mi><mi mathvariant="double-struck">Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H^1(K,\Z/n\Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbb">Z</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mord mathbb">Z</span><span class="mclose">)</span></span></span></span> to the the multiplicative group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msup><mi>K</mi><mo>×</mo></msup><msup><mo stretchy="false">)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">K^\times/(K^\times)^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> is a number field containing all the $$n$$th roots of unity, Selmer group calculations give you maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo><mo>→</mo><msup><mi>K</mi><mo>×</mo></msup><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msup><mi>K</mi><mo>×</mo></msup><msup><mo stretchy="false">)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">E(K)\to K^\times/(K^\times)^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> in the proof of the Mordell-Weil theorem with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span> an additive group, and I think that for my gang of PhD students at Imperial working on cool things they are going to need some kind of solution to the issue that right now mathlib has two ugly ways to define a group homomorphism from an additive group to a multiplicative group (<code>G -&gt;* multiplicative A</code> and <code>additive G -&gt;+ A</code>) and no non-ugly way. I've been putting this discussion off for years (e.g. with perfectoids we used multiplicative valuations, Maria has been using <code>multiplicative \Z</code> here there and everywhere) but I don't think can go on forever. The idea of splitting up the concept of an additive and multiplicative monoid is brilliant because it makes things like rings fit very nicely into the typeclass system, but I think that for the sake of my students' sanity we're going to have to figure out a way of doing this.</p>
<p>Two options spring to mind:</p>
<p>1) make a new typeclass <code>mul_to_add_monoid_hom G A</code> and then either duplicate a ton of stuff or write a tactic which does it for us<br>
2) Continue to run away from the problem and write horrible-looking code with <code>multiplicative (zmod n)</code> everywhere.</p>
<p>Neither looks fun but this is now a real problem. I think the option "define the group law on an elliptic curve to be multiplication" has to be ruled out because we'd be a laughing stock. Same comment goes for group law on a cohomology group, and definition of an abelian category. Maybe morally what's going on is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup><mo stretchy="false">(</mo><mi>G</mi><mi>a</mi><mi>l</mi><mo stretchy="false">(</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>K</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>L</mi><mo>×</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H^n(Gal(L/K),L^\times)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> should somehow have multiplication as the group law (because that's the group law on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mo>×</mo></msup></mrow><annotation encoding="application/x-tex">L^\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span></span></span></span>) but history won't let us do that.</p>



<a name="271703631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271703631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271703631">(Feb 12 2022 at 18:47)</a>:</h4>
<p>Do we care about being the laughing stock?</p>



<a name="271703646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271703646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271703646">(Feb 12 2022 at 18:48)</a>:</h4>
<p>Yes</p>



<a name="271703685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271703685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271703685">(Feb 12 2022 at 18:48)</a>:</h4>
<p>because then it's harder to learn. We need to stick to usual mathematical notation.</p>



<a name="271703774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271703774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271703774">(Feb 12 2022 at 18:51)</a>:</h4>
<p>I guess one thing that could be done is to simply define the map as a function, and then carry around the axiom <code>f (a * b) = f a + f b</code> and rewrite as necessary. But I'm sure this will get old. We will want to talk about the short exact sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><msub><mi>μ</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo><mo>→</mo><msup><mi>K</mi><mo>×</mo></msup><mo>→</mo><msup><mi>K</mi><mo>×</mo></msup><mo>→</mo><msup><mi>H</mi><mn>1</mn></msup><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><msub><mi>μ</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msup><mi>H</mi><mn>1</mn></msup><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1\to\mu_n(K)\to K^\times\to K^\times\to H^1(G,\mu_n)\to H^1(G,K^\times)[n] \to 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> for example, and the group law magically changes between multiplication and addition in the middle. Hmm, for this one we surely have to go with <code>additive</code>.</p>



<a name="271704277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271704277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271704277">(Feb 12 2022 at 19:01)</a>:</h4>
<p>This came up in the Galois thing, too. We wanted to filter the automorphisms of a cyclo extension through the roots of unity group, and we'd have to mess around with this</p>



<a name="271704723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271704723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271704723">(Feb 12 2022 at 19:09)</a>:</h4>
<p>Right now <span class="user-mention" data-user-id="464700">@David Ang</span> is just putting <code>multiplicative</code> everywhere.</p>



<a name="271710519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271710519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271710519">(Feb 12 2022 at 21:27)</a>:</h4>
<p>Are you sure <code>multiplicative</code> is the approach you want to take, as opposed to <code>additive</code>? These <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup></mrow><annotation encoding="application/x-tex">K^\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span></span></span></span> are global sections on an \'etale sheaf of abelian groups, and we usually write those additively...</p>



<a name="271710760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271710760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271710760">(Feb 12 2022 at 21:34)</a>:</h4>
<p>(Of course, this is the global sections of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="double-struck">G</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\mathbb{G}_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbb">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (THE multiplicative group!), so maybe an exception is in order.)</p>



<a name="271711648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271711648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271711648">(Feb 12 2022 at 21:57)</a>:</h4>
<p>In Lean4, is it possible to create a class called, say, <code>CommGroup</code> where instances can also include notations for the operation and the unit?</p>



<a name="271712417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271712417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271712417">(Feb 12 2022 at 22:15)</a>:</h4>
<p>Don't forget notation for the inverse and the division and the nat-power and the int-power and the ...</p>



<a name="271712474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271712474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271712474">(Feb 12 2022 at 22:16)</a>:</h4>
<p>Sure. Let's just think about monoids for now.</p>



<a name="271712509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271712509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271712509">(Feb 12 2022 at 22:17)</a>:</h4>
<p>Does that mean you expect lemma statements to not visually match where you'll use them?</p>



<a name="271712691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271712691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271712691">(Feb 12 2022 at 22:21)</a>:</h4>
<p>Maybe. Is that so awful? I would prefer to have one lemma called <code>op_assoc</code> or something that can be applied to both addition in Z and multiplication in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mn>37</mn></msub></mrow><annotation encoding="application/x-tex">\mu_{37}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">37</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>



<a name="271712773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271712773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271712773">(Feb 12 2022 at 22:23)</a>:</h4>
<p>Can do we something like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">class</span> <span class="n">has_unit</span> <span class="o">(</span><span class="n">tag</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">unit</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_op</span> <span class="o">(</span><span class="n">tag</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">has_unit.to_has_one</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_unit</span> <span class="bp">`</span><span class="n">additive</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">has_unit.unit</span> <span class="bp">`</span><span class="n">additive</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">has_op.to_has_mul</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_op</span> <span class="bp">`</span><span class="n">additive</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">has_op.op</span> <span class="bp">`</span><span class="n">additive</span><span class="o">⟩</span>

<span class="kd">class</span> <span class="n">monoid</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_op</span> <span class="n">n</span> <span class="n">R</span><span class="o">,</span> <span class="n">has_unit</span> <span class="n">n</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">unit_op</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">op</span> <span class="n">unit</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_unit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">op</span> <span class="n">x</span> <span class="n">unit</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">op_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">op</span> <span class="n">x</span> <span class="o">(</span><span class="n">op</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>

<span class="kn">export</span> <span class="n">monoid</span> <span class="o">(</span><span class="n">unit_op</span> <span class="n">op_unit</span> <span class="n">op_assoc</span><span class="o">)</span>

<span class="kd">notation</span> <span class="bp">`</span><span class="n">mul_monoid</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">monoid</span> <span class="o">(</span><span class="n">name.mk_string</span> <span class="s2">"multiplicative"</span> <span class="n">name.anonymous</span><span class="o">)</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">add_monoid</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">monoid</span> <span class="o">(</span><span class="n">name.mk_string</span> <span class="s2">"additive"</span> <span class="n">name.anonymous</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dunfold</span> <span class="n">has_mul.mul</span> <span class="n">has_one.one</span><span class="o">,</span>  <span class="c1">-- TODO</span>
  <span class="n">rw</span> <span class="n">op_unit</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="271712784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271712784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271712784">(Feb 12 2022 at 22:23)</a>:</h4>
<p>That is, store a name for the notation as an argument in the typeclass</p>



<a name="271712887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271712887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271712887">(Feb 12 2022 at 22:25)</a>:</h4>
<p>Dumb stuff, but are you not getting a name conflict with <a href="https://leanprover-community.github.io/mathlib_docs/find/unit">docs#unit</a>?</p>



<a name="271712893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271712893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271712893">(Feb 12 2022 at 22:25)</a>:</h4>
<p>But this still would mean that additive monoids and multiplicative monoids are different classes because the name parameter would be different</p>



<a name="271712953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271712953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271712953">(Feb 12 2022 at 22:26)</a>:</h4>
<p>How does that matter? You can be "name-polymorphic".</p>



<a name="271712982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271712982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271712982">(Feb 12 2022 at 22:27)</a>:</h4>
<p>Yeah okay</p>



<a name="271713025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713025">(Feb 12 2022 at 22:28)</a>:</h4>
<p>We'd need some special support in <code>rw</code> to avoid the line marked <code>TODO</code></p>



<a name="271713034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713034">(Feb 12 2022 at 22:28)</a>:</h4>
<p>Or we'd need to entirely remove <code>has_zero</code> and <code>has_one</code>, and have them just be notation for <code>has_unit _</code></p>



<a name="271713114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713114">(Feb 12 2022 at 22:30)</a>:</h4>
<p>This sounds like a very bad intersection with the <code>OfNat</code> conundrum.</p>



<a name="271713115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713115">(Feb 12 2022 at 22:30)</a>:</h4>
<p>What I would really like is to be able to pass the <em>notation</em> itself as a parameter</p>



<a name="271713196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713196">(Feb 12 2022 at 22:32)</a>:</h4>
<p>I.e. to be able to write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="mi">1</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">b</span>
</code></pre></div>



<a name="271713208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713208">(Feb 12 2022 at 22:32)</a>:</h4>
<p>Yeah, but that scales really badly to <code>[group (*) 1 (has_inv.inv) (/) (^) (^) R]</code> and <code>ring</code> is even worse</p>



<a name="271713218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713218">(Feb 12 2022 at 22:33)</a>:</h4>
<p>I would vouch against that. Soon, <a href="https://leanprover-community.github.io/mathlib_docs/find/boolean_algebra">docs#boolean_algebra</a> will have around 10 notations.</p>



<a name="271713231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713231">(Feb 12 2022 at 22:33)</a>:</h4>
<p>You can have default values for parameters btw</p>



<a name="271713285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713285">(Feb 12 2022 at 22:34)</a>:</h4>
<p>Writing <code>add_group</code> as a shorthand for <code>group (+) 0 has_neg.neg</code> sounds like a better idea already.</p>



<a name="271713315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713315">(Feb 12 2022 at 22:35)</a>:</h4>
<p>Yeah, but then you have to write <code>[has_add G] [has_zero G] [has_neg G] [add_group G]</code></p>



<a name="271713325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713325">(Feb 12 2022 at 22:35)</a>:</h4>
<p>Why?</p>



<a name="271713380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713380">(Feb 12 2022 at 22:36)</a>:</h4>
<p>Because <code>(+)</code> doesn't exist until you have the <code>has_add</code> instance lying around</p>



<a name="271713383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713383">(Feb 12 2022 at 22:36)</a>:</h4>
<p>because the notation typeclasses are typeclasses... <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="271713392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713392">(Feb 12 2022 at 22:36)</a>:</h4>
<p>In Lean4 you could presumably have a macro that expands <code>add_group M</code> to <code>group (+) ...</code></p>



<a name="271713406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713406">(Feb 12 2022 at 22:36)</a>:</h4>
<p>It would need to expand it to include the <code>[has_add G]</code> too</p>



<a name="271713408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713408">(Feb 12 2022 at 22:37)</a>:</h4>
<p>Again, that's not the problem. The problem is that <code>(+)</code> doesn't refer to anything.</p>



<a name="271713425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713425">(Feb 12 2022 at 22:37)</a>:</h4>
<p>Using <code> `additive </code> instead of <code>(+)</code> circumvents the problem because it generates the notation typeclasses from the names rather than depending on the notation typeclasses</p>



<a name="271713474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713474">(Feb 12 2022 at 22:38)</a>:</h4>
<p>Okay, this is all hypothetical anyway. I don't know if it's possible to pass in notation as a variable in Lean4.</p>



<a name="271713487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713487">(Feb 12 2022 at 22:38)</a>:</h4>
<p>One obvious problem with the "name-polymorphism" option of my proposal is that you need some way to pick a convenient notation inside the name-polymorphic lemma</p>



<a name="271713503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713503">(Feb 12 2022 at 22:39)</a>:</h4>
<p>Also, you definitely don't want to call all your lemmas <code>op_op_eq_op</code></p>



<a name="271713522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713522">(Feb 12 2022 at 22:39)</a>:</h4>
<p>Sure, you'd keep around <code>to_additive</code> and have it generate <code>mul</code> and <code>add</code> from the <code>op</code> versions</p>



<a name="271713774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713774">(Feb 12 2022 at 22:45)</a>:</h4>
<p>I don't know how this idea would play with the notation classes. Here is the simplest example of what I would like to be possible</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">has_binary_op</span> <span class="s2">"*"</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span>
</code></pre></div>
<p>And not to rely on <code>has_mul</code> whatsoever.</p>



<a name="271713828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271713828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271713828">(Feb 12 2022 at 22:46)</a>:</h4>
<p>(yes I know <code>has_ mul</code> is called <code>Mul</code> in Lean4 but you get the idea...)</p>



<a name="271714604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714604">(Feb 12 2022 at 23:06)</a>:</h4>
<p>Right, that's sort of similar to the approach I was trying to hit. As I mention in <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271713487">my message above</a> though, that's only half the problem - how do you write statements about monoids in general if you haven't chosen a notation for them?</p>



<a name="271714830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714830">(Feb 12 2022 at 23:12)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Your name tagging idea made me think about a metaprogramming approach. What if <code>to_additive</code> were revamped to generate multiplicative and additive lemmas for each generic monoid lemma?</p>
<p>In files about generic monoids, you could have <code>local infix ` * ` := monoid.op</code> so you can work with notation. Since names are being modified by the <code>to_additive</code> machinery, we don't have to worry about how <code>ring</code> would have conflicting <code>op_assoc</code> axioms for its additive and multiplicative structures.</p>
<p>We could then also generate lemmas about <code>-&gt;*</code>, <code>-&gt;+</code>, <code>*-&gt;+</code>, and <code>+-&gt;*</code> homomorphisms if the <code>to_additive</code> machinery could consider all four possible mul/add structures for the two arguments. (Presumably directed by some arguments to <code>to_additive</code> so this doesn't get too out of hand.)</p>



<a name="271714846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714846">(Feb 12 2022 at 23:13)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> make it polymorphic in the notation variable</p>



<a name="271714894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714894">(Feb 12 2022 at 23:14)</a>:</h4>
<p>The thing is that "files about generic monoids" are actually "all files that currently use <code>@[to_additive]</code>", so I think doing that globally in each of those files might not work out so well</p>



<a name="271714901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714901">(Feb 12 2022 at 23:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271714846">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> make it polymorphic in the notation variable</p>
</blockquote>
<p>Yes, indeed - but then you can't use <code>*</code> in your lemma statement any more, which is what I was trying to point out.</p>



<a name="271714903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714903">(Feb 12 2022 at 23:14)</a>:</h4>
<p>With this approach, the whole <code>to_additive</code> game wouldn't even exist!</p>



<a name="271714921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714921">(Feb 12 2022 at 23:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271714903">said</a>:</p>
<blockquote>
<p>With this approach, the whole <code>to_additive</code> game wouldn't even exist!</p>
</blockquote>
<p>It does if we want <code>mul</code> or <code>add</code> in our lemma names as Kyle I think is suggesting.</p>



<a name="271714934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714934">(Feb 12 2022 at 23:15)</a>:</h4>
<p>At any rate, my point is that "everywhere that currently uses <code>@[to_additive]</code> would end up being a notation-polymorphic lemma", and so we'd need to enable local notation for each one of those lemma</p>



<a name="271714935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714935">(Feb 12 2022 at 23:15)</a>:</h4>
<p>And we do want <code>mul</code> and <code>add</code> versions because rewriting gets hard when the function is a variable...</p>



<a name="271714981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714981">(Feb 12 2022 at 23:16)</a>:</h4>
<p>If rewriting gets hard, then it will be hard in all the polymorphic cases where <code>add</code> and <code>mul</code> can't save us</p>



<a name="271714997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271714997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271714997">(Feb 12 2022 at 23:17)</a>:</h4>
<p>I guess one solution is to have automation that takes a lemma written with <code>*</code> and that would make a lemma with arbitrary notation</p>



<a name="271715006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715006">(Feb 12 2022 at 23:17)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> That's basically what I was proposing, though the other way.</p>



<a name="271715018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715018">(Feb 12 2022 at 23:18)</a>:</h4>
<p>Yeah I see now!</p>



<a name="271715060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715060">(Feb 12 2022 at 23:18)</a>:</h4>
<p>A reason I was thinking the generic <code>monoid</code> seems useful is that then it puts <code>mul</code> and <code>add</code> on equal footing when you're configuring code generation.</p>



<a name="271715077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715077">(Feb 12 2022 at 23:19)</a>:</h4>
<p>And then you could also extend it with more notation typeclasses and generate more lemmas.</p>



<a name="271715084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715084">(Feb 12 2022 at 23:19)</a>:</h4>
<p>But there comes my question again. What names will you use? You're forbidding yourself both convention so as to avoid conflicts.</p>



<a name="271715142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715142">(Feb 12 2022 at 23:20)</a>:</h4>
<p>(It reminds me of how in some older languages with generics, like Ada, you have to declare that you're instantiating the generic variables. In this case, <code>monoid</code> gets instantiated as <code>add_monoid</code> and <code>mul_monoid</code>, perhaps.)</p>



<a name="271715148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715148">(Feb 12 2022 at 23:20)</a>:</h4>
<p>Why do the names matter?</p>



<a name="271715162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715162">(Feb 12 2022 at 23:21)</a>:</h4>
<p>Just write <code>assoc</code> instead of <code>add_assoc</code></p>



<a name="271715164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715164">(Feb 12 2022 at 23:21)</a>:</h4>
<p>because, against all odds, I'm not a computer <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="271715169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715169">(Feb 12 2022 at 23:21)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> For generic monoids, <code>op</code>-based seems fine. But then if there's <code>to_additive</code>-like metaprogramming, that all gets turned into <code>mul</code> and <code>add</code> versions.</p>



<a name="271715183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715183">(Feb 12 2022 at 23:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271715162">said</a>:</p>
<blockquote>
<p>Just write <code>assoc</code> instead of <code>add_assoc</code></p>
</blockquote>
<p>This doesn't scale too well for things like <code>mul_mul_mul_comm</code>, which after stripping away the operation name becomes the same as <code>mul_comm</code>.</p>



<a name="271715225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715225">(Feb 12 2022 at 23:22)</a>:</h4>
<p>Okay, and what about <a href="https://leanprover-community.github.io/mathlib_docs/find/sub_eq_add_neg">docs#sub_eq_add_neg</a>? Your heuristic breaks as soon as two operations are involved.</p>



<a name="271715251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715251">(Feb 12 2022 at 23:22)</a>:</h4>
<p>Maybe we just use <code>mul</code>-based naming <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="271715260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715260">(Feb 12 2022 at 23:23)</a>:</h4>
<p>so <code>mul</code>, <code>div</code>, <code>inv</code> for generic monoids.</p>



<a name="271715264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715264">(Feb 12 2022 at 23:23)</a>:</h4>
<p>Then you will get name conflicts with the multiplicative lemmas.</p>



<a name="271715265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715265">(Feb 12 2022 at 23:23)</a>:</h4>
<p>And have <code>generic_monoid.mul_mul_mul_comm</code> vs <code>mul_mul_mul_comm</code> for the generic  vs specialized versions?</p>



<a name="271715362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715362">(Feb 12 2022 at 23:25)</a>:</h4>
<p>I wonder if we could have something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">mul_left_comm</span>
  <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">tag</span> <span class="o">:</span> <span class="n">name</span> <span class="o">:=</span> <span class="bp">`</span><span class="n">multiplicative</span><span class="o">)</span> <span class="o">[</span><span class="n">generic_comm_monoid</span> <span class="n">tag</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>where the default value of <code>tag</code> is used to inform the notation in the local scope of the lemma</p>



<a name="271715452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715452">(Feb 12 2022 at 23:28)</a>:</h4>
<p>In particular it would be nice to be able to use this in things like <a href="https://tqft.net/mathlib/group_theory/eckmann_hilton">file#group_theory/eckmann_hilton</a> to have two simultaneous monoid structures on a type with locally distinct notations for each</p>



<a name="271715726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271715726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271715726">(Feb 12 2022 at 23:35)</a>:</h4>
<p>I should say that I'm more than happy to wait for Lean 4 if that helps. We can keep ploughing on with the <code>multiplicative</code> hack until then, nothing is blocked, it's just getting a bit nasty</p>



<a name="271723404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271723404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271723404">(Feb 13 2022 at 02:58)</a>:</h4>
<p>Stupid question, but why can't you just have one generic operation and just use different locales for different notation. Don't we basically use locales to unlock different notations anyway?</p>



<a name="271724058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271724058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271724058">(Feb 13 2022 at 03:16)</a>:</h4>
<p>Oh nevermind, you couldn't use both locales at the same time.</p>



<a name="271724215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271724215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271724215">(Feb 13 2022 at 03:21)</a>:</h4>
<p>Exactly, the problem is that we want <code>ring</code>s.</p>



<a name="271741832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271741832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271741832">(Feb 13 2022 at 11:36)</a>:</h4>
<p>Since this is still on the drawing board (and you can always want more!), would it be possible to also include the opposite operation?  I find <code>\op</code> somewhat clunkier and being able to simply pass <code>(swap (*))</code> to a statement could be easier.</p>



<a name="271741846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271741846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271741846">(Feb 13 2022 at 11:37)</a>:</h4>
<p>This would preempt also a <code>to_right</code> tactic from being written... <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="271742112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271742112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271742112">(Feb 13 2022 at 11:44)</a>:</h4>
<p>I've never seen a case where <code>to_right</code> would help; do you have one in mind?</p>



<a name="271742544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271742544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271742544">(Feb 13 2022 at 11:56)</a>:</h4>
<p>A lot of the lemmas about monotonicity of multiplication on the left get reproven for multiplication on the right.  The proofs are always the "same" and <em>should</em> also follow by the <code>left</code> lemma applied to the <code>\opp</code> monoid, but are simply repeated.  I'm not at a computer now, but lemmas in algebra.order.monoid_lemmas should give plenty of examples!</p>



<a name="271745375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271745375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271745375">(Feb 13 2022 at 13:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271713315">said</a>:</p>
<blockquote>
<p>Yeah, but then you have to write <code>[has_add G] [has_zero G] [has_neg G] [add_group G]</code></p>
</blockquote>
<p>I still think this is the way forwards, fwiw. We need macros that expand stuff like <code>[is_cyclotomic_extension {n} K L]</code>, because even without this happening we get crazy long variable lines that aren't how mathematicians work</p>



<a name="271745382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271745382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271745382">(Feb 13 2022 at 13:09)</a>:</h4>
<p>Have we got anything like the proposed [[]] notation in Lean4?</p>



<a name="271747893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271747893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271747893">(Feb 13 2022 at 14:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271745375">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271713315">said</a>:</p>
<blockquote>
<p>Yeah, but then you have to write <code>[has_add G] [has_zero G] [has_neg G] [add_group G]</code></p>
</blockquote>
<p>I still think this is the way forwards, fwiw. </p>
</blockquote>
<p>No, it is important to keep things bundled (not always, but still a lot) because of performance problems otherwise. See for instance <a href="https://arxiv.org/abs/2202.01629">https://arxiv.org/abs/2202.01629</a>, Section 10.</p>



<a name="271749080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271749080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271749080">(Feb 13 2022 at 14:38)</a>:</h4>
<p>Won't it be a constant slowdown at most? With only the amount of relevant [has_notation]  typeclasess</p>



<a name="271749088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271749088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271749088">(Feb 13 2022 at 14:39)</a>:</h4>
<p>Regardless, this is really interesting, we should definitely have a thread for all the ITP preprints!</p>



<a name="271752379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271752379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271752379">(Feb 13 2022 at 16:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/271749080">said</a>:</p>
<blockquote>
<p>Won't it be a constant slowdown at most? With only the amount of relevant [has_notation]  typeclasess</p>
</blockquote>
<p>Term size is exponential in the length of an "unbundled inheritance" chain, so quadratic for this proposal: let's say we want an instance of <code>add_group (ℤ × ℤ × ... × ℤ)</code>, with <code>n</code> copies of <code>ℤ</code>. Then we get a term like <code>prod.add_group ℤ^n int.add_group (prod.has_add ℤ^n int.has_add (prod.has_add ℤ^(n-1) int.has_add _) (prod.has_zero ℤ^n int.has_zero (prod.has_zero ℤ^(n-1) int.has_zero _) (prod.has_add ℤ^(n-1) int.has_add _) (prod.has_neg ℤ^n int.has_neg (prod.has_neg ℤ^(n-1) int.has_neg _) (prod.add_group ℤ^(n-1) _ _ _ _)</code>. For each <code>prod.add_group ℤ^i</code> we get some constant term size and 3 different <code>prod.has_$op ℤ^i</code> and one <code>prod.add_group ℤ^(i-1)</code>. For each <code>prod.has_$op ℤ^i</code> we get some constant term size and <code>i</code> different <code>prod.has_$op ℤ^j</code>.</p>



<a name="271752619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271752619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271752619">(Feb 13 2022 at 16:01)</a>:</h4>
<p>How often do we have large chains of <code>prod</code> as opposed to using <code>pi.add_group</code>?</p>



<a name="271752689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271752689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271752689">(Feb 13 2022 at 16:02)</a>:</h4>
<p><code>prod</code> is an easy example since the recursive behaviour is easy to explain, but the same goes for heterogeneous definitions of the form <code>set (finsupp (multiplicative (fin n → ℤ)^op))</code></p>



<a name="271752917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271752917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271752917">(Feb 13 2022 at 16:08)</a>:</h4>
<p>I'd expect that for these examples, quadratic depth is not too bad and increasing the term size here moves some complexity away from <em>unfolded</em> term size, which is relevant in certain parts of the type checker I understand from diagnosing a class of timeouts where big terms appear in the type. So I'm not opposed to unbundling notation/data from axioms/proofs.</p>



<a name="271753177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271753177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271753177">(Feb 13 2022 at 16:15)</a>:</h4>
<p>One option that we should consider is bundling all the data into one structure and all the proofs into another. So you'd have a <code>add_group_data ℤ</code> instance containing <code>+</code>, <code>-</code>, <code>0</code>, and a <code>add_group_laws ℤ</code> instance containing <code>add_assoc</code>, <code>add_zero</code>, <code>add_neg</code>. That makes refactors like adding a <code>nsmul</code> field to monoids a bit less painful: in the unbundled data case, you'd need to add an <code>has_smul ℕ M</code> everywhere you write <code>monoid M</code>.</p>



<a name="271753406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271753406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271753406">(Feb 13 2022 at 16:20)</a>:</h4>
<p>I like this <code>add_group_data</code> approach; I think the [[]]s will be essential for that though</p>



<a name="271764618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271764618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271764618">(Feb 13 2022 at 20:46)</a>:</h4>
<p>I also like this very much.  It also aligns with how I would think of a ring: a set/type with a bunch of operations, satisfying some conditions.  I imagine that working flexibly with <code>(+), (*)</code>, their <code>swap</code>s, adding opposites/inverses as needed will become easier!</p>



<a name="271764954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271764954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271764954">(Feb 13 2022 at 20:54)</a>:</h4>
<p>Unfortunately this discussion is not really about how we'd like to manipulate things. It's really about performance of the type class mechanism. I certainly don't understand this technology well enough to write any meaningful comment here.</p>



<a name="271954906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271954906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271954906">(Feb 15 2022 at 10:39)</a>:</h4>
<p>I also don't have a good answer here but this has reminded me that I was messing around with alternatives to <code>to_additive</code> a few months ago. I've just pasted a very old script I had lying around into <a href="https://gist.github.com/ocfnash/3e8a8cfb377f67e9b7fdea908d996f59">this gist</a>.</p>



<a name="271955106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271955106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271955106">(Feb 15 2022 at 10:41)</a>:</h4>
<p>I think it's basically the same idea as what Eric pasted above, namely we parameterise our operations so the key definition is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="bp">Ω</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_op</span> <span class="o">(</span><span class="n">ω</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_unit</span> <span class="o">(</span><span class="n">ω</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">unit</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>and then a group is defined as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">ω₁</span> <span class="o">:</span> <span class="bp">Ω</span><span class="o">)</span>
<span class="n">open_locale</span> <span class="n">mul_group_notation</span>

<span class="kd">class</span> <span class="n">group</span> <span class="kd">extends</span> <span class="n">has_op</span> <span class="n">α</span> <span class="n">ω₁</span><span class="o">,</span> <span class="n">has_unit</span> <span class="n">α</span> <span class="n">ω₁</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">))</span>
<span class="o">(</span><span class="n">mul_unit</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="bp">Ι</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">unit_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">Ι</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="bp">Ι</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="bp">Ι</span><span class="o">)</span>
</code></pre></div>
<p>It sort-of works. I haven't tried to see if it could really scale up but I'd love if something like this could.</p>



<a name="271955303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271955303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271955303">(Feb 15 2022 at 10:42)</a>:</h4>
<p>But it does at least give very basic <code>to_additive</code>-type <a href="https://gist.github.com/ocfnash/3e8a8cfb377f67e9b7fdea908d996f59#file-parametric_operations-lean-L81">magic</a> without actually duplicating any lemmas as well as allowing multiple operations and notation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">distrib</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">left_distrib</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">))</span>
<span class="o">(</span><span class="n">right_distrib</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">))</span>
</code></pre></div>



<a name="271956046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271956046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271956046">(Feb 15 2022 at 10:49)</a>:</h4>
<p>I also have another mathematical example where this comes up that I just learned last week. Apparently algebraists studying nilpotent groups <code>G</code> like to regard the lower central series as a filtration and then take the associated graded group <code>LG</code>. However <code>LG</code> is Abelian and furthermore  carries a natural Lie bracket (coming from the commutator of two group elements) making it a Lie ring so we really want to land in the additive world. I have no plans to formalise this, and I think it wouldn't be too hard to pass from multiplicative to additive classes, but it is another example (albeit exotic) I think.</p>



<a name="271970216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271970216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271970216">(Feb 15 2022 at 13:02)</a>:</h4>
<p>That example is not exotic at all. It's related to Malcev completions which are quite important (take Deligne's paper on P1 minus three points, for example).</p>



<a name="271974907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271974907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271974907">(Feb 15 2022 at 13:44)</a>:</h4>
<p>Interesting, thanks!</p>



<a name="271975991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271975991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271975991">(Feb 15 2022 at 13:52)</a>:</h4>
<p>BTW, if you interpret it properly, Kevin's example of Kummer theory can be seen as a special case of this. Namely, if you look at the isomorphism induced by the Kummer map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup><mi mathvariant="normal">/</mi><mi>n</mi><mo>≅</mo><msup><mi>H</mi><mn>1</mn></msup><mo stretchy="false">(</mo><mi>K</mi><mo separator="true">,</mo><msub><mi>μ</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K^\times/n \cong H^1(K,\mu_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, assume for simplicity that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>n</mi></msub><mo>⊂</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\mu_n \subset K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> then taking Pontryagin duals you obtain an isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>G</mi><mi>K</mi><mrow><mi>a</mi><mi>b</mi></mrow></msubsup><mo>⊗</mo><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo>≅</mo><mo stretchy="false">(</mo><msup><mi>K</mi><mo>×</mo></msup><mi mathvariant="normal">/</mi><mi>n</mi><msup><mo stretchy="false">)</mo><mo>∨</mo></msup></mrow><annotation encoding="application/x-tex">G_K^{ab} \otimes \mathbb{Z}/n \cong (K^\times/n)^\vee</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1244em;vertical-align:-0.2753em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-2.4247em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ab</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2753em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">×</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∨</span></span></span></span></span></span></span></span></span></span></span>. The cup-product in Galois cohomology is then related to the 2-step nilpotent part of this Lie algebra (well, the one arising from the mod-n central descending series) obtained from the absolute Galois group of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>, which (using some strong theorems, like the Merkurjev-Suslin theorem) can be related to the arithmetic of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>.</p>



<a name="271976467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/271976467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#271976467">(Feb 15 2022 at 13:56)</a>:</h4>
<p>I guess one doesn't really need Galois cohomology for this... the same holds for group cohomology of any group. For example, group homology is a thing, and you can ask what  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi mathvariant="double-struck">Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_1(G,\mathbb{Z})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbb">Z</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi mathvariant="double-struck">Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_2(G,\mathbb{Z})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbb">Z</span><span class="mclose">)</span></span></span></span> looks like.</p>



<a name="272015764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/272015764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#272015764">(Feb 15 2022 at 18:17)</a>:</h4>
<p>In knot theory, the Alexander module of a knot <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_1(\overline{X})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1333em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> as a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_1(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>-module, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><msup><mi>S</mi><mn>3</mn></msup><mo>∖</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">X=S^3\setminus K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> and where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span> is the universal abelian cover of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>. In group theory land, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_1(\overline{X})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1333em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> (as an additive group) is isomorphic (as a multiplicative group) to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mi mathvariant="normal">/</mi><msup><mi>G</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">G^{(1)}/G^{(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> with the earlier action being conjugation by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi mathvariant="normal">/</mi><msup><mi>G</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">G/G^{(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is the fundamental group of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>.</p>
<p>In general, the derived series is a filtration, and each quotient <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mi mathvariant="normal">/</mi><msup><mi>G</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">G^{(n)}/G^{(n+1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> is an abelian group and a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mo stretchy="false">[</mo><mi>G</mi><mi mathvariant="normal">/</mi><msup><mi>G</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{Z}[G/G^{(n)}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>-module (by conjugation), and is known as a higher Alexander module of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>.</p>



<a name="272017052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/272017052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#272017052">(Feb 15 2022 at 18:26)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> Barry Mazur would say these are the same picture.</p>



<a name="272089329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/272089329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#272089329">(Feb 16 2022 at 09:05)</a>:</h4>
<p>At the kind of mathematical level we're working at in mathlib I've found it fascinating that multiplication and addition have coexisted in different worlds and we've never needed to cross this divide at all. There's a natural pecking order for notation -- we have distribs to make * distribute over + but we never need to make + distribute over <em>. Valuations were the first example where I thought we'd have to deal with this but we formalised the theory of adic spaces in the perfectoid project and I thought it was striking that Huber used multiplicative notation for his target monoids meaning that the axiom was still v(x</em>y)=v(x)*v(y). However in this thread we're seeing examples where mathematicians really do pass from the multiplicative world to the additive world. I don't know whether this is some sort of profound thing or just a fact of life. Do we call something multiplication because it distributes over some addition? Do we call something addition because some multiplication distributes over it? Cohomology has an addition because we use cohomology rings, although the product is often denoted with a ∪.</p>



<a name="290499354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290499354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290499354">(Jul 22 2022 at 12:29)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/Additive.20characters/near/290429680">Here</a> is some related discussion.<br>
My use case is Gauss sums, where one has to simultaneously consider a morphism <code>ψ</code> from the additive group of a (finite) ring <code>R</code> into the multiplicative monoid of another ring <code>R'</code> ("additive character") and another morphism <code>χ</code> from the multiplicative monoid of <code>R</code> into that of <code>R'</code> ("multiplicative character"), which are multiplied and summed over all elements of <code>R</code>. It looks like I will have to define this in the form <code>∑ a : R, (χ a) * (ψ (of_add a))</code>, which is clumsy and ugly...</p>



<a name="290500725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290500725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290500725">(Jul 22 2022 at 12:43)</a>:</h4>
<p>Maybe it's time we had this? What are the objections, other than "we'll have to write some boilerplate"? The advantages are that we don't have to write what Michael just pasted above.</p>



<a name="290501165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290501165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290501165">(Jul 22 2022 at 12:46)</a>:</h4>
<p>Since it will only ever be needed between groups or monoids (I mean, no ring version or field version or whatever), I don't think it will ever get too complex or too boilerplaty. So I think it's indeed a good idea to get it.</p>



<a name="290501404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290501404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290501404">(Jul 22 2022 at 12:48)</a>:</h4>
<p>I also (and again!) support of this!  We may even try to get <code>degree</code> (with the appropriate no-zero-divisors assumption) to fit in there!</p>



<a name="290501451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290501451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290501451">(Jul 22 2022 at 12:49)</a>:</h4>
<p>I can see us ending up with <code>zero_one_hom</code>, <code>one_zero_hom</code>, <code>add_mul_hom</code>, <code>mul_add_hom</code>, <code>monoid_add_monoid_hom</code>, <code>add_monoid_monoid_hom</code>, and another 6 versions for equivs</p>



<a name="290501465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290501465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290501465">(Jul 22 2022 at 12:49)</a>:</h4>
<p>That's quite a lot of boilerplate</p>



<a name="290501557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290501557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290501557">(Jul 22 2022 at 12:50)</a>:</h4>
<p>Even if we don't care about all 12 we certainly care about 4.</p>



<a name="290501581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290501581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290501581">(Jul 22 2022 at 12:50)</a>:</h4>
<p>Is that an argument against or just an observation? I mean making LTE involved writing tens of thousands of lines of code which was quite a lot of code.</p>



<a name="290501636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290501636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290501636">(Jul 22 2022 at 12:51)</a>:</h4>
<p>Sort of an objection to the "not too boilerplaty" claim</p>



<a name="290501691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290501691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290501691">(Jul 22 2022 at 12:51)</a>:</h4>
<p>But do we care if we make another definition and then write some boilerplate?</p>



<a name="290503500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290503500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290503500">(Jul 22 2022 at 13:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/290501451">said</a>:</p>
<blockquote>
<p>I can see us ending up with <code>zero_one_hom</code>, <code>one_zero_hom</code>, <code>add_mul_hom</code>, <code>mul_add_hom</code>, <code>monoid_add_monoid_hom</code>, <code>add_monoid_monoid_hom</code>, and another 6 versions for equivs</p>
</blockquote>
<p>We probably don't need <code>zero_one</code> and <code>one_zero</code>, that's 2 down already.</p>



<a name="290503521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290503521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290503521">(Jul 22 2022 at 13:07)</a>:</h4>
<p>I'm not sure if we'd even need <code>add_mul_hom</code>+<code>mul_add_hom</code></p>



<a name="290504069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290504069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290504069">(Jul 22 2022 at 13:12)</a>:</h4>
<p>No need to add all the possible ones, only those that are genuinely useful. And I guess this should only be <code>monoid_add_monoid_hom</code> and <code>add_monoid_monoid_hom</code>. More can be added later if uses show up.</p>



<a name="290504936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290504936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290504936">(Jul 22 2022 at 13:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/290503521">said</a>:</p>
<blockquote>
<p>I'm not sure if we'd even need <code>add_mul_hom</code>+<code>mul_add_hom</code></p>
</blockquote>
<p>I can see us ending up with them eventually, given the interest in non-unital rings</p>



<a name="290504982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290504982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290504982">(Jul 22 2022 at 13:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/290504069">said</a>:</p>
<blockquote>
<p>No need to add all the possible ones, only those that are genuinely useful. And I guess this should only be <code>monoid_add_monoid_hom</code> and <code>add_monoid_monoid_hom</code>. More can be added later if uses show up.</p>
</blockquote>
<p>Indeed; but my thought is that this is a sign of either not having a scalable design, or just needing some automation to generate boilerplate for us</p>



<a name="290505048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290505048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290505048">(Jul 22 2022 at 13:22)</a>:</h4>
<p>And it's easier to write that automation / do the redesign if we have <code>n</code> existing versions to clean up instead of <code>n+12</code></p>



<a name="290505739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290505739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290505739">(Jul 22 2022 at 13:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/290504936">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/290503521">said</a>:<br>
I can see us ending up with them eventually, given the interest in non-unital rings</p>
</blockquote>
<p>Precisely, it's not a ring thing, it's a group thing, and used in very specific contexts. That's why I imagine we will only need these 2 versions.</p>



<a name="290506542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290506542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290506542">(Jul 22 2022 at 13:36)</a>:</h4>
<p>I'd argue it's a monoid thing not a group thing, and so therefore applies to rings too. We indeed don't need special cases for rings, but for instance if we introduce a power operation on non-unital monoids/rings by <code>pnat</code>, then that operaion would be an <code>add_mul_hom</code> in the second argument.</p>



<a name="290770842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290770842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290770842">(Jul 25 2022 at 15:03)</a>:</h4>
<p>I'm sitting in a lecture by Hendrik Lenstra at the Park City Mathematics Institute, and he just defined a map<br>
\Z^t --&gt; K^x, (n_i)_i |--&gt; a_1^{n_1} ... a_t^{n_t} (where $K$ is a number field), whose kernel he wants to compute...</p>



<a name="290773955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290773955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290773955">(Jul 25 2022 at 15:24)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">Z</mi><mi>t</mi></msup><mo>→</mo><msup><mi>K</mi><mi>x</mi></msup><mo separator="true">,</mo><msub><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mi>i</mi></msub><mo>↦</mo><msubsup><mi>a</mi><mn>1</mn><msub><mi>n</mi><mn>1</mn></msub></msubsup><mo>⋯</mo><msubsup><mi>a</mi><mi>t</mi><msub><mi>n</mi><mi>t</mi></msub></msubsup></mrow><annotation encoding="application/x-tex"> \mathbb{Z}^t \to K^x, {(n_i)}_i \mapsto a_1^{n_1} \cdots a_t^{n _t} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7936em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0126em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7463em;"><span style="top:-2.4542em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2963em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2458em;"><span></span></span></span></span></span></span></span></span></span></p>



<a name="290782858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290782858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290782858">(Jul 25 2022 at 16:17)</a>:</h4>
<p>(I probably had a type in my first attempt at LaTeX.)</p>



<a name="290846422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290846422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290846422">(Jul 26 2022 at 03:48)</a>:</h4>
<p>Here's a bit of code playing around with notation in Lean4</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">Op</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span> <span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>

<span class="n">macro</span> <span class="s2">"[[ Op "</span> <span class="n">a</span><span class="o">:</span><span class="n">term</span> <span class="s2">" using "</span> <span class="n">n</span><span class="o">:</span><span class="n">str</span> <span class="s2">"]]"</span> <span class="o">:</span> <span class="n">command</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="bp">`</span><span class="o">(</span><span class="kd">variable</span> <span class="o">[</span><span class="n">Op</span> <span class="bp">$</span><span class="n">a</span><span class="o">]</span>
    <span class="kn">local</span> <span class="kd">infix</span><span class="o">:</span><span class="mi">65</span> <span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">str</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">$</span><span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">Op.op</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">[[</span> <span class="n">Op</span> <span class="n">α</span> <span class="n">using</span> <span class="s2">" × "</span> <span class="o">]]</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">[[</span> <span class="n">Op</span> <span class="n">β</span> <span class="n">using</span> <span class="s2">" ++ "</span> <span class="o">]]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">×</span> <span class="n">b</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">++</span> <span class="n">b</span>
</code></pre></div>



<a name="290857865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/290857865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#290857865">(Jul 26 2022 at 07:32)</a>:</h4>
<p>The question is can we do rings like this or will typeclass inference get confused by the two <code>Op</code>s?</p>



<a name="291928385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/291928385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#291928385">(Aug 03 2022 at 22:24)</a>:</h4>
<p>I have started to write (= copy and modify) code for homomorphisms from additive to multiplicative monoids and vice versa.</p>
<p>So far, I took <code>algebra/hom/group.lean</code> and extracted three files out of it, <code>add_mul_hom.lean</code> (definition of homomorphisms from additive to multiplicative monoids and stuff that only relies on the definition), <code>mul_add_hom.lean</code> (same for the other dierction) and <code>hom_comp.lean</code> (stuff that involves both types like composition). I also converted (most of) <code>equiv.lean</code> into a file <code>equiv_mixed.lean</code> that has stuff on isomorphisms. What still needs to be done is to produce the corresponding versions of <code>grop_instances.lean</code> and <code>units.lean</code> (everything inside <code>algebra/hom</code>). (Plus perhaps further material that lives elsewhere.)</p>
<p>What would be a reasonable way to proceed? I could make a PR with what I have so far (labeled as WIP), so that people can comment on it, and we can also discuss questions that arise here. Does this sound reasonable, or are there other preferred ways of proceeding in similar cases?</p>



<a name="291932602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/291932602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#291932602">(Aug 03 2022 at 23:11)</a>:</h4>
<p>So, I'm going to second Eric's suggestion that this is too much boilerplate to actually undertake. That <code>pnat</code> instance he mentioned is definitely something on my todo list. I will completely agree that we need some way to talk abut group homs between additive and multiplicative groups (for instance, in my use case, the index map from the (operator algebraic) $K_1$ group to the $K_0$ group is a multiplicative to additive group hom). But <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> convinced me at LftCM that there is just too much duplication. <em>Perhaps</em> with the right <code>to_additive</code>-like automation, it could be feasible, but that still feels like the wrong solution to me.</p>



<a name="291934366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/291934366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#291934366">(Aug 03 2022 at 23:35)</a>:</h4>
<p>I think that <code>to_additive</code>-like automation would be difficult, since this would require to figure out which <code>mul</code>s etc. to turn into <code>add</code>s etc, depending on the kind of structure on the various monoids present (there can be up to four; the latter occurs when proving associativity of composition).<br>
Probably something like <code>switch_add_mul</code> would work that takes a statement/proof involving one "mixed" homomorphism of type mul to add (say) and turns it into the corresponding statement for add to mul.</p>
<p>What is the problem with duplication as long as somebody writes the code?</p>



<a name="291947461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/291947461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#291947461">(Aug 04 2022 at 00:05)</a>:</h4>
<p>The code has to be maintained after, ideally any change to the original API should be reflected in the duplicated one, which is tricky as often people making changes aren't aware of the duplicated version</p>



<a name="291947563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/291947563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#291947563">(Aug 04 2022 at 00:07)</a>:</h4>
<p>to_additive type automation may not be flawless, but I'd say it's worth exploring to reduce the manual effort. The original to_additive has edge cases too but it is still remarkably useful</p>



<a name="291948028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/291948028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#291948028">(Aug 04 2022 at 00:15)</a>:</h4>
<p>I assume the "right" way would be to write everything in terms of generic structures (not tied to additive or multiplicative notation) and then have automation that produces the 2^n variants of the generic statement (when n objects are involved). This should actually be quite possible via some kind of Macro expansion (which I think Lean4 is supposed to provide).</p>



<a name="291973086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/291973086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#291973086">(Aug 04 2022 at 07:14)</a>:</h4>
<p>I think it's dangerous to say "we don't want to do it this way which works, we should do it this way which is a dream which exists only in my head". Michael has a problem which needs to be solved and he has a solution. I know CS people are against code duplication in general but they're also against big monorepos in general and we've shown that actually a big monorepo can work fantastically. Who cares if the duplicated code gets out of sync? Category theory contains files which are literally two copies of the same code, one for limits and one for colimits. Separating additive and multiplicative groups is a fundamental design decision in mathlib, made because we want type class inference to infer monoid laws, and type class inference wants there to be one answer but rings have two laws. It's very easy to speculate how things could have been if rings had been built in another way, but they weren't, and the code duplication that Michael is suggesting is simply a consequence we are at some point going to have to face. Nobody was complaining when Scott was making PRs which were twice as long as some theoretical automation could have made them because the duplication was a practical solution to a clearly existing problem. I think the same is true here.</p>



<a name="292016899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292016899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292016899">(Aug 04 2022 at 14:41)</a>:</h4>
<blockquote>
<p>and the code duplication that Michael is suggesting is simply a consequence we are at some point going to have to face</p>
</blockquote>
<p>The problem is, the longer we put off facing it, the more it grows and the more likely we never end up facing it, which means:</p>
<ul>
<li>Newcomers to mathlib always have to write tonnes of boilerplate, because while we already have hundreds of boilerplate lemmas for <code>add_monoid_hom</code>, we won't have them for <code>mul_add_hom</code></li>
<li>We're increasing faced with refactors which are no longer possible to make because there's just too much boilerplate that needs changing.</li>
</ul>



<a name="292020627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292020627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292020627">(Aug 04 2022 at 15:07)</a>:</h4>
<p>Yes I see that refactors would be problematic. But I can't imagine how automation can do this job, because how can it distinguish the source <code>*</code> from the target <code>*</code>? Is that sort of problem possible? If <code>f : G -&gt;* H</code> and the lemma is <code>f (a * b) = f a * f b</code> you want the automation to spit out <code>f (a * b) = f a + f b</code>. </p>
<p>For me the question of a refactor, or of automation, are problems which can possibly be solved tomorrow (the first might never happen, the second is probably a nontrivial project), but making a bundled structure <code>f : G -&gt; A</code> with <code>f (g * h) = f g + f h</code> is a problem which can easily be solved today and which we need today.</p>



<a name="292021336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292021336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292021336">(Aug 04 2022 at 15:12)</a>:</h4>
<p>Automation could have you define the structures / write the lemmas in the generic way, then spit out the various specialized versions</p>



<a name="292021495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292021495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292021495">(Aug 04 2022 at 15:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp/near/292020627">said</a>:</p>
<blockquote>
<p>because how can it distinguish the source <code>*</code> from the target <code>*</code>?</p>
</blockquote>
<p>One is <code>@has_mul.mul G _inst_1</code>, the other is <code>@has_mul.mul H _inst_2</code></p>



<a name="292031064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292031064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292031064">(Aug 04 2022 at 16:21)</a>:</h4>
<p>So moving forward how about we write the code duplication today and leave the tactic-writing until Lean 4?</p>



<a name="292041517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292041517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292041517">(Aug 04 2022 at 17:16)</a>:</h4>
<p>But note that you need a version of the automation that can deal with more than two monoids (or similar), so it will have to be able to generate 8 or 16 versions in some cases.</p>



<a name="292050108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292050108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292050108">(Aug 04 2022 at 18:22)</a>:</h4>
<p>I think if Michael really wants to write an initial draft of this by hand, then that's fine; but I think before we <em>merge</em> anything like this we'll need to have a hard think about how to deal with these problems. My fear (maybe unfounded, but obviously shared by several people here) is that we will mire ourselves in tedious work and / or that the library will become disjointed because of failure to keep the multiplicative/additive and mixed parts in sync.</p>
<p>At the very least, we need some sort of back-of-the-envelope calculation to estimate how many defs and lemmas we're talking about here. I get the feeling that it may be a few thousand. To me, this reeks of trying to do convergence without filters, which would be a nightmare; but maybe I'm wrong about mul/add.</p>



<a name="292067520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292067520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292067520">(Aug 04 2022 at 20:43)</a>:</h4>
<p>I think that one reason I'm so much more keen on the idea of making a <code>mul_add_hom</code> structure is that my naive model of the result is just one file which is handy in a few places but just sits there in the background not really doing much. Please don't take my huge enthusiasm for this structure as some kind of demand! It's more a "what is there not to like about this idea?" situation -- I really don't get what people are fussing about. Just one file, imported occasionally in the (rare!) situations where it really makes life easier, and who cares if it's out of sync; if it actually becomes a problem then OK we just make the tactic (note of course that any tactic-making now is a really bad idea as it actively makes the port to Lean 4 harder), but just one random file imported a few times to make some constructions less horrible -- how can this be problematic? My impression is that everyone else seems to be gazing years into the future and worrying about things not scaling. That's not why we want this structure! It's hard to imagine that it will ever need to be built upon too much, and people will add API if and when they need it. Note that we've got to LTE without ever needing it, so it's clear (to my surprise) that this structure only has some kind of niche usage, it's not going to take over the algebra hierarchy! I just don't get what people are worried about. Michael are you envisaging a few thousand lemmas to do what you want to do??</p>



<a name="292070357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292070357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292070357">(Aug 04 2022 at 21:09)</a>:</h4>
<p>Kevin, I shared your feeling until I talked to Yury at breakfast at LftCM (I thought maybe you were even sitting there, but perhaps I'm misremembering). I don't remember all the details, but essentially, you're probably going to need: map and comap, kernels and images, composition lemmas, etc. (I think he went on naming several much more far reaching things).</p>
<p>Where did I ballpark a few thousand lemmas? Well, <code>algebra.hom.group</code> alone (where <code>monoid_hom</code> is defined) likely has 100-200 lemmas, and this doesn't even touch subgroups (kernel, image etc.). You will also need either new hom classes, or else just write the <code>map_add_mul</code>, <code>map_zero_one</code> lemmas manually. I think it's reasonable to hit a thousand lemmas doing this, and I've almost surely missed a bunch of things which will be necessary.</p>
<p>Now, <em>despite</em> my relatively newfound skepticism, if this is implemented and it seems to work, then great! All i'm advocating for is that we design carefully; not doing so can bite us.</p>



<a name="292070656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292070656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292070656">(Aug 04 2022 at 21:12)</a>:</h4>
<p>Remember also, naming is hard to keep straight. Right now, (almost) every time a lemma name is changed <code>to_additive</code> takes care of renaming the additive one. For all of these, you have to manually keep the names in sync, not to mention the statements. <em>Maybe</em> because it is only about groups, the naming is relatively stable at this point, I have no idea.</p>



<a name="292071910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292071910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292071910">(Aug 04 2022 at 21:25)</a>:</h4>
<p>Naming is going to be a problem when there are three or more monoids involved.<br>
E.g., there are eight ways to compose homomorphisms. Fixing the type of the seoncd one (in order of application; it is the first argument to <code>comp</code>), there are still two compositions to be defined: say, the second homomorphism <code>g</code>  is from multiplicative to additive. Then we can (pre-)compose <code>g</code> with an <code>f</code> that is either a hom. from additive to multiplcicative or a multiplicative hom.<br>
It would be desirable if all of this would be called <code>comp</code> in some appropriate namespace. But since there are two different <code>comp</code>s, we then cannot just simply use <code>monoid_to_add_monoid_hom.comp</code>. Perhaps <code>monoid_to_add_monoid_hom.add.comp</code> and <code>monoid_to_add_monoid_hom.mul.comp</code>?<br>
Then we could write <code>g.add.comp f</code> or <code>g.mul.comp f</code>. (Of course, it would be more desirable to just write <code>g.comp f</code>, but I think this would require the possibility to overload names, which, as far as I know, Lean does not provide.)</p>



<a name="292071953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292071953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292071953">(Aug 04 2022 at 21:25)</a>:</h4>
<p>This would have to be taken care of by the <code>to_additive</code> analogues.</p>



<a name="292072089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292072089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292072089">(Aug 04 2022 at 21:27)</a>:</h4>
<p>It gets even worse with <code>comp_assoc</code>. This involves <em>four</em> monoids, so we need names like <code>monoid_hom.add.mul.comp_assoc</code> if we do it in a similar way.</p>



<a name="292072303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292072303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292072303">(Aug 04 2022 at 21:28)</a>:</h4>
<p>(It would be even better if there would be a general <code>comp_assoc</code> lemma that applies whenever stuff gets composed that can be coerced to functions and for which composition makes sense. The proofs of these sixteen lemmas are all the same.)</p>



<a name="292073292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292073292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292073292">(Aug 04 2022 at 21:38)</a>:</h4>
<p>But do you actually need these things in your use case? You don't even need a map which sends multiplication to addition, right? Such things seem to be much rarer.</p>



<a name="292073626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292073626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292073626">(Aug 04 2022 at 21:42)</a>:</h4>
<p>Recently I played with the idea of defining contravariant functors directly (no mention of <code>op</code>) and here you probably really would need all these extra things, but boy was it glorious not having to deal with all the <code>op</code>s!</p>



<a name="292074367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292074367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292074367">(Aug 04 2022 at 21:51)</a>:</h4>
<p>For my use case, I probably really don't need much. But I assume there will be more applications (also for mul_to_add), and so I would support the notion that it should be done "right", by which I would understand that you can do everything you can do with homomorphisms between monoids of the same kind also with homomorphisms between monoids of different kinds. And I agree that the best way of doing that is to beef up <code>to_additive</code> such that it produces the necessary versions for all combinations.</p>



<a name="292074468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292074468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292074468">(Aug 04 2022 at 21:52)</a>:</h4>
<p>Logarithms and exponentials are not that uncommon and would be fairly typical examples.</p>



<a name="292074831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292074831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292074831">(Aug 04 2022 at 21:56)</a>:</h4>
<p>I want to argue that logarithm <em>is</em> uncommon, because it's not defined on the negative reals, so as it stands in mathlib (where it takes junk values) it doesn't send * to +. It would work for positive reals but we don't even have a type for these in Lean, so they can't be common either. I think the exp direction is much more common.</p>



<a name="292075090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292075090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292075090">(Aug 04 2022 at 21:58)</a>:</h4>
<p>"not that uncommon" was referring to mathematics, not necessarily mathlib <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="292075563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292075563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292075563">(Aug 04 2022 at 22:02)</a>:</h4>
<p>If you'd asked me 5 years ago I would have said that maps that take + to * and * to + were all over the place and that any system which randomly separated out "groups with group law +" from "groups with group law *" was completely crazy. Now I have to admit that I was wrong.</p>



<a name="292075828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292075828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292075828">(Aug 04 2022 at 22:05)</a>:</h4>
<p>Yes, it does work surprisingly well.</p>



<a name="292075987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292075987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292075987">(Aug 04 2022 at 22:06)</a>:</h4>
<p>Has anybody been trying to consider <code>pow x</code> or <code>zpow x</code> as a monoid/group homomorphism? That would appear pretty natural (and perhaps underscores Kevin's point that add_to_mul is more common than <code>mul_to_add</code>).</p>



<a name="292077186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292077186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292077186">(Aug 04 2022 at 22:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Regarding both directions of maps: in the 6-term cyclic exact sequence (due to Bott periodicity) in operator algebraic K-theory corresponding to a short exact sequence <code>0 → J → A → A / J → 0</code>, which is:<br>
<code>K₀(J) → K₀(A) → K₀(A / J) e→ K₁(J) → K₁(A) → K₁(A / J) δ→ K₀(J)</code> (wrap this around)<br>
Then the maps I labeled <code>e</code> is an <code>add → mul</code> and <code>δ</code> is a <code>mul → add</code> because <code>K₀</code> is additive but <code>K₁</code> is multiplicative.</p>



<a name="292107010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292107010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292107010">(Aug 05 2022 at 04:44)</a>:</h4>
<p>Not sure if this has been mentioned already, but when one of these maps appears on the side in some complex construction, I think it is not at all a bad idea to just use <code>A -&gt; multiplicative B</code> homs instead of doing thousands of boilerplate lemmas for a new class. It is only when these show up often enough that the boilerplate associated with working with them is higher than the general API that we should consider doing all the combinatorial explosion of lemmas</p>



<a name="292107736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292107736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292107736">(Aug 05 2022 at 04:58)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Yes, that's what Michael has been using so far. Search for <code>add_char</code> in mathlib if you want to see details (-;</p>



<a name="292107794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292107794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292107794">(Aug 05 2022 at 04:59)</a>:</h4>
<p>In particular, if you have that as a backup plan then it means you don't have to go nuts on the combinatorial explosion, you can just do the particular special cases that happen to be very common</p>



<a name="292108060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292108060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292108060">(Aug 05 2022 at 05:03)</a>:</h4>
<p>Certainly if the new notion would also unfold into a <code>A →* multiplicative B</code>.</p>



<a name="292623869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292623869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292623869">(Aug 09 2022 at 17:33)</a>:</h4>
<p>The solution I have come up with for my use case is the following. Define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.basic</span>
<span class="kn">import</span> <span class="n">field_theory.finite.galois_field</span>
<span class="kn">import</span> <span class="n">number_theory.cyclotomic.primitive_roots</span>
<span class="kn">import</span> <span class="n">field_theory.finite.trace</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">R'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">R'</span><span class="o">]</span>

<span class="kd">@[derive [comm_monoid, inhabited]</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">add_char</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→*</span> <span class="n">R'</span>
</code></pre></div>
<p>as is currently done in <code>number_theory.legendre_symbol.add_character</code>, and then define the coercion to a function as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">multiplicative</span>

<span class="kd">instance</span> <span class="n">add_char.has_coe_to_fun</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">add_char</span> <span class="n">R</span> <span class="n">R'</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R'</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ψ</span> <span class="n">x</span><span class="o">,</span> <span class="n">ψ.to_fun</span> <span class="o">(</span><span class="n">of_add</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>
<p>so that it includes the conversion from <code>R</code> to <code>multiplicative R</code>.<br>
Then I can write, e.g., <code>ψ (a * x)</code> (for <code>ψ : add_char R R'</code> and <code>a x : R</code>) , and it is what I want it to be (i.e., <code>ψ.to_fun (of_add (a * x))</code> and not <code>ψ.to_fun (of_add a * of_add x) = ψ.to_fun (of_add (a + x))</code>).<br>
It is then easy to show API lemmas like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">map_zero_one</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="n">add_char</span> <span class="n">R</span> <span class="n">R'</span><span class="o">)</span> <span class="o">:</span> <span class="n">ψ</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">lemma</span> <span class="n">map_add_mul</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="n">add_char</span> <span class="n">R</span> <span class="n">R'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">ψ</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ψ</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">ψ</span> <span class="n">y</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">lemma</span> <span class="n">map_nsmul_pow</span> <span class="o">(</span><span class="n">ψ</span> <span class="o">:</span> <span class="n">add_char</span> <span class="n">R</span> <span class="n">R'</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">ψ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">ψ</span> <span class="n">x</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>and use them in the proofs, so that there is no need to even see an <code>of_add</code> or <code>to_add</code> anywhere (except in the proofs of these API lemmas).</p>



<a name="292624121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292624121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292624121">(Aug 09 2022 at 17:34)</a>:</h4>
<p>I'm going to PR this next, once <a href="https://github.com/leanprover-community/mathlib/pull/15888">#15888</a> is merged (which should be soon).</p>



<a name="292634517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292634517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292634517">(Aug 09 2022 at 18:34)</a>:</h4>
<p>That's very nice!</p>



<a name="292635094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292635094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292635094">(Aug 09 2022 at 18:38)</a>:</h4>
<blockquote>
<p>Has anybody been trying to consider pow x or zpow x as a monoid/group homomorphism?</p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/powers_hom">docs#powers_hom</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/zpowers_hom">docs#zpowers_hom</a></p>



<a name="292635724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292635724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292635724">(Aug 09 2022 at 18:42)</a>:</h4>
<p>Oh that's a great solution!</p>



<a name="292636645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292636645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292636645">(Aug 09 2022 at 18:48)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> How generally can this be made to work? That is, does it solve all our problems? Are there limitations you have encountered?</p>



<a name="292638901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292638901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292638901">(Aug 09 2022 at 19:01)</a>:</h4>
<p>I haven't tried to see how general this is. At least for what I wanted, it's sufficient.<br>
I guess it would not work that well when you want to compose homomorphisms, say you have <code>M →+ N</code> and <code>N +→* P</code> (using <code>+→*</code> for a homomorphism from additive to multiplicative) and want to produce <code>M +→* P</code>.</p>



<a name="292647054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292647054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292647054">(Aug 09 2022 at 19:55)</a>:</h4>
<p>It is possible (to get compositions as above), but one has to use <code>to_multiplicative</code>, e.g. as in the following.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ψ'</span> <span class="o">:=</span> <span class="n">ψ.char.comp</span> <span class="o">(</span><span class="n">algebra.trace</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">p</span><span class="o">)</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">to_add_monoid_hom.to_multiplicative</span>
</code></pre></div>
<p>But maybe it is a good compromise...</p>



<a name="292647864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292647864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292647864">(Aug 09 2022 at 20:00)</a>:</h4>
<p>In terms of the simplicity of the solution and the integration with existing API, I think this is really quite spectacular. Nice work!</p>



<a name="292664625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292664625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292664625">(Aug 09 2022 at 21:59)</a>:</h4>
<p>I think this is already the solution we use for <a href="https://leanprover-community.github.io/mathlib_docs/find/add_valuation.has_coe_to_fun">docs#add_valuation.has_coe_to_fun</a></p>



<a name="292664775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292664775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292664775">(Aug 09 2022 at 22:00)</a>:</h4>
<p>Although your version of inserting the <code>of_add</code> is certainly nicer</p>



<a name="292984333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/292984333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#292984333">(Aug 11 2022 at 18:30)</a>:</h4>
<p>This is now <a href="https://github.com/leanprover-community/mathlib/pull/16016">#16016</a> (also a nice number...).</p>



<a name="293236169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/293236169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#293236169">(Aug 13 2022 at 07:25)</a>:</h4>
<p>It would be nice if someone could have a look at <a href="https://github.com/leanprover-community/mathlib/pull/16016">#16016</a>. <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="197836">@Jireh Loreaux</span> <span class="user-mention" data-user-id="310045">@Eric Wieser</span> <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> ?</p>



<a name="293434290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/293434290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#293434290">(Aug 14 2022 at 19:16)</a>:</h4>
<p>"Lint mathlib" fails on <a href="https://github.com/leanprover-community/mathlib/pull/16016">#16016</a> after the latest push with error message</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">curl</span><span class="o">:</span> <span class="o">(</span><span class="mi">35</span><span class="o">)</span> <span class="n">OpenSSL</span> <span class="n">SSL_connect</span><span class="o">:</span> <span class="n">Connection</span> <span class="n">reset</span> <span class="kd">by</span> <span class="n">peer</span> <span class="k">in</span> <span class="n">connection</span> <span class="n">to</span> <span class="n">github.com</span><span class="o">:</span><span class="mi">443</span>
<span class="n">elan</span><span class="o">:</span> <span class="n">command</span> <span class="n">failed</span><span class="o">:</span> <span class="n">curl</span> <span class="bp">-</span><span class="n">sSfL</span> <span class="bp">-</span><span class="n">o</span> <span class="bp">/</span><span class="n">dev</span><span class="bp">/</span><span class="n">null</span> <span class="bp">-</span><span class="n">w</span> <span class="bp">%</span><span class="o">{</span><span class="n">url_effective</span><span class="o">}</span> <span class="n">https</span><span class="o">:</span><span class="bp">//</span><span class="n">github.com</span><span class="bp">/</span><span class="n">leanprover</span><span class="bp">/</span><span class="n">elan</span><span class="bp">/</span><span class="n">releases</span><span class="bp">/</span><span class="n">latest</span>
<span class="n">curl</span><span class="o">:</span> <span class="o">(</span><span class="mi">22</span><span class="o">)</span> <span class="n">The</span> <span class="n">requested</span> <span class="n">URL</span> <span class="n">returned</span> <span class="n">error</span><span class="o">:</span> <span class="mi">404</span>
<span class="n">elan</span><span class="o">:</span> <span class="n">command</span> <span class="n">failed</span><span class="o">:</span> <span class="n">curl</span> <span class="bp">-</span><span class="n">sSfL</span> <span class="n">https</span><span class="o">:</span><span class="bp">//</span><span class="n">github.com</span><span class="bp">/</span><span class="n">leanprover</span><span class="bp">/</span><span class="n">elan</span><span class="bp">/</span><span class="n">releases</span><span class="bp">/</span><span class="n">download</span><span class="bp">/</span><span class="n">latest</span><span class="bp">/</span><span class="n">elan</span><span class="bp">-</span><span class="n">x86_64</span><span class="bp">-</span><span class="n">unknown</span><span class="bp">-</span><span class="n">linux</span><span class="bp">-</span><span class="n">gnu.tar.gz</span> <span class="bp">-</span><span class="n">o</span> <span class="bp">/</span><span class="n">tmp</span><span class="bp">/</span><span class="n">tmp.97CY0BiNCz</span><span class="bp">/</span><span class="n">elan</span><span class="bp">-</span><span class="n">init.tar.gz</span>
<span class="n">Error</span><span class="o">:</span> <span class="n">Process</span> <span class="n">completed</span> <span class="k">with</span> <span class="n">exit</span> <span class="n">code</span> <span class="mi">1</span><span class="bp">.</span>
</code></pre></div>
<p>What can I do about this?</p>



<a name="293434925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/293434925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#293434925">(Aug 14 2022 at 19:25)</a>:</h4>
<p>I'm re-running the failed jobs for a second time now, and at least it doesn't fail after a few seconds. I'll keep my fingers crossed...</p>



<a name="293437856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/map%20from%20mult%20gp%20to%20add%20gp/near/293437856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/map.20from.20mult.20gp.20to.20add.20gp.html#293437856">(Aug 14 2022 at 20:04)</a>:</h4>
<p>OK, <a href="https://github.com/leanprover-community/mathlib/pull/16016">#16016</a> is green again. Can it go on the merge queue now? <span class="user-mention" data-user-id="112680">@Johan Commelin</span>  <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> <br>
See also the discussion <a href="#narrow/stream/113488-general/topic/.60pnat.60.20vs.20.60.5Bfact.20.280.20.3C.20n.29.5D.60/near/293293368">here</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
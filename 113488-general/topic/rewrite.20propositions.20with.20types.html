---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/rewrite.20propositions.20with.20types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/rewrite.20propositions.20with.20types.html">rewrite propositions with types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="307852140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/rewrite%20propositions%20with%20types/near/307852140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siyuan Yan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/rewrite.20propositions.20with.20types.html#307852140">(Nov 03 2022 at 22:33)</a>:</h4>
<p>I'm new to lean, and this is an example from the tutorials:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">even_fun</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">odd_fun</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">f</span> <span class="n">x</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">even_fun</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">even_fun</span> <span class="n">g</span> <span class="bp">→</span>  <span class="n">even_fun</span> <span class="o">(</span><span class="n">f</span> <span class="bp">+</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>instead of <code>def</code>s and <code>... → ... → ...</code>, how do I make a type for even function? This is want I want to write:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">EvenFunction</span> <span class="n">ℝ</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">???</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Moreover, what should I write at the <code>???</code> part to claim that <code>f + g</code> still has type <code>EvenFunction ℝ ℝ</code>?</p>



<a name="307852424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/rewrite%20propositions%20with%20types/near/307852424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/rewrite.20propositions.20with.20types.html#307852424">(Nov 03 2022 at 22:35)</a>:</h4>
<p>Did you already write <code>EvenFunction</code>? How did you define it? Or is that part of the question as well?</p>



<a name="307852688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/rewrite%20propositions%20with%20types/near/307852688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siyuan Yan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/rewrite.20propositions.20with.20types.html#307852688">(Nov 03 2022 at 22:36)</a>:</h4>
<p>That's part of the question <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="307853701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/rewrite%20propositions%20with%20types/near/307853701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/rewrite.20propositions.20with.20types.html#307853701">(Nov 03 2022 at 22:44)</a>:</h4>
<p>I am not at a level too much beyond where you are, but part of what you're asking might have to do with <a href="https://leanprover-community.github.io/glossary.html#bundled-vs-unbundled">glossary#bundled-vs-unbundled</a>.</p>
<p>You can define a simple type which is a function along with a proof that it's even via e.g.:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">def</span> <span class="n">even_fun</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">odd_fun</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">f</span> <span class="n">x</span>

<span class="kd">structure</span> <span class="n">even_function</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_even_to_fun</span> <span class="o">:</span> <span class="n">even_fun</span> <span class="n">to_fun</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">even_function.add</span> <span class="o">:</span> <span class="n">even_function</span> <span class="bp">→</span> <span class="n">even_function</span> <span class="bp">→</span> <span class="n">even_function</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f.to_fun</span> <span class="bp">+</span> <span class="n">g.to_fun</span><span class="o">,</span> <span class="kd">begin</span>
<span class="kd">end</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_add</span>  <span class="n">even_function</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">add</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">even_function</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">f</span> <span class="bp">+</span> <span class="n">g</span>
</code></pre></div>
<p>but now you see you may need to teach lean even how to add those (which involves filling in the proof you were talking about).</p>



<a name="307854153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/rewrite%20propositions%20with%20types/near/307854153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/rewrite.20propositions.20with.20types.html#307854153">(Nov 03 2022 at 22:48)</a>:</h4>
<p>In type theory, if you make a new type <code>EvenFunction ℝ ℝ</code> then there are two issues: firstly if <code>f</code> has type <code>EvenFunction ℝ ℝ</code> then it will <em>not</em> have type <code>ℝ → ℝ</code>, in other words it definitely will not be a function from <code>ℝ</code> to <code>ℝ</code>. You will be able to tell Lean to <em>interpret</em> it as a function from the reals to the reals, but it will add a little up-arrow in front of it -- this will be an "invisible function" from the type <code>EvenFunction ℝ ℝ</code> to the type <code>ℝ → ℝ</code>, just like in Lean there are invisible functions from the naturals to the integers to the rationals to the reals to the complexes, from the rationals to the 37-adic numbers etc etc. And second it will not be a <em>theorem</em> that <code>f + g</code> still has type <code>EvenFunction ℝ ℝ</code> -- the assertion that a term has a given type is just some inbuilt thing in type theory, it's not something you can prove. So if you do it this way then the assertion will still have the same content but it will be wrapped up differently -- it will be a <em>definition</em> of an addition on the type <code>EvenFunction ℝ ℝ</code>, and then a theorem that <code>f+g</code>, when interpreted via the "invisible function", or coercion, and evaluated at a real <code>x</code>, will equal the coercion of <code>f</code> evaluated at <code>x</code>, add the coercion of <code>g</code> evaluated at <code>x</code>. So it's all the same information but packaged up in a totally different way.</p>
<p>To make the coercion in Lean 3 you need to know about <code>has_coe_to_fun</code> and to make the addition you need to know about the <code>has_add</code> typeclass.</p>



<a name="307855026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/rewrite%20propositions%20with%20types/near/307855026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siyuan Yan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/rewrite.20propositions.20with.20types.html#307855026">(Nov 03 2022 at 22:55)</a>:</h4>
<p><span class="user-mention" data-user-id="321696">@Julian Berman</span> <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> thanks! those are two different approaches. I was more thinking in line with Kevin. Interesting to know <code>structure</code> exists too!</p>



<a name="307855219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/rewrite%20propositions%20with%20types/near/307855219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siyuan Yan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/rewrite.20propositions.20with.20types.html#307855219">(Nov 03 2022 at 22:57)</a>:</h4>
<p>actually maybe not too different? structure seems to be a "frontend" for defining inductive types?</p>



<a name="307856252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/rewrite%20propositions%20with%20types/near/307856252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/rewrite.20propositions.20with.20types.html#307856252">(Nov 03 2022 at 23:05)</a>:</h4>
<p>You can read about structures in chapter 9 of <a href="https://leanprover.github.io/theorem_proving_in_lean/">#tpil</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html">how to do well founded recursion without...</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="244930271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244930271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244930271">(Jul 05 2021 at 12:31)</a>:</h4>
<p>how to do well founded recursion without well founded recursion? this is my attempt so far... not successful...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">something</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">something</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">something</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">less</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">loglike</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">something</span> <span class="n">less</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">value'</span> <span class="o">(</span><span class="n">something.intro</span> <span class="n">value</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">value</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span>
  <span class="o">(</span><span class="n">loglike</span> <span class="o">(</span><span class="n">value</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="n">value</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">less</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">value</span> <span class="o">:=</span> <span class="kd">begin</span>
      <span class="n">apply</span> <span class="n">lt_of_le_of_ne</span> <span class="o">(</span><span class="n">zero_le</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">tauto</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">nat.div_lt_self</span> <span class="n">value</span> <span class="mi">2</span> <span class="n">this</span> <span class="kd">begin</span>
      <span class="n">norm_num</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="244931102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244931102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244931102">(Jul 05 2021 at 12:40)</a>:</h4>
<p>someone on here said that well-founded recursion is just structural recursion, that's why I'm doing this</p>



<a name="244932458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244932458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244932458">(Jul 05 2021 at 12:55)</a>:</h4>
<p>You can't use the equation compiler for this, because it doesn't support recursion on inductive predicates without well founded recursion, which is what you are trying to avoid. Instead you can just call the recursor directly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">loglike</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">something</span> <span class="n">less</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">something.rec_on</span> <span class="n">h</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">value</span> <span class="n">h</span> <span class="n">IH</span><span class="o">,</span>
  <span class="k">if</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">value</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span>
  <span class="o">(</span><span class="n">IH</span> <span class="o">(</span><span class="n">value</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">less</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">value</span> <span class="o">:=</span> <span class="kd">begin</span>
      <span class="n">apply</span> <span class="n">lt_of_le_of_ne</span> <span class="o">(</span><span class="n">zero_le</span> <span class="n">_</span><span class="o">),</span>
      <span class="n">tauto</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">nat.div_lt_self</span> <span class="n">value</span> <span class="mi">2</span> <span class="n">this</span> <span class="kd">begin</span>
      <span class="n">norm_num</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>



<a name="244936907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244936907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244936907">(Jul 05 2021 at 13:39)</a>:</h4>
<p>Well, your implementation has a bug. And I'm not asking you to fix that bug because, well, what's the point <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> I mean, I want to understand how rec_on works to fix that bug myself. I don't understand rec_on at all, how does it work?</p>



<a name="244937344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244937344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244937344">(Jul 05 2021 at 13:43)</a>:</h4>
<p>This is the signature of rec_on:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">Π</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">l</span><span class="o">}</span> <span class="o">{</span><span class="n">ᾰ</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">something</span> <span class="n">r</span> <span class="n">ᾰ</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">something</span> <span class="n">r</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">ᾰ</span>
</code></pre></div>
<p>The first parameter is the relation obviously. And I guess the C is the result type, and <code>ᾰ</code> is a parameter in the introduction rule. <code>something r ᾰ</code> is the inductive predicate, and <code>x</code> is also a parameter in the introduction rule (???) and the <code>(∀ (y : ℕ), r y x → something r y)</code> is the hypothesis in the introduction rule (?). <code>(Π (y : ℕ), r y x → C y) → C x</code> means a function that outputs the result type and <code> C ᾰ</code> is the final result. I feel like I'm typing nonsense. Because to be honest I don't understand the parameters at all.</p>



<a name="244938346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244938346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244938346">(Jul 05 2021 at 13:52)</a>:</h4>
<p>Oh, the explanation is here:</p>
<blockquote>
<p>The implicit argument, C, is the codomain of the function being defined. In type theory it is common to say C is the motive for the elimination/recursion, since it describes the kind of object we wish to construct. The next argument, n : nat, is the input to the function. It is also known as the major premise. Finally, the two arguments after specify how to compute the zero and successor cases, as described above. They are also known as the minor premises.</p>
</blockquote>
<p>It doesn't explain how the <code>rec_on</code> function itself is evaluated though. How is it evaluated then?</p>



<a name="244938578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244938578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244938578">(Jul 05 2021 at 13:54)</a>:</h4>
<p>And why does your function output <code>0</code> when I run <code>#eval loglike 1000000 (something.intro 1000000 (is_wf 1000000))</code>? This is my is_wf lemma, it's gnarly but hey, I'm just goofing around!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">invent</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">something</span> <span class="n">less</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">less</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">something</span> <span class="n">less</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h_h</span> <span class="n">y</span> <span class="n">h1</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_wf</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">less</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">something</span> <span class="n">less</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">rw</span> <span class="n">less</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">something.intro</span> <span class="mi">0</span> <span class="kd">begin</span>
      <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">less</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">linarith</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">exact</span> <span class="n">something.intro</span> <span class="n">y_n.succ</span> <span class="kd">begin</span>
      <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">hhh</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">less</span> <span class="n">at</span> <span class="n">hhh</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="n">nat.eq_or_lt_of_le</span> <span class="o">(</span><span class="n">nat.le_of_succ_le_succ</span> <span class="n">hhh</span><span class="o">),</span>
      <span class="n">cases</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">hhh</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">this.symm</span> <span class="n">at</span> <span class="n">y_ih</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">this.symm</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">y_ih</span> <span class="kd">begin</span>
        <span class="n">rw</span> <span class="n">less</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">less</span><span class="o">,</span>
        <span class="k">have</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">y.succ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="n">this</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">this</span> <span class="n">h</span><span class="o">,</span>
      <span class="kd">end</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">less</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">y_n</span> <span class="bp">&lt;</span> <span class="n">y_n.succ</span> <span class="o">:=</span> <span class="kd">begin</span>
        <span class="n">apply</span> <span class="n">nat.lt_succ_of_le</span><span class="o">,</span>
        <span class="n">linarith</span><span class="o">,</span>
      <span class="kd">end</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="n">y_ih</span> <span class="kd">begin</span>
        <span class="n">rw</span> <span class="n">less</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">this</span> <span class="n">h</span><span class="o">,</span>
      <span class="kd">end</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">invent</span> <span class="n">y_n</span> <span class="n">y</span> <span class="n">this</span> <span class="kd">begin</span>
        <span class="n">rw</span> <span class="n">less</span><span class="o">,</span>
        <span class="n">assumption</span><span class="o">,</span>
      <span class="kd">end</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="244938627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244938627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244938627">(Jul 05 2021 at 13:55)</a>:</h4>
<p>My original function, on the other hand, outputs <code>20</code>.</p>



<a name="244938663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244938663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244938663">(Jul 05 2021 at 13:55)</a>:</h4>
<p>That is, when I stick the <code>meta</code> keyword in front of the function definition.</p>



<a name="244945653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244945653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244945653">(Jul 05 2021 at 14:56)</a>:</h4>
<p>In your example <code>C</code> is just <code>λ  _, nat</code></p>



<a name="244949560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244949560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244949560">(Jul 05 2021 at 15:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="270523">Huỳnh Trần Khanh</span> <a href="#narrow/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E/near/244936907">said</a>:</p>
<blockquote>
<p>Well, your implementation has a bug. And I'm not asking you to fix that bug because, well, what's the point <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> I mean, I want to understand how rec_on works to fix that bug myself. I don't understand rec_on at all, how does it work?</p>
</blockquote>
<p>Could you be more specific? It compiles just fine. As for what it actually does, I didn't pay it much attention, I think the body of the function is on you</p>



<a name="244950681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244950681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244950681">(Jul 05 2021 at 15:43)</a>:</h4>
<p>Oh, you are right, you've found one of lean's dirty secrets. Here's a function that computes a value in the singleton type <code>one_hundred</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">acc'</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">acc'</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">acc'</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">one_hundred</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">100</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">one_hundred</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">acc'.rec_on</span> <span class="n">one_hundred</span> <span class="o">(</span><span class="bp">=</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">one_hundred</span><span class="o">)</span> <span class="o">⟨</span><span class="mi">100</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="gr">sorry</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span> <span class="n">IH</span><span class="o">,</span> <span class="n">x</span>
</code></pre></div>
<p>You won't guess what the value is though:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">foo.1</span> <span class="c1">-- 0</span>
</code></pre></div>



<a name="244950792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244950792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244950792">(Jul 05 2021 at 15:44)</a>:</h4>
<p>Change one character and it works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">one_hundred</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">acc.rec_on</span> <span class="n">one_hundred</span> <span class="o">(</span><span class="bp">=</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">one_hundred</span><span class="o">)</span> <span class="o">⟨</span><span class="mi">100</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="gr">sorry</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span> <span class="n">IH</span><span class="o">,</span> <span class="n">x</span>
<span class="k">#eval</span> <span class="n">foo.1</span> <span class="c1">-- 100</span>
</code></pre></div>



<a name="244951234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244951234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244951234">(Jul 05 2021 at 15:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="270523">Huỳnh Trần Khanh</span> <a href="#narrow/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E/near/244938346">said</a>:</p>
<blockquote>
<p>It doesn't explain how the <code>rec_on</code> function itself is evaluated though. How is it evaluated then?</p>
</blockquote>
<p>When you declare an inductive type, the kernel makes lambda functions that correspond to the type's constructors. When the whnf reduction procedure needs to apply the recursor, there's a kernel function that fishes out the appropriate lambda and just applies it like a regular function. You can see the procedure for making one of the computation rules here:<br>
<a href="https://github.com/leanprover/lean4/blob/99e2a577910812726958303fd1deeae52f57684e/src/kernel/inductive.cpp#L639">https://github.com/leanprover/lean4/blob/99e2a577910812726958303fd1deeae52f57684e/src/kernel/inductive.cpp#L639</a><br>
<a href="https://github.com/ammkrn/nanoda_lib/blob/998ef68742d2ccc9f82442d70ae16802f44e33f2/src/inductive.rs#L1116">https://github.com/ammkrn/nanoda_lib/blob/998ef68742d2ccc9f82442d70ae16802f44e33f2/src/inductive.rs#L1116</a></p>
<p><a href="https://github.com/digama0/lean-type-theory">Mario's paper</a> has a written description in 2.6.3/2.6.4</p>



<a name="244951483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244951483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244951483">(Jul 05 2021 at 15:52)</a>:</h4>
<p>I'm not sure if there's a way to get Lean to print the value level of the computation rule. Someone else might know.</p>



<a name="244951750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244951750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244951750">(Jul 05 2021 at 15:55)</a>:</h4>
<p>Or if you know any of the languages used in the type checkers you can use one of those to print out whatever kernel terms you want.</p>



<a name="244952034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244952034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244952034">(Jul 05 2021 at 15:59)</a>:</h4>
<p>Here's an example for <code>nat.rec_on</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">nat.rec_on</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">l</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="mi">0</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">n.succ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">n</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">nat.rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span><span class="o">)</span> <span class="mi">0</span> <span class="n">z</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">@</span><span class="n">nat.rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">z</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s</span> <span class="n">n</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.rec_on</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span><span class="o">)</span> <span class="n">n</span> <span class="n">z</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>So when given <code>z</code> as initial value and <code>s</code> as a successor function, it returns <code>z</code> when the input is <code>0</code>, and when the input is <code>n+1</code>, it first calls itself recursively at <code>n</code> to produce a result <code>IH</code>, then calls <code>s n IH</code></p>



<a name="244953030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244953030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244953030">(Jul 05 2021 at 16:10)</a>:</h4>
<p>When the inductive type contains a nested function, <code>IH</code> will itself be a function, which can be called by the provided user function:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">foo</span><span class="o">)</span> <span class="bp">→</span> <span class="n">foo</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">@</span><span class="n">foo.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">foo</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>I'm simplifying to the nondependent case here but it still has a rather involved function signature. The recursor takes one "configuration" argument of type <code>(ℕ → foo) → (ℕ → α) → α</code>, which defines what we want to compute by recursion, and one "main" argument of type <code>foo</code>, which is what we are actually recursing over. When we define the body, we get two arguments, of types <code>ℕ → foo</code> and <code>ℕ → α</code>. The first argument is the contents of the current value after destructing the <code>foo.mk</code>: since it has one argument of type <code>ℕ → foo</code> the recursor gives it to us, and we can call this function to receive embedded values. The other function of type <code>ℕ → α</code> is the inductive hypothesis. We are trying to define a function returning values in <code>α</code>, so if we want to query the children of the current value we can use this function to do so.</p>



<a name="244953241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244953241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244953241">(Jul 05 2021 at 16:12)</a>:</h4>
<p>Mario, can you expand what the "dirty secret" about <code>acc</code> is there? Having the VM produce a different answer to the one you have a proof of seems like a pretty big deal, even if it doesn't impact soundness.</p>



<a name="244953382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244953382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244953382">(Jul 05 2021 at 16:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">foo</span><span class="o">)</span> <span class="o">(</span><span class="n">IH</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">IH</span> <span class="mi">2</span>

<span class="kd">def</span> <span class="n">rec_f</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">foo.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:</span> <span class="n">rec_f</span> <span class="o">(</span><span class="n">foo.mk</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">α</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">rec_f</span> <span class="o">(</span><span class="n">x</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="244953588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244953588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244953588">(Jul 05 2021 at 16:17)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Indeed, this is a bug in the VM that can cause programs to crash or compute wrong answers. The dirty secret is that because supporting large-eliminating propositions is complicated, the lean devs punted on the problem and only implemented it for two specific types: <code>eq</code> and <code>acc</code>. Luckily you can simulate all other large eliminating inductives using these, and the built in compilation strategy uses them, so people were none the wiser.</p>



<a name="244953868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244953868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244953868">(Jul 05 2021 at 16:20)</a>:</h4>
<p>In case you were wondering where the <code>0</code> came from:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">acc'</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">acc'</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">acc'</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">acc'.rec_on</span> <span class="n">string</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">string</span><span class="o">)</span> <span class="s2">""</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cc</span><span class="o">⟩</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span> <span class="n">IH</span><span class="o">,</span> <span class="n">x</span>

<span class="k">#eval</span> <span class="n">foo</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">vm check failed: is_external(o) (possibly due to incorrect axioms, or sorry)</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="244954428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244954428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244954428">(Jul 05 2021 at 16:26)</a>:</h4>
<p>Actually there are a few more builtin inductive predicates, like <code>and</code>. This one gives a nice error message:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">and'</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">and'</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">and</span> <span class="n">true</span> <span class="n">true</span> <span class="o">:=</span> <span class="o">⟨⟨⟩,</span> <span class="o">⟨⟩⟩</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">and.rec</span> <span class="n">true</span> <span class="n">true</span> <span class="o">(</span><span class="n">one_hundred</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">100</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="n">foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="c1">-- 100</span>
<span class="kd">def</span> <span class="n">foo'</span> <span class="o">:</span> <span class="n">and'</span> <span class="n">true</span> <span class="n">true</span> <span class="o">:=</span> <span class="o">⟨⟨⟩,</span> <span class="o">⟨⟩⟩</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">and'.rec</span> <span class="n">true</span> <span class="n">true</span> <span class="o">(</span><span class="n">one_hundred</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">100</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="n">foo'</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
<span class="c1">-- code generation failed, inductive predicate 'and'' is not supported</span>
</code></pre></div>



<a name="244954605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244954605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244954605">(Jul 05 2021 at 16:29)</a>:</h4>
<p>Amusingly, it seems the humble <code>true</code> was supported however:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">true'</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">true'</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="o">⟨⟩</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">true.rec</span> <span class="o">(</span><span class="n">one_hundred</span><span class="o">)</span> <span class="o">⟨</span><span class="mi">100</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="n">foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="c1">-- 100</span>
<span class="kd">def</span> <span class="n">foo'</span> <span class="o">:</span> <span class="n">true'</span> <span class="o">:=</span> <span class="o">⟨⟩</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">true'.rec</span> <span class="o">(</span><span class="n">one_hundred</span><span class="o">)</span> <span class="o">⟨</span><span class="mi">100</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="n">foo'</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="c1">-- 100</span>
</code></pre></div>



<a name="244954637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244954637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244954637">(Jul 05 2021 at 16:30)</a>:</h4>
<p>The recursor for <code>true</code> is very useless:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="n">eliminator</span> <span class="n">true.rec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">l</span><span class="o">},</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">C</span>
</code></pre></div>



<a name="244954893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244954893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244954893">(Jul 05 2021 at 16:33)</a>:</h4>
<p>so the moral of the story is... lean codegen is a clownfest? <span aria-label="clown" class="emoji emoji-1f921" role="img" title="clown">:clown:</span> this is honestly... intriguing. like... lean can do something entirely different if it doesn't understand how to interpret our code computationally...</p>



<a name="244954913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244954913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244954913">(Jul 05 2021 at 16:33)</a>:</h4>
<p>what's the motivation for this quirk though? performance?</p>



<a name="244955285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244955285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244955285">(Jul 05 2021 at 16:36)</a>:</h4>
<p>to be quite frank I've never intentionally introduced a bug before... it's kind of weird that the lean devs intentionally introduce a bug into their software for some reason, and I want to understand the reasoning</p>



<a name="244955462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244955462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244955462">(Jul 05 2021 at 16:39)</a>:</h4>
<blockquote>
<p>intentionally introduce a bug</p>
</blockquote>
<p>Please don't accuse anyone of being malicious.</p>



<a name="244955480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244955480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244955480">(Jul 05 2021 at 16:39)</a>:</h4>
<p>hmm I don't? it's just that I find this quirk intriguing <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="244955545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244955545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244955545">(Jul 05 2021 at 16:40)</a>:</h4>
<p>The story with all of these things is simply limited developer time.  This is not an intentional limitation, just that nobody had the time and motivation to implement it.</p>



<a name="244955608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244955608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244955608">(Jul 05 2021 at 16:41)</a>:</h4>
<p>People's efforts go into what the community wants. Lean has made it into Nature with some high-powered maths but in all that code there is no <code>#eval</code> at all, it's not what (those kinds of) mathematicians do. Because there is no big demand for getting the Lean 3 VM better, it stays as it is.</p>



<a name="244956270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244956270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244956270">(Jul 05 2021 at 16:49)</a>:</h4>
<p>Alright. Thank you for taking the time to answer this extremely crazy question! I have to go to bed now, see you! And I learned an extremely crazy quirk of the Lean theorem prover too <span aria-label="heart" class="emoji emoji-2764" role="img" title="heart">:heart:</span></p>



<a name="244959553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244959553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Huỳnh Trần Khanh <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244959553">(Jul 05 2021 at 17:30)</a>:</h4>
<p>One final question (because I can't sleep LOL): this quirk doesn't exist in Lean 4 right?</p>



<a name="244961558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244961558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gihan Marasingha <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244961558">(Jul 05 2021 at 18:00)</a>:</h4>
<p>Well-founded recursion isn't structural recursion (except in the sense that it involves structural recursion on <code>well_founded</code>). To my (admittedly freshly-formed) understanding, it's about constructing a function via <code>well_founded.fix</code>, together with the proof, via<code>well_founded.fix_eq</code>, that the function so constructed has the desired properties.</p>



<a name="244965919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244965919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244965919">(Jul 05 2021 at 19:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="270523">Huỳnh Trần Khanh</span> <a href="#narrow/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E/near/244959553">said</a>:</p>
<blockquote>
<p>One final question (because I can't sleep LOL): this quirk doesn't exist in Lean 4 right?</p>
</blockquote>
<p>Lean 4 behavior is very slightly worse than lean 3 here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">OneHundred</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">100</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">OneHundred</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">100</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">inductive</span> <span class="n">True'</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">True'</span>

<span class="kd">def</span> <span class="n">True.foo</span> <span class="o">:</span> <span class="n">True</span> <span class="o">:=</span> <span class="o">⟨⟩</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">True.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">OneHundred</span><span class="o">)</span> <span class="n">mk</span> <span class="n">True.foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
<span class="c1">-- code generator does not support recursor 'True.rec' yet, consider using 'match ... with' and/or structural recursion</span>
<span class="kd">def</span> <span class="n">True'.foo</span> <span class="o">:</span> <span class="n">True'</span> <span class="o">:=</span> <span class="o">⟨⟩</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">True'.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">OneHundred</span><span class="o">)</span> <span class="n">mk</span> <span class="n">True'.foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
<span class="c1">-- code generator does not support recursor 'True'.rec' yet, consider using 'match ... with' and/or structural recursion</span>

<span class="kd">inductive</span> <span class="n">And'</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">And'</span> <span class="n">a</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">And.foo</span> <span class="o">:</span> <span class="n">And</span> <span class="n">True</span> <span class="n">True</span> <span class="o">:=</span> <span class="o">⟨⟨⟩,</span> <span class="o">⟨⟩⟩</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">And.rec</span> <span class="n">True</span> <span class="n">True</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">OneHundred</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">mk</span><span class="o">)</span> <span class="n">And.foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="c1">-- 100</span>
<span class="kd">def</span> <span class="n">And'.foo</span> <span class="o">:</span> <span class="n">And'</span> <span class="n">True</span> <span class="n">True</span> <span class="o">:=</span> <span class="o">⟨⟨⟩,</span> <span class="o">⟨⟩⟩</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">And'.rec</span> <span class="n">True</span> <span class="n">True</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">OneHundred</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">mk</span><span class="o">)</span> <span class="n">And'.foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
<span class="c1">-- code generator does not support recursor 'And'.rec' yet, consider using 'match ... with' and/or structural recursion</span>

<span class="kd">inductive</span> <span class="n">Eq'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">Eq'</span> <span class="n">a</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">Eq.foo</span> <span class="o">:</span> <span class="n">Eq</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">Eq.rec</span> <span class="n">Nat</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">OneHundred</span><span class="o">)</span> <span class="n">mk</span> <span class="mi">0</span> <span class="n">Eq.foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="c1">-- 100</span>
<span class="kd">def</span> <span class="n">Eq'.foo</span> <span class="o">:</span> <span class="n">Eq'</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">:=</span> <span class="o">⟨⟩</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">Eq'.rec</span> <span class="n">Nat</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">OneHundred</span><span class="o">)</span> <span class="n">mk</span> <span class="mi">0</span> <span class="n">Eq'.foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
<span class="c1">-- code generator does not support recursor 'Eq'.rec' yet, consider using 'match ... with' and/or structural recursion</span>

<span class="kd">inductive</span> <span class="n">Acc'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Acc'</span> <span class="n">r</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">Acc'</span> <span class="n">r</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">Acc.foo</span> <span class="o">:</span> <span class="n">Acc</span> <span class="n">Eq</span> <span class="n">mk</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">Acc.rec</span> <span class="n">OneHundred</span> <span class="n">Eq</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">OneHundred</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span> <span class="n">IH</span> <span class="bp">=&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="n">mk</span> <span class="n">Acc.foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
<span class="c1">-- code generator does not support recursor 'Acc.rec' yet, consider using 'match ... with' and/or structural recursion</span>
<span class="kd">def</span> <span class="n">Acc'.foo</span> <span class="o">:</span> <span class="n">Acc'</span> <span class="n">Eq</span> <span class="n">mk</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">Acc'.rec</span> <span class="n">OneHundred</span> <span class="n">Eq</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">OneHundred</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span> <span class="n">IH</span> <span class="bp">=&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="n">mk</span> <span class="n">Acc'.foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
<span class="c1">-- code generator does not support recursor 'Acc'.rec' yet, consider using 'match ... with' and/or structural recursion</span>
</code></pre></div>
<p>This makes sense considering that even regular well founded recursion is not implemented yet. On the bright side, the error is uniformly reported instead of having a loophole that allows seeing behind the under construction sign</p>



<a name="244966116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244966116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244966116">(Jul 05 2021 at 19:07)</a>:</h4>
<p>Oops, spoke too soon:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">False'</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">def</span> <span class="n">False.foo</span> <span class="o">:</span> <span class="n">False</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">False.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">OneHundred</span><span class="o">)</span> <span class="n">False.foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
<span class="c1">-- server crash</span>
<span class="kd">def</span> <span class="n">False'.foo</span> <span class="o">:</span> <span class="n">False'</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="k">#eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">False'.rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">OneHundred</span><span class="o">)</span> <span class="n">False'.foo</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span>
<span class="c1">-- code generator does not support recursor 'False'.rec' yet, consider using 'match ... with' and/or structural recursion</span>
</code></pre></div>



<a name="244966180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how%20to%20do%20well%20founded%20recursion%20without.../near/244966180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E.html#244966180">(Jul 05 2021 at 19:08)</a>:</h4>
<p>although to be fair I think it's fine to say that evaluating <code>False.rec</code> is undefined behavior</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/GLn.20functor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html">GLn functor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="293426938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293426938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ZHAO Jinxiang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293426938">(Aug 14 2022 at 17:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.general_linear_group</span>
<span class="kn">import</span> <span class="n">category_theory.functor.category</span>
<span class="kn">import</span> <span class="n">algebra.category.Ring.basic</span>

<span class="kn">namespace</span> <span class="n">playground</span>
<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">GLn_functor</span> <span class="o">:</span> <span class="n">CommRing</span> <span class="bp">⥤</span> <span class="n">Group</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">R.α</span><span class="o">),</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">CommRing</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">A.α</span> <span class="bp">→+*</span> <span class="n">B.α</span><span class="o">),</span> <span class="o">(</span>
  <span class="kd">begin</span>
    <span class="c1">-- TODO: help me here</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span> <span class="o">:</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">A.α</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">B.α</span><span class="o">)),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">unit_functor</span> <span class="o">:</span> <span class="n">CommRing</span> <span class="bp">⥤</span> <span class="n">Group</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">R</span><span class="bp">ˣ</span><span class="o">),</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">CommRing</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">A.α</span> <span class="bp">→+*</span> <span class="n">B.α</span><span class="o">),</span> <span class="o">(</span>
  <span class="kd">begin</span>
    <span class="c1">-- TODO: help me here</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span> <span class="o">:</span> <span class="n">Group.of</span> <span class="o">(</span><span class="bp">↥</span><span class="n">A</span><span class="o">)</span><span class="bp">ˣ</span> <span class="bp">⟶</span> <span class="n">Group.of</span> <span class="o">(</span><span class="bp">↥</span><span class="n">B</span><span class="o">)</span><span class="bp">ˣ</span><span class="o">),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>

<span class="kd">end</span> <span class="n">playground</span>
</code></pre></div>
<p>I don't know how to fix the sorry here. Can you help me? <span aria-label="flushed" class="emoji emoji-1f633" role="img" title="flushed">:flushed:</span></p>



<a name="293429837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293429837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293429837">(Aug 14 2022 at 18:24)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/Group.of_hom">docs#Group.of_hom</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/units.map">docs#units.map</a></p>



<a name="293430017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293430017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293430017">(Aug 14 2022 at 18:27)</a>:</h4>
<p>You have to write the analogue of <a href="https://leanprover-community.github.io/mathlib_docs/find/units.map">docs#units.map</a> for GL n by yourself, it seems.</p>



<a name="293430448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293430448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293430448">(Aug 14 2022 at 18:33)</a>:</h4>
<p>You may use <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.map">docs#matrix.map</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/ring_hom.map_det">docs#ring_hom.map_det</a></p>



<a name="293430533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293430533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293430533">(Aug 14 2022 at 18:34)</a>:</h4>
<p><del>It's a pity that <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.general_linear_group">docs#matrix.general_linear_group</a> doesn't work for noncommutative rings like the quaternions currently.</del> (The determinant definition can't be generalized to noncommutative rings, so maybe we should just work with the unit group in the matrix ring if we want that.)</p>



<a name="293437693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293437693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293437693">(Aug 14 2022 at 20:02)</a>:</h4>
<p>Isn't <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.general_linear_group">docs#matrix.general_linear_group</a> just an alias for <code>units</code>?</p>



<a name="293442079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293442079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293442079">(Aug 14 2022 at 21:03)</a>:</h4>
<p>Probably in some sense, but in the same sense that the complexes is just an alias for R x R</p>



<a name="293444977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293444977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293444977">(Aug 14 2022 at 21:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/GLn.20functor/near/293437693">said</a>:</p>
<blockquote>
<p>Isn't <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.general_linear_group">docs#matrix.general_linear_group</a> just an alias for <code>units</code>?</p>
</blockquote>
<p>Indeed! I was misguided by the docstring saying it's the matrices with determinant a unit. So the current definition can be generalized to noncommutative rings without problem.</p>



<a name="293447273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293447273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293447273">(Aug 14 2022 at 22:43)</a>:</h4>
<p>That docstring is also misleading in that I think most people would interpret "matrix with unit determinant" as "matrix with determinant 1".</p>



<a name="293463194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293463194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293463194">(Aug 15 2022 at 04:38)</a>:</h4>
<p>Also "defined as a subtype of matrices" in that docstring is a lie</p>



<a name="293469067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293469067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ZHAO Jinxiang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293469067">(Aug 15 2022 at 06:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.general_linear_group</span>
<span class="kn">import</span> <span class="n">category_theory.functor.category</span>
<span class="kn">import</span> <span class="n">algebra.category.Ring.basic</span>
<span class="kn">import</span> <span class="n">linear_algebra.special_linear_group</span>

<span class="kn">namespace</span> <span class="n">playground</span>
<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">GLn_functor</span> <span class="o">:</span> <span class="n">CommRing</span> <span class="bp">⥤</span> <span class="n">Group</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">R.α</span><span class="o">),</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">CommRing</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">A.α</span> <span class="bp">→+*</span> <span class="n">B.α</span><span class="o">),</span> <span class="o">(</span>
  <span class="kd">begin</span>
    <span class="n">apply</span> <span class="n">Group.of_hom</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">f1</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">ring_hom.map_det</span> <span class="n">n</span> <span class="n">_</span> <span class="n">_</span> <span class="n">A.α</span> <span class="n">_</span> <span class="n">B.α</span> <span class="n">_</span> <span class="n">f</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">monoid_hom.mk'</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">A.α</span><span class="o">)</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">B.α</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="kd">begin</span>
      <span class="n">refine</span> <span class="n">matrix.general_linear_group.mk'</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">matrix.map</span> <span class="n">X</span> <span class="n">f</span><span class="o">,</span>
    <span class="c1">-- TODO: help me here</span>
      <span class="gr">sorry</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">),</span>
    <span class="n">apply</span> <span class="n">this</span><span class="o">,</span>
    <span class="c1">-- TODO: help me here</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">:</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">A.α</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">B.α</span><span class="o">)),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">unit_functor</span> <span class="o">:</span> <span class="n">CommRing</span> <span class="bp">⥤</span> <span class="n">Group</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">R</span><span class="bp">ˣ</span><span class="o">),</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">CommRing</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">A.α</span> <span class="bp">→+*</span> <span class="n">B.α</span><span class="o">),</span> <span class="n">units.map</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="n">units.map_id</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">A.α</span> <span class="bp">→+*</span> <span class="n">B.α</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">B.α</span> <span class="bp">→+*</span> <span class="n">C.α</span><span class="o">),</span> <span class="kd">by</span> <span class="n">fconstructor</span><span class="o">,</span>
<span class="o">}</span>

<span class="kd">end</span> <span class="n">playground</span>
</code></pre></div>
<p>Thank you <span class="user-mention" data-user-id="224323">@Junyan Xu</span> . But I still don't know how to fix this.</p>



<a name="293470188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293470188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293470188">(Aug 15 2022 at 06:20)</a>:</h4>
<p>Can you not reuse what you did in <code>unit_functor</code>?</p>



<a name="293470658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293470658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293470658">(Aug 15 2022 at 06:26)</a>:</h4>
<p><span class="user-mention" data-user-id="329691">@ZHAO Jinxiang</span> This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">GLn_functor</span> <span class="o">:</span> <span class="n">CommRing</span> <span class="bp">⥤</span> <span class="n">Group</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">R.α</span><span class="o">),</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">CommRing</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">A.α</span> <span class="bp">→+*</span> <span class="n">B.α</span><span class="o">),</span> <span class="o">(</span>
  <span class="kd">begin</span>
    <span class="n">apply</span> <span class="n">Group.of_hom</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">units.map</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">f.map_matrix.to_monoid_hom</span><span class="o">,</span> <span class="c">/-</span><span class="cm"> ring_hom.map_matrix -/</span>
  <span class="kd">end</span> <span class="o">:</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">A.α</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">B.α</span><span class="o">)),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>
<p>Since we discovered that <code>general_linear_group</code> is actually defined to be the units, we apply <code>units.map</code> again.</p>



<a name="293470897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293470897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293470897">(Aug 15 2022 at 06:29)</a>:</h4>
<p>In term mode you can just do <code>  map := λ _ _ f, Group.of_hom (units.map f.map_matrix.to_monoid_hom),</code> or even omit the <code>Group.of_hom</code> (not necessarily good practice).</p>



<a name="293471135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293471135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293471135">(Aug 15 2022 at 06:32)</a>:</h4>
<p>Can you not get <code>GLn_functor</code> as the composition of some functor and <code>unit_functor</code>?</p>



<a name="293471579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293471579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293471579">(Aug 15 2022 at 06:39)</a>:</h4>
<p>Btw, <code>unit_functor</code> already exists as <a href="https://leanprover-community.github.io/mathlib_docs/find/Mon.units">docs#Mon.units</a> composed with the appropriate sequence of forgetful functors.</p>



<a name="293481167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293481167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Birkbeck <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293481167">(Aug 15 2022 at 08:15)</a>:</h4>
<p>Yeah the doc strings are my fault I forgot to change them after the PR review changes</p>



<a name="293544664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293544664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> ZHAO Jinxiang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293544664">(Aug 15 2022 at 14:54)</a>:</h4>
<p>Thanks for all your  helps.<br>
But it seems that I also need help here. <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.general_linear_group</span>
<span class="kn">import</span> <span class="n">category_theory.functor.category</span>
<span class="kn">import</span> <span class="n">algebra.category.Ring.basic</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">GLn_functor</span> <span class="o">:</span> <span class="n">CommRing</span> <span class="bp">⥤</span> <span class="n">Group</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">R.α</span><span class="o">),</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">A.α</span> <span class="bp">→+*</span> <span class="n">B.α</span><span class="o">),</span>
    <span class="o">(</span><span class="n">units.map</span> <span class="n">f.map_matrix.to_monoid_hom</span> <span class="o">:</span>
      <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">A.α</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">B.α</span><span class="o">)),</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">dunfold</span> <span class="n">CommRing</span> <span class="n">category.to_category_struct</span> <span class="n">SemiRing.assoc_ring_hom</span> <span class="n">bundled_hom.map_hom</span> <span class="n">bundled_hom.bundled_hom_of_parent_projection</span> <span class="n">comm_ring.to_ring</span> <span class="n">bundled_hom.map</span><span class="o">,</span>
    <span class="n">dunfold</span> <span class="n">SemiRing.bundled_hom</span><span class="o">,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">convert_to</span> <span class="n">units.map</span> <span class="bp">↑</span><span class="o">((</span><span class="n">ring_hom.id</span> <span class="n">A.α</span><span class="o">)</span><span class="bp">.</span><span class="n">map_matrix</span><span class="o">)</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">dunfold</span> <span class="n">ring_hom.id</span> <span class="n">id</span> <span class="n">coe</span> <span class="n">lift_t</span> <span class="n">has_lift_t.lift</span> <span class="n">coe_t</span> <span class="n">has_coe_t.coe</span> <span class="n">ring_hom.map_matrix</span> <span class="n">units.map</span> <span class="n">monoid_hom.mk'</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">dunfold</span> <span class="n">group.to_monoid</span> <span class="n">div_inv_monoid.to_monoid</span> <span class="n">bundled_hom.id</span><span class="o">,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">dunfold</span> <span class="n">monoid_hom.id</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">A.α</span> <span class="bp">→+*</span> <span class="n">B.α</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">B.α</span> <span class="bp">→+*</span> <span class="n">C.α</span><span class="o">),</span> <span class="kd">begin</span>
    <span class="c1">-- TODO: help me here</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">units_functor</span> <span class="o">:</span> <span class="n">CommRing</span> <span class="bp">⥤</span> <span class="n">Group</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">R</span><span class="bp">ˣ</span><span class="o">),</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">CommRing</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">A.α</span> <span class="bp">→+*</span> <span class="n">B.α</span><span class="o">),</span> <span class="n">units.map</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">map_id'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="n">units.map_id</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">A.α</span> <span class="bp">→+*</span> <span class="n">B.α</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">B.α</span> <span class="bp">→+*</span> <span class="n">C.α</span><span class="o">),</span> <span class="kd">by</span> <span class="n">fconstructor</span><span class="o">,</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">det_nat_trans</span> <span class="o">:</span> <span class="o">(</span><span class="n">GLn_functor</span> <span class="n">n</span><span class="o">)</span> <span class="bp">⟶</span> <span class="n">units_functor</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">matrix.general_linear_group.det</span><span class="o">,</span>
  <span class="n">naturality'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span> <span class="n">R'</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">R.α</span> <span class="bp">→+*</span> <span class="n">R'.α</span><span class="o">),</span> <span class="kd">begin</span>
    <span class="n">dunfold</span> <span class="n">GLn_functor</span> <span class="n">units_functor</span><span class="o">,</span>
    <span class="n">dsimp</span><span class="o">,</span>
    <span class="n">dunfold</span> <span class="n">coe</span> <span class="n">lift_t</span> <span class="n">has_lift_t.lift</span> <span class="n">coe_t</span> <span class="n">has_coe_t.coe</span> <span class="n">coe_fn</span> <span class="n">fun_like.has_coe_to_fun</span> <span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="c1">-- TODO: help me here</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span>
<span class="o">}</span>
</code></pre></div>



<a name="293547246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293547246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293547246">(Aug 15 2022 at 15:06)</a>:</h4>
<p>I imagine <a href="https://leanprover-community.github.io/mathlib_docs/find/units.map_comp">docs#units.map_comp</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/ring_hom.map_matrix_comp">docs#ring_hom.map_matrix_comp</a> will do most of the work</p>



<a name="293550196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293550196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293550196">(Aug 15 2022 at 15:12)</a>:</h4>
<p>The first <code>sorry</code> is <code>refl</code></p>



<a name="293586469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293586469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293586469">(Aug 15 2022 at 17:13)</a>:</h4>
<p>In fact, the two first definitions can be compressed to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">GLn_functor</span> <span class="o">:</span> <span class="n">CommRing</span> <span class="bp">⥤</span> <span class="n">Group</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span>       <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">Group.of</span> <span class="o">(</span><span class="n">GL</span> <span class="n">n</span> <span class="n">R.α</span><span class="o">),</span>
  <span class="n">map</span>       <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">f</span><span class="o">,</span> <span class="n">units.map</span> <span class="n">f.map_matrix.to_monoid_hom</span><span class="o">,</span>
  <span class="n">map_id'</span>   <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">units_functor</span> <span class="o">:</span> <span class="n">CommRing</span> <span class="bp">⥤</span> <span class="n">Group</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span>       <span class="o">:=</span> <span class="bp">λ</span> <span class="n">R</span><span class="o">,</span> <span class="n">Group.of</span> <span class="n">R</span><span class="bp">ˣ</span><span class="o">,</span>
  <span class="n">map</span>       <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">f</span> <span class="o">,</span> <span class="n">units.map</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">map_id'</span>   <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="n">units.map_id</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">map_comp'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>
</code></pre></div>



<a name="293586750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293586750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293586750">(Aug 15 2022 at 17:15)</a>:</h4>
<p>I find that most of the proofs in the category theory side of mathlib are obtained by some combination of <code>ext, simp, dsimp, refl</code>.  However, since they usually take a long time to play out, trying out all combinations is usually not a viable option.  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="293591137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293591137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293591137">(Aug 15 2022 at 17:44)</a>:</h4>
<p>I guess <code>tidy</code> can do them. So you can even leave out the last two fields in both defs.</p>



<a name="293592145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293592145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293592145">(Aug 15 2022 at 17:49)</a>:</h4>
<p>Ah, this is another proof strategy: not even proving lemmas!</p>



<a name="293592516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293592516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293592516">(Aug 15 2022 at 17:52)</a>:</h4>
<p>What's the correct abstract category theory nonsense that makes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>↦</mo><mi>E</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \mapsto End(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> into a functor?</p>



<a name="293592578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293592578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293592578">(Aug 15 2022 at 17:52)</a>:</h4>
<p>(taking values in <code>Mon</code>, say)</p>



<a name="293604904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293604904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293604904">(Aug 15 2022 at 19:12)</a>:</h4>
<p>Are you sure this is a functor?</p>



<a name="293606115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293606115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293606115">(Aug 15 2022 at 19:20)</a>:</h4>
<p>It's not.</p>



<a name="293606312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293606312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293606312">(Aug 15 2022 at 19:21)</a>:</h4>
<p>But the functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>↦</mo><mi>E</mi><mi>n</mi><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msup><mi>k</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k \mapsto End_k(k^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7054em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is, and the functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>↦</mo><mi>G</mi><msub><mi>L</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k \mapsto GL_n(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7054em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> is the composition of that with the units functor. I'm just wondering if there is a categorical abstraction of this.</p>



<a name="293606685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293606685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293606685">(Aug 15 2022 at 19:23)</a>:</h4>
<p>The End in that example is a representable functor taking values in rings so maybe it has something to do with Hopf algebras rather than a general category thing</p>



<a name="293606806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293606806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293606806">(Aug 15 2022 at 19:24)</a>:</h4>
<p>oh yeah that's a good point</p>



<a name="293607155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293607155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293607155">(Aug 15 2022 at 19:26)</a>:</h4>
<p>I guess the general thing is to take a monoid object in some monoidal category and to look at its units.</p>



<a name="293607170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293607170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293607170">(Aug 15 2022 at 19:26)</a>:</h4>
<p>then take the functor these things represent</p>



<a name="293617119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293617119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293617119">(Aug 15 2022 at 20:38)</a>:</h4>
<p>My viewpoint is that M : R ↦ R^n defines a "dependent functor" from Ring to Module over the ring, and you can view it as a sheaf of modules. Usually <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Hom</mtext><mi>R</mi></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Hom}_R(M(R), N(R))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord text"><span class="mord">Hom</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">))</span></span></span></span> don't form a (pre)sheaf (so it's not the way to define sheaf Hom), but here M is "quasi-coherent" so we're OK; to define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup><mo>→</mo><msup><mi>S</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">S^n\to S^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>R</mi><mi>n</mi></msup><mo>→</mo><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">f : R^n\to R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> and a ring hom <code>ϕ : R →+* S</code> you compose the isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup><mo>≅</mo><msup><mi>R</mi><mi>n</mi></msup><msub><mo>⊗</mo><mi>S</mi></msub><mi>S</mi></mrow><annotation encoding="application/x-tex">S^n\cong R^n\otimes_S S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup><msub><mo>⊗</mo><mi>S</mi></msub><mi>S</mi><mo>→</mo><msup><mi>S</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R^n\otimes_S S\to S^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> induced by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> composed with the dependent "<a href="http://functor.map">functor.map</a> ϕ": <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup><mo>→</mo><msup><mi>S</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R^n\to S^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> (as R-modules). Of course when M=N the sheaf Hom from M to itself is a sheaf of rings by composition.</p>
<p>By the way I think we should define presheaves of modules (on ringed spaces) in terms of dependent functors, and build the API to connect with other useful definitions afterwards. Even though <code>Cat</code> is a 1-category and the (restriction of scalars) functor taking a Ring to its category of modules is a strict functor, we may want to define functors dependent on an arbitrary (op)lax functor into <code>Cat</code>, now that we have the framework (and notice that extension of scalars isn't a strict functor). However, it seems that a theory of dependent functors isn't present in the literature.</p>



<a name="293617529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293617529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293617529">(Aug 15 2022 at 20:40)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> what do you mean by dependent functors? I would love to see a definition of presheaves of modules in mathlib! It's been missing for far too long. I would really like to see the sheaf of Kaehler differentials, which would be a great test case.</p>



<a name="293617761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293617761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293617761">(Aug 15 2022 at 20:42)</a>:</h4>
<p>Dependent functor are the functorial analogue of a dependent function ;)</p>



<a name="293617834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293617834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293617834">(Aug 15 2022 at 20:42)</a>:</h4>
<p>So <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>↦</mo><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R \mapsto R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> is a dependent functor because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup><mo>:</mo><mi>M</mi><mi>o</mi><msub><mi>d</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">R^n : Mod_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>o</mi><msub><mi>d</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">Mod_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a category which depends on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></p>



<a name="293617867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293617867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293617867">(Aug 15 2022 at 20:43)</a>:</h4>
<p>And when you have a morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \to S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> you relate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">S^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> by base-change</p>



<a name="293618000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293618000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293618000">(Aug 15 2022 at 20:44)</a>:</h4>
<p>This is all possible to make precise with pseudofunctors and/or Grothendieck constructions</p>



<a name="293618058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293618058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293618058">(Aug 15 2022 at 20:44)</a>:</h4>
<p>It's basically the definition of a sheaf of modules and I <a href="https://github.com/leanprover-community/mathlib/commit/a96576ee24ca8b87e7b3103c901e23f9f7328b77#diff-be29c27083b2c5945ac483756ce16a0b587b96b09f3dc2704c95801ad10c16e5R31-R39">made the definition here</a>; it's a functor dependent on a <code>oplax_functor (locally_discrete C) Cat</code>, which in the case of sheaf of modules you take it to be the sheaf of rings (which is a functor from opens to Ring) composed with the functor from Ring to Cat.<br>
<code>variables {C : Type u} [category.{v} C] (F : oplax_functor (locally_discrete C) Cat.{v' u'})</code></p>



<a name="293618257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293618257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293618257">(Aug 15 2022 at 20:46)</a>:</h4>
<p>I'd encourage you to PR it! I think it's time we started experimenting with this.</p>



<a name="293618369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293618369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293618369">(Aug 15 2022 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/GLn.20functor/near/293618257">said</a>:</p>
<blockquote>
<p>I'd encourage you to PR it! I think it's time we started experimenting with this.</p>
</blockquote>
<p>I'll second this!</p>



<a name="293618392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293618392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293618392">(Aug 15 2022 at 20:47)</a>:</h4>
<p>I haven't developed much (if any) APIs for it; as you can see it's been abandoned for months with lots of sorries. Maybe someone can take it up!</p>



<a name="293618951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293618951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293618951">(Aug 15 2022 at 20:51)</a>:</h4>
<p>I don't see sorries...</p>



<a name="293619245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293619245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293619245">(Aug 15 2022 at 20:53)</a>:</h4>
<p>I see merge conflicts, and I also see that I no longer understand how VS Code deals with them :-/</p>



<a name="293620820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293620820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293620820">(Aug 15 2022 at 21:05)</a>:</h4>
<p>Yeah, it seems I haven't even written down the sorries, but I did have a <a href="https://github.com/leanprover-community/mathlib/commit/014c90b4862b1a6271ef3aac2ec77492bf338a48">TODO list</a> that I just pushed. I've also defined dependent nat_trans and shown that dependent functors <a href="https://github.com/leanprover-community/mathlib/commit/c916a79331b1d447f8bfd8864b3dddfaa53a968d#diff-be29c27083b2c5945ac483756ce16a0b587b96b09f3dc2704c95801ad10c16e5R63">form a category</a>. The latest commit in that branch changed functors to prefunctors, because I wanted to understand which conditions are essential. The branch does a lot of other stuff and the dependent functor portion is very much under construction; I don't think a single defintion could make a PR ...</p>



<a name="293626703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/293626703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#293626703">(Aug 15 2022 at 21:52)</a>:</h4>
<p>I have made PRs with just definitions eg projective modules and elliptic curves</p>



<a name="294983118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/GLn%20functor/near/294983118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/GLn.20functor.html#294983118">(Aug 24 2022 at 05:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/GLn.20functor/near/293617761">said</a>:</p>
<blockquote>
<p>Dependent functor are the functorial analogue of a dependent function ;)</p>
</blockquote>
<p>This analogy actually makes a lot of sense. If categories are types and functors are functions, then functor categories are function types, functors to Cat are type families, and Grothendieck constructions are sigma types; what's missing are pi types (i.e. dependent function types), and introducing a category of dependent functors would fill in this gap.</p>
<p>The paper <a href="https://arxiv.org/abs/2109.04239">https://arxiv.org/abs/2109.04239</a> feels very relevant, but I find the notation hard to decipher. I'm unaware of any other reference.</p>
<p>In the context of sheaves of modules we have the following:</p>
<ol>
<li>
<p>We have the functor <code>Module : Ring ⥤ Cat</code> with <code>functor.map</code> given by restriction of scalars, and we consider it as a type family <code>F : β → Type*</code>.</p>
</li>
<li>
<p>We can form the Grothendieck category of the functor <code>Module</code>, i.e. the category <code>BundledModule</code>, which corresponds to the sigma type <code>Σ b, F b</code>.</p>
</li>
<li>
<p>Whenever we have a presheaf of rings, i.e. a functor <code>f : opens X ⥤ Ring</code> (omitting the <code>op</code>), composing with <code>Module</code> gives a functor <code>opens X ⥤ Cat</code>, corresponding to the function <code>F ∘ f : α → Type*</code>. </p>
</li>
<li>
<p>Composition is functorial, resulting in a functor <code>(opens X ⥤ Ring) ⥤ (opens X ⥤ Cat)</code> from presheaves of rings to presheaves of Cats, corresponding to the fact that <code>λ f, F ∘ f : (α → β) → (α → Type*)</code> is a function.</p>
</li>
<li>
<p>Now for every <code>opens X ⥤ Cat</code> we introduce a dependent functor category; this association is functorial and corresponds to the function <code>λ ι, Π a, ι a : (α → Type*) → Type*</code>.</p>
</li>
<li>
<p>Composing with the functor in 4, we arrive at a functor <code>(opens X ⥤ Ring) ⥤ Cat</code>, sending a presheaf of rings O_X to the category of presheaves of modules over O_X, and we may take its Grothendieck construction, which corresponds to the type <code>Σ f, Π a, F (f a)</code>.</p>
</li>
<li>
<p>This category should be equivalent (or isomorphic?) to the category of presheaves of bundled modules over X, i.e. <code>opens X ⥤ BundledModule</code>, corresponding to the type <code>α → Σ b, F b</code>. This looks similar to Theorem 3.6 in the paper.</p>
</li>
</ol>
<p>Interestingly, the functoriality of the Grothendieck construction is not used in the argument above.</p>
<p>In Type* the construction of the equivalence is very simple:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fun_to_sigma_equiv'</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="bp">Σ</span> <span class="n">b</span><span class="o">,</span> <span class="n">F</span> <span class="n">b</span><span class="o">)</span> <span class="bp">≃</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">F</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="o">⟨</span><span class="n">sigma.fst</span> <span class="bp">∘</span> <span class="n">g</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">sigma.snd</span> <span class="o">(</span><span class="n">g</span> <span class="n">a</span><span class="o">)⟩,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">a</span><span class="o">,</span> <span class="o">⟨</span><span class="n">g.fst</span> <span class="n">a</span><span class="o">,</span> <span class="n">g.snd</span> <span class="n">a</span><span class="o">⟩,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">sigma.eta</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">sigma.eta</span> <span class="o">}</span>
</code></pre></div>
<p>The special case <code>F := id</code> yields <code>(α → Σ b, b) ≃ (Σ f : α → Type*, Π a, f a)</code> but the construction isn't simpler.</p>
<p>However, a lot needs to be done to flesh out the category version; for example, it's not totally clear which functors mentioned above should be strict (if any) and which are allowed to be (op)lax. To deal with sheaves of modules, it suffices to restrict to strict functors, since <code>Module : Ring ⥤ Cat</code> is strict, but we may not want to exploit this strictness since it involves equality of functors. If that's the case, then the first thing to do is probably generalizing the Grothendieck construction to any oplax functor, which I have done in <a href="https://github.com/leanprover-community/mathlib/compare/lax_grothendieck_bicat#diff-779e8ece193ac9cfb8b3ab087590457d8f57c59a774bd663d70eaa8e6a160ecd">the branch</a> and should be ready to PR after some cleanup.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
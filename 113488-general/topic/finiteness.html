---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/finiteness.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html">finiteness</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="124610398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610398">(Apr 04 2018 at 06:10)</a>:</h4>
<p>Do mathlib have something that behaves like:</p>
<div class="codehilite"><pre><span></span>class  Finite (α : Type u) :=
  (cardinality : nat)
  (bijection : trunc (equiv α (fin cardinality)))
</pre></div>



<a name="124610440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610440">(Apr 04 2018 at 06:10)</a>:</h4>
<p>Is this gross for some reason, and should be avoided?</p>



<a name="124610449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610449">(Apr 04 2018 at 06:11)</a>:</h4>
<p>It is in my category theory repo (the category “set”)</p>



<a name="124610450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610450">(Apr 04 2018 at 06:11)</a>:</h4>
<p>and it’s called fintype</p>



<a name="124610479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610479">(Apr 04 2018 at 06:12)</a>:</h4>
<p>It can't be called fintype, because mathlib already has a fintype which is slightly different (but equivalent, of course).</p>



<a name="124610492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610492">(Apr 04 2018 at 06:12)</a>:</h4>
<p>I guess I'm asking if there is a strong reason to (bite the bullet and learn how to use multisets and) use mathlib's fintype, or if it's okay to use something like this.</p>



<a name="124610554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610554">(Apr 04 2018 at 06:15)</a>:</h4>
<p>oops i meant the category is called set and uses fintype</p>



<a name="124610595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610595">(Apr 04 2018 at 06:16)</a>:</h4>
<p>but I guess I didn’t notice that you used trunc</p>



<a name="124610881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610881">(Apr 04 2018 at 06:27)</a>:</h4>
<p>That's <code>fintype</code>. If you want to use such an interface to it, prove it and use it</p>



<a name="124610925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124610925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124610925">(Apr 04 2018 at 06:28)</a>:</h4>
<p>Okay, I  guess that's a good point. In the meantime I'm discovering <code>fintype</code> is pretty easy to use anyway.</p>



<a name="124611257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124611257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124611257">(Apr 04 2018 at 06:41)</a>:</h4>
<p>What is the lemma that says <code>fintype</code> gives <code>decidable_eq</code>?</p>



<a name="124611576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124611576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124611576">(Apr 04 2018 at 06:52)</a>:</h4>
<p>I don't think it's true. So your formulation is a bit stronger, since it equips the set with a function to <code>fin</code>; in mathlib's <code>fintype</code>, this function is <code>index_of</code>, but it requires a separate proof of <code>decidable_eq</code></p>



<a name="124611584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124611584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124611584">(Apr 04 2018 at 06:53)</a>:</h4>
<p>your <code>Finite</code> should be equivalent to the conjunction of <code>fintype</code> and <code>decidable_eq</code></p>



<a name="124611585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/124611585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#124611585">(Apr 04 2018 at 06:53)</a>:</h4>
<p>ah, okay.</p>



<a name="206179081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206179081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206179081">(Aug 06 2020 at 18:29)</a>:</h4>
<p>Is there any way we could get to a world in which</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">finite</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="c1">-- any definition of finiteness</span>

<span class="kn">structure</span> <span class="n">finset</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">s</span><span class="o">)</span>

<span class="n">class</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">))</span>
</code></pre></div>



<a name="206181704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206181704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206181704">(Aug 06 2020 at 18:51)</a>:</h4>
<p>cons: all <code>big_operators</code> stuff becomes noncomputable<br>
pros: API becomes comprehensible by humans, and no more instance diamonds for <code>fintype</code></p>



<a name="206182245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206182245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206182245">(Aug 06 2020 at 18:55)</a>:</h4>
<p>(I also dream of a world where <code>decidable</code>would disappear, but I know this won't happen)</p>



<a name="206182616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206182616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206182616">(Aug 06 2020 at 18:58)</a>:</h4>
<p>Up to <del>proof irrelevance</del> propositional equivalence, none of these definitions are different except you replaced <code>fintype A</code> with <code>nonempty (fintype A)</code>. Maybe we should just have a class for that, replacing <code>set.finite</code></p>



<a name="206182980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206182980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206182980">(Aug 06 2020 at 19:01)</a>:</h4>
<p>actually do we lose anything by just changing <code>fintype</code> to the nonempty version of what it currently is? <code>fintype.univ</code> becomes noncomputable but it fixes the instance diamonds</p>



<a name="206183036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206183036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206183036">(Aug 06 2020 at 19:01)</a>:</h4>
<p><code>fintype.card</code> also becomes noncomputable</p>



<a name="206183487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206183487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206183487">(Aug 06 2020 at 19:04)</a>:</h4>
<p>My bigger issue is that I find it really difficult to find what I'm looking for in <code>data.finset</code>/<code>data.fintype</code>/<code>data.set.finite</code>; it's possible this could be improved without any representation changes</p>



<a name="206183748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206183748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206183748">(Aug 06 2020 at 19:06)</a>:</h4>
<p>But a related issue is that there are three different ways to express the same ideas and they are connected by constructions that are not that simple</p>



<a name="206183881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206183881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206183881">(Aug 06 2020 at 19:07)</a>:</h4>
<p>It's my completely unsubstantiated opinion that if we proved a bunch of things for <code>finite</code>, say, we could systematically deduce the consequences for <code>finset</code> and <code>fintype</code> and end up with a more organized API</p>



<a name="206184647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206184647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206184647">(Aug 06 2020 at 19:14)</a>:</h4>
<p>Here is some pure fantasy: a universe level for only finite types</p>



<a name="206185310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206185310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206185310">(Aug 06 2020 at 19:21)</a>:</h4>
<p><code>Type (1/2:\Q)</code></p>



<a name="206211134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206211134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206211134">(Aug 06 2020 at 23:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>



<a name="206214294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206214294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206214294">(Aug 07 2020 at 00:50)</a>:</h4>
<p>We must make finiteness easier for mathematicians. Counting is all over Sylow's theorems and if people can't knock them off in Lean using what we have, then I think we don't have the right things. I recently had two distinct proofs that the trivial subgroup of a group was a fintype and it was annoying.</p>



<a name="206450031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206450031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206450031">(Aug 10 2020 at 11:17)</a>:</h4>
<p>OK I have just spent some time trying to understand the issues here. I'm trying to prove Sylow's theorems with students. Sylow's theorems are theorems about finite groups with no mention of decidable equality or ever explicitly attempting to write down elements -- they apply to all finite groups. Hence it seems to me that computability is irrelevant, so <code>fintype</code> and <code>finset</code> are not the right classes. But <code>set.finite</code> isn't either, because it is unbundled finiteness. Reid is proposing a bundled version of finiteness which he also calls <code>finset</code> but how about for now we call it <code>finset2</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">finset2</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>


<p>Is there an argument for developing an API for this? It is bundled noncomputable finiteness which seems to me to be the best for Lean and the best for Sylow. Have I understood things correctly? Are people just going to tell me to go ahead and try?</p>



<a name="206451212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206451212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206451212">(Aug 10 2020 at 11:36)</a>:</h4>
<p>As for cardinality some non-cardinal options would be finset2.card, <code>set.fincard : set X -&gt; nat</code> or <code>fincard : Type u -&gt; nat</code>. These are all functions we don't have, right? <span class="user-mention" data-user-id="110031">@Patrick Massot</span> you were complaining about fintype in another thread and it's got to the point where I just want to fix it. Sylow's theorems are about finite groups and I don't care whether they have decidable equality, I just want to be able to count subsets and not run into diamonds -- this is not an unreasonable request I don't think but perhaps the infrastructure is not yet there for this kind of thing.</p>



<a name="206614920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206614920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206614920">(Aug 11 2020 at 18:48)</a>:</h4>
<p>More thoughts about finiteness and cardinality for sets and types.</p>
<p>Let's start with sets. Now <code>set.finite</code> exists in mathlib already; its definition is</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">finite</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>


<p>. It's not a class. Why is <code>set.finite</code> not a class? <code>is_subgroup</code> was a class. Could both <code>set.finite</code> and <code>set.infinite</code> be classes? This would be unbundled finiteness for sets (<code>normal</code> is unbundled Prop-valued normality for subgroups and we tried bundling it in the group theory game but it's quite inconvenient because you either reproduce a bunch of <code>subgroup.*</code> in <code>normal.*</code> or you put <code>to_subgroup</code> everywhere). The definition of bundled finiteness for sets I'm working with is</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">finset2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">//</span> <span class="n">finite</span> <span class="n">S</span><span class="o">}</span>
</code></pre></div>


<p>The idea would be to develop some API for <code>set.finite</code> and encourage mathematicians who don't <code>#eval</code> to either use <code>set.finite</code> or <code>finset2</code> as their standard concept of finiteness for sets depending on whether they like bundled or unbundled -- and in particular to avoid <code>finset</code> completely because this is constructible finiteness.</p>
<p>For set cardinality the issue is that I don't know whether unbundled or bundled will be best, so I have had to introduce two nat-valued cardinalities -- firstly note that we have</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">equiv_finset</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset2</span> <span class="n">X</span> <span class="err">≃</span> <span class="o">(</span><span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>


<p>and so we can define</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finset2</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">finset2</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="o">((</span><span class="n">finset2</span><span class="bp">.</span><span class="n">equiv_finset</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span>
</code></pre></div>


<p>i.e. finset2.card is just finset.card but ported over the canonical bijection. This is cardinality for bundled finite sets. For unbundled finite sets there is the issue of trying to find the <code>finite</code> instance, and experience seems to show that this can be hard work, so I introduce</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">sum</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">s</span> <span class="k">then</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">f</span> <span class="k">else</span> <span class="mi">37</span>
</code></pre></div>


<p>and then define</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">set</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">s</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>


<p>These functions are really easy to apply because they don't check finiteness. Under finiteness conditions you can relate the card to finset2.card and this is your route back to finset.card if you want to port API.</p>
<p>Earlier on in my Lean career I was concerned about all this <code>noncomputable</code> stuff because I didn't really know how important computability was. The thing to understand about noncomputable cards is that you can still prove Sylow's theorems which are all about cards, you just can't <code>#eval</code>, and because I never <code>#eval</code> anyway I'm not bothered.</p>
<hr>
<p>Now onto types. For unbundled finiteness for types I'm using</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">is_finite</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">X</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">is_finite</span>
</code></pre></div>


<p>and again the idea is to encourage non-#eval mathematicians to use <code>is_finite</code> instead of <code>fintype</code>, because using it is strictly easier, modulo the fact that of course a whole load of the <code>fintype</code> library needs to be ported over. </p>
<p>Bundling finite types seems like the sort of thing that the category theory library might want to do, but I'm not doing it right now.</p>
<p>For cardinality again I follow the principle that the fewer inputs your function has, the easier it is to use it, so I have gone for </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">fincard</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">is_finite</span> <span class="n">X</span> <span class="k">then</span> <span class="bp">@</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">X</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">h</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>


<p>and of course there's a route back to fintype.card in the <code>is_finite</code> setting, which enables noncomputational API (e.g. all theorems) to be ported.</p>
<p>All this work is piling up in the group-theory-game repo because we have got to the point where we want to prove Sylow's theorems. I think it might be sensible to start sending some of it to mathlib. Before I start, does anyone have any comments about the proposal, naming conventions, or anything else? I feel bad adding more definitions of finiteness but I think these are the things we need for reasoning. When I was refactoring subgroups I ran into an issue in the proof of Sylow's theorem where we are proving there are subgroups of order p^n for all n&lt;=v_p(G); the n=0 case used <code>bot</code> and at some point I wanted to rewrite <code>card_bot</code> but unfortunately there are two proofs that the bot subgroup of a finite group is finite in mathlib -- one coming from the fact that it's the trivial group and one coming from the fact that a subset of a finite type is finite. This is just silly -- we don't need these subsingleton diamonds getting in the way when we are reasoning.</p>



<a name="206618412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206618412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206618412">(Aug 11 2020 at 19:15)</a>:</h4>
<p>What ever happened to definition irrelevance / API making? Instead of defining <code>finset2</code>, make an api that lets you treat a <code>finset</code> like a <code>finset2</code></p>



<a name="206618856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206618856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206618856">(Aug 11 2020 at 19:19)</a>:</h4>
<p>Agree with Mario here, nothing about finset forces you to be constructive.</p>



<a name="206619038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206619038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206619038">(Aug 11 2020 at 19:20)</a>:</h4>
<p>I think my definition of <code>finsum</code> is strictly more powerful than your <code>sum</code> too. If you are going to have no well definedness assumptions, you may as well have it give a reasonable result on the widest possible domain</p>



<a name="206619278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206619278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206619278">(Aug 11 2020 at 19:22)</a>:</h4>
<p>Oops, it appears this is a thread-spanning topic now. I'm referring to <a href="#narrow/stream/116395-maths/topic/universe.20hell.20in.20linear.20algebra/near/206415746">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/universe.20hell.20in.20linear.20algebra/near/206415746</a></p>



<a name="206619862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206619862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206619862">(Aug 11 2020 at 19:27)</a>:</h4>
<p>Yeah sorry, I had to choose whether to go with this thread or that one.</p>



<a name="206621224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206621224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206621224">(Aug 11 2020 at 19:39)</a>:</h4>
<p>finsum is fine by me -- I was just using something Jeremy knocked up for MIL. I'm not sure I understand the finset2 thing though. I was 100% sure I used finset2 to make is_finite but I just removed the import and don't use it at all. So should I ditch finset2? I'm not sure I even need it now.</p>



<a name="206621416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206621416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206621416">(Aug 11 2020 at 19:40)</a>:</h4>
<p>So is the point that we just don't define <code>finset2</code> at all, prove that <code>{S : set X // finite S} ≃ (finset X)</code> and then for every lemma about finsets I prove some analogous lemma for set.finite?</p>



<a name="206621784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206621784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206621784">(Aug 11 2020 at 19:43)</a>:</h4>
<p>In what sense is that not already done in mathlib?</p>



<a name="206621847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206621847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206621847">(Aug 11 2020 at 19:44)</a>:</h4>
<p>set.finite has lots of lemmas generated exactly that way, and they are all very easy</p>



<a name="206621865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206621865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206621865">(Aug 11 2020 at 19:44)</a>:</h4>
<p>so you can add more if something is missing without too much trouble</p>



<a name="206622282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206622282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206622282">(Aug 11 2020 at 19:48)</a>:</h4>
<p>I am confused about why we don't want <code>finset2</code>. What were the problems with <code>is_subgroup</code> which made us switch to <code>subgroup</code>? Were there actually no problems and we just decided that we wanted the cool dot notation?</p>



<a name="206622352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206622352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206622352">(Aug 11 2020 at 19:49)</a>:</h4>
<p>it was a class</p>



<a name="206630145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630145">(Aug 11 2020 at 20:55)</a>:</h4>
<p>So <code>set.finite</code> and <code>set.infinite</code> should not be classes? Here's the current definitions (mostly due to other people):</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finsupp</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span> <span class="n">set</span><span class="bp">.</span><span class="n">infinite</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">α</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="k">then</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum_in</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">finsum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span> <span class="k">then</span> <span class="n">f</span> <span class="n">i</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">localized</span> <span class="s2">&quot;notation `∑` binders `, ` r:(scoped:67 f, finsum f) := r&quot;</span> <span class="k">in</span> <span class="n">finsum</span>
<span class="n">localized</span> <span class="s2">&quot;notation `∑` binders ` in ` s `, ` r:(scoped:67 f, finsum_in s f) := r&quot;</span> <span class="k">in</span> <span class="n">finsum</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">set</span><span class="bp">.</span><span class="n">card</span> <span class="o">{</span><span class="n">ι</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:=</span> <span class="err">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="mi">1</span>

<span class="n">def</span> <span class="n">is_finite</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">X</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">is_finite</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">fincard</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">is_finite</span> <span class="n">X</span> <span class="k">then</span> <span class="bp">@</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">X</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">h</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>



<a name="206630312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630312">(Aug 11 2020 at 20:57)</a>:</h4>
<p>I think <code>set.card</code> should be defined directly rather than by summing ones, but the definition will be equivalent regardless so it's not that important</p>



<a name="206630380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630380">(Aug 11 2020 at 20:57)</a>:</h4>
<p><code>set.card s := fincard (\u s)</code> for example</p>



<a name="206630474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630474">(Aug 11 2020 at 20:58)</a>:</h4>
<p>also <code>set.finite</code> can be refactored on top of <code>is_finite</code></p>



<a name="206630585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630585">(Aug 11 2020 at 20:59)</a>:</h4>
<p>As for making <code>is_finite</code> a class, I think it will work okay, but it will be about as good as <code>fintype</code> for what it does</p>



<a name="206630713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630713">(Aug 11 2020 at 21:00)</a>:</h4>
<p>In particular, AFAICT all the gripes about <code>fintype</code> are eliminated if it is excised from definitions such as <code>fincard</code></p>



<a name="206630869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630869">(Aug 11 2020 at 21:01)</a>:</h4>
<p>wait -- are you telling me that the def of <code>fincard</code> should be rethought?</p>



<a name="206630935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206630935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206630935">(Aug 11 2020 at 21:02)</a>:</h4>
<p>no, I'm saying that it solves the bulk of the problems on its own</p>



<a name="206631019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631019">(Aug 11 2020 at 21:03)</a>:</h4>
<p>As long as the <code>fintype</code> instance doesn't occur in the statement of theorems using finiteness, it should be fine to appear as a hypothesis</p>



<a name="206631103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631103">(Aug 11 2020 at 21:03)</a>:</h4>
<p>so perhaps the <code>is_finite</code> class isn't so important</p>



<a name="206631172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631172">(Aug 11 2020 at 21:04)</a>:</h4>
<p>This is not just navel-gazing for its own sake -- I'm trying to use finiteness to prove results in group theory. The idea of decreeing that "we will only take sizes of sets" or "...of types" sounded appealing to me, but I've seen explicit examples today where you really have to move between sets and types.</p>



<a name="206631258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631258">(Aug 11 2020 at 21:04)</a>:</h4>
<p>I'm still not convinced that you can't just use <code>fintype (\u s)</code> for talking about sets in a world of classes on types</p>



<a name="206631338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631338">(Aug 11 2020 at 21:05)</a>:</h4>
<p>The main use of <code>is_finite</code> is not as a class but as a hypothesis, a proposition to be used however you use propositions</p>



<a name="206631364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631364">(Aug 11 2020 at 21:05)</a>:</h4>
<p>How are you proposing saying things like "if p is a partition of the finite type X then the sum of the sizes of the blocks of p equals the size of X"?</p>



<a name="206631452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631452">(Aug 11 2020 at 21:06)</a>:</h4>
<p><code>theorem foo [fintype X] : ... fincard X</code></p>



<a name="206631499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631499">(Aug 11 2020 at 21:07)</a>:</h4>
<p>But you need to count all the subsets too</p>



<a name="206631530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631530">(Aug 11 2020 at 21:07)</a>:</h4>
<p>you have a set of subsets -- you don't really want to convert all of these to types, do you?</p>



<a name="206631532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631532">(Aug 11 2020 at 21:07)</a>:</h4>
<p><code>finsum (\lam p, fincard p) = fincard X</code></p>



<a name="206631550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631550">(Aug 11 2020 at 21:07)</a>:</h4>
<p>it's fine, let coercion do its magic</p>



<a name="206631698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631698">(Aug 11 2020 at 21:09)</a>:</h4>
<p>In practice I was using <code>is_finite</code> in the fincard proofs because most of them are case splits on whether something is finite or not. So it was very convenient to have <code>is_finite</code> as a class because i could just dump it into the inference system and then not worry about it. But I guess that given that I had it, I could just feed it into the theorems I need rather than doing the <code>resetI</code> dance</p>



<a name="206631843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206631843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206631843">(Aug 11 2020 at 21:11)</a>:</h4>
<p>Amusing thing: when doing some set lemmas I realised I was constantly splitting on whether something was finite or infinite, and they were both classes, so I proved that every set was finite or infinite and then was doing <code>cases; resetI</code>. I then joked that I should just be doing <code>casesI</code> so I wrote it for a joke and then it turned out that it existed :P</p>



<a name="206632005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632005">(Aug 11 2020 at 21:12)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">partition</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">//</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∃!</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">p</span><span class="o">}</span>

<span class="kn">theorem</span> <span class="n">partition_sum</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">partition</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finsum_in</span> <span class="n">P</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">fincard</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fincard</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>easy peasy</p>



<a name="206632046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632046">(Aug 11 2020 at 21:12)</a>:</h4>
<p>(I won't prove it right now because <code>fincard</code> et al don't have an API yet)</p>



<a name="206632059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632059">(Aug 11 2020 at 21:12)</a>:</h4>
<p>that's a bad theorem, it uses the forbidden fintype</p>



<a name="206632084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632084">(Aug 11 2020 at 21:13)</a>:</h4>
<p>No, the fintype does not appear in the statement of the theorem, so you can just get it from wherever you like</p>



<a name="206632124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632124">(Aug 11 2020 at 21:13)</a>:</h4>
<p>you won't have unification problems as a result</p>



<a name="206632150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632150">(Aug 11 2020 at 21:13)</a>:</h4>
<p>Oh I see. But you should prove this for <code>is_finite</code> because it's more general</p>



<a name="206632225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632225">(Aug 11 2020 at 21:14)</a>:</h4>
<p>it's (constructively, even) equivalent</p>



<a name="206632330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632330">(Aug 11 2020 at 21:15)</a>:</h4>
<p>then you should prove it for <code>is_finite</code> because fintype is deprecated?</p>



<a name="206632338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632338">(Aug 11 2020 at 21:15)</a>:</h4>
<p>the idea with this proposal is that you use <code>fintype</code> for your typeclass needs and reserve <code>is_finite</code> as a regular hypothesis that you can pop open when you want to teach the typeclass system</p>



<a name="206632435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632435">(Aug 11 2020 at 21:16)</a>:</h4>
<p>I thought I never wanted to use <code>fintype</code> ever again?</p>



<a name="206632463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632463">(Aug 11 2020 at 21:16)</a>:</h4>
<p>It already has all the "structural" instances you want</p>



<a name="206632512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632512">(Aug 11 2020 at 21:17)</a>:</h4>
<p>the bad thing about fintype is that because it is a Type, you can get into unification issues like patrick mentioned at the start of the other thread</p>



<a name="206632545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206632545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206632545">(Aug 11 2020 at 21:17)</a>:</h4>
<p>but as long as you use <code>fincard</code> instead of <code>fintype.card</code> that problem goes away</p>



<a name="206735086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206735086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206735086">(Aug 12 2020 at 18:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/finiteness/near/206631843">said</a>:</p>
<blockquote>
<p>I then joked that I should just be doing <code>casesI</code> so I wrote it for a joke and then it turned out that it existed :P</p>
</blockquote>
<p>on a related note, I just discovered <code>fconstructor</code></p>



<a name="206839142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206839142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206839142">(Aug 13 2020 at 16:41)</a>:</h4>
<p>Jason wanted to make an API for <code>finsum</code> (which was defined by Mario to be)</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">α</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="k">then</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>


<p>and he realised that what he wanted was to prove that it equalled finset.sum. This would be easier if we used the following definition:</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum2</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">function</span><span class="bp">.</span><span class="n">support</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="k">then</span> <span class="err">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>


<p>Are there disadvantages to <code>finsum2</code> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> ?</p>



<a name="206843947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206843947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206843947">(Aug 13 2020 at 17:23)</a>:</h4>
<p>which one has less imports?</p>



<a name="206843977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206843977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206843977">(Aug 13 2020 at 17:23)</a>:</h4>
<p>Either way you want to prove both definitions are the same</p>



<a name="206844082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206844082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206844082">(Aug 13 2020 at 17:24)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finsupp</span> <span class="n">data</span><span class="bp">.</span><span class="n">support</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">α</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="k">then</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum2</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">function</span><span class="bp">.</span><span class="n">support</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="k">then</span> <span class="err">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span>

<span class="kn">theorem</span> <span class="n">finsum_eq_finsum2</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">finsum</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">finsum2</span> <span class="n">f</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">finsum</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">finsum2</span><span class="o">,</span>
  <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">h3</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">unfold</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum</span><span class="o">,</span>
    <span class="n">congr&#39;</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mem_support_iff</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="n">h1</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">,</span>
      <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="n">h1</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">clear</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h1</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h1</span><span class="bp">.</span><span class="n">finite_supp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h1</span><span class="o">,</span>
    <span class="n">clear</span> <span class="n">h1</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">α</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">support</span> <span class="o">:=</span> <span class="n">h3</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span>
      <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">f</span><span class="o">,</span>
      <span class="n">mem_support_to_fun</span> <span class="o">:=</span> <span class="k">begin</span>
        <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">function</span><span class="bp">.</span><span class="n">mem_support</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">],</span>
      <span class="kn">end</span> <span class="o">},</span>
    <span class="n">use</span> <span class="n">f&#39;</span><span class="o">,</span>
    <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">}</span>
<span class="kn">end</span> <span class="bp">.</span>
</code></pre></div>



<a name="206844370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206844370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206844370">(Aug 13 2020 at 17:26)</a>:</h4>
<p>what is <code>finiteness.is_finite</code>?</p>



<a name="206844810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206844810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206844810">(Aug 13 2020 at 17:30)</a>:</h4>
<p>wow, I thought <code>function.support</code> would have an easy definition but the file that defines it has a ton of imports</p>



<a name="206845842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206845842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206845842">(Aug 13 2020 at 17:38)</a>:</h4>
<p>I thought we stopped caring about the import hierarchy 37 days ago</p>



<a name="206859914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206859914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206859914">(Aug 13 2020 at 19:35)</a>:</h4>
<p>This file has many imports because it was added after these imports</p>



<a name="206860011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206860011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206860011">(Aug 13 2020 at 19:36)</a>:</h4>
<p>It's easy to remove all imports if you move lemmas to other files</p>



<a name="206867649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206867649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206867649">(Aug 13 2020 at 20:34)</a>:</h4>
<p>Another insight from Chris at Xena this evening; how about this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ&#39;</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">)</span> <span class="k">then</span>
  <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">elems</span> <span class="k">else</span> <span class="err">∅</span>

<span class="n">def</span> <span class="n">fincard&#39;</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card</span> <span class="err">$</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ&#39;</span> <span class="n">X</span>
</code></pre></div>


<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> you had suggested</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">fincard</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">X</span><span class="o">)</span> <span class="k">then</span> <span class="bp">@</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">X</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">h</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>


<p>-- does this variant meet with your approval?</p>



<a name="206871712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206871712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206871712">(Aug 13 2020 at 21:07)</a>:</h4>
<p>ha, clever</p>



<a name="206871749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206871749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206871749">(Aug 13 2020 at 21:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I would go as far as saying that the <code>finset.univ</code> in mathlib should be replaced with your new <code>finset.univ'</code> etc.</p>



<a name="206871752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206871752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206871752">(Aug 13 2020 at 21:07)</a>:</h4>
<p>that finset.univ' could be useful for many things</p>



<a name="206871817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/206871817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#206871817">(Aug 13 2020 at 21:07)</a>:</h4>
<p>(etc. = the same for other definitions depending <strong>directly</strong> on fintype)</p>



<a name="207073922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/207073922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#207073922">(Aug 16 2020 at 14:33)</a>:</h4>
<p>OK so <span class="user-mention" data-user-id="243312">@Jason KY.</span> and I have been hacking away on this stuff, and we ran into something which presumably has been run into before. Recall we've been talking about these definitions (either will do for me but the finset one is easier to port with):</p>
<div class="codehilite"><pre><span></span><code><span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f&#39;</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">α</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f&#39;</span> <span class="k">then</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="mi">0</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">finsum2</span> <span class="o">{</span><span class="n">ι</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">function</span><span class="bp">.</span><span class="n">support</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">finite</span> <span class="k">then</span> <span class="err">∑</span> <span class="n">x</span> <span class="k">in</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>


<p>Jason pointed out that we should probably do products too -- but then we run into the following issue: finsupp and support both want a zero. Is there an analogous construction in Lean which does either of these things but with a 1?</p>



<a name="207074096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/207074096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#207074096">(Aug 16 2020 at 14:38)</a>:</h4>
<p>We can make <code>one_support</code> or whatever -- <code>function.one_support f</code> is the things which don't get mapped to one -- but then <code>to_additive</code> will turn this into <code>zero_support</code>. Presumably we can work around this? But do we want <code>one_support</code> at all?</p>



<a name="207733621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/207733621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#207733621">(Aug 22 2020 at 17:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/finiteness/near/206631843">said</a>:</p>
<blockquote>
<p>so I proved that every set was finite or infinite and then was doing <code>cases; resetI</code>. I then joked that I should just be doing <code>casesI</code> so I wrote it for a joke and then it turned out that it existed :P</p>
</blockquote>
<p>I also just learned you can use it instead of unfreezing local instances.</p>



<a name="207735502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/207735502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#207735502">(Aug 22 2020 at 18:09)</a>:</h4>
<p>We can define <code>set.to_finset</code> using the same trick, then <code>finset.univ = univ.to_finset</code>, <code>fincard = finset.univ.card</code></p>



<a name="207736793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/207736793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#207736793">(Aug 22 2020 at 18:39)</a>:</h4>
<p>There's a <code>fincard</code> branch of mathlib by the way.</p>



<a name="212431131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212431131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212431131">(Oct 06 2020 at 13:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/finiteness/near/206179081">said</a>:</p>
<blockquote>
<p>Is there any way we could get to a world in which</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finite</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="c1">-- any definition of finiteness</span>

<span class="kd">structure</span> <span class="n">finset</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">))</span>
</code></pre></div>

</blockquote>
<p>I hereby sign this petition.</p>



<a name="212431901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212431901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212431901">(Oct 06 2020 at 14:03)</a>:</h4>
<p>I sign any petition that could make finiteness manageable.</p>



<a name="212432715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212432715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212432715">(Oct 06 2020 at 14:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/finiteness/near/206183881">said</a>:</p>
<blockquote>
<p>It's my completely unsubstantiated opinion that if we proved a bunch of things for <code>finite</code>, say, we could systematically deduce the consequences for <code>finset</code> and <code>fintype</code> and end up with a more organized API</p>
</blockquote>
<p>What would this systematic deduction look like? It should be possible to do that with current definitions, right?</p>
<p>I think the only design choice that is not trivial upto Prop-eq is whether <code>fintype</code> is Type or Prop valued.</p>



<a name="212432826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212432826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212432826">(Oct 06 2020 at 14:10)</a>:</h4>
<p>Otoh, I do wish quite often that we had</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finite</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">,</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">t</span>
<span class="c1">-- instead of</span>
<span class="kd">def</span> <span class="n">finite</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>



<a name="212432951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212432951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212432951">(Oct 06 2020 at 14:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> If you want to start with <code>set.finite</code> instead of <code>finset</code>, I guess</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finite'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span>
</code></pre></div>

<p>would be an obvious way to start.</p>



<a name="212433090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212433090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212433090">(Oct 06 2020 at 14:12)</a>:</h4>
<p>But it's not yet clear to me how <code>set.finite</code> and <code>finset</code> would become much easier to handle than with what we have now. (Not saying the current setup is easy.)</p>



<a name="212433238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212433238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212433238">(Oct 06 2020 at 14:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/finiteness/near/212432951">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> If you want to start with <code>set.finite</code> instead of <code>finset</code>, I guess</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finite'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span>
</code></pre></div>

<p>would be an obvious way to start.</p>
</blockquote>
<p>You don't even need an if and only if, only that <code>l</code> surjects onto <code>s</code>.</p>



<a name="212433561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212433561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212433561">(Oct 06 2020 at 14:15)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">finite'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span>
</code></pre></div>



<a name="212433847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212433847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212433847">(Oct 06 2020 at 14:17)</a>:</h4>
<p>This makes it easier to prove that the intersection / union of two finite sets are finite.</p>



<a name="212435137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212435137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212435137">(Oct 06 2020 at 14:25)</a>:</h4>
<p>It really doesn't matter how you define <code>finite</code>. The right place to start would be <code>constant finite : set \a -&gt; Prop</code>. At some point you'll have collected a bunch of proof obligations like <code>finite_union</code>, <code>finite_fin</code>, ... and then you can think about what definition would be best to prove them all.<br>
A more important question might be whether <code>finite</code> or <code>fintype</code> should be the primitive one, with the other one defined in terms of it. But I think it doesn't matter too much.</p>



<a name="212435370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212435370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212435370">(Oct 06 2020 at 14:27)</a>:</h4>
<p>Currently <code>finset</code> is the primitive one. Is that bad?</p>



<a name="212435687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212435687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212435687">(Oct 06 2020 at 14:29)</a>:</h4>
<p>Oh? Why isn't <code>set.finite</code> defined as "there exists a finset such that..."?</p>



<a name="212435729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212435729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212435729">(Oct 06 2020 at 14:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/finiteness/near/212433090">said</a>:</p>
<blockquote>
<p>But it's not yet clear to me how <code>set.finite</code> and <code>finset</code> would become much easier to handle than with what we have now. (Not saying the current setup is easy.)</p>
</blockquote>
<p>One advantage is everything just becomes more straightforward.</p>
<ul>
<li>If you have <code>(s : set T) (h : finite s)</code>, you don't need to go hunt down <code>finite.to_finset</code>. You can just write <code>⟨s, h⟩</code>.</li>
<li>More importantly, when you extract the underlying <code>set</code> of this <code>finset</code>, it's now defeq to what you started with.</li>
<li>That means if we define all the <code>has_mem</code>, <code>has_union</code> etc. on <code>finset</code> using the corresponding <code>set</code> definition on the first component, then everything becomes defeq. You don't even really need to prove a theorem like <code>(s t : finset α) : s ⊆ s ∪ t</code> because you can just apply the <code>set</code> version. All lemmas about bounded quantification over <code>set</code> also apply to bounded quantification over <code>finset</code>, etc.</li>
</ul>



<a name="212435916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212435916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212435916">(Oct 06 2020 at 14:30)</a>:</h4>
<p>(The other, more substantial advantage is that all the <code>decidable_eq</code> stuff disappears, but that comes with tradeoffs.)</p>



<a name="212436240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212436240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212436240">(Oct 06 2020 at 14:33)</a>:</h4>
<p>I think the current definition of <code>finset</code> probably comes from Coq or something but it doesn't fit the mathematician's idea of a finite set, which is first and foremost a <strong>set</strong>, that happens to be finite.</p>



<a name="212436432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212436432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212436432">(Oct 06 2020 at 14:34)</a>:</h4>
<p>Actually, we could probably achieve much of these "everything becomes more straightforward" advantages just by changing the definition of <code>finset</code>to have an underlying <code>set</code> field, without simultaneously making things classical.</p>



<a name="212437183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212437183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212437183">(Oct 06 2020 at 14:39)</a>:</h4>
<p>So it would have a <code>set</code> field and a <code>multiset</code> and a proof that they are "equal"?</p>



<a name="212437386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212437386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212437386">(Oct 06 2020 at 14:40)</a>:</h4>
<p>But I guess that breaks the "everything is straightforward" part of the multiset-finset interface</p>



<a name="212437410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212437410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212437410">(Oct 06 2020 at 14:40)</a>:</h4>
<p>Not saying that's a dealbreaker</p>



<a name="212437663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212437663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212437663">(Oct 06 2020 at 14:42)</a>:</h4>
<p>I guess if you wanted to do the constructive version of this then you would consider <code>s : set</code> together with a "finiteness structure" on <code>s</code>, which would be some kind of subsingleton (e.g. <code>trunc (\Sigma n, s \~- fin n)</code>)</p>



<a name="212438163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212438163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212438163">(Oct 06 2020 at 14:45)</a>:</h4>
<p>But yeah, you could also do what you suggested.</p>



<a name="212438299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212438299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212438299">(Oct 06 2020 at 14:46)</a>:</h4>
<p>But I'd rather go completely classical. I'm just worried about what the story is going to be for computing, say, <code>finset.sum</code> over a singleton.</p>



<a name="212438798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212438798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212438798">(Oct 06 2020 at 14:50)</a>:</h4>
<p>As far as I can tell, effectively the only purpose of this <code>decidable_eq</code> stuff in <code>finset</code>/<code>fintype</code> is so that <code>finset.sum</code>+relatives will reduce on things like empty sets and singletons (is that it? I thought about <code>finset.insert</code> too but <code>finset.sum_insert</code> doesn't seem to be true by <code>rfl</code> actually).</p>



<a name="212444791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212444791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212444791">(Oct 06 2020 at 15:28)</a>:</h4>
<p>To my mind, the reason <code>finset</code> has a separate name is because it's not just the same as a finite set. If you want a finite set you can say that - a <code>set</code> that is <code>finite</code></p>



<a name="212444876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212444876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212444876">(Oct 06 2020 at 15:29)</a>:</h4>
<p>But in that case we should port all the <code>finset.sum</code>, <code>finset.min</code> etc stuff to <code>set</code> + <code>finite</code> where it would be used</p>



<a name="212445003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212445003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212445003">(Oct 06 2020 at 15:30)</a>:</h4>
<p>Well yes, I thought we had made plans about that as well (c.f. <code>finsum</code>)</p>



<a name="212445065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212445065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212445065">(Oct 06 2020 at 15:31)</a>:</h4>
<p>In particular I think that in most cases you can leave off the finiteness assumptions in the definitions</p>



<a name="212445223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212445223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212445223">(Oct 06 2020 at 15:32)</a>:</h4>
<p>I still really hate this style.</p>



<a name="212445283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212445283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212445283">(Oct 06 2020 at 15:32)</a>:</h4>
<p>I don't think that partial functions does anyone any favors</p>



<a name="212445351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212445351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212445351">(Oct 06 2020 at 15:33)</a>:</h4>
<p>particularly when they get involved in stating structures and things, and you need to write proofs inline</p>



<a name="212445835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212445835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212445835">(Oct 06 2020 at 15:37)</a>:</h4>
<p>I don't understand how the proposed changes (change argument of <code>sum</code> from <code>finset</code> to <code>set</code> and pass finiteness assumptions to lemmas) won't make long <code>calc</code> manipulations of sums <em>a lot</em> messier.</p>



<a name="212446040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212446040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212446040">(Oct 06 2020 at 15:38)</a>:</h4>
<p>Particularly when the indexing set of the sum is changing through the calculation</p>



<a name="212446476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212446476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212446476">(Oct 06 2020 at 15:42)</a>:</h4>
<p>If each index set is "structurally" finite, then we can use a typeclass on <code>set.finite</code> to discharge it</p>



<a name="212446501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212446501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212446501">(Oct 06 2020 at 15:42)</a>:</h4>
<p>Oh boy you might have found something I hate even more <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="212446594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212446594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212446594">(Oct 06 2020 at 15:43)</a>:</h4>
<p>importantly, we won't have to worry about carrying the original finiteness proof through all the manipulations and getting a mismatch when a new proof also applies</p>



<a name="212446751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212446751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212446751">(Oct 06 2020 at 15:44)</a>:</h4>
<p>Then again, in a case like this it seems like <code>finset</code> might be more your cup of tea. So why the use of sets?</p>



<a name="212447051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212447051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212447051">(Oct 06 2020 at 15:46)</a>:</h4>
<p>Well, for example, because I have a <code>set R</code> which is definable in an o-minimal structure and so I know either it's finite or contains an interval. If it's finite I want to take the smallest element (I also know it's nonempty), if it contains an interval I want to do something else.</p>



<a name="212447369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212447369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212447369">(Oct 06 2020 at 15:48)</a>:</h4>
<p>Currently I think what I do is: if it's finite then I use <code>set.finite.to_finset</code> to get a <code>finset</code>, then take the <code>min</code> of that, and then I need to do a bit of arguing to show how it relates to my original set.</p>



<a name="212447404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212447404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212447404">(Oct 06 2020 at 15:48)</a>:</h4>
<p><code>simp</code>?</p>



<a name="212448105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212448105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212448105">(Oct 06 2020 at 15:54)</a>:</h4>
<p>I don't remember exactly what I had to do, but it was effort that served no apparent real purpose.</p>



<a name="212448183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212448183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212448183">(Oct 06 2020 at 15:55)</a>:</h4>
<p>In this case it was just a local <code>let</code> inside a proof, so <code>simp</code> wouldn't be too bad, but if it was an auxiliary top-level definition, then the "no partial functions" style is really annoying because the proof of finiteness now becomes a second top-level thing that you have to pass around as well</p>



<a name="212449060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212449060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212449060">(Oct 06 2020 at 16:01)</a>:</h4>
<p>I mean you could use <code>{s // finite s}</code> in some of these applications, but I don't know about giving this type the full mathlib treatment because it is isomorphic to <code>finset</code> and the API is the same</p>



<a name="212449205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212449205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212449205">(Oct 06 2020 at 16:02)</a>:</h4>
<p>Replacing <code>finset</code> with this is exactly what I want to do, and I don't agree that the API is the same.</p>



<a name="212449226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212449226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212449226">(Oct 06 2020 at 16:03)</a>:</h4>
<p>the functions are the same, the lemmas are the same</p>



<a name="212449247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212449247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212449247">(Oct 06 2020 at 16:03)</a>:</h4>
<p>don't come to me about defeq</p>



<a name="212449386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212449386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212449386">(Oct 06 2020 at 16:04)</a>:</h4>
<p>For <code>&lt;s, h&gt;</code> I'd rather see that as a lean limitation that we can't customize the function that this invokes</p>



<a name="212449515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212449515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212449515">(Oct 06 2020 at 16:05)</a>:</h4>
<p>Well this is very frustrating. All I can say is that I find <code>finset</code> consistently more difficult to deal with than the <code>set</code> equivalent. For a long time I thought it was just me, but finally I realized that it doesn't have to be this way.</p>



<a name="212450217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212450217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212450217">(Oct 06 2020 at 16:10)</a>:</h4>
<p>If you really want to do it, the API would have to be at least as large as <code>finset.lean</code>. Half baked APIs make me sad</p>



<a name="212450293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212450293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212450293">(Oct 06 2020 at 16:11)</a>:</h4>
<p>Of course, my intention was to replace <code>finset</code> entirely</p>



<a name="212450346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212450346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212450346">(Oct 06 2020 at 16:11)</a>:</h4>
<p>so that's why I'm more interested in the question: what will break?</p>



<a name="212450347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212450347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212450347">(Oct 06 2020 at 16:11)</a>:</h4>
<p>But I don't see that as an option, because <code>finset</code> has its place as a nodups <code>multiset</code></p>



<a name="212450439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212450439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212450439">(Oct 06 2020 at 16:12)</a>:</h4>
<p>Perhaps that's a niche thing, but it's distinct</p>



<a name="212450509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212450509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212450509">(Oct 06 2020 at 16:12)</a>:</h4>
<p>we can change the name if it makes it easier</p>



<a name="212450581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212450581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212450581">(Oct 06 2020 at 16:13)</a>:</h4>
<p>As I said: the API is the same, so nothing should break, in particular if <code>fintype</code> remains based on the old <code>finset</code></p>



<a name="212450624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212450624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212450624">(Oct 06 2020 at 16:13)</a>:</h4>
<p><code>fintype</code> instances need to compute</p>



<a name="212450747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212450747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212450747">(Oct 06 2020 at 16:14)</a>:</h4>
<p>and they are occasionally defeq-forced, so replacing them with something noncomputable isn't going to fly</p>



<a name="212450851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212450851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212450851">(Oct 06 2020 at 16:15)</a>:</h4>
<p>Ideally <code>fintype</code> would become a proposition as well, and where something computational is really needed, we would use <code>fin_enum</code>. However I'm not sure how important this is.</p>



<a name="212451051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212451051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212451051">(Oct 06 2020 at 16:16)</a>:</h4>
<p>That seems reasonable; the fact that <code>fintype</code> instances lose the order is occasionally problematic</p>



<a name="212451351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212451351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212451351">(Oct 06 2020 at 16:18)</a>:</h4>
<p>so what would be the typeclass for finiteness of sets? would you reuse <code>fintype (\u s)</code> or would <code>set.finite s</code> be a class?</p>



<a name="212451690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212451690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212451690">(Oct 06 2020 at 16:21)</a>:</h4>
<p>I wasn't intending to change the status quo in terms of having <code>finite</code> as an unbundled predicate and <code>finset</code> as a bundled structure for <code>set</code>, and <code>fintype</code> as a class for types... it seems fairly reasonable to me</p>



<a name="212452099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452099">(Oct 06 2020 at 16:24)</a>:</h4>
<p>in particular finiteness of sets is often non-structural, e.g., if <code>s ⊆ t</code> and <code>t</code> is finite then <code>s</code> is finite... I guess the same thing can happen with an injective map of types but maybe it's less important there?</p>



<a name="212452191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452191">(Oct 06 2020 at 16:25)</a>:</h4>
<p>I mean would the type in instances be <code>[fintype (\u s)] : fintype (\u (s \cap t))</code> or <code>[set.finite s] : set.finite (s \cap t)</code></p>



<a name="212452200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452200">(Oct 06 2020 at 16:25)</a>:</h4>
<p>I think injective maps are important enough to please let <code>set.finite</code> not be a class.</p>



<a name="212452311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452311">(Oct 06 2020 at 16:26)</a>:</h4>
<p>both would work I think, the second one requires <code>set.finite</code> to be a class which has occasional consequences for freezing which are sometimes undesirable for a proposition</p>



<a name="212452389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452389">(Oct 06 2020 at 16:26)</a>:</h4>
<p>I see, I think the first one is okay. But now I also realize I think I haven't had so much experience with <code>fintype</code> directly.</p>



<a name="212452564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452564">(Oct 06 2020 at 16:28)</a>:</h4>
<p>If you want <code>fintype</code> on <code>\u</code> of some set though then it makes sense to have structural instances for this that are parallel to <code>finite.union</code>, ... I guess.</p>



<a name="212452722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452722">(Oct 06 2020 at 16:29)</a>:</h4>
<p>but now maybe we're losing the whole <code>{s // finite s}</code> thing this way</p>



<a name="212452737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452737">(Oct 06 2020 at 16:29)</a>:</h4>
<p>I'm not sure what these instances would bottom out to though</p>



<a name="212452915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452915">(Oct 06 2020 at 16:30)</a>:</h4>
<p>I would still prefer that <code>finite s</code> be defined as it is now, in terms of old <code>finset</code></p>



<a name="212452930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452930">(Oct 06 2020 at 16:31)</a>:</h4>
<p>Like why would you have any instance of <code>fintype (\u s)</code> in the first place (aside from if <code>s : set t</code> where <code>fintype t</code>)</p>



<a name="212452977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452977">(Oct 06 2020 at 16:31)</a>:</h4>
<p>you might have <code>finite s</code> and <code>haveI</code> a <code>fintype (\u s)</code> instance</p>



<a name="212452999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212452999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212452999">(Oct 06 2020 at 16:31)</a>:</h4>
<p>maybe that's too much trouble?</p>



<a name="212453273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212453273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212453273">(Oct 06 2020 at 16:34)</a>:</h4>
<p>Working with finite sets in this way is probably always going to be a little brittle. It's easy to misplace the finiteness proofs</p>



<a name="212453414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212453414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212453414">(Oct 06 2020 at 16:35)</a>:</h4>
<p>I have always found it very easy to work with <code>finset</code> as currently defined because of its robust API, but that's only when dealing with them as <code>finset</code>s and not necessarily when interfacing with sets</p>



<a name="212453600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212453600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212453600">(Oct 06 2020 at 16:37)</a>:</h4>
<p>aagh I hate defeq</p>



<a name="212453766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212453766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212453766">(Oct 06 2020 at 16:39)</a>:</h4>
<p>I think <code>finite</code> would end up sort of like <code>is_subgroup</code> in that (besides maybe being used to implement <code>finset</code>) it ends up getting used mainly to mediate between the <code>set</code> world and the <code>finset</code> world</p>



<a name="212453792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212453792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212453792">(Oct 06 2020 at 16:39)</a>:</h4>
<p>like in the definable set example I gave before, where you have a <code>set</code> and then later you acquire the information that it's finite</p>



<a name="212454142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454142">(Oct 06 2020 at 16:42)</a>:</h4>
<p>I mean you can do all that with the current API</p>



<a name="212454175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454175">(Oct 06 2020 at 16:42)</a>:</h4>
<p>I'm sorry the function that does it has a name</p>



<a name="212454214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454214">(Oct 06 2020 at 16:43)</a>:</h4>
<p>right, and you end up with 100-character long <code>simp only</code>s instead of nothing</p>



<a name="212454236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454236">(Oct 06 2020 at 16:43)</a>:</h4>
<p>nothing, he says</p>



<a name="212454377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454377">(Oct 06 2020 at 16:44)</a>:</h4>
<p>I guess I don't understand the apparent opposition. Like is it a problem that <code>(x, y).fst</code> is defeq to <code>x</code>? Should we have only a propositional equality?</p>



<a name="212454440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454440">(Oct 06 2020 at 16:45)</a>:</h4>
<p>Why would it be unreasonable to think "finite set" = <code>subtype set.finite</code>?</p>



<a name="212454456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454456">(Oct 06 2020 at 16:45)</a>:</h4>
<p>I really hate this aspect of lean, that it makes one look so much worse than the other even though they are about the same complexity</p>



<a name="212454578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454578">(Oct 06 2020 at 16:46)</a>:</h4>
<p>If defeq wasn't a thing then they would be the same, and you could set up the "refl"-equivalent tactic to work with whatever you say</p>



<a name="212454624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454624">(Oct 06 2020 at 16:46)</a>:</h4>
<p>in lean that tool is <code>simp</code> but it does just a bit too much</p>



<a name="212454635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454635">(Oct 06 2020 at 16:47)</a>:</h4>
<p>Right, I agree that this whole conversation  is somehow an artifact of DTT</p>



<a name="212454871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454871">(Oct 06 2020 at 16:49)</a>:</h4>
<p>Is there a way we can fix this with more notation?</p>



<a name="212454985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212454985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212454985">(Oct 06 2020 at 16:50)</a>:</h4>
<p>like make the constructor easier to call, and add a custom simp set to make the <code>simp only</code> more palatable</p>



<a name="212455114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212455114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212455114">(Oct 06 2020 at 16:51)</a>:</h4>
<p>I think if we start bending over backwards to make all the defeqs work out we will lose, because it is impossible to please everyone</p>



<a name="212455177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212455177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212455177">(Oct 06 2020 at 16:52)</a>:</h4>
<p>all equalities should be defeqs</p>



<a name="212455675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212455675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212455675">(Oct 06 2020 at 16:56)</a>:</h4>
<p>Already Johan's suggestion of adding "... and a <code>set</code>, such that it's equal to the <code>multiset</code>" would be an improvement. Then all the lemmas that say that union commutes with taking the underlying sets get baked into the definitions of those operations.</p>



<a name="212456961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212456961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212456961">(Oct 06 2020 at 17:07)</a>:</h4>
<p>But since (independently of this issue) it's also quite annoying to deal with <code>finset.inter</code> and so on having these <code>decidable_eq</code> instances which may or may not be coherent, and considering that in the end, it's unclear how much working constructively really buys us, it seems to me that doing things classically would be better anyways. And at that point just using <code>subtype set.finite</code> seems like a welcome simplification.</p>



<a name="212462420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212462420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212462420">(Oct 06 2020 at 17:55)</a>:</h4>
<p>I wonder if this might be a good setup. It lets you reuse all the <code>fintype</code> machinery, so it might make fleshing out the interface easier.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.basic</span>

<span class="kd">structure</span> <span class="n">new_finset</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_set</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">finite</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">to_set</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">set.to_new_finset</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span> <span class="n">new_finset</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">new_finset.mk</span> <span class="n">s</span> <span class="o">(</span><span class="kd">by</span> <span class="n">apply_instance</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">new_finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">new_finset.to_set</span><span class="o">⟩</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">new_finset.coe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">new_finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">s.to_set</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="n">new_finset.fintype</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">new_finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">s.finite</span>
</code></pre></div>



<a name="212462576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212462576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212462576">(Oct 06 2020 at 17:56)</a>:</h4>
<p>The current <code>finset</code> would still exist somewhere but with a new name.</p>



<a name="212463166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212463166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212463166">(Oct 06 2020 at 18:00)</a>:</h4>
<p>You also get a fairly nice <code>new_finset.univ</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">new_finset.univ</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">new_finset</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_set</span> <span class="o">:=</span> <span class="n">set.univ</span><span class="o">,</span>
  <span class="n">finite</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span> <span class="o">}</span>
</code></pre></div>



<a name="212463333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212463333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212463333">(Oct 06 2020 at 18:02)</a>:</h4>
<p>Wouldn't this get annoying because you would have to deal with the coercion from the set to the associated subtype?</p>



<a name="212464263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/212464263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#212464263">(Oct 06 2020 at 18:10)</a>:</h4>
<p>If you want to go between <code>set</code> and <code>finset</code> you already have to use <code>set.to_finset</code> and <code>finset</code>'s lift to <code>set</code>.</p>
<p>But something that would likely be a problem is that there are non-defeq <code>fintype</code> instances... so I retract this proposal.  (Maybe it'd be ok with <code>nonempty (fintype to_set)</code>.)</p>



<a name="252102661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/252102661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#252102661">(Sep 05 2021 at 21:21)</a>:</h4>
<p>Reviving this thread, I'm wondering whether there's a reason the first definition was chosen over the second:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">set.finite</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="n">s</span><span class="o">)</span>
<span class="c1">-- versus</span>
<span class="kd">def</span> <span class="n">set.finite</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">t</span>
</code></pre></div>



<a name="252102755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness/near/252102755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/finiteness.html#252102755">(Sep 05 2021 at 21:23)</a>:</h4>
<p>Also, in case it changes the calculus of including a noncomputable finset, <a href="https://leanprover-community.github.io/mathlib_docs/find/set_like">docs#set_like</a> would be a way to implement one with a little less boilerplate (but still, it would be an undertaking to do it this way):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universes</span> <span class="n">u</span>

<span class="kd">structure</span> <span class="n">finset'</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">finite'</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="n">s</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">t</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">finset'</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">set_like</span> <span class="o">(</span><span class="n">finset'</span> <span class="n">α</span><span class="o">)</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">finset'.s</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">p</span><span class="o">,</span> <span class="n">cases</span> <span class="n">q</span><span class="o">,</span> <span class="n">congr'</span> <span class="o">}⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">mem_coe</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s.s</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[ext]</span> <span class="kd">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">set_like.ext</span> <span class="n">h</span>

<span class="sd">/-- Copy of a `finset'` with a new `s` equal to the old one. Useful to fix definitional</span>
<span class="sd">equalities. See See Note [range copy pattern]. -/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">copy</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">finite'</span> <span class="o">:=</span> <span class="n">hs.symm</span> <span class="bp">▸</span> <span class="n">s.finite'</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">finite</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">s.finite'</span>

<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">finset'</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.finite.some</span><span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_set_finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">s.finite.some_spec.symm</span>

<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset'</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">s</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">set.finite_mem_finset</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">))</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kd">end</span> <span class="n">finset'</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/by.20exactI.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html">by exactI</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222904065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222904065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222904065">(Jan 15 2021 at 18:38)</a>:</h4>
<p>I have a question for Lean hackers (<span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="110026">@Simon Hudon</span>  etc).<br>
Here is the main statement from LTE:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">main</span> <span class="o">[</span><span class="n">BD.suitable</span> <span class="n">c'</span><span class="o">]</span>
  <span class="o">(</span><span class="n">r</span> <span class="n">r'</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r'</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">r</span> <span class="bp">&lt;</span> <span class="n">r'</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">r'</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)]</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">)],</span>
  <span class="bp">∃</span> <span class="n">c₀</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">,</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">S</span><span class="o">],</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">NormedGroup</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_with_aut</span> <span class="n">r</span> <span class="n">V</span><span class="o">],</span>
  <span class="kd">by</span> <span class="n">exactI</span> <span class="o">(</span><span class="n">Mbar_system</span> <span class="n">V</span> <span class="n">S</span> <span class="n">r</span> <span class="n">r'</span> <span class="n">BD</span> <span class="n">c'</span><span class="o">)</span><span class="bp">.</span><span class="n">is_bdd_exact_for_bdd_degree_above_idx</span> <span class="n">k</span> <span class="n">m</span> <span class="n">c₀</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>All of this looks pretty reasonable, but the <code>by exactI</code> is of course a bit annoying.</p>
<p>Do you think we can change Lean so that it will trigger a cache reset when it parses <code>[normed_with_aut r V]</code> (or any other <code>[foobar]</code>) after <code>:</code>?</p>
<p>I realise that this would lead to 3 extra cache resets in the current statement... is that expensive?</p>



<a name="222904183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222904183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222904183">(Jan 15 2021 at 18:39)</a>:</h4>
<p>It's not impossible.  The real question is: how important is this to you given that it will be fixed in <span aria-label="four leaf clover" class="emoji emoji-1f340" role="img" title="four leaf clover">:four_leaf_clover:</span> and that we have a workaround in <span aria-label="three" class="emoji emoji-0033-20e3" role="img" title="three">:three:</span>?</p>



<a name="222904221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222904221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222904221">(Jan 15 2021 at 18:39)</a>:</h4>
<p>You can also make notation if you find the current workaround to be too ugly.</p>



<a name="222904249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222904249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222904249">(Jan 15 2021 at 18:39)</a>:</h4>
<p>How would that work?</p>



<a name="222904280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222904280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222904280">(Jan 15 2021 at 18:39)</a>:</h4>
<p>You mean some notation for the <code>by exactI</code>?</p>



<a name="222904473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222904473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222904473">(Jan 15 2021 at 18:40)</a>:</h4>
<p>I think you can do this using user notation.</p>



<a name="222904729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222904729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222904729">(Jan 15 2021 at 18:42)</a>:</h4>
<p>I don't know what you have in mind, sorry</p>



<a name="222906492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222906492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222906492">(Jan 15 2021 at 18:54)</a>:</h4>
<p>This seems to work, you just need to adapt it to exactI:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="kn">open</span> <span class="n">lean</span>
<span class="kn">open</span> <span class="n">lean.parser</span>
<span class="kn">open</span> <span class="n">interactive</span>
<span class="kn">open</span> <span class="n">tactic</span>

<span class="kd">reserve</span> <span class="kd">prefix</span> <span class="bp">`♯ᵢ</span> <span class="bp">`</span><span class="o">:</span><span class="mi">100</span>

<span class="kd">@[user_notation]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">exact_notation</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">parse</span> <span class="bp">$</span> <span class="n">tk</span> <span class="s2">"♯ᵢ"</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">lean.parser.pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">pexpr</span> <span class="o">:=</span> <span class="k">do</span>
<span class="n">expr.macro</span> <span class="n">d</span> <span class="o">[</span><span class="n">_</span><span class="o">]</span> <span class="bp">←</span> <span class="n">pure</span> <span class="bp">``</span><span class="o">(</span><span class="kd">by</span> <span class="n">skip</span><span class="o">),</span>
<span class="n">pure</span> <span class="bp">$</span> <span class="n">expr.macro</span> <span class="n">d</span> <span class="o">[</span><span class="n">const</span> <span class="bp">``</span><span class="n">tactic.interactive.exact</span> <span class="o">[]</span> <span class="o">(</span><span class="n">cast</span> <span class="n">undefined</span> <span class="n">e.reflect</span><span class="o">)]</span>

<span class="k">#check</span> <span class="bp">♯ᵢ</span> <span class="mi">1</span>
</code></pre></div>



<a name="222906533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222906533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222906533">(Jan 15 2021 at 18:54)</a>:</h4>
<p>Ooh wow! I would have never been able to write that myself</p>



<a name="222906596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222906596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222906596">(Jan 15 2021 at 18:55)</a>:</h4>
<p>I'll try it out</p>



<a name="222906597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222906597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222906597">(Jan 15 2021 at 18:55)</a>:</h4>
<p>Yes, I would have liked to write <code> ``(by exact %%e) </code>, but lean doesn't let me do that.</p>



<a name="222907025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222907025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222907025">(Jan 15 2021 at 18:58)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> if I replace <code>by exactI</code> with <code>♯ᵢ</code> then I get <code>unexpected token</code></p>



<a name="222907690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222907690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222907690">(Jan 15 2021 at 19:01)</a>:</h4>
<p>sorry, that was a copy-paste error... let me try better</p>



<a name="222908190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222908190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222908190">(Jan 15 2021 at 19:04)</a>:</h4>
<p>With</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[user_notation]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">exact_notation</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">parse</span> <span class="bp">$</span> <span class="n">tk</span> <span class="s2">"♯ᵢ"</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">lean.parser.pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">pexpr</span> <span class="o">:=</span> <span class="k">do</span>
<span class="n">expr.macro</span> <span class="n">d</span> <span class="o">[</span><span class="n">_</span><span class="o">]</span> <span class="bp">←</span> <span class="n">pure</span> <span class="bp">``</span><span class="o">(</span><span class="kd">by</span> <span class="n">skip</span><span class="o">),</span>
<span class="n">pure</span> <span class="bp">$</span> <span class="n">expr.macro</span> <span class="n">d</span> <span class="o">[</span><span class="n">const</span> <span class="bp">`</span><span class="n">tactic.interactive.exactI</span> <span class="o">[]</span> <span class="o">(</span><span class="n">cast</span> <span class="n">undefined</span> <span class="n">e.reflect</span><span class="o">)]</span>
</code></pre></div>
<p>it works! <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> thanks a lot, this is very nice indeed!</p>



<a name="222908384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222908384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222908384">(Jan 15 2021 at 19:05)</a>:</h4>
<p>You should also change <code>lean.parser.pexpr</code> to <code>(lean.parser.pexpr 0)</code> (then it parses more like <code>$</code> or <code>by exactI</code>)</p>



<a name="222908627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222908627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222908627">(Jan 15 2021 at 19:07)</a>:</h4>
<p>aah, cool, let me try that</p>



<a name="222908841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222908841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222908841">(Jan 15 2021 at 19:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">main</span> <span class="o">[</span><span class="n">BD.suitable</span> <span class="n">c'</span><span class="o">]</span>
  <span class="o">(</span><span class="n">r</span> <span class="n">r'</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r'</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">r</span> <span class="bp">&lt;</span> <span class="n">r'</span><span class="o">)]</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">r'</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)]</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">)],</span>
  <span class="bp">∃</span> <span class="n">c₀</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">,</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">S</span><span class="o">],</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">NormedGroup</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_with_aut</span> <span class="n">r</span> <span class="n">V</span><span class="o">],</span><span class="bp">​</span>
    <span class="o">(</span><span class="n">Mbar_system</span> <span class="n">V</span> <span class="n">S</span> <span class="n">r</span> <span class="n">r'</span> <span class="n">BD</span> <span class="n">c'</span><span class="o">)</span><span class="bp">.</span><span class="n">is_bdd_exact_for_bdd_degree_above_idx</span> <span class="n">k</span> <span class="n">m</span> <span class="n">c₀</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> this is awesome!</p>



<a name="222909087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222909087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222909087">(Jan 15 2021 at 19:10)</a>:</h4>
<ol>
<li>yes, that is totally a zero-width space after that final <code>,</code></li>
<li>this statement looks a lot better</li>
<li>this also solves another annoying bug: with <code>by exactI</code> if you Ctrl-clicked on <code>is_bdd_exact_for_bdd_degree_above_idx</code> it would go to the definition of <code>exactI</code> instead of the definition that you actually want. Now "Go to definition" works as expected</li>
</ol>



<a name="222913765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222913765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222913765">(Jan 15 2021 at 19:41)</a>:</h4>
<p>Of course, a better solution would be to have explicit <code>k</code> and <code>c₀</code> in terms of <code>m</code>, and put everything left of the colon :-)</p>



<a name="222914005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222914005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222914005">(Jan 15 2021 at 19:43)</a>:</h4>
<p>I do not yet have enough understanding of the proof to know whether that is an option</p>



<a name="222914075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222914075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222914075">(Jan 15 2021 at 19:43)</a>:</h4>
<p>Maybe explicit can even mean <code>classical.some</code>?</p>



<a name="222914174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222914174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222914174">(Jan 15 2021 at 19:44)</a>:</h4>
<p>But I guess we still need to understand what properties of <code>k</code> are needed :)</p>



<a name="222914521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/by%20exactI/near/222914521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/by.20exactI.html#222914521">(Jan 15 2021 at 19:46)</a>:</h4>
<p>I'm pretty sure the proof has to give an explicit <code>k</code>, because you couldn't do a proof by contradiction by quantifying over every type and every normed group like that (no way to take a limit and argue that the limit has a nice behavior, as one often does in proofs that give something non-explicit). Although this "explicit" might be completely untractable :-)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
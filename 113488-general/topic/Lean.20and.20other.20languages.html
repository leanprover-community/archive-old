---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Lean.20and.20other.20languages.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html">Lean and other languages</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="273090753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273090753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273090753">(Feb 24 2022 at 13:47)</a>:</h4>
<p>Is there much written comparing and contrasting Lean (Lean 3 and Lean 4) with other similar theorem provers like Coq, or other general-languages-that-contain-theorem-provers like F*, or the wider zoo of Theoremy Stuff?</p>
<p>I'm currently trying to learn a bit of F* and it just seems horrible, conceptually, compared to the more elegant approach of Lean, but I'm sure I'm missing something. I'm looking for balanced thoughts on the different things that these different languages do well. I like Lean the most - but maybe I'm biased or wrong! It has been tricky to find discussion of serious comparisons though.</p>



<a name="273097569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273097569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273097569">(Feb 24 2022 at 14:41)</a>:</h4>
<blockquote>
<p>I'm currently trying to learn a bit of F* and it just seems horrible, conceptually, compared to the more elegant approach of Lean, but I'm sure I'm missing something.</p>
</blockquote>
<p>Could you elaborate on what seems horrible about F*? I can make some guesses but there are a lot of ways you could mean this.</p>



<a name="273123418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273123418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273123418">(Feb 24 2022 at 17:39)</a>:</h4>
<p>Oh, well, first off I find the whole "embed proofs into the types of definitions" thing... just very Ugh.</p>



<a name="273123464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273123464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273123464">(Feb 24 2022 at 17:39)</a>:</h4>
<p>I'm fundamentally happier with a paradigm where you define things, and then prove stuff about them.</p>



<a name="273123697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273123697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273123697">(Feb 24 2022 at 17:41)</a>:</h4>
<p>Sometimes, of course, a definition contains a proof - fine. But - to take the example they give in their manual - the idea that the type of a max function should include the assertion that it is indeed the max seems...</p>



<a name="273123724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273123724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273123724">(Feb 24 2022 at 17:41)</a>:</h4>
<p>I just don't understand what advantages are gained by doing things like that.</p>



<a name="273123833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273123833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273123833">(Feb 24 2022 at 17:42)</a>:</h4>
<p>Also in general I think it looks less nice than Lean, but that's really just syntax + syntactic sugar + Unicode support helping Lean.</p>



<a name="273129519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273129519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273129519">(Feb 24 2022 at 18:23)</a>:</h4>
<p>I don't know anything about F#, but a function like max is totally determined by its characteristic property and the particular implementation is irrelevant. The proof of correctness of the implementation is necessarily coupled to the implementation anyways, so you might as well do them at the same time and then create an abstraction boundary around them.</p>



<a name="273129542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273129542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273129542">(Feb 24 2022 at 18:23)</a>:</h4>
<p>For functions like addition of natural numbers, obviously that kind of thing doesn't make sense.</p>



<a name="273130744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273130744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273130744">(Feb 24 2022 at 18:33)</a>:</h4>
<p>F*, not F#. Agreed that the particular implementation is irrelevant, but the way Lean does this (you have a "default max" function, and then a linear order contains as part of its structure a different max function and a proof that it is equal to the default) makes much more sense to me. (Because the type of max is still α → α → α.)</p>



<a name="273131410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273131410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273131410">(Feb 24 2022 at 18:39)</a>:</h4>
<p>Since F* has subtyping, I think you can say the type of max is A -&gt; A -&gt; A too</p>



<a name="273131536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273131536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273131536">(Feb 24 2022 at 18:41)</a>:</h4>
<p>Oh I assumed we were talking about, say, the maximum of a list</p>



<a name="273131546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273131546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273131546">(Feb 24 2022 at 18:41)</a>:</h4>
<p>Yeah, I guess! I just find it much harder to read.</p>



<a name="273132044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273132044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273132044">(Feb 24 2022 at 18:45)</a>:</h4>
<p>Again I don't know much about F* (including the name, lol) but the fact that the max operation on an ordering is determined by the other structure is at the very least conceptually important--it means you don't have to worry about where the operation came from, or about keeping definitions of max coherent. In the Lean approach you just know it is a function, and then you have to worry about its definition and coherence and so on</p>



<a name="273133037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273133037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273133037">(Feb 24 2022 at 18:53)</a>:</h4>
<p>Anyways the main point is that "define things and then prove facts about them" is non-modular if you don't have some other form of discipline, since a proof about a definition is coupled to that definition.</p>



<a name="273134376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273134376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273134376">(Feb 24 2022 at 19:03)</a>:</h4>
<p>I think F* is mainly aimed at program verification, right? So then it makes sense that you would have a lot of functions like <code>list.max</code> that are intended to fulfill some given specification, and you want to treat them as opaque and not transparent.</p>



<a name="273136045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20and%20other%20languages/near/273136045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20and.20other.20languages.html#273136045">(Feb 24 2022 at 19:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Lean.20and.20other.20languages/near/273132044">said</a>:</p>
<blockquote>
<p>Again I don't know much about F* (including the name, lol) but the fact that the max operation on an ordering is determined by the other structure is at the very least conceptually important--it means you don't have to worry about where the operation came from, or about keeping definitions of max coherent. In the Lean approach you just know it is a function, and then you have to worry about its definition and coherence and so on</p>
</blockquote>
<p>We-ll, actually in Lean you know some of its properties inherently - but yeah this is essentially why F* does things that way I think.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Haskell.20is.20inconsistent.3F.3F.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell.20is.20inconsistent.3F.3F.3F.html">Haskell is inconsistent???</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="193762523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%20is%20inconsistent%3F%3F%3F/near/193762523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell.20is.20inconsistent.3F.3F.3F.html#193762523">(Apr 13 2020 at 11:12)</a>:</h4>
<p>Looks like it is a well-known fact that <a href="https://www.cs.unm.edu/~stelleg/liar.html" title="https://www.cs.unm.edu/~stelleg/liar.html">Haskell is inconsistent</a>. What does it mean and does it matter?</p>



<a name="193762691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%20is%20inconsistent%3F%3F%3F/near/193762691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell.20is.20inconsistent.3F.3F.3F.html#193762691">(Apr 13 2020 at 11:15)</a>:</h4>
<p>If you use the Curry Howard isomorphism, aka propositions as types, any type theory has a corresponding logic. However, any programming language that is turing complete, with unguarded recursion or infinite loops, corresponds to a logic that is inconsistent. This is fine because these logics aren't being used for proving things, and it doesn't mean that you can necessarily break the type system (of course, you might still be able to break the type system for other reasons, e.g. unchecked cast).</p>



<a name="193762759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%20is%20inconsistent%3F%3F%3F/near/193762759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell.20is.20inconsistent.3F.3F.3F.html#193762759">(Apr 13 2020 at 11:16)</a>:</h4>
<p>Here's an easy haskell style proof of false:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">foo</span>
</pre></div>



<a name="193762793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%20is%20inconsistent%3F%3F%3F/near/193762793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell.20is.20inconsistent.3F.3F.3F.html#193762793">(Apr 13 2020 at 11:17)</a>:</h4>
<p>in haskell this term is called "bottom" and it inhabits every type</p>



<a name="193771330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Haskell%20is%20inconsistent%3F%3F%3F/near/193771330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Haskell.20is.20inconsistent.3F.3F.3F.html#193771330">(Apr 13 2020 at 13:24)</a>:</h4>
<p>And there are many more complicated ones, starting with the one you linked to. But happily since Haskell has general recursion anyways, we can declare them not to be problems and get lots of other nice things, like non-strictly positive inductive types and so on.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html">inherit typeclass instances for a wrapper structure</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206223914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206223914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206223914">(Aug 07 2020 at 04:49)</a>:</h4>
<p>Hi, I have a simple wrapper </p>
<div class="codehilite"><pre><span></span><code>  <span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>
  <span class="kn">structure</span> <span class="n">Address</span> <span class="o">:=</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span>
</code></pre></div>


<p>but want to assign some properties for it already defined for ints (e.g. <code>linear_order</code>) . Is there a straightforward way of defining  instances  like this beyond duplicating all the code for ints?</p>



<a name="206225755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206225755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206225755">(Aug 07 2020 at 05:40)</a>:</h4>
<p>We have quite a few <code>def</code>s/<code>lemma</code>s that transfer instances along equivalences.</p>



<a name="206225771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206225771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206225771">(Aug 07 2020 at 05:41)</a>:</h4>
<p>E.g., look at <code>data/equiv/transfer_instance</code> for algebraic types and <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_order.lift">docs#linear_order.lift</a> etc for <code>order</code>.</p>



<a name="206228361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206228361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206228361">(Aug 07 2020 at 06:44)</a>:</h4>
<p>Thanks, that puts me on track to solve this!  It feels basic but  I'm going in circles trying to prove the  equivalence. I can prove a bijection from int to Address but cannot prove an injection from Address to int, which is what I need</p>
<div class="codehilite"><pre><span></span><code>  <span class="c1">-- linear_order.lift needs an injective function TO the type that already has</span>
  <span class="c1">-- a linear_order instance</span>
  <span class="n">def</span> <span class="n">cast_address</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">Address</span><span class="o">):</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span>

  <span class="c1">-- needed to prove bij below</span>
  <span class="kn">lemma</span> <span class="n">val_mk_inverse</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">:</span> <span class="n">Address</span><span class="o">,</span> <span class="o">(</span><span class="n">Address</span><span class="bp">.</span><span class="n">mk</span> <span class="n">z</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span> <span class="n">cases</span> <span class="n">z</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="kn">end</span>
  <span class="c1">-- That the inverse of cast_address is surjective might be useful?</span>
  <span class="kn">lemma</span> <span class="n">bij</span><span class="o">:</span>  <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">Address</span><span class="bp">.</span><span class="n">mk</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">unfold</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="o">{</span><span class="n">finish</span><span class="o">},</span> <span class="c1">-- injectivity handled automatically</span>
    <span class="n">unfold</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span><span class="o">,</span> <span class="n">intros</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H</span><span class="o">:</span> <span class="n">Address</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">b</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">val_mk_inverse</span>  <span class="n">b</span><span class="o">,</span>
    <span class="n">exact</span> <span class="bp">⟨</span><span class="n">b</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">H</span><span class="bp">⟩</span>
  <span class="kn">end</span>

  <span class="kn">lemma</span> <span class="n">inj</span><span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">cast_address</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">unfold</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span><span class="o">,</span> <span class="n">intros</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">castEq</span><span class="o">,</span>
   <span class="n">unfold</span> <span class="n">cast_address</span> <span class="n">at</span> <span class="n">castEq</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">Hinj</span><span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">Address</span><span class="bp">.</span><span class="n">mk</span> <span class="o">:=</span> <span class="n">bij</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
      <span class="n">unfold</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">at</span> <span class="n">Hinj</span><span class="o">,</span>

      <span class="c1">-- have Hsur: function.surjective Address.mk := bij.2,</span>

      <span class="c1">-- unfold function.surjective at Hsur,</span>

    <span class="n">cases</span> <span class="n">Address</span><span class="bp">.</span><span class="n">decidable_eq</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span>


    <span class="c1">-- have Hsur: function.surjective Address.mk := bij.2,</span>
    <span class="c1">-- unfold function.surjective at Hsur,</span>
    <span class="c1">-- have h1 := Hsur a1, have h2 := Hsur a2,</span>
    <span class="c1">-- cases eq1: h1 with h1v h1&#39;, cases eq2: h2 with h2v h2&#39;,</span>
    <span class="c1">-- rw &lt;-h1&#39;, rw &lt;-h2&#39;, simp,</span>
    <span class="c1">-- have Hinj: function.injective Address.mk := bij.1,</span>
    <span class="c1">-- unfold function.injective at Hinj,</span>
    <span class="c1">-- have Hinj&#39; := @Hinj h1v h2v,</span>
    <span class="c1">-- apply Hinj&#39;,</span>
    <span class="c1">-- simp,</span>
  <span class="kn">end</span>
</code></pre></div>


<p>Is there an easy way to do this for a simple wrapper?</p>



<a name="206233763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206233763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206233763">(Aug 07 2020 at 08:23)</a>:</h4>
<p>Also not having luck trying to extract the the inverse from the bijection</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">def</span> <span class="n">inverse_of_bijection_is_injective</span><span class="o">:</span> <span class="err">Σ&#39;</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">Address</span> <span class="bp">→</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">f</span> <span class="o">:=</span>
    <span class="c1">-- Error right at the start: &quot;induction tactic failed,</span>
    <span class="c1">-- recursor &#39;Exists.dcases_on&#39; can only eliminate into Prop&quot;</span>
    <span class="k">match</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective_iff_has_inverse</span><span class="bp">.</span><span class="n">mp</span> <span class="n">bij</span> <span class="k">with</span>
     <span class="bp">|</span> <span class="bp">⟨</span><span class="n">a</span> <span class="o">,</span><span class="n">b</span> <span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">_</span>
     <span class="kn">end</span>
</code></pre></div>


<p>Different error which I also don't fully grasp when I try this in tactic mode:</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">def</span> <span class="n">cast_to_int&#39;</span><span class="o">:</span> <span class="err">Σ&#39;</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">Address</span> <span class="bp">→</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">f</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="k">have</span> <span class="n">H</span> <span class="o">:=</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective_iff_has_inverse</span><span class="bp">.</span><span class="n">mp</span> <span class="n">bij</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="n">H</span><span class="o">,</span> <span class="c1">-- existsi tactic failed, type mismatch between given</span>
               <span class="c1">--term witness and expected type</span>

    <span class="kn">end</span>
</code></pre></div>



<a name="206239347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206239347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206239347">(Aug 07 2020 at 09:42)</a>:</h4>
<p>You shouldn't be proving things like <code>bijective</code>, you should be writing down functions in each direction and proving they're inverses of each other, ie making a term of type <code>equiv Address int</code></p>



<a name="206239483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206239483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206239483">(Aug 07 2020 at 09:45)</a>:</h4>
<p>To get an inverse operation from a bijection you need the axiom of choice -- why not just build the inverse explicitly and use that</p>



<a name="206240635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206240635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Wong <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206240635">(Aug 07 2020 at 10:00)</a>:</h4>
<p>To explain your error: <code>bijective</code> is defined as a Prop (does not contain data). But <code>Σ</code> is a Type (contains data) and so needs a concrete witness to construct. (Technically your code uses <code>Σ'</code> but the principle is the same.)</p>



<a name="206240896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206240896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206240896">(Aug 07 2020 at 10:05)</a>:</h4>
<p>I see now - thanks for explaining the error and connection to choice. And eventually was able to prove the injectivity (don't know why it took me so many attempts):</p>
<div class="codehilite"><pre><span></span><code>  <span class="kn">structure</span> <span class="n">Address</span><span class="o">:=</span> <span class="o">(</span><span class="n">val</span><span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span>
  <span class="n">def</span> <span class="n">to_z</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">Address</span><span class="o">):</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span>

  <span class="kn">lemma</span> <span class="n">to_z_inj</span><span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">to_z</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">unfold</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span><span class="o">,</span>
    <span class="n">intros</span>  <span class="n">t1</span> <span class="n">t2</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e1</span><span class="o">:</span><span class="n">t1</span><span class="o">,</span> <span class="n">cases</span> <span class="n">e2</span><span class="o">:</span><span class="n">t2</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span><span class="n">unfold</span> <span class="n">to_z</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">e1</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span> <span class="n">rw</span> <span class="n">e2</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
  <span class="kn">end</span>
</code></pre></div>



<a name="206243301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206243301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206243301">(Aug 07 2020 at 10:42)</a>:</h4>
<p>The <code>equiv</code> is easier to make and all the lemmas which you're proving are already proved for general <code>equiv</code>s.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>
<span class="kn">structure</span> <span class="n">Address</span> <span class="o">:=</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">cast_address</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">Address</span><span class="o">):</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">a</span><span class="bp">.</span><span class="n">val</span>

<span class="n">def</span> <span class="n">inv_fun</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Address</span> <span class="o">:=</span> <span class="n">Address</span><span class="bp">.</span><span class="n">mk</span> <span class="n">n</span>

<span class="n">def</span> <span class="n">bij</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">Address</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">cast_address</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">inv_fun</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">rintro</span> <span class="bp">⟨</span><span class="n">n</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intro</span> <span class="n">n</span><span class="o">,</span> <span class="n">refl</span> <span class="o">}</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">val_mk_inverse</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">:</span> <span class="n">Address</span><span class="o">,</span> <span class="o">(</span><span class="n">Address</span><span class="bp">.</span><span class="n">mk</span> <span class="n">z</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">bij</span><span class="bp">.</span><span class="n">left_inv</span>

<span class="kn">lemma</span> <span class="n">bij&#39;</span> <span class="o">:</span>  <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">Address</span><span class="bp">.</span><span class="n">mk</span> <span class="o">:=</span> <span class="n">bij</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">bijective</span>

<span class="kn">lemma</span> <span class="n">inj</span><span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">cast_address</span> <span class="o">:=</span> <span class="n">bij</span><span class="bp">.</span><span class="n">injective</span>
</code></pre></div>



<a name="206243354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206243354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206243354">(Aug 07 2020 at 10:43)</a>:</h4>
<p>If you are in a situation where you can write down the inverse, rather than just abstractly proving that a function is bijective (a weaker statement because it's a Prop rather than data) then you should write down the inverse; it makes your objects much easier to work with.</p>



<a name="206245038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206245038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206245038">(Aug 07 2020 at 11:08)</a>:</h4>
<p><span class="user-mention" data-user-id="312852">@Kris Brown</span> what do you need this for? (<a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a>)</p>



<a name="206321277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inherit%20typeclass%20instances%20for%20a%20wrapper%20structure/near/206321277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inherit.20typeclass.20instances.20for.20a.20wrapper.20structure.html#206321277">(Aug 07 2020 at 23:55)</a>:</h4>
<p>I'll interpret that question pretty broadly. I'm working on a project for formally verified Go code.  My initial work was modeling Hoare logic based on this resource (<a href="https://github.com/coq-community/hoare-tut">https://github.com/coq-community/hoare-tut</a>) , and lately I've switched to modeling separation logic based on this resource (<a href="https://github.com/affeldt-aist/seplog/blob/master/seplog/seplog.v">https://github.com/affeldt-aist/seplog/blob/master/seplog/seplog.v</a>). </p>
<p>I've copied definitions of some of the core data structures to give a feel for the project.</p>
<div class="codehilite"><pre><span></span><code>  <span class="kn">inductive</span> <span class="n">GoTypeDecl</span><span class="o">:</span> <span class="kt">Type</span>
   <span class="bp">|</span> <span class="n">gInt</span><span class="o">:</span>  <span class="n">GoTypeDecl</span>
   <span class="bp">|</span> <span class="n">gStr</span><span class="o">:</span>  <span class="n">GoTypeDecl</span>
   <span class="bp">|</span> <span class="n">gErr</span><span class="o">:</span>  <span class="n">GoTypeDecl</span>
   <span class="bp">|</span> <span class="n">gBool</span><span class="o">:</span> <span class="n">GoTypeDecl</span>
   <span class="bp">|</span> <span class="n">gPtr</span><span class="o">:</span>  <span class="n">GoTypeDecl</span> <span class="bp">→</span> <span class="n">GoTypeDecl</span>
   <span class="bp">|</span> <span class="n">gRef</span><span class="o">:</span>  <span class="n">string</span> <span class="bp">→</span> <span class="n">GoTypeDecl</span>

  <span class="kn">inductive</span> <span class="n">GoPrimType</span><span class="o">:</span> <span class="kt">Type</span>
   <span class="bp">|</span> <span class="n">pInt</span><span class="o">:</span>  <span class="bp">ℤ</span>  <span class="bp">→</span> <span class="n">GoPrimType</span>
   <span class="bp">|</span> <span class="n">pStr</span><span class="o">:</span>  <span class="n">string</span>  <span class="bp">→</span> <span class="n">GoPrimType</span>
   <span class="bp">|</span> <span class="n">pErr</span><span class="o">:</span>  <span class="n">string</span>  <span class="bp">→</span> <span class="n">GoPrimType</span>
   <span class="bp">|</span> <span class="n">pBool</span><span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">GoPrimType</span>
   <span class="bp">|</span> <span class="n">pPt</span><span class="o">:</span> <span class="n">GoTypeDecl</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="n">GoPrimType</span>
   <span class="bp">|</span> <span class="n">pStruct&#39;</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">fields</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">string</span><span class="o">)</span>
              <span class="o">(</span><span class="n">vals</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">fields</span><span class="o">,</span> <span class="n">GoPrimType</span><span class="o">)</span> <span class="o">:</span> <span class="n">GoPrimType</span>

  <span class="kn">structure</span> <span class="n">GoStruct</span> <span class="o">(</span><span class="n">name</span><span class="o">:</span> <span class="n">string</span><span class="o">):=</span>
     <span class="o">(</span><span class="n">fields</span><span class="o">:</span> <span class="n">finset</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">vals</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">fields</span><span class="o">,</span> <span class="n">GoPrimType</span><span class="o">)</span>

<span class="n">def</span> <span class="n">type_dict</span><span class="o">:</span> <span class="n">GoTypeDecl</span> <span class="bp">→</span> <span class="kt">Type</span>
    <span class="bp">|</span> <span class="n">gStr</span>    <span class="o">:=</span> <span class="n">string</span>
    <span class="bp">|</span> <span class="n">gErr</span>    <span class="o">:=</span> <span class="n">string</span>
    <span class="bp">|</span> <span class="n">gInt</span>    <span class="o">:=</span> <span class="bp">ℤ</span>
    <span class="bp">|</span> <span class="n">gBool</span>   <span class="o">:=</span> <span class="n">bool</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">gPtr</span> <span class="bp">_</span><span class="o">):=</span> <span class="bp">ℤ</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">gRef</span> <span class="n">s</span><span class="o">):=</span> <span class="n">GoStruct</span> <span class="n">s</span>

  <span class="kn">structure</span> <span class="n">Address</span> <span class="o">:=</span> <span class="o">(</span><span class="n">val</span><span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span>
  <span class="kn">structure</span> <span class="n">Heap</span> <span class="o">:=</span> <span class="o">(</span><span class="n">vals</span><span class="o">:</span> <span class="n">finmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span> <span class="n">Address</span><span class="o">,</span> <span class="err">Σ</span> <span class="n">dt</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">,</span> <span class="n">type_dict</span> <span class="n">dt</span><span class="o">))</span>
  <span class="kn">structure</span> <span class="n">Store</span> <span class="o">:=</span>   <span class="o">(</span><span class="n">vals</span><span class="o">:</span> <span class="n">finmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span> <span class="n">string</span><span class="o">,</span> <span class="err">Σ</span> <span class="n">dt</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">,</span> <span class="n">type_dict</span> <span class="n">dt</span><span class="o">))</span>
  <span class="kn">structure</span> <span class="n">Var</span> <span class="o">(</span><span class="n">t</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">name</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span>

  <span class="kn">inductive</span> <span class="n">Expr</span><span class="o">:</span> <span class="n">GoTypeDecl</span> <span class="bp">→</span> <span class="kt">Type</span>
   <span class="bp">|</span> <span class="n">const</span>  <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span> <span class="n">type_dict</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span>
   <span class="bp">|</span> <span class="n">getvar</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span> <span class="n">Var</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span>
   <span class="bp">|</span> <span class="n">relop</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span>
      <span class="n">Relop</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">gBool</span>
   <span class="bp">|</span> <span class="n">binop</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span>
      <span class="n">Binop</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span>
   <span class="bp">|</span> <span class="n">unop</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span>
      <span class="n">Unop</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">get_field</span> <span class="o">{</span><span class="n">struct</span><span class="o">:</span> <span class="n">string</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span>
      <span class="n">Expr</span> <span class="o">(</span><span class="n">gRef</span> <span class="n">struct</span><span class="o">)</span> <span class="bp">→</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">update_field</span> <span class="o">{</span><span class="n">struct</span><span class="o">:</span> <span class="n">string</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span> <span class="c1">-- pure update/not mutation</span>
      <span class="n">Expr</span> <span class="o">(</span><span class="n">gRef</span> <span class="n">struct</span><span class="o">)</span> <span class="bp">→</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="o">(</span><span class="n">gRef</span> <span class="n">struct</span><span class="o">)</span>

  <span class="kn">inductive</span> <span class="n">cmd</span><span class="o">:</span> <span class="kt">Type</span>
    <span class="bp">|</span> <span class="n">skip</span><span class="o">:</span> <span class="n">cmd</span>
    <span class="bp">|</span> <span class="n">assign</span>   <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span> <span class="n">Var</span> <span class="n">α</span>         <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span>        <span class="bp">→</span> <span class="n">cmd</span>
    <span class="bp">|</span> <span class="n">lookup</span>   <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span> <span class="n">Var</span> <span class="n">α</span>         <span class="bp">→</span> <span class="n">Expr</span> <span class="o">(</span><span class="n">gPtr</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">cmd</span>
    <span class="bp">|</span> <span class="n">mutation</span> <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span> <span class="n">Expr</span> <span class="o">(</span><span class="n">gPtr</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Expr</span> <span class="n">α</span>        <span class="bp">→</span> <span class="n">cmd</span>
    <span class="bp">|</span> <span class="n">while</span><span class="o">:</span>                    <span class="n">Expr</span> <span class="n">gBool</span>    <span class="bp">→</span> <span class="n">cmd</span>           <span class="bp">→</span> <span class="n">cmd</span>
    <span class="bp">|</span> <span class="n">seq</span><span class="o">:</span>                      <span class="n">cmd</span>           <span class="bp">→</span> <span class="n">cmd</span>           <span class="bp">→</span> <span class="n">cmd</span>
    <span class="bp">|</span> <span class="n">ifte</span><span class="o">:</span>                     <span class="n">Expr</span> <span class="n">gBool</span>    <span class="bp">→</span> <span class="n">cmd</span>           <span class="bp">→</span> <span class="n">cmd</span> <span class="bp">→</span> <span class="n">cmd</span>
    <span class="bp">|</span> <span class="n">declare</span>  <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span> <span class="n">Var</span> <span class="o">(</span><span class="n">gPtr</span> <span class="n">α</span><span class="o">)</span>  <span class="bp">→</span> <span class="n">cmd</span>
    <span class="bp">|</span> <span class="n">isnil</span>    <span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}:</span> <span class="n">Expr</span> <span class="o">(</span><span class="n">gPtr</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Var</span> <span class="n">gBool</span>     <span class="bp">→</span> <span class="n">cmd</span>
    <span class="bp">|</span> <span class="n">call</span> <span class="o">{</span><span class="n">β</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">}</span> <span class="o">{</span><span class="n">struct</span><span class="o">:</span> <span class="n">string</span><span class="o">}</span>
           <span class="o">(</span><span class="n">callee</span><span class="o">:</span> <span class="n">Expr</span> <span class="o">(</span><span class="n">gRef</span> <span class="n">struct</span><span class="o">))</span> <span class="c1">-- object whose method is called</span>
           <span class="o">(</span><span class="n">method</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span>             <span class="c1">-- Name of method</span>
           <span class="o">(</span><span class="n">arg</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="err">Σ</span> <span class="n">α</span><span class="o">,</span> <span class="n">Expr</span> <span class="n">α</span><span class="o">))</span>    <span class="c1">-- Values we want to pass to the func</span>
           <span class="o">(</span><span class="n">result</span><span class="o">:</span> <span class="n">Var</span> <span class="n">β</span><span class="o">)</span>              <span class="c1">-- store result in this variable</span>
           <span class="o">:</span> <span class="n">cmd</span><span class="bp">.</span>

  <span class="kn">structure</span> <span class="n">Sig</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">args</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">GoTypeDecl</span><span class="o">))</span>
    <span class="o">(</span><span class="n">return</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">GoTypeDecl</span><span class="o">))</span>
    <span class="o">(</span><span class="n">receiver</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">is_ptr</span><span class="o">:</span> <span class="n">bool</span><span class="o">)</span>

  <span class="kn">structure</span> <span class="n">GoStructDecl</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">string</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">fields</span><span class="o">:</span> <span class="n">pairmap</span> <span class="n">string</span> <span class="n">GoTypeDecl</span><span class="o">)</span>
    <span class="o">(</span><span class="n">methods</span><span class="o">:</span> <span class="n">pairmap</span> <span class="n">string</span> <span class="o">(</span><span class="n">Sig</span> <span class="bp">×</span> <span class="n">cmd</span><span class="o">))</span>

  <span class="kn">structure</span> <span class="n">Decls</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">structs</span><span class="o">:</span> <span class="n">finmap</span> <span class="o">((</span><span class="bp">λ</span> <span class="n">s</span><span class="o">:</span> <span class="n">string</span><span class="o">,</span> <span class="err">Σ</span> <span class="bp">_</span><span class="o">:</span><span class="n">unit</span><span class="o">,</span> <span class="n">GoStructDecl</span> <span class="n">s</span><span class="o">)))</span>

  <span class="n">def</span> <span class="n">Ctx</span> <span class="o">:=</span> <span class="n">Store</span> <span class="bp">×</span> <span class="n">Heap</span> <span class="bp">×</span>  <span class="n">Decls</span>

 <span class="c1">-- semantics of expressions</span>
  <span class="n">def</span> <span class="kn">eval</span><span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">α</span><span class="o">:</span> <span class="n">GoTypeDecl</span><span class="o">},</span> <span class="n">Expr</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Store</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">type_dict</span> <span class="n">α</span><span class="o">)</span>
<span class="c1">-- Semantics of program commands</span>
<span class="kn">inductive</span> <span class="n">exec</span> <span class="o">:</span> <span class="n">option</span> <span class="n">Ctx</span> <span class="bp">→</span> <span class="n">cmd</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">Ctx</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="c1">-- [A bunch of lemmas related to separation logic, weakest preconditions]</span>
</code></pre></div>


<p>To answer the question narrowly, I want to define a <code>to_string</code> method for <code>Heap</code> and I need to convert the map into a list of pairs that can be printed, which requires a decidable linear order on the keys. I could just use raw integers instead of defining <code>Address</code>, but I like the type-safety since integers are used in lots of places.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
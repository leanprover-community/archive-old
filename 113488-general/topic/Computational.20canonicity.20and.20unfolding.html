---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Computational.20canonicity.20and.20unfolding.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20canonicity.20and.20unfolding.html">Computational canonicity and unfolding</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="211136528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20canonicity%20and%20unfolding/near/211136528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Pedro Minicz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20canonicity.20and.20unfolding.html#211136528">(Sep 24 2020 at 14:11)</a>:</h4>
<p>Lean sometimes forces you to unfold definitions. Some tactics, like <code>rw</code>, may fail a given goal, but succeed in a <em>definitionally</em> equal term after unfolding. I've noticed this since I've migrated from Coq (I am by no means an "expert" Coq user) that some goals in Lean need <code>unfold</code> or <code>dsimp</code> there Coq made me expect them to "just work."</p>
<p>While listening to the "Every proof assistant: Cubical Agda" talk (can be found <a href="http://math.andrej.com/2020/09/10/cubical-agda/">here</a>), around 10 minutes in, the speaker explains that one of the drawbacks of adding axioms such as <code>funext</code> is that you break canonicity and, therefore, proofs may become longer because of the necessity of manual unfolding among other things. This is quite interesting. Between Agda, Coq, and Lean, Lean is the only one that actively uses such axioms, that is, while one can postulate <code>funext</code> and friends in Agda and Coq, it is "not encouraged", while in Lean <code>funext</code>, <code>propext</code>, and <code>choice</code> are in the prelude.</p>
<p>My question is: has the "embracing" of axioms influenced how Lean treats expressions modulo beta-reduction/unfolding?</p>



<a name="211136773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational%20canonicity%20and%20unfolding/near/211136773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Computational.20canonicity.20and.20unfolding.html#211136773">(Sep 24 2020 at 14:13)</a>:</h4>
<p>I'm pretty sure this is only a performance choice for <code>rw</code>. We do have tactics that see through definitions. That's one of the reason to use <code>simp_rw</code> for instance.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/37.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html">37</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="202211440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202211440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202211440">(Jun 28 2020 at 00:17)</a>:</h4>
<p>I am proud to have inserted what is as far as I know the first 37 in mathlib, put there at request of the inhabited linter. Nobody cared. Similarly 1/0 to a mathematician is just junk. The computer scientists insist on returning a value such as 0 simply because it is more convenient computationally.<br>
Could one define a mathematician's division on the reals or more generally any field in the following way : <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x/y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> in maths node is what we both agree on for y nonzero, and for y=0 it is a value called <code>junk</code>, a term which is a default value of every type? Am I working in some junk monad or something? We could recover mathematically correct natural subtraction this way. Is <code>omega</code> easier to write for mathematician's subtraction? We promise this question isn't junk, now let <code>ring</code> solve <code>a-b+b=a</code> because omega is buggy (note to self: add link to Rob issue). Turns out mathematicians might be happy to enter <code>a&lt;=b</code> into the typeclass system. </p>
<p>Mathematicians can't understand why a-b+b=a on nat is not done by <code>ring</code>.</p>



<a name="202211502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202211502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202211502">(Jun 28 2020 at 00:19)</a>:</h4>
<p>I think you're just talking about the Maybe / option monad</p>



<a name="202214373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202214373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202214373">(Jun 28 2020 at 01:48)</a>:</h4>
<p>The specific proposal is slightly different than option. In optional division, a / b = None if and only if b = 0.  In junk division, a / b = junk if b = 0 or b * junk = a since junk is a number.  As I see it junk division has the advantage also that you don’t have to constantly use monadic operations to get the result from inside the monad.  But it has some of the same disadvantages as the current division, with slightly less downsides since you can’t use the fact that 1/0 = 0 (but you can still use the fact that 1/0 is some arbitrary real number).</p>



<a name="202214482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202214482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202214482">(Jun 28 2020 at 01:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> <a href="#narrow/stream/113488-general/topic/37/near/202214373">said</a>:</p>
<blockquote>
<p>The specific proposal is slightly different than option. In optional division, a / b = None if and only if b = 0.  In junk division, a / b = junk if b = 0 or b * junk = a since junk is a number.  As I see it junk division has the advantage also that you don’t have to constantly use monadic operations to get the result from inside the monad.  But it has some of the same disadvantages as the current division, with slightly less downsides since you can’t use the fact that 1/0 = 0 (but you can still use the fact that 1/0 is some arbitrary real number).</p>
</blockquote>
<p>In optional division we should have <code>a / b = None</code> when <code>a = None</code> as well, which matches your description of junk division -- though I suppose this depends on how exactly we're defining optional division</p>



<a name="202214621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202214621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202214621">(Jun 28 2020 at 01:55)</a>:</h4>
<p>I assume it was</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">divOpt</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">real</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">real</span><span class="o">)</span> <span class="o">:</span> <span class="n">real</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">none</span> <span class="k">else</span> <span class="n">a</span><span class="bp">/</span><span class="n">b</span>
</code></pre></div>


<p>where a/b is the current division.  In your proposal, you are adding an additional element to the reals.</p>



<a name="202214694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202214694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202214694">(Jun 28 2020 at 01:57)</a>:</h4>
<p>Right, I think this is what Kevin was talking about though - a default value of every type</p>



<a name="202214739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202214739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202214739">(Jun 28 2020 at 01:58)</a>:</h4>
<p>I think he wants that default value to still be an element of the type, but you can't prove what it is.  (And to be clear, I assume we are only talking about inhabited types. <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span> )</p>



<a name="202214836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202214836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202214836">(Jun 28 2020 at 02:01)</a>:</h4>
<p>Actually, I read it again. Maybe that is what he meant.</p>



<a name="202215116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215116">(Jun 28 2020 at 02:09)</a>:</h4>
<p>In Scala, types can can be subtypes of other types.  One interesting consequence is that the error type is a subtype all all types.  So you can write, something like <code>if b = 0 then error else a/b</code>, but of course Scala isn't a theorem prover and if one isn't careful you can easily break consistency here. I assume one would have a real difficult time making a division using any method that is both (1) easy to use and (2) doesn't allow you to prove some <br>
"false theorem", like <code>exists a: real, 1 / a = a</code>.</p>



<a name="202215171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215171">(Jun 28 2020 at 02:10)</a>:</h4>
<p>I think with Lean's hidden coercions though (especially into <code>option</code>) we can mimic Scala's subtyping - or at least be able to divide nicely - while remaining within the option monad</p>



<a name="202215303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215303">(Jun 28 2020 at 02:14)</a>:</h4>
<p>I wonder if instead, one defined division with an implicit or type class assumption {h : b ne 0} or [h : b ne 0].  So if one writes <code>a/b</code> they have to have in the context that <code>b != 0</code>.  I also, haven't thought this through though.</p>



<a name="202215316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215316">(Jun 28 2020 at 02:14)</a>:</h4>
<p>I think this idea has come up a bunch of times, my recollection was that it's nice in theory but awkward in practice</p>



<a name="202215330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215330">(Jun 28 2020 at 02:15)</a>:</h4>
<p>I think you idea would be the same, no. <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>



<a name="202215333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215333">(Jun 28 2020 at 02:15)</a>:</h4>
<p>I don't immediately see why</p>



<a name="202215384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215384">(Jun 28 2020 at 02:16)</a>:</h4>
<p>Well consider the theorem if a/a = a then a = 1.  Is this true in this optional reals?  I don't think so, unless we change the meaning of quantifiers.</p>



<a name="202215481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215481">(Jun 28 2020 at 02:20)</a>:</h4>
<p>Also, I imagine a coersion from <code>some n</code> to <code>n</code> say causing a number of small difficulties.  Does <code>foo (x/y)</code> even type check if <code>foo : real -&gt; real</code> and <code>y = None</code>?</p>



<a name="202215654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215654">(Jun 28 2020 at 02:24)</a>:</h4>
<p>No, the coercion is the other way</p>



<a name="202215662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215662">(Jun 28 2020 at 02:24)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">def</span> <span class="n">optional_div</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">option</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">option</span> <span class="n">ℝ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">some</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">y</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">some</span> <span class="o">(</span><span class="n">x</span> <span class="bp">/</span> <span class="n">y</span><span class="o">)</span> <span class="k">else</span> <span class="n">none</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">),</span> <span class="n">optional_div</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">ite</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">=</span> <span class="bp">_</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">split_ifs</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">injection</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">div_self</span> <span class="n">h</span> <span class="n">at</span> <span class="n">h_1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h_1</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">injection</span> <span class="n">hx</span> <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202215669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215669">(Jun 28 2020 at 02:25)</a>:</h4>
<p>I don't actually know Lean's option API very well so it could well be possible to improve this, but I hope it illustrates what I mean</p>



<a name="202215708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215708">(Jun 28 2020 at 02:26)</a>:</h4>
<p>I don't see how the difficulties which come with typeclass/implicit parameters transfer to this, but I don't for a second doubt that there could be other difficulties</p>



<a name="202215734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Olson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215734">(Jun 28 2020 at 02:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> There is a field-like algebraic structure called a "meadow" with division-by-zero, and one variant of meadows literally defines <code>1 / 0 = junk</code> as you suggested, and otherwise coincides with the field division operator. They are discussed here for example: <a href="https://arxiv.org/abs/1406.6878v3">https://arxiv.org/abs/1406.6878v3</a> (The paper uses the name <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">a</mi></mrow><annotation encoding="application/x-tex">\bold{a}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">a</span></span></span></span></span> for <code>junk</code>.)</p>



<a name="202215795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Olson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215795">(Jun 28 2020 at 02:29)</a>:</h4>
<p>I'm curious how far you could get defining everything in terms of meadows and then showing field-specific theorems under the hypothesis <code>denom ≠ 0</code> (just as you do now with <code>1 / 0 = 0</code> or <code>1 / 0 = 37</code>). The upside is that there's also a sensible algebraic theory for <code>1 / 0 = junk</code>, it's just not fields.</p>



<a name="202215854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202215854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Olson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202215854">(Jun 28 2020 at 02:30)</a>:</h4>
<p>Incidentally there's also a version of meadows with <code>1 / 0 = 0</code>, but the authors of this paper at least seem to prefer the other version.</p>



<a name="202216027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216027">(Jun 28 2020 at 02:36)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> That is interesting!</p>



<a name="202216356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216356">(Jun 28 2020 at 02:47)</a>:</h4>
<p>Another option would be to use the powerset monad instead of the Maybe monad, and define x/0 to be everything.</p>



<a name="202216403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216403">(Jun 28 2020 at 02:48)</a>:</h4>
<p>That's an interesting idea! Maybe we could get a theory of multivalued functions too then</p>



<a name="202216412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216412">(Jun 28 2020 at 02:49)</a>:</h4>
<p>Algebra has things called "hyperstructures" where operations take values in sets</p>



<a name="202216414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216414">(Jun 28 2020 at 02:49)</a>:</h4>
<p>So it's not that crazy of an idea :)</p>



<a name="202216420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216420">(Jun 28 2020 at 02:49)</a>:</h4>
<p>Fair, I just hadn't heard of hyperstructures, nor thought of applying nondeterminism monads to Lean</p>



<a name="202216465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216465">(Jun 28 2020 at 02:50)</a>:</h4>
<p>You can do this with any monad actually, just work internally in the Kleisli category</p>



<a name="202216487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216487">(Jun 28 2020 at 02:52)</a>:</h4>
<p>I'm not sure we want to be in the Kleisli category here though, it seems more natural to me to define operations on <code>T ℝ</code> and have the monad's unit as an implicit coercion</p>



<a name="202216530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216530">(Jun 28 2020 at 02:53)</a>:</h4>
<p>I agree.. you want to quantify over terms in the original type. The maps are taken in the Kleisli category though.</p>



<a name="202216542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216542">(Jun 28 2020 at 02:53)</a>:</h4>
<p>I think this is essentially what you were suggesting with the Maybe monad, right?</p>



<a name="202216933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216933">(Jun 28 2020 at 03:06)</a>:</h4>
<p>Currently the following doesn't type check:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">add</span> <span class="n">x</span> <span class="o">(</span><span class="n">optional_div</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>


<p>But I assume that is just because there aren't enough coercion rules.</p>



<a name="202216943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216943">(Jun 28 2020 at 03:07)</a>:</h4>
<p>Also the same with <code>+</code> in place of <code>add</code> but that is because <code>option ℝ</code> doesn't have <code>has_add</code>.  I think you want to make this work without the user noticing this, you would have to go through every type class and extend it to <code>option alpha</code> if appropriate (or find a way to do it automatically, like Scala's implicit macros).</p>



<a name="202216989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216989">(Jun 28 2020 at 03:08)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">option</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">option</span><span class="bp">.</span><span class="n">defs</span>
<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">def</span> <span class="n">ℝ&#39;</span> <span class="o">:=</span> <span class="n">option</span> <span class="n">ℝ</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">ℝ</span> <span class="n">ℝ&#39;</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">some</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="n">ℝ&#39;</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">x</span> <span class="bp">&lt;*&gt;</span> <span class="n">y</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">ℝ&#39;</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">x</span> <span class="bp">&lt;*&gt;</span> <span class="n">y</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_inv</span> <span class="n">ℝ&#39;</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">bind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">ite</span> <span class="o">(</span><span class="n">y</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="err">↑</span><span class="o">(</span><span class="n">y</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="n">none</span><span class="o">)</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_div</span> <span class="n">ℝ&#39;</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="bp">⁻¹⟩</span>
</code></pre></div>


<p>This is an option</p>



<a name="202216998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202216998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202216998">(Jun 28 2020 at 03:09)</a>:</h4>
<p>It needs a bunch of lemmas to be generated to make it possible to prove things</p>



<a name="202217067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202217067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202217067">(Jun 28 2020 at 03:11)</a>:</h4>
<p>You would have to do it for other types too, since <code>(floor r/r) + 1</code> where <code>floor : real -&gt; nat</code> would now return an <code>option nat</code>.  Basically, anything that touches a partial function becomes an option.</p>



<a name="202217132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202217132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202217132">(Jun 28 2020 at 03:13)</a>:</h4>
<p>Right, because junk is a value of any type</p>



<a name="202217253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202217253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202217253">(Jun 28 2020 at 03:16)</a>:</h4>
<p>So we aren't just making a new reals, we are making a new type theory.</p>



<a name="202217257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202217257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202217257">(Jun 28 2020 at 03:17)</a>:</h4>
<p>We're adding a new layer on the existing type theory</p>



<a name="202217262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202217262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202217262">(Jun 28 2020 at 03:17)</a>:</h4>
<p>I'm not arguing this is a good idea, just that it's one implementation of what I interpret Kevin wants</p>



<a name="202217312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202217312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202217312">(Jun 28 2020 at 03:18)</a>:</h4>
<p>I think it is the best proposal so far probably.  (Except for replacing 1/0 = 0 with some arbitrary real number that we can't prove what it is.)</p>



<a name="202217606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202217606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202217606">(Jun 28 2020 at 03:29)</a>:</h4>
<p>I guess I was surprised that it works as well as it does.  The only issue is the fact that it has to propagate through much of Lean means that one would have to adjust a bunch of stuff to make the coercions seamless.</p>



<a name="202218102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202218102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202218102">(Jun 28 2020 at 03:46)</a>:</h4>
<p>I wonder what will come first? <span aria-label="smile" class="emoji emoji-263a" role="img" title="smile">:smile:</span> </p>
<ol>
<li>Proper partial functions in theorem provers which are easy to work with and are natural to mathematicians.</li>
<li>AI which formalizes mathematics for us.</li>
</ol>
<p>I would have guessed the former, but this division issue has been around for a long time...</p>



<a name="202218890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202218890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202218890">(Jun 28 2020 at 04:17)</a>:</h4>
<p>I'd be curious how this partial function problem manifests itself in measure and probably theory.  In both, there is a reoccurring assumption of having measurable functions.  However, no mathematician is going to write that assumption on every line of a proof.  (Actually, one might argue that there is a lot that probabilists don't write down in their proofs.)  I think Lean's current solution for chaining together "measurable" functions is a Giry monad.  However the Giry monad can't be implemented purely in Lean (since not all Lean functions are measurable), only a non-lawful approximation of it.  In particular, just like division, if a function is not measurable, the result is something trivial.  The zero measure I think.  I'm curious how easy this would be to work.  Much of probability theory is just chaining together calculations, but if at every step of the calculation, one has to prove that the resulting term is still measurable (and not degenerate), that would be quite painful.  Have we found a working solution in that setting?</p>



<a name="202218943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202218943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202218943">(Jun 28 2020 at 04:18)</a>:</h4>
<p>(Or maybe this isn't as painful as I imagine.  I still hold out hope that someone can formalize martingales and finally formally prove the strong law of large numbers via the martingale proof.)</p>



<a name="202220703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202220703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202220703">(Jun 28 2020 at 05:23)</a>:</h4>
<p>This approach is what is used in the HOLs by the way</p>



<a name="202220715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202220715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202220715">(Jun 28 2020 at 05:23)</a>:</h4>
<p>Could I just say that having 0^-1 = 0 allows for some simpler lemmas</p>



<a name="202220717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202220717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202220717">(Jun 28 2020 at 05:23)</a>:</h4>
<p>there is a hilbert epsilon operator on every type, so you can just use <code>epsilon (\lam x, false)</code> as a random value in whatever type</p>



<a name="202220754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202220754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202220754">(Jun 28 2020 at 05:24)</a>:</h4>
<p><code>epsilon (\lam x, true)</code>  also works</p>



<a name="202220758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202220758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202220758">(Jun 28 2020 at 05:24)</a>:</h4>
<p>But it's a big problem in dependent type theory because not all types are inhabited</p>



<a name="202220761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202220761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202220761">(Jun 28 2020 at 05:24)</a>:</h4>
<p>(and consistency depends on this)</p>



<a name="202220825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202220825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202220825">(Jun 28 2020 at 05:27)</a>:</h4>
<p>I think it is kind of ridiculous to compare this to general AI (and I get it's hyperbole, but still). This is entirely a problem of our own making, it doesn't even slightly generalize to other approaches to theorem proving</p>



<a name="202220829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202220829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202220829">(Jun 28 2020 at 05:27)</a>:</h4>
<p>The Giry monad thing is also a very lean problem</p>



<a name="202220839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202220839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202220839">(Jun 28 2020 at 05:27)</a>:</h4>
<p>You can certainly have a notation for lawful bind</p>



<a name="202220877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202220877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202220877">(Jun 28 2020 at 05:28)</a>:</h4>
<p>just not using do notation as currently implemented</p>



<a name="202221008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202221008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202221008">(Jun 28 2020 at 05:33)</a>:</h4>
<p>There were already a few occurrences of 37 in mathlib :) <a href="https://github.com/leanprover-community/mathlib/search?q=37&amp;unscoped_q=37">https://github.com/leanprover-community/mathlib/search?q=37&amp;unscoped_q=37</a><br>
Also, mathlib currently has exactly 37 watchers :P</p>



<a name="202221053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202221053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202221053">(Jun 28 2020 at 05:34)</a>:</h4>
<p>I see that <span class="user-mention" data-user-id="110044">@Chris Hughes</span> has learnt well from <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span></p>



<a name="202221233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202221233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202221233">(Jun 28 2020 at 05:40)</a>:</h4>
<p>hrm, I'd rather see <code>arbitrary _</code> used for that</p>



<a name="202221745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202221745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202221745">(Jun 28 2020 at 05:56)</a>:</h4>
<p>I'm curious about how mathematicians view expressions like <code>x / y</code> where <code>y</code> could be zero.  Let's say I ask Lean to prove a theorem like <code>forall (x y :Nat), x / y &lt;= x</code> whose validity depends on the meaning of <code>x / 0</code>.   Is it important to mathematicians that one cannot prove this proposition in Lean?<br>
I'm personally agnostic to this.  I'd often rather have a simpler total logic that sometimes let me prove nonsense theorems.<br>
Somewhat related, the first theorem prover I used, ACL2,  used an untyped logic solved this by having a notion of "guards" that defiend the partial domains of functions.  In normal usage, there were all sorts of nonsense theorems that were true like <code>0/0 = 0</code>, but if you really cared, you could validate all the guards were satisfied.</p>



<a name="202226706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202226706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202226706">(Jun 28 2020 at 08:37)</a>:</h4>
<p>in lean 4, some functions return <code>arbitrary a</code> in edge cases. but <code>arbitrary</code> is defined as a constant, which is essentially a definition without delta reduction in lean 4 (as opposed to an axiom). i think if there is no delta reduction you won't be able to unfold the definition and prove it to be equal to some value?</p>
<p>aside from this and the other things mentioned, one possible solution would be to have a proper multi-valued logic with junk values that propagate through all expressions.</p>



<a name="202226720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202226720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202226720">(Jun 28 2020 at 08:37)</a>:</h4>
<p>and what is <code>arbitrary empty</code> in Lean 4?</p>



<a name="202226757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202226757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202226757">(Jun 28 2020 at 08:38)</a>:</h4>
<p>but that comes with its own bag of problems, e.g. now you need a weak negation etc</p>



<a name="202226760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202226760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202226760">(Jun 28 2020 at 08:38)</a>:</h4>
<p>arbitrary is still just Inhabited.default</p>



<a name="202226778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202226778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202226778">(Jun 28 2020 at 08:39)</a>:</h4>
<p>constants work differently in lean 4</p>



<a name="202226783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202226783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202226783">(Jun 28 2020 at 08:39)</a>:</h4>
<p>so it's like an <code>irreducible</code> version of <code>default</code></p>



<a name="202226786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202226786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202226786">(Jun 28 2020 at 08:39)</a>:</h4>
<p>do irreducibles have delta reduction?</p>



<a name="202226892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202226892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202226892">(Jun 28 2020 at 08:42)</a>:</h4>
<p>i always thought irreducible only affects elaboration, not type checking (but i never used it much in my own work)</p>



<a name="202227683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227683">(Jun 28 2020 at 09:07)</a>:</h4>
<p>Note that <code>arbitrary A</code> already exists in lean 3, and it is just an irreducible version of <code>default</code></p>



<a name="202227727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227727">(Jun 28 2020 at 09:08)</a>:</h4>
<p>irreducibles have delta reduction but only in the kernel, which means that you have to circumvent the elaborator if you want to use it in a proof</p>



<a name="202227737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227737">(Jun 28 2020 at 09:09)</a>:</h4>
<p><code>constant</code>s in lean 4 don't even have delta reduction in the kernel</p>



<a name="202227803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227803">(Jun 28 2020 at 09:11)</a>:</h4>
<p>and they do in lean 3?</p>



<a name="202227859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227859">(Jun 28 2020 at 09:12)</a>:</h4>
<p>In lean 3 <code>constant</code> is just a synonym of <code>axiom</code></p>



<a name="202227865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227865">(Jun 28 2020 at 09:13)</a>:</h4>
<p>obviously there is no delta reduction because there is no definition</p>



<a name="202227870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227870">(Jun 28 2020 at 09:13)</a>:</h4>
<p>in lean 4 there is a definition but no delta reduction</p>



<a name="202227875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227875">(Jun 28 2020 at 09:13)</a>:</h4>
<p>what definition?</p>



<a name="202227876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227876">(Jun 28 2020 at 09:13)</a>:</h4>
<p>like <code>constant foo : nat := 37</code></p>



<a name="202227917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227917">(Jun 28 2020 at 09:14)</a>:</h4>
<p>you cannot prove in lean 4 that <code>foo = 37</code></p>



<a name="202227936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202227936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202227936">(Jun 28 2020 at 09:15)</a>:</h4>
<p>The lean 3 equivalent of that is <code>constant foo : nat</code> and again you can't prove that <code>foo = 37</code> but this is not really a surprise</p>



<a name="202228872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202228872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202228872">(Jun 28 2020 at 09:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/37/near/202227727">said</a>:</p>
<blockquote>
<p>irreducibles have delta reduction but only in the kernel, which means that you have to circumvent the elaborator if you want to use it in a proof</p>
</blockquote>
<p>right, that's what i thought. i can't think of any major downsides vs. <code>x/0 = 37</code>, so maybe this would be the right approach?</p>



<a name="202228930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202228930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202228930">(Jun 28 2020 at 09:47)</a>:</h4>
<p>for programming purposes, there is also <code>panic</code>: <a href="https://github.com/leanprover/lean4/blob/ab5c0301d657ead4d950f461d4bcdd36606c5e72/src/Init/Util.lean#L30">https://github.com/leanprover/lean4/blob/ab5c0301d657ead4d950f461d4bcdd36606c5e72/src/Init/Util.lean#L30</a></p>



<a name="202228998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202228998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202228998">(Jun 28 2020 at 09:49)</a>:</h4>
<p>(constants still behave like their (possibly external) definitions during evaluation, so there are different semantics)</p>



<a name="202229638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202229638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202229638">(Jun 28 2020 at 10:07)</a>:</h4>
<p>I think the right approach is <code>x / 0 = 0</code></p>



<a name="202229683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202229683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202229683">(Jun 28 2020 at 10:08)</a>:</h4>
<p>but that's just for division</p>



<a name="202230255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202230255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202230255">(Jun 28 2020 at 10:22)</a>:</h4>
<p>i wonder if one could improve the error reporting in tactic mode when a user encounters <code>arbitrary</code> to tell the user that they might be missing an assumption</p>



<a name="202230327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202230327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202230327">(Jun 28 2020 at 10:24)</a>:</h4>
<p>I'm not sure what kind of situation would require this</p>



<a name="202230345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202230345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202230345">(Jun 28 2020 at 10:25)</a>:</h4>
<p>people would probably get stuck before they see <code>arbitrary</code>, i guess</p>



<a name="202243879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202243879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202243879">(Jun 28 2020 at 16:33)</a>:</h4>
<p>I think <code>x/0=junk</code> gives you some added information which you're losing with this totalitarian viewpoint</p>



<a name="202244254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202244254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202244254">(Jun 28 2020 at 16:43)</a>:</h4>
<p>Can you confirm Kevin that <code>junk</code> should be a new object not in ℝ, as opposed to an arbitrary member of ℝ?</p>



<a name="202244297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202244297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202244297">(Jun 28 2020 at 16:44)</a>:</h4>
<p>So, something like <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>'s suggestion above?  (But maybe more built into the type theory.)</p>



<a name="202248819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202248819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202248819">(Jun 28 2020 at 18:39)</a>:</h4>
<p><code>junk</code> is an indication that something went wrong, and that tactics should be able to be more efficient if they work under the assumption that nothing went wrong. How it's modelled I don't know, but I think it's persistent: if you do anything to junk you end up with junk.</p>



<a name="202248976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202248976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202248976">(Jun 28 2020 at 18:43)</a>:</h4>
<p>Yeah I think this matches the interpretation of the Maybe monad as failure</p>



<a name="202249302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202249302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202249302">(Jun 28 2020 at 18:50)</a>:</h4>
<p>It sounds like kevin wants a way to open the Maybe monad (in the middle of a tactic proof, or maybe always at the beginning by default), do a bunch of stuff, then <em>exit</em> the Maybe monad, generating proof obligations for as few <code>some</code>s as possible.</p>



<a name="202249652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202249652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202249652">(Jun 28 2020 at 18:58)</a>:</h4>
<p>Right, if the result of the tactic's computation is Nothing then the tactic just fails</p>



<a name="202249727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202249727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202249727">(Jun 28 2020 at 19:00)</a>:</h4>
<p>That said, perhaps he wants something a little different: "more efficient if they work under the assumption that nothing went wrong"</p>



<a name="202250091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202250091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202250091">(Jun 28 2020 at 19:09)</a>:</h4>
<p>Right -- I don't want Lean to not apply (a-b)+b=a just because it isn't always true -- I want it to apply it and pick up the pieces later -- I would not have done a-b if it was junk so there's a b&lt;=a proof available somewhere, maybe by <code>linarith</code>.</p>



<a name="202250286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202250286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202250286">(Jun 28 2020 at 19:14)</a>:</h4>
<p>Hmm, so at the moment you could do this manually using <code>rw</code>, and pick up the pieces later (while <code>simp</code> wouldn't because of the extra pieces), so could your notion just be achieved with a version of <code>simp</code> which generates a bunch of new proof obligations</p>



<a name="202251248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202251248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Carl Friedrich Bolz-Tereick <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202251248">(Jun 28 2020 at 19:36)</a>:</h4>
<p>(this is a complete side note and not really relevant to the mathematics, but this idea of junk is extremely similar to how some C/C++ compilers reason about code. They have different kinds of abstract "poison" values that mean "this cannot have happened, so we can optimize code under the assumption that nothing went wrong". getting the semantics of these poison values right is rather tricky, though: <a href="https://dl.acm.org/doi/pdf/10.1145/3140587.3062343">https://dl.acm.org/doi/pdf/10.1145/3140587.3062343</a> )</p>



<a name="202255745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202255745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202255745">(Jun 28 2020 at 21:16)</a>:</h4>
<p>One thing I thought about is that one would have to be careful with equality and <code>junk</code>, since <code>junk = junk</code>.  In the current option proposals, this is true: `exists a : real, 1/a = 1/(a+a).</p>



<a name="202255973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202255973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202255973">(Jun 28 2020 at 21:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/37/near/202250091">said</a>:</p>
<blockquote>
<p>if it was junk so there's a b&lt;=a proof available somewhere, maybe by <code>linarith</code>.</p>
</blockquote>
<p>Would we expect a tactic to know this? (a-b)+b=a could also be junk since b is junk say.  It would have to backtrack to even know how one got to junk, so it know which assumption it can use.</p>



<a name="202255977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202255977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202255977">(Jun 28 2020 at 21:21)</a>:</h4>
<p>i think if you want to exclude cases like <code>junk = junk</code> you will have to go the route of a multi-valued logic where undefined values behave similar to exceptions. i'm not sure if that is a good idea, and surely you will then need things like weak negation, weak implication etc. to make sense of things like LEM.</p>



<a name="202256225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202256225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202256225">(Jun 28 2020 at 21:27)</a>:</h4>
<p>A whole different option with monads is to use a state monad.  The state would be of type Prop (or a list Prop) and be the assumptions needed to get a result.  Then there isn't a junk value, but instead <code>a - b</code> would technically return something of type <code>(a &lt;= b) -&gt; nat</code>, but the first part would be hidden by the monad.  It wouldn't compute (in the sense of #eval) in the same way as the option monad, but it would still be a monad which would hide the fact the the obligations still need to be met.  With coercion, you could write (a - b - c - d) easily.  The are just carried along until the end to be filled in.  (I haven't thought through the details with the context.  So, maybe that makes it difficult or impossible to implement.)  Also, I imagine this has all the same problems as the other similar solutions like implicit and type class assumptions.</p>



<a name="202256490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202256490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202256490">(Jun 28 2020 at 21:32)</a>:</h4>
<p>We will never see junk values because the code mathematicians write avoids junk. We don't divide by zero, this is the point. For CS people the ability to do it is a convenience with occasional advantages. For us it's never done and this fact is not being leveraged to its full extent</p>



<a name="202256573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202256573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202256573">(Jun 28 2020 at 21:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/37/near/202256490">said</a>:</p>
<blockquote>
<p>We will never see junk values because the code mathematicians write avoids junk. We don't divide by zero, this is the point. For CS people the ability to do it is a convenience with occasional advantages. For us it's never done and this fact is not being leveraged to its full extent</p>
</blockquote>
<p>mathematicians are lazy! (in the sense of haskell)</p>



<a name="202256679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202256679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202256679">(Jun 28 2020 at 21:37)</a>:</h4>
<p>If someone writes <code>(a - b) + b = a</code>, is it automatically true, since obviously <code>b &gt;= a</code> for <code>a - b</code> to be written?  Or does it still require the assumption <code>b &gt;= a</code>?  For what it's worth, if someone can get that state monad example of mine, working, then with automatic coercion, when one writes <code>(a - b) + b = a</code> it is just a pretty printed version of <code>(a &lt;= b) -&gt; (a - b) + b = a</code> and the monad might make it easier to do proofs.</p>



<a name="202281094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202281094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202281094">(Jun 29 2020 at 08:00)</a>:</h4>
<p>I'd like to see a "subsingleton monad" (is there a name for this?), mapping a type <code>X</code> to the type of subsingleton subsets of <code>X</code>, i.e. objects that are well-defined if they exist. Classically this is the same as <code>option X</code> -- a subsingleton is either empty or just some singleton -- but you wouldn't need undecidable <code>if</code>s to define things like inverses or integrals</p>



<a name="202281508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202281508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202281508">(Jun 29 2020 at 08:04)</a>:</h4>
<p>I fear that all these suggestions are in the end harder to compose than <code>1/0 = 0</code> and <code>2 - 37 = 0</code>.<br>
<span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> tactics could still apply <code>(a - b) + b = a</code> even if you use <code>0</code> instead of <code>junk</code>, right? The promise is still there.</p>



<a name="202281898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202281898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202281898">(Jun 29 2020 at 08:09)</a>:</h4>
<p><code>roption</code> serves a similar purpose to the subsingleton monad you speak of.</p>



<a name="202282307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202282307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202282307">(Jun 29 2020 at 08:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110044">Chris Hughes</span> <a href="#narrow/stream/113488-general/topic/37/near/202281898">said</a>:</p>
<blockquote>
<p><code>roption</code> serves a similar purpose to the subsingleton monad you speak of.</p>
</blockquote>
<p>Oh, thanks! <code>roption</code> is indeed isomorphic to subsingleton</p>



<a name="202300798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202300798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202300798">(Jun 29 2020 at 12:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/37/near/202281508">said</a>:</p>
<blockquote>
<p>I fear that all these suggestions are in the end harder to compose than <code>1/0 = 0</code> and <code>2 - 37 = 0</code>.</p>
</blockquote>
<p>That is what I would have thought too, but did you see <a href="#narrow/stream/113488-general/topic/37/near/202215662">the example above</a>?  It seems to show that with monads (which naturally compose well), and coercion, some ideas seem to compose almost seamlessly.</p>



<a name="202301354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202301354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202301354">(Jun 29 2020 at 12:21)</a>:</h4>
<p>monads don't compose as well as actual composition though</p>



<a name="202301541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202301541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202301541">(Jun 29 2020 at 12:23)</a>:</h4>
<p>It is possible to use an option monad for things like subtraction, and indeed <code>nat.psub</code> exists if you want to use it. But try it for a while and you will find it's strictly worse than just using <code>nat.sub</code> because you still have the same assumptions you need to pass around and now you also have to deal with the fact that <code>rw</code> doesn't really work anymore</p>



<a name="202313182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202313182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202313182">(Jun 29 2020 at 14:04)</a>:</h4>
<p>What I want is Pi (a b : nat), (h : b &lt;= a := by schoolkid) -&gt; nat</p>



<a name="202313324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202313324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202313324">(Jun 29 2020 at 14:05)</a>:</h4>
<p>This is mathematical subtraction on nat, and it has better lemmas than rubbish old computer science subtraction</p>



<a name="202313525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202313525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202313525">(Jun 29 2020 at 14:07)</a>:</h4>
<p>Are you saying you don't like burritos?</p>



<a name="202315163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202315163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202315163">(Jun 29 2020 at 14:17)</a>:</h4>
<p>That still doesn't really solve anything, it just means you will be calling on the schoolkid all the time, even when not really necessary, and the job still has to be done</p>



<a name="202315644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202315644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202315644">(Jun 29 2020 at 14:20)</a>:</h4>
<p>One tactic that might be useful is a tactic that looks at the goal and adds <code>b &lt;= a</code> to the context for every subtraction <code>a - b</code> in the goal if it's not already present (and it can be extensible with more partiality conditions, e.g. <code>b != 0</code> when you see <code>a / b</code>, <code>a &gt;= 0</code> when you see <code>sqrt a</code>, etc)</p>



<a name="202316247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202316247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202316247">(Jun 29 2020 at 14:23)</a>:</h4>
<p>Alternatively, rather than adding these to the context they could be added as extra arguments to a <code>simp</code> invocation so that more conditional rewrite rules fire. So you could <code>partial_simp</code> <code>(a - b) + b</code> to <code>a</code> and it would automatically try to prove <code>h : b &lt;= a</code> (using a discharger, perhaps <code>linarith</code> by default) and then call <code>simp [h]</code> so that the conditional rewrite rule <code>nat.sub_add_cancel</code> applies</p>



<a name="202316477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202316477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202316477">(Jun 29 2020 at 14:24)</a>:</h4>
<p>this is pretty similar to how <code>nlinarith</code> works: look at the goal, heuristically add some assumptions to the context, then call the workhorse <code>linarith</code> tactic</p>



<a name="202316903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202316903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202316903">(Jun 29 2020 at 14:27)</a>:</h4>
<p>I think the claim is the job will almost always have to be done anyways (why bother forming <code>n-1</code> if you don't need to know it's one less than <code>n</code>) and easier to solve in the context where you wrote <code>n-1</code> than later.</p>



<a name="202317702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202317702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202317702">(Jun 29 2020 at 14:32)</a>:</h4>
<p>that's not always true. For instance you might need to prove <code>n - 1 &gt; 0</code> and then you want to know that <code>n &gt; 1</code> instead.  Here <code>n &gt;= 1</code> might not come up at all and would be a distraction</p>



<a name="202317843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202317843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202317843">(Jun 29 2020 at 14:32)</a>:</h4>
<p>But how would you get <code>n - 1</code> in the first place then?</p>



<a name="202318010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318010">(Jun 29 2020 at 14:33)</a>:</h4>
<p>What do you mean? In the context we know <code>n &gt; 1</code> so <code>n - 1</code> is well formed, but we don't care that <code>n &gt;= 1</code> even though it is true</p>



<a name="202318079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318079">(Jun 29 2020 at 14:34)</a>:</h4>
<p>Why is <code>n - 1 &gt; 0</code> our goal</p>



<a name="202318138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318138">(Jun 29 2020 at 14:34)</a>:</h4>
<p>That's just the example</p>



<a name="202318180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318180">(Jun 29 2020 at 14:34)</a>:</h4>
<p>maybe we are taking the log</p>



<a name="202318200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318200">(Jun 29 2020 at 14:34)</a>:</h4>
<p>What my point is, is that mathematicians don't do subtraction unless it's sensible</p>



<a name="202318217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318217">(Jun 29 2020 at 14:34)</a>:</h4>
<p>But why are we taking the log? Eventually we have to relate it back to <code>n</code> right?</p>



<a name="202318221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318221">(Jun 29 2020 at 14:34)</a>:</h4>
<p>your example is silly</p>



<a name="202318265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318265">(Jun 29 2020 at 14:34)</a>:</h4>
<p>If we didn't need to know that <code>n - 1</code> was one less than <code>n</code> we could just write 37 or whatever.</p>



<a name="202318292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318292">(Jun 29 2020 at 14:34)</a>:</h4>
<p>I'm really confused now</p>



<a name="202318343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318343">(Jun 29 2020 at 14:35)</a>:</h4>
<p>I'm saying we are doing some math with <code>log (n - 1)</code>, say</p>



<a name="202318391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318391">(Jun 29 2020 at 14:35)</a>:</h4>
<p>Sure, I claim all the same properties hold of <code>log 37</code></p>



<a name="202318407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318407">(Jun 29 2020 at 14:35)</a>:</h4>
<p>except for one</p>



<a name="202318444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318444">(Jun 29 2020 at 14:35)</a>:</h4>
<p>and so in order to do something with this expression we end up having to prove <code>n - 1 &gt; 0</code>, and we want to apply a theorem that says <code>n &gt; 1 -&gt; n - 1 &gt; 0</code></p>



<a name="202318517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318517">(Jun 29 2020 at 14:36)</a>:</h4>
<p>and this theorem does not say <code>n &gt; 1 -&gt; n &gt;= 1 -&gt; n - 1 &gt; 0</code> because that would be stupid</p>



<a name="202318589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318589">(Jun 29 2020 at 14:36)</a>:</h4>
<p>But we would never see <code>n - 1</code> in the first place unless we were going to use <code>(n - 1) + 1 = n</code> later anyways</p>



<a name="202318821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318821">(Jun 29 2020 at 14:38)</a>:</h4>
<p>not necessarily</p>



<a name="202318855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318855">(Jun 29 2020 at 14:38)</a>:</h4>
<p>we might need to use a different theorem about subtraction</p>



<a name="202318906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318906">(Jun 29 2020 at 14:38)</a>:</h4>
<p>that one is just the "definitional theorem", we could be working well past that level</p>



<a name="202318990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202318990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202318990">(Jun 29 2020 at 14:39)</a>:</h4>
<p>for example we wanted to apply a theorem that uses nat subtraction in its statement</p>



<a name="202319186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319186">(Jun 29 2020 at 14:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> If your goal is <code>0 ≤ srqt x</code>, do you want to prove <code>0 ≤ x</code> as a precondition, or just have this be a theorem without assumptions?</p>



<a name="202319208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319208">(Jun 29 2020 at 14:40)</a>:</h4>
<p>I am onboard with always having the fact <code>1 &lt;= n</code> "on call" as it were, but I don't want every theorem ever about subtraction to have this as an assumption that needs to be threaded through</p>



<a name="202319240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319240">(Jun 29 2020 at 14:40)</a>:</h4>
<p>That's why <code>nat.sub</code> is defined the way it is</p>



<a name="202319265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319265">(Jun 29 2020 at 14:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/37/near/202318589">said</a>:</p>
<blockquote>
<p>But we would never see <code>n - 1</code> in the first place unless we were going to use <code>(n - 1) + 1 = n</code> later anyways</p>
</blockquote>
<p>You might need an arbitrary <code>k</code> such that <code>k &lt; n &lt;= 2*k</code> (still assuming <code>n&gt;1</code>)</p>



<a name="202319302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319302">(Jun 29 2020 at 14:41)</a>:</h4>
<p>and it's annoying because <code>omega</code> is broken</p>



<a name="202319421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319421">(Jun 29 2020 at 14:41)</a>:</h4>
<p>but when I do subtraction I don't want to use nat.sub, I'd rather use mathematician's subtraction, because I think it will be better for automation</p>



<a name="202319523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319523">(Jun 29 2020 at 14:42)</a>:</h4>
<p>Why?</p>



<a name="202319583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319583">(Jun 29 2020 at 14:42)</a>:</h4>
<p>Automation can just assume you didn't do anything stupid, right?</p>



<a name="202319591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319591">(Jun 29 2020 at 14:42)</a>:</h4>
<p>I contend that the only difference between <code>nat.sub</code> and mathematician's subtraction is better bookkeeping around these "on call" assumptions</p>



<a name="202319767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319767">(Jun 29 2020 at 14:43)</a>:</h4>
<p>Automation can just generate some side goals, and work under the assumption that everything is <em>mathematically sane</em>.<br>
It could proceed to try to prove some of these side goals...</p>



<a name="202319782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319782">(Jun 29 2020 at 14:43)</a>:</h4>
<p>I don't see what the problem is with the way Lean handles partial function.<br>
Mathematicians only use these function with some preconditions. In the case that you assume those preconditions, our functions have the exact behavior you want. Why do you care it has a (unexpected?) behavior in cases when you don't use it?<br>
The real problem is that <code>nat.sub</code> is denoted <code>-</code> and <code>nat.div</code> denoted <code>/</code> so you can "accidentally" use it, while you really wanted to use a different operation.</p>



<a name="202319911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202319911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202319911">(Jun 29 2020 at 14:44)</a>:</h4>
<p>I don't think lean currently has a very good way to notate "preferred preconditions" right now, but it is nothing we couldn't solve with a tactic that introduces a framework of annotations of its own</p>



<a name="202320057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202320057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202320057">(Jun 29 2020 at 14:45)</a>:</h4>
<p>I really don't want <code>x - y</code> to end up in <code>option nat</code>.</p>



<a name="202320092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202320092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202320092">(Jun 29 2020 at 14:45)</a>:</h4>
<p>And I also don't want <code>x -[h] y</code></p>



<a name="202320487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202320487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202320487">(Jun 29 2020 at 14:47)</a>:</h4>
<p>Of course the real problem is that a mathematician <em>will</em> write <code>k - n</code> and expect <code>k - n + n = k</code>, whatever the values of <code>k</code> and <code>n</code>. This is the real problem with <code>nat.sub</code>.</p>



<a name="202320572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202320572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202320572">(Jun 29 2020 at 14:48)</a>:</h4>
<p>How does <code>field_simp</code> handle this? It's not that hard to look at a term, locate all the partial function subterms, and derive a list of things that "really ought to be true" and then... prove them somehow?</p>



<a name="202320610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202320610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202320610">(Jun 29 2020 at 14:48)</a>:</h4>
<p>It's different from <code>x / y</code>, because there the promise is that <code>y</code> will never be zero.</p>



<a name="202320695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202320695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202320695">(Jun 29 2020 at 14:48)</a>:</h4>
<p>We could lint theorems that fail their preferred preconditions</p>



<a name="202320725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202320725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202320725">(Jun 29 2020 at 14:48)</a>:</h4>
<p><code>field_simp</code> is just a curated simpset, right?</p>



<a name="202320805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202320805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202320805">(Jun 29 2020 at 14:49)</a>:</h4>
<p>I thought it derives the preferred preconditions but maybe it just accepts proofs of those preconditions</p>



<a name="202321031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321031">(Jun 29 2020 at 14:50)</a>:</h4>
<p>But we probably don't need to lint theorems because if they fail preconditions they are either true by funny tricks (in which case we probably intend to silence the lint) or they are false and the user will notice soon enough</p>



<a name="202321053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321053">(Jun 29 2020 at 14:50)</a>:</h4>
<p>Proposal: use notation <code>∸</code> for <code>nat.sub</code>.</p>



<a name="202321315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321315">(Jun 29 2020 at 14:52)</a>:</h4>
<p>How about <code>nat.div</code> and <code>int.div</code>?</p>



<a name="202321356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321356">(Jun 29 2020 at 14:52)</a>:</h4>
<p><code>/.</code> for both?</p>



<a name="202321396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321396">(Jun 29 2020 at 14:53)</a>:</h4>
<p><code>class has_ill_behaved_div</code></p>



<a name="202321404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321404">(Jun 29 2020 at 14:53)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/3226">#3226</a> mentions having to prove nats are &gt;= 0 many times, which seems prophetic of these nat.sub solutions</p>



<a name="202321499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321499">(Jun 29 2020 at 14:54)</a>:</h4>
<p>I like <code>//</code> from python</p>



<a name="202321544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321544">(Jun 29 2020 at 14:54)</a>:</h4>
<p>for truncated div</p>



<a name="202321563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321563">(Jun 29 2020 at 14:54)</a>:</h4>
<p>also fine with me</p>



<a name="202321570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321570">(Jun 29 2020 at 14:54)</a>:</h4>
<p>Or the <code>-:-</code> symbol?</p>



<a name="202321593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321593">(Jun 29 2020 at 14:54)</a>:</h4>
<p><code>÷</code></p>



<a name="202321668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321668">(Jun 29 2020 at 14:55)</a>:</h4>
<p><code>//</code> could look confusing in <code>{x // y // x = 37}</code></p>



<a name="202321693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321693">(Jun 29 2020 at 14:55)</a>:</h4>
<p>ah, that's true</p>



<a name="202321712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321712">(Jun 29 2020 at 14:55)</a>:</h4>
<p>Of course it's unambiguous, but still</p>



<a name="202321742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321742">(Jun 29 2020 at 14:55)</a>:</h4>
<p>But why are we disambiguating this symbol anyway?</p>



<a name="202321837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321837">(Jun 29 2020 at 14:56)</a>:</h4>
<p>I don't want to send the message this is "wrong division"</p>



<a name="202321931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321931">(Jun 29 2020 at 14:56)</a>:</h4>
<p>Because people use these operations without realizing they are using <em>these</em> operations.</p>



<a name="202321940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321940">(Jun 29 2020 at 14:56)</a>:</h4>
<p>I wish <code>k - n</code> would be an int, and <code>k ∸ n</code> a <code>nat</code>. But that would require changing the type signature of <code>-</code> to something ugly with an outparam. Doesn't sound like a good idea.</p>



<a name="202321978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202321978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202321978">(Jun 29 2020 at 14:57)</a>:</h4>
<p>I understand the appeal only when the symbol is being used out of the traditional domain</p>



<a name="202322179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322179">(Jun 29 2020 at 14:58)</a>:</h4>
<p>If <code>k &gt;= n</code>, then I see no issue at all with the notation <code>k - n</code>, because it's not a lie</p>



<a name="202322212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322212">(Jun 29 2020 at 14:58)</a>:</h4>
<p>Sure, but what if <code>k &lt; n</code>?</p>



<a name="202322223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322223">(Jun 29 2020 at 14:58)</a>:</h4>
<p>and if <code>k &lt; n</code> then what are you even doing writing <code>k - n</code></p>



<a name="202322225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322225">(Jun 29 2020 at 14:58)</a>:</h4>
<p>This actually happens in maths <span aria-label="shock" class="emoji emoji-1f628" role="img" title="shock">:shock:</span></p>



<a name="202322255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322255">(Jun 29 2020 at 14:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/37/near/202322223">said</a>:</p>
<blockquote>
<p>and if <code>k &lt; n</code> then what are you even doing writing <code>k - n</code></p>
</blockquote>
<p>Well, you might be a mathematician</p>



<a name="202322271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322271">(Jun 29 2020 at 14:58)</a>:</h4>
<p>we can have a tactic that will slap you on the wrist if you desire</p>



<a name="202322299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322299">(Jun 29 2020 at 14:58)</a>:</h4>
<p>The typically expect the result to be an <code>int</code></p>



<a name="202322316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322316">(Jun 29 2020 at 14:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/37/near/202322271">said</a>:</p>
<blockquote>
<p>we can have a tactic that will slap you on the wrist if you desire</p>
</blockquote>
<p>That doesn't sound very user friendly.</p>



<a name="202322336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322336">(Jun 29 2020 at 14:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I think the problem is users might write <code>n - m</code> or <code>n / m</code> while they really meant to first apply a cast to <code>n</code>, but don't realize that didn't happen automatically.</p>



<a name="202322386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322386">(Jun 29 2020 at 14:59)</a>:</h4>
<p>then maybe a wrist slapping tactic is the right solution</p>



<a name="202322494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322494">(Jun 29 2020 at 15:00)</a>:</h4>
<p>Or a wrist slapping notation?</p>



<a name="202322510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322510">(Jun 29 2020 at 15:00)</a>:</h4>
<p>it can scour the context for things that probably don't mean what you think they mean</p>



<a name="202322529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322529">(Jun 29 2020 at 15:00)</a>:</h4>
<p>You could just have the type checker do the wrist slapping.</p>



<a name="202322559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322559">(Jun 29 2020 at 15:00)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">Error</span><span class="o">:</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kn">instance</span> <span class="bp">`</span><span class="n">has_sub</span> <span class="n">nat</span><span class="bp">`</span>
</code></pre></div>



<a name="202322570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322570">(Jun 29 2020 at 15:00)</a>:</h4>
<p>Or we use different notation, and have a lemma that in all sensible cases <code>n ∸ m = n - m</code></p>



<a name="202322583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322583">(Jun 29 2020 at 15:00)</a>:</h4>
<p>no, this can't be more than a lint because there are also legitimate uses for out of domain stuff</p>



<a name="202322675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322675">(Jun 29 2020 at 15:01)</a>:</h4>
<p>but we have that lemma already, it's called <code>int.coe_nat_sub</code></p>



<a name="202322731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322731">(Jun 29 2020 at 15:01)</a>:</h4>
<p>Exactly, it would just look a bit different after the change</p>



<a name="202322821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322821">(Jun 29 2020 at 15:02)</a>:</h4>
<p>I would still want what you are calling <code>n - m</code> to actually elaborate to <code>\u n - \u m</code></p>



<a name="202322909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322909">(Jun 29 2020 at 15:03)</a>:</h4>
<p>I agree, can we do that?</p>



<a name="202322937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322937">(Jun 29 2020 at 15:03)</a>:</h4>
<p>only in the right typing context</p>



<a name="202322946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202322946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202322946">(Jun 29 2020 at 15:03)</a>:</h4>
<p>That would be awesome...</p>



<a name="202323098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323098">(Jun 29 2020 at 15:04)</a>:</h4>
<p>How about abolishing <code>k - n</code>, and having <code>k ∸ n</code> and <code>k -[ℤ] n</code>. Then users are always explicit about what they mean.</p>



<a name="202323155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323155">(Jun 29 2020 at 15:04)</a>:</h4>
<p>The latter being notation for <code>(k:ℤ) - n</code>.</p>



<a name="202323208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323208">(Jun 29 2020 at 15:05)</a>:</h4>
<p>Well, maybe it's not worth it... to have separate notation for that.</p>



<a name="202323380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323380">(Jun 29 2020 at 15:06)</a>:</h4>
<p>What is the proposal exactly? In context <code>m - n : ?A</code> we first assume <code>-</code> is <code>has_sub.sub ?A ?M</code> and then have to determine the type of <code>n : ?A</code> and <code>m : ?A</code>, then see <code>n : nat</code>, reject this because <code>has_sub nat</code> fails (or is suppressed somehow), and then insert a coercion; we still have to determine what <code>?A</code> is and then deep magic causes <code>?A := int</code></p>



<a name="202323469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323469">(Jun 29 2020 at 15:07)</a>:</h4>
<p>this looks like something that is not likely to happen in lean 3</p>



<a name="202323517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323517">(Jun 29 2020 at 15:07)</a>:</h4>
<p><code>has_sub</code> should remain to depend on just one type.</p>



<a name="202323541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323541">(Jun 29 2020 at 15:07)</a>:</h4>
<p>Just remove the instance for <code>nat</code></p>



<a name="202323637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323637">(Jun 29 2020 at 15:08)</a>:</h4>
<p>And have special notation for <code>nat.sub</code>.</p>



<a name="202323751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323751">(Jun 29 2020 at 15:09)</a>:</h4>
<p>We create a new class <code>has_truncated_sub</code> and <code>∸</code> is notation for that.</p>



<a name="202323814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323814">(Jun 29 2020 at 15:09)</a>:</h4>
<p>Similarly for <code>has_crazy_div</code>. And we have instances <code>has_crazy_div nat</code> and <code>has_crazy_div int</code>.</p>



<a name="202323875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323875">(Jun 29 2020 at 15:10)</a>:</h4>
<p>Am I allowed to say that I am completely happy with the current state of affairs, writing <code>n - m</code> to mean nat subtraction?</p>



<a name="202323884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323884">(Jun 29 2020 at 15:10)</a>:</h4>
<p>I still think this kind of marginalizes <code>nat.sub</code> when it is used legitimately like <code>2 ^ n - 1 = sum_k 2^k</code></p>



<a name="202323953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323953">(Jun 29 2020 at 15:10)</a>:</h4>
<p>Having to put a monus in there is just cognitive overhead for the reader</p>



<a name="202323986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202323986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202323986">(Jun 29 2020 at 15:10)</a>:</h4>
<p>And that trying complicated solutions around a non-existing problem will likely only make things worse.</p>



<a name="202324118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324118">(Jun 29 2020 at 15:11)</a>:</h4>
<p>I don't think the solution is that complicated. And we've seen quite some users being very confused by <code>2 - 5 = 0</code>.</p>



<a name="202324160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324160">(Jun 29 2020 at 15:12)</a>:</h4>
<p>Unfortunately Casper isn't on Zulip yet...</p>



<a name="202324196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324196">(Jun 29 2020 at 15:12)</a>:</h4>
<p>We need linters and assistance tools for this</p>



<a name="202324219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324219">(Jun 29 2020 at 15:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/37/near/202324196">said</a>:</p>
<blockquote>
<p>We need linters and assistance tools for this</p>
</blockquote>
<p>Like a type checker?</p>



<a name="202324230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324230">(Jun 29 2020 at 15:12)</a>:</h4>
<p>no</p>



<a name="202324271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324271">(Jun 29 2020 at 15:13)</a>:</h4>
<p>like a sanity checker</p>



<a name="202324279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324279">(Jun 29 2020 at 15:13)</a>:</h4>
<p>Having <code>3 - 2</code> parse to nat subtraction and <code>3 - 5</code> insert a coercion looks like a crazy hack to me.</p>



<a name="202324322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324322">(Jun 29 2020 at 15:13)</a>:</h4>
<p>it's also probably undecidable</p>



<a name="202324333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324333">(Jun 29 2020 at 15:13)</a>:</h4>
<p>That's not what we are suggesting</p>



<a name="202324487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324487">(Jun 29 2020 at 15:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> <code>3 - 5</code> would simply not typecheck in my proposal. (Unless the type is <code>int</code> or some other <code>add_group</code> say.)</p>



<a name="202324636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324636">(Jun 29 2020 at 15:14)</a>:</h4>
<p><code>3 ∸ 5 = 0</code></p>



<a name="202324721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324721">(Jun 29 2020 at 15:14)</a>:</h4>
<p>and <code>3 - 2</code> presumably also doesn't typecheck?</p>



<a name="202324766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324766">(Jun 29 2020 at 15:14)</a>:</h4>
<p>even though any mathematician will say that this is fine</p>



<a name="202324813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324813">(Jun 29 2020 at 15:15)</a>:</h4>
<p>Yup...</p>



<a name="202324827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324827">(Jun 29 2020 at 15:15)</a>:</h4>
<p>When you type C++ in a modern IDE and you are doing something weird (using an uninitialized variable, say), you get a live warning. I would be fine with having the same mechanism fire up if you write <code>m - n</code> and <code>linarith</code> can not infer <code>n \le m</code> from the context. But it should just be a warning, and let you proceed if you want to.</p>



<a name="202324901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324901">(Jun 29 2020 at 15:15)</a>:</h4>
<p>I would be very happy with that solution. But I don't have the brains to implement it.</p>



<a name="202324990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324990">(Jun 29 2020 at 15:16)</a>:</h4>
<p>Having live feedback from tactics while I type is not something that exists in our ecosystem at the moment.</p>



<a name="202324995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202324995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202324995">(Jun 29 2020 at 15:16)</a>:</h4>
<p>if it's explicitly invoked (the wrist slapping tactic) it's not so hard to implement</p>



<a name="202325003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202325003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202325003">(Jun 29 2020 at 15:16)</a>:</h4>
<p>Also... it needs to be fast.</p>



<a name="202325024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202325024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202325024">(Jun 29 2020 at 15:16)</a>:</h4>
<p>calling linarith all the time will probably not be fast</p>



<a name="202325075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202325075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202325075">(Jun 29 2020 at 15:17)</a>:</h4>
<p>but you could swap it out for <code>assumption</code> in many cases</p>



<a name="202325115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202325115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202325115">(Jun 29 2020 at 15:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/37/near/202324995">said</a>:</p>
<blockquote>
<p>if it's explicitly invoked (the wrist slapping tactic) it's not so hard to implement</p>
</blockquote>
<p>I don't think newbies are going to explicitly invoke anything.</p>



<a name="202325126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202325126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202325126">(Jun 29 2020 at 15:17)</a>:</h4>
<p>I like to give the example</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">composition_card</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">composition</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>


<p>in <code>composition.lean</code>. Where <code>-</code> is nat subtraction. I want to keep the right to do this :)</p>



<a name="202325143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202325143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202325143">(Jun 29 2020 at 15:17)</a>:</h4>
<p>I love this discussion... but dinner is calling</p>



<a name="202325322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202325322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202325322">(Jun 29 2020 at 15:19)</a>:</h4>
<p>Sebastien I think that this qualifies you as a CS person to Kevin</p>



<a name="202328527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202328527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202328527">(Jun 29 2020 at 15:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/37/near/202325143">said</a>:</p>
<blockquote>
<p>I love this discussion... but dinner is calling</p>
</blockquote>
<p>I have a new theory about Covid. I think it was created by some Dutch scientists to make sure international conferences are cancelled because they can't stand having dinner at a civilized time.</p>



<a name="202331384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202331384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202331384">(Jun 29 2020 at 16:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113488-general/topic/37/near/202325126">said</a>:</p>
<blockquote>
<p>I like to give the example</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">composition_card</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">composition</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>


<p>in <code>composition.lean</code>. Where <code>-</code> is nat subtraction. I want to keep the right to do this :)</p>
</blockquote>
<p>Every mathematician will think that you proved that <code>fintype.card (composition 0) = 1 / 2</code>.</p>
<p><del>(Of course that's actually true by <code>rfl</code>, which is all the more confusing.)</del></p>



<a name="202331577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202331577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202331577">(Jun 29 2020 at 16:08)</a>:</h4>
<p>No, clearly <code>2 ^ (0 - 1) = 1 ≠ 0 = 1 / 2</code></p>



<a name="202331703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202331703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202331703">(Jun 29 2020 at 16:09)</a>:</h4>
<p>Ooh crap...</p>



<a name="202337704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202337704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202337704">(Jun 29 2020 at 16:51)</a>:</h4>
<p>Maybe <code>/</code> should round up? After all, it's returning junk values whenever the denominator doesn't divide the numerator :-)</p>



<a name="202337918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202337918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202337918">(Jun 29 2020 at 16:52)</a>:</h4>
<p>I defined <code>int</code> as the quotient of nat^2 by the usual equivalence relation yesterday, and along the way discovered that the function <code>nat -&gt; nat -&gt; int</code> which Johan was talking about in the context of subtraction is actually called <code>quotient.mk</code>.</p>



<a name="202340688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202340688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202340688">(Jun 29 2020 at 17:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Why didn't you just reuse Amelia's api? Is this for some teaching stuff?</p>



<a name="202343515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202343515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/37.html#202343515">(Jun 29 2020 at 17:33)</a>:</h4>
<p>Yes</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html">Opaque junk values for partial functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="319438942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319438942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319438942">(Jan 04 2023 at 17:46)</a>:</h4>
<p>I was reading through <a href="#narrow/stream/113488-general/topic/Incomplete.20pattern.20match">this thread</a> and was trying to think of ways to stop proofs that <code>1 - 2 = 3 - 6</code> (or something similar, I could see a variety of reasons that nat subtraction specifically shouldn't be changed). This idea probably sounded better in my head than it does on paper, but I was wondering if we could define a <code>junk_value</code> function that prevents proofs of equality, like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">opaque</span> <span class="n">junk_value</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="kd">def</span> <span class="n">minus</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="k">then</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">m</span> <span class="k">else</span> <span class="n">junk_value</span> <span class="n">n</span> <span class="n">m</span>
</code></pre></div>
<p>That way, <code>1 - 2</code> reduces to <code>junk_value 1 2</code> and <code>3 - 5</code> reduces to <code>junk_value 3 5</code>, which are computationally equal, but as far as I know there's no way to prove this (except maybe <code>native_decide</code>, which I don't know how it works).</p>
<p>A more generic <code>junk_value</code> function that works for all types could be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span>
<span class="n">opaque</span> <span class="n">junk_value</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Inhabited.default</span>
</code></pre></div>
<p>where <code>β</code> would likely be a tuple containing the type of all arguments.</p>



<a name="319441494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319441494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319441494">(Jan 04 2023 at 17:59)</a>:</h4>
<p>One caveat is that for subtraction, it essentially has to be defined twice, once where <code>1 - 2</code> returns <code>0</code> and once where it returns <code>junk_value 1 2</code>. If you try defining it in one go, like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="n">junk_value</span> <span class="mi">0</span> <span class="n">m</span>
<span class="bp">|</span> <span class="n">n</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">sub</span> <span class="n">n</span> <span class="n">m</span>
</code></pre></div>
<p>Then <code>1 - 5</code> and <code>2 - 6</code> both reduce to <code>junk_value 0 4</code> and can be proven equal.</p>



<a name="319441866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319441866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319441866">(Jan 04 2023 at 18:01)</a>:</h4>
<p>Is that a problem?</p>



<a name="319441955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319441955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319441955">(Jan 04 2023 at 18:02)</a>:</h4>
<p>Because <code>(1:ℤ) - (5:ℤ) = (2:ℤ) - (6:ℤ)</code>.</p>



<a name="319442119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319442119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319442119">(Jan 04 2023 at 18:03)</a>:</h4>
<p>I think it's reasonable to occasionaly have <code>junk_value a b = junk_value c d</code> if <code>a + d = c + b</code>.</p>



<a name="319442176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319442176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319442176">(Jan 04 2023 at 18:03)</a>:</h4>
<p>But anyway, it turns out that for applications in can be very helpful to have well-chosen junk-values.</p>



<a name="319442310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319442310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319442310">(Jan 04 2023 at 18:04)</a>:</h4>
<p>It can occasionally be a footgun, which is probably what you are trying to avoid. But it also saves you from checking a tonne of annoying side conditions.</p>



<a name="319442831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319442831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319442831">(Jan 04 2023 at 18:07)</a>:</h4>
<p>For natural number subtraction, I do agree that opaque junk values are not the way to go because having <code>1 - 2 = 0</code> is actually sometimes a useful property. I was thinking that <code>junk_value</code> would be more helpful in situations where there's not really a good junk value to choose.</p>



<a name="319442883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319442883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319442883">(Jan 04 2023 at 18:08)</a>:</h4>
<p>Why would it be helpful in such situations?</p>



<a name="319443042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319443042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319443042">(Jan 04 2023 at 18:08)</a>:</h4>
<p>If there's not really a good junk value to choose, then the risk for footguns is also quite small, I think.</p>



<a name="319443075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319443075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319443075">(Jan 04 2023 at 18:08)</a>:</h4>
<p>In which case it doesn't matter which junk value you choose.</p>



<a name="319443144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319443144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319443144">(Jan 04 2023 at 18:09)</a>:</h4>
<p>Do you have a concrete example in mind?</p>



<a name="319443918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319443918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319443918">(Jan 04 2023 at 18:13)</a>:</h4>
<p>No, I don't really have a concrete example. I guess it would help in some obscure definitions where it isn't made clear that junk values exist. I remember seeing some definition of an inverse in a ring or monoid (<a href="https://leanprover-community.github.io/mathlib_docs/find/ring.inverse">docs#ring.inverse</a>) where it would return the inverse if it existed and zero if it didn't, but the function was just called <code>something.inverse</code> I think. That's not really a good example either because you can just read the doc strings, but someone looking at a lemma might see something like <code>inverse 3 = inverse 4</code> and be confused</p>



<a name="319444062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319444062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319444062">(Jan 04 2023 at 18:14)</a>:</h4>
<p>But generally, I agree that the risk is quite small</p>



<a name="319444081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319444081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319444081">(Jan 04 2023 at 18:14)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/ring.inverse">docs#ring.inverse</a></p>



<a name="319449267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319449267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319449267">(Jan 04 2023 at 18:42)</a>:</h4>
<blockquote>
<p>A more generic <code>junk_value</code> function that works for all types could be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span> <span class="n">v</span>
<span class="n">opaque</span> <span class="n">junk_value</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">Inhabited.default</span>
</code></pre></div>
<p>where <code>β</code> would likely be a tuple containing the type of all arguments.</p>
</blockquote>
<p>A <em>generic</em> junk value function is just as problematic as using 0, if you want to avoid "junk" theorems.  Because now you can prove e.g. <code>x / 0 = x % 0</code> by reflexivity.  You need to use a different opaque function for every occurrence to get truly unspecified values.</p>



<a name="319449932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319449932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319449932">(Jan 04 2023 at 18:46)</a>:</h4>
<p>And even then they're merely unspecified, you can still prove all kinds of theorems about them.  Like <code>(a / b)^2 + 1 &gt; 0</code>.</p>



<a name="319451841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319451841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319451841">(Jan 04 2023 at 18:56)</a>:</h4>
<p>I didn't consider the <code>x / 0 = x % 0</code> case that you mentioned. I guess a tactic could be used to generate the junk functions, or have <code>junk_value</code> take in a string containing the function name.<br>
I don't really think there's a way to solve the second problem. At the very least, there's no way to take advantage of the specific undefined value and any theorems you prove about them essentially have to hold for every nat. It is still a bit unmathematical, but less alarming than something like <code>∀ n : ℕ, ∃ k, n / k = k</code>.</p>



<a name="319461233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319461233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319461233">(Jan 04 2023 at 19:51)</a>:</h4>
<p>On the other hand, there are useful theorems for nat.sub that you can't prove if the value is arbitrary instead of 0, like <a href="https://leanprover-community.github.io/mathlib_docs/find/has_ordered_sub">docs#has_ordered_sub</a>.</p>



<a name="319527101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319527101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin (尹維晨) <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319527101">(Jan 05 2023 at 07:23)</a>:</h4>
<p>Idea: mathlib should compile successfully independently of the choice of junk value for any partial function in mathlib. Why not have some kind of marker on all definitions of partial functions? Then periodically somebody goes through all these markers and changes their junk values to other junk values to test if the rest of mathlib is truly independent of these choices.</p>



<a name="319527558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319527558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319527558">(Jan 05 2023 at 07:26)</a>:</h4>
<p>I remember thinking about this a few years ago and then deciding that any change that made things more complicated was hard to justify in practice.</p>



<a name="319527659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319527659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319527659">(Jan 05 2023 at 07:27)</a>:</h4>
<p>this is not true: we sometimes rely on junk values so that some simple theorems are true with less assumptions than in traditional maths. I don't have a good example at hand, though.</p>



<a name="319527794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319527794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin (尹維晨) <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319527794">(Jan 05 2023 at 07:28)</a>:</h4>
<p>Is this something desirable if traditional mathematicians are the intended users?</p>



<a name="319527998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319527998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319527998">(Jan 05 2023 at 07:30)</a>:</h4>
<p>This is definitely desirable since it leaves less assumptions to check for the user of theorems, and therefore makes the library smoother to use.</p>



<a name="319528018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319528018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319528018">(Jan 05 2023 at 07:30)</a>:</h4>
<p>it is very practiable and if it does not change the interesting mathematics, then I think nobody will object to that.</p>



<a name="319528149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319528149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319528149">(Jan 05 2023 at 07:31)</a>:</h4>
<p>A good example is the change of variables formula <a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.integral_target_eq_integral_abs_det_fderiv_smul">docs#measure_theory.integral_target_eq_integral_abs_det_fderiv_smul</a>, where you don't need to check that the function is integrable because otherwise the same junk value <code>0</code> is used on both sides of the formula which is therefore still true.</p>



<a name="319529970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319529970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319529970">(Jan 05 2023 at 07:47)</a>:</h4>
<p>The canonical example is (a+b)/c=a/c+b/c</p>



<a name="319576075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319576075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319576075">(Jan 05 2023 at 12:35)</a>:</h4>
<p>Kevin has a nice blog post about this on Xena, btw. (If I was at a desk I'd look it up)</p>



<a name="319577480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319577480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319577480">(Jan 05 2023 at 12:42)</a>:</h4>
<p><a href="https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>



<a name="319691686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319691686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin (尹維晨) <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319691686">(Jan 05 2023 at 23:24)</a>:</h4>
<p>I somewhat agree with Sebastian Reichelt's comment on your post, Kevin, that the proof assistant should make the experience of using partial functions more convenient, independently of the question of the practical use of junk values. For example (maybe I'm totally misunderstanding how proof assistants work), when writing <code>real.sqrt x</code>, the proof assistant should let you keep on proving things without interruption, while silently introducing another goal <code>x ≥ 0</code> to be completed later. If such goals are showing up repeatedly throughout the proof, then a list of local "facts" may be declared and proven at the beginning of your proof / block, which the compiler can automatically use to discharge such goals.</p>



<a name="319692325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319692325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319692325">(Jan 05 2023 at 23:28)</a>:</h4>
<p>that would be nice, but I think it is mostly wishful thinking to think that those goals would be silently created and/or discharged without interrupting the "flow"</p>



<a name="319703228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319703228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319703228">(Jan 06 2023 at 01:14)</a>:</h4>
<p>A whole series of real functions happen to have junk values defined to be equal to the real part of the (principal value of the) corresponding complex function at that argument; that applies to <code>sqrt</code>, <code>log</code>, <code>arcsin</code>, <code>arccos</code>, <code>arctan</code>, <code>rpow</code> at least (though only <code>rpow</code> has that as the definition, and we don't have the complex inverse trigonometric functions defined at all). It seems those junk values often work well together to reduce the number of times hypotheses are needed that arguments are in range.</p>



<a name="319703229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319703229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319703229">(Jan 06 2023 at 01:14)</a>:</h4>
<p>Doesn't typing <code>suffices h : 0 &lt;= x</code> basically just keep the <code>0 &lt;= x</code> goal out of the way and force you to prove it at the end instead of immediately? I know no one uses it that way but I don't really think that Winston Yin's suggestion is infeasible with our current tactics. Discharging these goals is probably the hard part. It could perhaps be some new syntax, like two underscores or something, that you use instead of a proof to defer the proof until the end.</p>



<a name="319720686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319720686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin (尹維晨) <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319720686">(Jan 06 2023 at 05:29)</a>:</h4>
<blockquote>
<p>A whole series of real functions happen to have junk values defined to be equal to the real part of the ...</p>
</blockquote>
<p>Then I am happy to stop calling them junk and call them unconventional instead. Seems to me they're no different than "0! = 1" or "heaviside(0) = 1/2" in spirit. From the standpoint of popularising formalisation towards mathematicians, this (philosophical) point about partial functions would have to be made clear from the beginning, probably somewhere on the path of de-conversion from set theory. Then I'll just accept that "any practical implementation of type theory really doesn't like partial functions".</p>



<a name="319720869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319720869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319720869">(Jan 06 2023 at 05:32)</a>:</h4>
<p><span class="user-mention" data-user-id="521331">@Niels Voss</span> You would still be typing more lines of proof than you have to do now. Which I would rather not.</p>



<a name="319721099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319721099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319721099">(Jan 06 2023 at 05:35)</a>:</h4>
<p>I guess I agree with that. Also, having read all the replies to this thread, I agree now that having <code>1 - 2</code> be <code>0</code> is probably the best that we can do in practice, though I agree with Winston Yin that this should be documented somewhere.</p>



<a name="319721350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319721350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Winston Yin (尹維晨) <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319721350">(Jan 06 2023 at 05:39)</a>:</h4>
<p>My point is that it should not only be documented on <code>nat.sub</code>, but in any introduction to computer formalisation of maths. For me that was TPiL, but it was not clear to me then how much Lean doesn't like partial functions and subtypes.</p>



<a name="319734891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319734891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319734891">(Jan 06 2023 at 08:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319720869">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="521331">Niels Voss</span> You would still be typing more lines of proof than you have to do now. Which I would rather not.</p>
</blockquote>
<p>I think this is actually false</p>



<a name="319735015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319735015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319735015">(Jan 06 2023 at 08:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Would you bundle the side conditions? Otherwise I don't see how you would save on lines.</p>



<a name="319735034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319735034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319735034">(Jan 06 2023 at 08:12)</a>:</h4>
<p>Unless you have some really smart automation going on.</p>



<a name="319735259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319735259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319735259">(Jan 06 2023 at 08:14)</a>:</h4>
<p>You basically always need to know whatever facts guarantee that what you wrote down was "well-defined" (else, why not just write 37 instead?) and if you make those proofs arguments to the partial functions, then they are available for later automation</p>



<a name="319735675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319735675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319735675">(Jan 06 2023 at 08:18)</a>:</h4>
<p>But that can also be done with our current strategy, right?</p>



<a name="319735702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319735702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319735702">(Jan 06 2023 at 08:18)</a>:</h4>
<p>You add <code>have aux1 : side condition</code> to your context, and voila, it is available to automation.</p>



<a name="319735737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319735737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319735737">(Jan 06 2023 at 08:19)</a>:</h4>
<p>only sufficiently local automation</p>



<a name="319735766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319735766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319735766">(Jan 06 2023 at 08:19)</a>:</h4>
<p>Anyways, I'm fairly convinced that the mathlib wisdom on this is just wrong but I don't think it will change.</p>



<a name="319735863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319735863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319735863">(Jan 06 2023 at 08:20)</a>:</h4>
<p>Are there examples of libraries (preferably with a DTT foundation) that take a different route?</p>



<a name="319735940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319735940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319735940">(Jan 06 2023 at 08:21)</a>:</h4>
<p>Also, if you want to pass the side condition to the partial function (which isn't what Niels was suggesting in the post I replied to) then how would you combine that with readable notation?</p>



<a name="319737388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319737388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319737388">(Jan 06 2023 at 08:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319449932">said</a>:</p>
<blockquote>
<p>And even then they're merely unspecified, you can still prove all kinds of theorems about them.  Like <code>(a / b)^2 + 1 &gt; 0</code>.</p>
</blockquote>
<p>That only applies to type theory. In set theory, a function is a set of ordered pairs. If called with an argument outside of the domain, the result can be any set (choice-based set parametrized with the function and the argument), which is not necessarily in the codomain. So, you couldn't prove <code>(a / b)^2 + 1 &gt; 0</code> if <code>a</code> or <code>b</code> cannot be proved to be real numbers for example.</p>



<a name="319737617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319737617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319737617">(Jan 06 2023 at 08:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319735259">said</a>:</p>
<blockquote>
<p>You basically always need to know whatever facts guarantee that what you wrote down was "well-defined" (else, why not just write 37 instead?) and if you make those proofs arguments to the partial functions, then they are available for later automation</p>
</blockquote>
<p>Making more functions take proofs as arguments will lead to <code>rw</code> throwing <code>motive not type correct</code> all the time.</p>



<a name="319738456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319738456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319738456">(Jan 06 2023 at 08:43)</a>:</h4>
<p>I think the idea for having an "unknown" junk value (or an implicit junk value as a corollary of using <code>classical.epsilon</code>) rather than an explicit default value is to prevent us from proving nonsense theorems (such as <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.div_zero">docs#nat.div_zero</a>), simply because they are counter-intuitive to most mathematicians, and generally a bad advertisement for Lean. Instead, the right path would be to invent a better way of dealing with those special conditions.</p>



<a name="319837755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319837755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319837755">(Jan 06 2023 at 18:31)</a>:</h4>
<blockquote>
<p>That only applies to type theory.</p>
</blockquote>
<p>Obviously we're only talking about Lean('s foundations) here.  There are other foundations where partiality is even "better" handled, and you can't even prove <code>a / b = a / b</code> (which is a junk theorem provable in set theory).</p>



<a name="319883493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319883493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319883493">(Jan 06 2023 at 23:55)</a>:</h4>
<p>Do you have an example of such foundations? I'm interested to learn more about them.</p>



<a name="319883578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319883578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319883578">(Jan 06 2023 at 23:56)</a>:</h4>
<p>BTW, I think <code>a / b = a / b</code> would be the expected result no matter what <code>a</code> and <code>b</code> are. Most mathematicians would agree that <code>1 / 0 = 1 / 0</code>, even though <code>1 / 0</code> may not be a real number, but it is definitely "something", and any object is equal to itself. (Unless equality itself is a partial relation?)</p>



<a name="319885540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319885540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tyler Josephson ⚛️ <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319885540">(Jan 07 2023 at 00:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319692325">said</a>:</p>
<blockquote>
<p>that would be nice, but I think it is mostly wishful thinking to think that those goals would be silently created and/or discharged without interrupting the "flow"</p>
</blockquote>
<p>This reminds me of what I see WolframAlpha doing sometimes. For example, <a href="https://www.wolframalpha.com/input?i=a+x+%5E+2+%2B+b+x+%2B+c+%3D+0+solve+for+x">https://www.wolframalpha.com/input?i=a+x+%5E+2+%2B+b+x+%2B+c+%3D+0+solve+for+x</a>. The answer depends on whether or not a and b are 0, and I didn’t specify. But I still get an answer — in fact, I get a few answers, along with the additional hypotheses needed to get to each one.</p>



<a name="319905330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319905330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319905330">(Jan 07 2023 at 05:02)</a>:</h4>
<p>We have this thing called partial equivalence relations, and it is very useful in proving type theoretic theorems. Also, some constructive foundations use this (a type equipped with a PER) when you don't have good quotients and subtypes.</p>



<a name="319919992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/319919992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#319919992">(Jan 07 2023 at 08:28)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/divp">docs#divp</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/has_deriv_at">docs#has_deriv_at</a>, and <a href="https://leanprover-community.github.io/mathlib_docs/find/nnreal.sqrt">docs#nnreal.sqrt</a> for people who want to avoid junk values.</p>



<a name="321896751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321896751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321896751">(Jan 17 2023 at 18:24)</a>:</h4>
<p>After some research I have come to the conclusion: <strong>Every proof assistant that uses classical logic and formalizes real numbers have <code>x/0=0</code></strong>.</p>



<a name="321896909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321896909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321896909">(Jan 17 2023 at 18:25)</a>:</h4>
<p>I am very happy to be proved wrong but I just haven't come across any. For constructive people, this is not an option because you can't decide whether a real number is zero, so they have to find another way.</p>



<a name="321897075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321897075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321897075">(Jan 17 2023 at 18:26)</a>:</h4>
<p>Also, this is not restricted to type theory. Mizar does that too.</p>



<a name="321897361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321897361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321897361">(Jan 17 2023 at 18:28)</a>:</h4>
<p>Metamath defines <code>x/0</code> to be the empty set instead of 0, but that also counts as a junk value.</p>



<a name="321897529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321897529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321897529">(Jan 17 2023 at 18:28)</a>:</h4>
<p>I would count <em>any</em> value for <code>x/0</code> as a junk value...</p>



<a name="321897656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321897656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321897656">(Jan 17 2023 at 18:29)</a>:</h4>
<p>No, if division returns <code>Option Real</code> and <code>x/0 = None</code> then probably not</p>



<a name="321897812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321897812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321897812">(Jan 17 2023 at 18:30)</a>:</h4>
<p>Or if it is outright undefined, like if you have a proof obligation before you use division.</p>



<a name="321897876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321897876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321897876">(Jan 17 2023 at 18:30)</a>:</h4>
<p>Can you add a real number to the empty set in Metamath? I think they use complex numbers?</p>



<a name="321897893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321897893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321897893">(Jan 17 2023 at 18:30)</a>:</h4>
<p>In that case, before starting on formalizing math, I would have considered <em>all</em> values as junk values!  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="321898068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321898068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321898068">(Jan 17 2023 at 18:31)</a>:</h4>
<p>Yes you can add anything. Nonsense addtions return the empty set.</p>



<a name="321898236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321898236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321898236">(Jan 17 2023 at 18:31)</a>:</h4>
<p>Yeah so maybe the lesson is that junk values occur much more often in set theory than in type theory.</p>



<a name="321901232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321901232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321901232">(Jan 17 2023 at 18:47)</a>:</h4>
<p><a href="https://arxiv.org/abs/0901.0823">There's a paper</a> defining "meadows," which are rings with a total inverse-like function. Fields extend to meadows if you have x/0 = 0.</p>
<p>There's also something called a <a href="https://en.wikipedia.org/wiki/Von_Neumann_regular_ring">von Neumann regular ring</a> -- I guess <a href="#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/203041825">I brought these up before</a> in this context. In a von Neumann regular ring, for every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> there exists a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mi>y</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x=xyx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">x</span></span></span></span>, a sort of weak inverse. If you say you want an involutive function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">f:R\to R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> that chooses a weak inverse for each element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, then it must be the case that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(0)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>.</p>



<a name="321901540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321901540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321901540">(Jan 17 2023 at 18:49)</a>:</h4>
<p>I think that from an algebraic point of view, there are plenty of good reasons for <code>x/0 = 0</code>. But topologically it is of course garbáge.</p>



<a name="321912748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321912748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321912748">(Jan 17 2023 at 19:46)</a>:</h4>
<blockquote>
<p>Metamath defines <code>x/0</code> to be the empty set instead of 0, but that also counts as a junk value.<br>
Nonsense addtions return the empty set.</p>
</blockquote>
<p>In the classical set theory (also applies to mizar) it would be much better if they defined addition and division of real numbers using Hilbert's epsilon, so that the result of <code>x / 0</code> can be any set that could possibly exist, not necessarily a real number. Then create an appropriate API for using division and all lemmas that use division <code>a / b</code> would have an assumption <code>b ≠ 0</code>. From the implementational point of view, this additional assumption can be proved automatically from the local context in most cases (just like Lean's type class resolution).</p>



<a name="321913271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321913271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321913271">(Jan 17 2023 at 19:49)</a>:</h4>
<p>Unfortunately, metamath lacks automation and mizar is no longer actively developed (and more importantly not open source). I'm wondering what could be the reason there are no good set-theoretic theorem provers out there.</p>



<a name="321920221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321920221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321920221">(Jan 17 2023 at 20:30)</a>:</h4>
<p>Metamath must have something going for it, if Mario can prove the prime number theorem in it.</p>



<a name="321922002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321922002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321922002">(Jan 17 2023 at 20:40)</a>:</h4>
<p>That thing is probably Mario...</p>



<a name="321962644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321962644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321962644">(Jan 18 2023 at 02:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/319735259">said</a>:</p>
<blockquote>
<p>You basically always need to know whatever facts guarantee that what you wrote down was "well-defined" (else, why not just write 37 instead?) and if you make those proofs arguments to the partial functions, then they are available for later automation</p>
</blockquote>
<p>A good example of where this approach is useful is <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.cons">docs#finset.cons</a> / <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.disj_union">docs#finset.disj_union</a> vs <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.has_insert">docs#finset.has_insert</a> / <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.has_union">docs#finset.has_union</a>. When working with sums, the first pair has an obvious lemma with no side conditions.</p>



<a name="321962796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321962796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321962796">(Jan 18 2023 at 02:18)</a>:</h4>
<p>One downside of this approach is that you often need two versions of every lemma, one with the free hypothesis variables on the RHS, and one with them on the LHS; <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.singleton_disj_union">docs#finset.singleton_disj_union</a> doesn't automatically populate the side condition when rewriting backwards.</p>



<a name="321962997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321962997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321962997">(Jan 18 2023 at 02:21)</a>:</h4>
<p>For division we have <code>/ₚ</code>. It requires the denominator to be a unit.</p>



<a name="321982709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321982709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321982709">(Jan 18 2023 at 06:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="404479">Trebor Huang</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/321896751">said</a>:</p>
<blockquote>
<p>After some research I have come to the conclusion: <strong>Every proof assistant that uses classical logic and formalizes real numbers have <code>x/0=0</code></strong>.</p>
</blockquote>
<p>Metamath does not define the division function at zero. The function properly has the domain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="double-struck">C</mi><mo>∖</mo><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}\times(\mathbb{C}\setminus\{0\})\to \mathbb{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7722em;vertical-align:-0.0833em;"></span><span class="mord mathbb">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbb">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mclose">})</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span>. It is true that if you evaluate <code>( x / 0 )</code> you get the empty set but that's because this is what happens when you use the "function value" operator on a ZFC function out of domain, not because division was defined that way.</p>



<a name="321983467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321983467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321983467">(Jan 18 2023 at 06:56)</a>:</h4>
<p>Even more interestingly, there is a new metamath database <a href="https://us.metamath.org/ileuni/mmil.html">iset.mm</a> (for intuitionistic set theory) which has gotten a lot of recent work done on it thanks to Jim Kingdon, and while it tries to follow <a href="https://us.metamath.org/mpeuni/mmset.html">set.mm</a> where possible you just flat out cannot prove that the "function value" operation makes any sense without an assumption that the input is in the function's domain. It gets as far as the real numbers, and division again has the same definition (well, I think you need the denominator to be apart from zero but w/e), but you definitely don't have <code>x/0 = 0</code> there. (Although, you did head this off by qualifying "classical logic" so I suppose that doesn't count against your claim.)</p>



<a name="321985530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321985530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321985530">(Jan 18 2023 at 07:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/321913271">said</a>:</p>
<blockquote>
<p>Unfortunately, metamath lacks automation and mizar is no longer actively developed (and more importantly not open source). I'm wondering what could be the reason there are no good set-theoretic theorem provers out there.</p>
</blockquote>
<p>Just in case it wasn't obvious, this is basically asking "why aren't there more theorem provers with 30+ person-years of effort put into them". That doesn't come cheap, and as a result you will see a variety of development-specific peculiarities in the ones that exist. Mizar is quite honestly the best contender in that space, it has had many years of effort put into it, but it started out in a completely different era and it has a lot of baggage from that time period. I will also of course shill my <a href="https://github.com/digama0/mm0">MM0</a> system as a sort of hybrid of metamath with automation, although (like metamath) it is not explicitly set theory based so much as FOL based.</p>



<a name="321988909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321988909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321988909">(Jan 18 2023 at 07:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/321985530">said</a>:</p>
<blockquote>
<p>Just in case it wasn't obvious, this is basically asking "why aren't there more theorem provers with 30+ person-years of effort put into them". </p>
</blockquote>
<p>I'm not talking about math library, I'm talking about design choices of the verifier. Foundations, implementation decisions, term/tactic mode proofs, and similar concepts. Once conceptually designed, a single person can implemented it in a very short period of time and start building a math library.</p>



<a name="321989845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321989845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321989845">(Jan 18 2023 at 07:44)</a>:</h4>
<p>Last year I started designing and implementing a purely set-theoretic theorem prover. Two of my friends are working with me and we plan to finish the verifier near the end of this year. Then we will build a simple math library and prove basic things from number theory. I'm pretty sure this won't take 30+ person-years of effort.</p>



<a name="321992415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321992415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321992415">(Jan 18 2023 at 08:03)</a>:</h4>
<p>sure, but will it be "good"? That's a really load-bearing word. It takes years of effort for a theorem prover to become "good"</p>



<a name="321992506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321992506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321992506">(Jan 18 2023 at 08:04)</a>:</h4>
<p>There are plenty of theorem provers out there with every possible design decision if you don't put that word in</p>



<a name="321993037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321993037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321993037">(Jan 18 2023 at 08:08)</a>:</h4>
<p>Set theory based provers probably have different aesthetics, so what counts as junk value would be different. Judging from a type theoretic perspective returning the empty set definitely counts as junk values, but you could argue otherwise from the set theoretic view.</p>



<a name="321993429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321993429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321993429">(Jan 18 2023 at 08:11)</a>:</h4>
<p>In any FOL system, function symbols are fundamentally required to denote something. It's no different from a type theory system in which there is only one or only a few types</p>



<a name="321993447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321993447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321993447">(Jan 18 2023 at 08:11)</a>:</h4>
<p>the best you can do is control what theorems are provable about that something</p>



<a name="321993720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321993720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321993720">(Jan 18 2023 at 08:13)</a>:</h4>
<p>Personally, I'm in the camp of embracing "junk values" and making them as useful as possible though, so I'm not really motivated to come up with even more tightly isolated junk values, because it never works and only causes pain in my experience</p>



<a name="321993956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321993956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321993956">(Jan 18 2023 at 08:15)</a>:</h4>
<p>So if I were making a theorem prover I would set <a href="https://github.com/digama0/mm0/blob/45e06c7f95293e974bebd66350c9c45ca304a9a3/examples/peano.mm0#L275"><code>x / 0 = 0</code></a> like lean does</p>



<a name="321994017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321994017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321994017">(Jan 18 2023 at 08:15)</a>:</h4>
<p>In first order logic + set theory, the empty set looks very much like a global canonical junk, so I'm fine with that. Type theory doesn't give you that (at least not in Lean, I think some type theories not using the CH isomorphism introduce a global undefined value for every type).</p>



<a name="321994041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/321994041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#321994041">(Jan 18 2023 at 08:15)</a>:</h4>
<p><code>Inhabited</code> basically gives you canonical junk</p>



<a name="322119027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322119027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322119027">(Jan 18 2023 at 18:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/321993956">said</a>:</p>
<blockquote>
<p>So if I were making a theorem prover I would set <a href="https://github.com/digama0/mm0/blob/45e06c7f95293e974bebd66350c9c45ca304a9a3/examples/peano.mm0#L275"><code>x / 0 = 0</code></a> like lean does</p>
</blockquote>
<p>It highly depends on what the goal of a theorem prover is supposed to be. MM0 has an objective task it's trying to accomplish, so it makes sense to have <code>x / 0 = 0</code> as a theorem if it helps reach the final task. However, if we want to write a general-purpose theorem prover to formalize actual mathematics, I see the undefinedness of <code>x / 0</code> as a challenge for the theorem prover inventors, rather than a nuisance we want to avoid at all costs. Mathematicians can handle that on paper without any trouble, so a good theorem prover should have the ability to smoothly translate mathematician's intuition to a formal proof, not to artificially force mathematicians to change their intuition because of the implementational limitations.</p>



<a name="322125938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322125938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322125938">(Jan 18 2023 at 18:42)</a>:</h4>
<p>This is most likely an irreconcilable difference of opinion, but my angle as a logician and formalist is to find the optimal way to communicate mathematics to a computer, not just to do paper mathematics in the computer and faithfully represent all the designed-for-humans tricks used in paper presentations of mathematics. The latter is a goal for some people, and systems based on controlled natural language very clearly show it, but I am looking at the longer term, where we eventually realize we don't need to follow those old habits anymore. It is akin to the evolution of programming languages: many of the old programming languages were <em>very</em> CNL inspired, but modern programming languages have diverged somewhat from that into simpler grammars with a greater emphasis on symbols instead of words, making the most of a restricted lexicon to make things easy for both the human and the computer.</p>
<p>As it relates to undefinedness specifically, I find that the best way to render the mathematical practice of having "unmentionables" is to use garbage values and then just... not talk about them. Or use them to reduce hypotheses in theorems because more hypotheses = more work.</p>



<a name="322136542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322136542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322136542">(Jan 18 2023 at 19:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/322119027">said</a>:</p>
<blockquote>
<p>A good theorem prover should have the ability to smoothly translate mathematician's intuition to a formal proof, not to artificially force mathematicians to change their intuition because of the implementational limitations.</p>
</blockquote>
<p>Note that this might be alternatively phrased as</p>
<blockquote>
<p>A good theorem prover should never produce new mathematical viewpoints or ideas, and it should have the ability to transfer mathematician's old ideas as faithfully as possible.</p>
</blockquote>



<a name="322138664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322138664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322138664">(Jan 18 2023 at 19:47)</a>:</h4>
<p>I don't think I agree with this rephrasing. But in any case, I think that while there are cases where garbage values really are garbage, in many instances I think that appropriately chosen junk values can actually become "not junk". For instance, I consider the theorem</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group_with_zero</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹⁻¹</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>a <em>feature</em>, not a bug or a misrepresentation of the mathematical content. Sure, it conflicts with the way mathematical content is currently presented, but I have pretty much decided that I prefer it this way and I would hope eventually the mathematical community could accept the more useful (i.e., ones that make a bunch of theorems have weaker hypotheses) "junk values".</p>
<p>Oh, and if you don't want garbage values, there's always <a href="https://leanprover-community.github.io/mathlib_docs/find/pfun">docs#pfun</a>.</p>



<a name="322143672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322143672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322143672">(Jan 18 2023 at 20:14)</a>:</h4>
<p>I would say that mathematicians do <em>not</em> handle division by zero on paper without any trouble -- they simply <em>don't divide by zero</em>.</p>



<a name="322156397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322156397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arien Malec <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322156397">(Jan 18 2023 at 21:28)</a>:</h4>
<p>Physicists, on the other hand…</p>



<a name="322160762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322160762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322160762">(Jan 18 2023 at 21:53)</a>:</h4>
<blockquote>
<p>I would say that mathematicians do not handle division by zero on paper without any trouble -- they simply don't divide by zero.</p>
</blockquote>
<p>By "Mathematicians can handle <strong>that</strong> on paper" I mean handling of the additional assumptions of the form <code>x ≠ 0</code></p>



<a name="322161141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322161141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322161141">(Jan 18 2023 at 21:55)</a>:</h4>
<p>That is, they don't need to interrupt the proof to show that the division in some particular expression is well-defined. It is either obvious from the context, or in case it's not, they give a small comment explaining why the denominator can't be zero there.</p>



<a name="322162051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322162051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322162051">(Jan 18 2023 at 22:01)</a>:</h4>
<p>If one day mathematicians realize they want division by zero to be 0 and change the standard convention, we should accept that. My point is not whether that definition would be useful in practice or not, but that a good theorem prover should let the user easily work with truly undefined results if the user wants them in definitions for whatever reason.</p>



<a name="322162567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322162567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322162567">(Jan 18 2023 at 22:04)</a>:</h4>
<p>Yes, mathematicians are good at knowing that xy is obviously nonzero if x and y are nonzero, or that sqrt(x^2+1) is obviously non-zero etc (here x and y are reals). But this sounds like a hard problem for automation.</p>



<a name="322163512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322163512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322163512">(Jan 18 2023 at 22:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/322162051">said</a>:</p>
<blockquote>
<p>If one day mathematicians realize they want division by zero to be 0 and change the standard convention, we should accept that. My point is not whether that definition would be useful in practice or not, but that a good theorem prover should let the user easily work with truly undefined results if the user wants them in definitions for whatever reason.</p>
</blockquote>
<p>These people are welcome to make their division with <code>pfun</code> but I'm happy to stick with what's easiest. I don't particularly believe in building scaffolding so that people can fall off from higher up</p>



<a name="322164196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322164196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322164196">(Jan 18 2023 at 22:15)</a>:</h4>
<p>You can also use this as an argument against type systems.</p>



<a name="322165674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322165674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322165674">(Jan 18 2023 at 22:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/322162567">said</a>:</p>
<blockquote>
<p>that xy is obviously nonzero if x and y are nonzero, or that sqrt(x^2+1) is obviously non-zero etc </p>
</blockquote>
<p>And it's not just this but also: the cardinality of a nonempty (and also finite, obviously) set is obviously non-zero, and the set is also nonempty for some obvious reason...</p>



<a name="322184344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322184344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322184344">(Jan 19 2023 at 01:15)</a>:</h4>
<p>If a mathematician wants to talk about division (as a partial function) in Lean, they can use <a href="https://leanprover-community.github.io/mathlib_docs/find/divp">docs#divp</a> with <code>units.mk0</code> here and there.</p>



<a name="322198065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322198065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322198065">(Jan 19 2023 at 04:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="404479">Trebor Huang</span> <a href="#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions/near/322136542">said</a>:<br>
Note that this might be alternatively phrased as</p>
<blockquote>
<p>A good theorem prover should never produce new mathematical viewpoints or ideas, and it should have the ability to transfer mathematician's old ideas as faithfully as possible.</p>
</blockquote>
<p>I don't really know if I agree with this rephrasing, because it is possible that at some point in the future, the problem of partial functions will be solved <em>by</em> an innovation in mathematics. I read somewhere that to formalize the many different types of limits in Lean we had to use filters, which in my opinion is an example of something difficult to formalize being formalized by coming up with new mathematics. You can call me overly optimistic, but in other words it's possible that at some point in the future we will encounter a way to express partial functions in a natural way consistent with pen-and-paper mathematics but friendly to formalization (kind of like how the Curry-Howard isomorphism is very unique and different from what mathematicians are used to but ultimately is consistent with mathematicians' basic rules). My point is not that this is particularly likely to happen, but rather that looking for ways to formalize difficult-to-formalize ideas in a natural way can actually be somewhat insightful, and not just clinging onto obsolete ideas from pen-and-paper mathematics.</p>
<p>However, as far as Lean is concerned, I think <code>n / 0 = 0</code> is the best choice simply because it makes a lot of things easier to work with by reducing the number of hypotheses, and isn't as different from pen-and-paper mathematics as I had originally thought (and, as other people have mentioned, junk values can have a lot of desirable properties). The only place where I am a bit wary of this would be when programming, since I would normally expect division by zero to crash the program (which can potentially avoid many worse things such as data corruption or security vulnerabilities). Hopefully with the ability to do logical verification this won't be that big of a problem.</p>



<a name="322198785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322198785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322198785">(Jan 19 2023 at 04:40)</a>:</h4>
<p>What is the essential difference between introducing filters (for basic analysis) and introducing <code>x/0=0</code>? One is more aesthetically grounded than the other? Apart from that these two are both forcing something mathematicians don't conventionally use, because they make formalization easier.</p>



<a name="322198860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322198860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Trebor Huang <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322198860">(Jan 19 2023 at 04:41)</a>:</h4>
<p>Also, in Lean we have that <code>lst[n]!</code> crashes the program, but is definitionally equal to some junk value. Do we do that for division? (Not for real number, for the more computable stuff)</p>



<a name="322199273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322199273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322199273">(Jan 19 2023 at 04:48)</a>:</h4>
<p>I can't really argue much about the filters because I actually don't know much about them, I just happened to briefly read about them somewhere. Division could be designed to crash when dividing by zero, but I think that actually might prevent you from being able to prove that your program doesn't crash. Right now, you pretty much know that if you don't use either panic or an operation ending with a <code>!</code> then your program probably won't crash. Maybe a separate <code>/!</code> operator that crashes could be introduced.<br>
Now that I think about it more, I actually don't know a good way to resolve the programming aspect of division by zero, aside from using <code>divp</code>, which as was discussed earlier, would be more difficult to use.</p>



<a name="322199658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Opaque%20junk%20values%20for%20partial%20functions/near/322199658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Niels Voss <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions.html#322199658">(Jan 19 2023 at 04:55)</a>:</h4>
<p>Now that I think about it, something like <code>divp</code> (or a <code>divp?</code> that returns an <code>option</code>) might not actually be that bad of an idea while programming, because it helps prevent certain types of errors when implementing algorithms. <code>n / 0 = 0</code> is still probably better for doing mathematics, though.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
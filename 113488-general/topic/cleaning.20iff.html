---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/cleaning.20iff.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html">cleaning iff</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="174212351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174212351">(Aug 27 2019 at 09:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> in particular: another area (besides calculations) where I'm always angry about automation is many proofs that are only unpackaging and repackaging stuff. The following is an example abstracted from a topological groups and filter context:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_sub</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="err">$</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
 <span class="o">(</span><span class="bp">∀</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">},</span> <span class="n">V</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">t</span> <span class="err">∈</span> <span class="n">T</span><span class="o">),</span> <span class="n">set</span><span class="bp">.</span><span class="n">prod</span> <span class="n">t</span> <span class="n">t</span> <span class="err">⊆</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">V</span><span class="o">))</span> <span class="bp">↔</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">U</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">M</span> <span class="err">∈</span> <span class="n">T</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">-</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>



<a name="174212424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174212424">(Aug 27 2019 at 09:48)</a>:</h4>
<p>This has no mathematical content (in the sense that a mathematician wouldn't understand what requires a proof here).</p>



<a name="174212570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174212570">(Aug 27 2019 at 09:50)</a>:</h4>
<p>What I would like Lean to do is at least to peel-off layers that are common to both lines.</p>



<a name="174212582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174212582">(Aug 27 2019 at 09:50)</a>:</h4>
<p>Note that in this specific example, <code>by simp [subset_def]</code> works.</p>



<a name="174212794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174212794">(Aug 27 2019 at 09:53)</a>:</h4>
<p>But it takes time to reach that conclusion. I also experimented writing the following stupid tactic:</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">tactic</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">clean_step</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">tgt</span> <span class="err">←</span> <span class="n">target</span><span class="o">,</span>
   <span class="k">match</span> <span class="n">tgt</span> <span class="k">with</span>
   <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">a</span> <span class="bp">→</span> <span class="err">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">intros</span><span class="o">]</span>
   <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">a</span> <span class="bp">↔</span> <span class="err">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
                     <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">c</span> <span class="bp">→</span> <span class="err">%%</span><span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">c</span><span class="bp">.</span><span class="n">has_var</span> <span class="k">then</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">imp_congr</span><span class="o">]</span> <span class="k">else</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">forall_congr</span><span class="o">]</span>
                     <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">Exists</span> <span class="err">%%</span><span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">exists_congr</span><span class="o">]</span>
                     <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="n">iff</span><span class="bp">.</span><span class="n">rfl</span><span class="o">]</span>
                     <span class="kn">end</span>
   <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">&quot;Goal is not a forall, implies or iff&quot;</span>
   <span class="kn">end</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">clean_iff</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span> <span class="n">repeat</span> <span class="n">clean_step</span>
</pre></div>


<p>doing the peeling-off. In the example above, it reduces the goal to <code>set.prod s s ⊆ (λ (x : α × α), x.snd - x.fst) ⁻¹' a ↔  ∀ (x y : α), x ∈ s → y ∈ s → y - x ∈ a</code> which can be closed by <code>library_search</code>, which is pretty good I think. Should we try to make a smarter version of that tactic?</p>



<a name="174213553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174213553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174213553">(Aug 27 2019 at 10:04)</a>:</h4>
<p>I've wanted such a "mild" congr tactic as well.</p>



<a name="174226236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174226236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174226236">(Aug 27 2019 at 13:04)</a>:</h4>
<p>This does feel like something within the scope of congr</p>



<a name="174229806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174229806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174229806">(Aug 27 2019 at 13:41)</a>:</h4>
<p>I have had to do similar things, with crazy lambdas and corner brackets. It is funny how much of mathematics is just unpacking and repacking information. This is something that a decent tableau prover should do. (I am disappointed that <code>finish</code> is no help.) It is worth experimenting to see how useful a <code>congr</code>-like tactic is, though eventually it would be nice to see this subsumed by general automation.</p>



<a name="174229918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174229918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174229918">(Aug 27 2019 at 13:42)</a>:</h4>
<p>I have no opinion about what kind of automation should do it, I only say <em>I</em> don't want to do it.</p>



<a name="174230252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174230252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174230252">(Aug 27 2019 at 13:46)</a>:</h4>
<p>Here is my short answer to your "automation for the working mathematician" wish-list question:</p>
<ul>
<li>elaboration that works, including coercions, especially to functions, and type class resolution</li>
<li>calculations where I only give the intermediate steps I would write on paper, using <code>ring</code>, <code>abel</code> and their non-existent extensions to other algebraic structures, and non-linear <code>linarith</code></li>
<li>packing/unpacking stuff</li>
</ul>



<a name="174231499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174231499">(Aug 27 2019 at 13:58)</a>:</h4>
<p>Thanks! I really am taking notes and gathering all the comments I received.</p>



<a name="174231785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174231785">(Aug 27 2019 at 14:02)</a>:</h4>
<p>I would have never guessed that when I started Lean and everything was confusing, but today it's clear that elaboration is by far the most important aspect. I spend most of my wasted time fighting the elaborator (and parser maybe).</p>



<a name="174231906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174231906">(Aug 27 2019 at 14:03)</a>:</h4>
<p>With good-old-paper-maths you could offload those fights to the reader (-;</p>



<a name="174231930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174231930">(Aug 27 2019 at 14:03)</a>:</h4>
<p>This and so many other boring details</p>



<a name="174231934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174231934">(Aug 27 2019 at 14:03)</a>:</h4>
<p>The elaborator is the formalisation of "left as an exercise for the reader" <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="174232508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174232508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174232508">(Aug 27 2019 at 14:09)</a>:</h4>
<p>One important question is what should be done by the elaborator and what should be done by automation at a later stage. The elaborator should be focused on filling in information that is absolutely essential to make sense of an expression. It may be putting too much of a burden on the elaborator to expect it to prove that an operation is commutative or a set is finite. Maybe that is best done by another process later on, that acts when all the implicit data has been inferred.</p>



<a name="174233034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174233034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174233034">(Aug 27 2019 at 14:14)</a>:</h4>
<p>Let me prove once more that I have no idea how type classes work, and ask: why is it stupid to insert the following two mechanisms into type class search:</p>
<ul>
<li>allow to write <code>instance_for `X my_class := explicit_instance or by apply_instance</code> where, as usual, <code> `X </code> is a name. Then every type Lean wants to infer an instance for <code>my_type X</code> use the database created by that line. </li>
<li>If the previous method fails,  class search <code>[my_class X Y Z...]</code> by a search by name head_symbol_of_X.class_name</li>
</ul>
<p>If both fail then use the current algorithm. To me it sounds like this would solve most of the cases where Lean fails or take forever to find an instance. For instance we have files in the perfectoid space where <code>K</code> denotes a field, and it does so for 1000 lines.  And each proof involves Lean searching at least twice for <code>comm_ring K</code>. It sounds like looking at a hash table under key <code>K</code> would be much faster.</p>



<a name="174233591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174233591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174233591">(Aug 27 2019 at 14:20)</a>:</h4>
<p>I don't think I want to put a burden on the elaborator. I only want coercions and type class search to do their jobs. And also, I'd like the elaborator to stop thinking every numeral is in nat</p>



<a name="174237114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174237114">(Aug 27 2019 at 14:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Adding a head index (i.e. exactly what <code>simp</code> uses) to the instance search is definitely something we have been thinking about. Though I believe Leo already has new plans for the whole algorithm we haven't talked about yet, so I won't speculate any further for now.</p>



<a name="174237153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174237153">(Aug 27 2019 at 14:59)</a>:</h4>
<p>Does that mean it will only become as slow as <code>simp</code> is? (See the other thread...)</p>



<a name="174237166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174237166">(Aug 27 2019 at 14:59)</a>:</h4>
<p>no</p>



<a name="174237242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174237242">(Aug 27 2019 at 15:00)</a>:</h4>
<p>Great!</p>



<a name="174237270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174237270">(Aug 27 2019 at 15:00)</a>:</h4>
<p>I'm pretty sure you have thought about all that. I was honestly asking why things are not that simple.</p>



<a name="174237344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174237344">(Aug 27 2019 at 15:01)</a>:</h4>
<p>But generally speaking, it's not immediately clear how exactly the index should work: Does it only index a single parameter of the class? Is it always the first one? Or does this need to be customizable, by an attribute on the class?</p>



<a name="174237465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174237465">(Aug 27 2019 at 15:02)</a>:</h4>
<p>I'm sure there are some examples in mathlib where indexing by the first parameter would not be optimal</p>



<a name="174237508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174237508">(Aug 27 2019 at 15:03)</a>:</h4>
<p>I guess that using the first parameter would already cover a lot of cases. You don't have to cover all cases since you can always fall back to a more general arguments. It even looks to me like this part of the procedure should be stupid enough to fail very quickly when it fails</p>



<a name="174237879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174237879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174237879">(Aug 27 2019 at 15:07)</a>:</h4>
<p>Sure, it's a single lookup of the head constant name in a hopefully fast data structure for deciding which algorithm to follow. The big issue in Lean 3 is where to build and store this data structure - this is exactly the issue with <code>simp</code> constantly rebuilding its simpset. This will work completely differently in Lean 4.</p>



<a name="174238228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174238228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174238228">(Aug 27 2019 at 15:10)</a>:</h4>
<p>I know GHC has an index on the head type constructor for ordinary type classes (although it also supports instances that aren't of the Haskell 98 form which specify only the head). I don't remember what it does for multiparameter type classes, I could check at some point.</p>



<a name="174238286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174238286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174238286">(Aug 27 2019 at 15:11)</a>:</h4>
<p>And what about my even stupider idea of a local indexing by name of variable?</p>



<a name="174238295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174238295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174238295">(Aug 27 2019 at 15:11)</a>:</h4>
<p>My guess is that it's usually best to index the last type argument</p>



<a name="174238296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174238296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174238296">(Aug 27 2019 at 15:11)</a>:</h4>
<p>It's much easier if you're not an interactive compiler :)</p>



<a name="174238464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174238464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174238464">(Aug 27 2019 at 15:13)</a>:</h4>
<p>(Also Haskell does not have priorities. Should a head matching always be prioritized over a unification match? Is that intuitive?)</p>



<a name="174238782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174238782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174238782">(Aug 27 2019 at 15:17)</a>:</h4>
<p>I think I'd be happy if head matching were prioritized. I always feel a bit queasy when I see an instance where the whole type is one variable. It does not use any specific knowledge of the type we're creating an instance for. I think specific insight should be prioritized</p>



<a name="174238911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174238911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174238911">(Aug 27 2019 at 15:18)</a>:</h4>
<blockquote>
<p>And what about my even stupider idea of a local indexing by name of variable?</p>
</blockquote>
<p>It would probably help, but I wouldn't hold my breath for such a hack being included in Lean proper. The head index should be strictly better.</p>



<a name="174239258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174239258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/cleaning.20iff.html#174239258">(Aug 27 2019 at 15:21)</a>:</h4>
<p>They cover different cases (at least the way I dream of it)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
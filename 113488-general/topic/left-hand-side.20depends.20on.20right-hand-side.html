---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html">left-hand-side depends on right-hand-side</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="210950898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210950898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210950898">(Sep 23 2020 at 01:35)</a>:</h4>
<p>Can anyone explain what "cases tactic failed, when eliminating equality left-hand-side depends on right-hand-side" means?</p>



<a name="210950972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210950972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210950972">(Sep 23 2020 at 01:36)</a>:</h4>
<p>I'd provide an example but it's deep in some complex stuff, and I don't understand it well enough to produce a more minimal example</p>



<a name="210951441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951441">(Sep 23 2020 at 01:46)</a>:</h4>
<p>Here is a minimal example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">trivial</span> <span class="o">}</span> <span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">h</span><span class="o">,</span> <span class="n">trivial</span> <span class="o">}</span> <span class="c1">-- error</span>
</code></pre></div>

<p><code>cases h</code> can be used on equalities when either the left-hand side or the right-hand side is a variable in the local context. If you do that, the variable is removed from the context and every occurrence of it is replaced by the other side of the equality. Now in the second example above, the variable <code>n</code> also occurs on the left-hand side of the equality, so after you replace all <code>n</code> by <code>n + m</code> you still cannot remove <code>n</code> from the context. If that happens, the tactic raises an error. So the problem is that the left-hand side contains the variable you want to remove.</p>



<a name="210951456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951456">(Sep 23 2020 at 01:47)</a>:</h4>
<p>Note: sometimes doing <code>dsimp</code> before <code>cases</code> simplifies the equality so that the variable doesn't occur in the left hand side anymore.</p>



<a name="210951528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951528">(Sep 23 2020 at 01:48)</a>:</h4>
<p>The thing is that there aren't any equalities in my context</p>



<a name="210951547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951547">(Sep 23 2020 at 01:48)</a>:</h4>
<p>I'm trying to do <code>cases</code> on a variable of a dependent type, so maybe there's like, hidden implicit equalities</p>



<a name="210951565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951565">(Sep 23 2020 at 01:49)</a>:</h4>
<p>What tactic did you execute to get this error? If you did <code>cases</code> what is the type of the variable you cased on?</p>



<a name="210951639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951639">(Sep 23 2020 at 01:50)</a>:</h4>
<p>Is it an inductive type? An inductive family of types? Are all indices variables? If so, you can try <code>induction</code> instead.<br>
(If you don't know what this means, the question is probably "no")</p>



<a name="210951660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951660">(Sep 23 2020 at 01:51)</a>:</h4>
<p>aight, here's my code in all it's newbtacular glory: <a href="https://pastebin.com/jjMR45t8">https://pastebin.com/jjMR45t8</a></p>



<a name="210951683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951683">(Sep 23 2020 at 01:51)</a>:</h4>
<p>I'm modeling reduction rules over a kind of primitive recursive functions</p>



<a name="210951731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951731">(Sep 23 2020 at 01:52)</a>:</h4>
<p>Line 55 is the source of the error. Bizzarely, vscode isn't letting me copy-paste the error itself</p>



<a name="210951751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951751">(Sep 23 2020 at 01:53)</a>:</h4>
<p>I think the problem is that you have an inductive family of types with 2 explicit indices, and that the variable <code>f_g</code> occurs in both of them.</p>



<a name="210951857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951857">(Sep 23 2020 at 01:55)</a>:</h4>
<p>huh, okay. Moving the subst that set the two to be equal into the specific case where I'm using it has at least made the error go away.</p>



<a name="210951860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951860">(Sep 23 2020 at 01:55)</a>:</h4>
<p>If you replace the offending tactic with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>            <span class="n">generalize</span> <span class="n">eq1</span> <span class="o">:</span> <span class="n">f_f.comp</span> <span class="n">f_g</span> <span class="bp">=</span> <span class="n">c1</span><span class="o">,</span>
            <span class="n">generalize</span> <span class="n">eq2</span> <span class="o">:</span> <span class="n">g_f.comp</span> <span class="n">f_g</span> <span class="bp">=</span> <span class="n">c2</span><span class="o">,</span>
            <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
            <span class="n">cases</span> <span class="n">h2</span><span class="o">,</span>
            <span class="n">subst</span> <span class="n">eq2</span><span class="o">,</span>
</code></pre></div>

<p>You see that you cannot now substitute <code>eq1</code> away, since neither side is a variable. This is roughly what <code>cases</code> is doing under the hood.</p>



<a name="210951909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951909">(Sep 23 2020 at 01:56)</a>:</h4>
<p>Sorry, replace <code>intro h2, cases h2</code> with the above snippet.</p>



<a name="210951918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951918">(Sep 23 2020 at 01:56)</a>:</h4>
<p>So</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">step_decidable</span> <span class="o">:</span>
    <span class="bp">Π</span> <span class="o">(</span><span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">),</span>
    <span class="n">decidable</span> <span class="o">(</span><span class="n">step</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">case</span> <span class="n">comp</span> <span class="o">{</span>
        <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
        <span class="n">case</span> <span class="n">comp</span> <span class="o">{</span>
            <span class="n">by_cases</span> <span class="o">(</span><span class="n">f_tint</span> <span class="bp">=</span> <span class="n">g_tint</span><span class="o">),</span>
            <span class="n">focus</span> <span class="o">{</span>
                <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
                <span class="n">by_cases</span> <span class="o">(</span><span class="n">f_g</span> <span class="bp">=</span> <span class="n">g_g</span><span class="o">),</span>
                <span class="n">focus</span> <span class="o">{</span>
                    <span class="n">subst</span> <span class="n">h</span><span class="o">,</span>
                    <span class="n">cases</span> <span class="n">f_ih_f</span> <span class="n">g_f</span><span class="o">,</span>
                    <span class="n">case</span> <span class="n">is_true</span> <span class="o">{</span>
                        <span class="n">apply</span> <span class="o">(</span><span class="n">is_true</span><span class="o">),</span>
                        <span class="n">constructor</span><span class="o">,</span>
                        <span class="n">assumption</span><span class="o">,</span>
                        <span class="n">done</span>
                    <span class="o">},</span>
                <span class="o">},</span>
            <span class="o">},</span>
            <span class="n">apply</span><span class="o">(</span><span class="n">is_false</span><span class="o">),</span>
            <span class="n">generalize</span> <span class="n">eq1</span> <span class="o">:</span> <span class="n">f_f.comp</span> <span class="n">f_g</span> <span class="bp">=</span> <span class="n">c1</span><span class="o">,</span>
            <span class="n">generalize</span> <span class="n">eq2</span> <span class="o">:</span> <span class="n">g_f.comp</span> <span class="n">f_g</span> <span class="bp">=</span> <span class="n">c2</span><span class="o">,</span>
            <span class="n">intro</span> <span class="n">h2</span><span class="o">,</span>
            <span class="n">cases</span> <span class="n">h2</span><span class="o">,</span>
            <span class="n">subst</span> <span class="n">eq2</span><span class="o">,</span>
        <span class="o">},</span>
    <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="210951939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210951939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210951939">(Sep 23 2020 at 01:57)</a>:</h4>
<p>incidentally, when I have a goal which is effectively &lt;empty type&gt; -&gt; false, is there a less verbose way of solving that than to introduce and do cases on the empty type?</p>



<a name="210952042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952042">(Sep 23 2020 at 01:59)</a>:</h4>
<p>If the empty type is sufficiently simple you can do <code>rintro ⟨⟩</code></p>



<a name="210952116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952116">(Sep 23 2020 at 02:00)</a>:</h4>
<p>hmm, do I need to import something to use that?</p>



<a name="210952118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952118">(Sep 23 2020 at 02:00)</a>:</h4>
<p><code>rintro</code> is a nice tactic to introduce variables and immediately case on them. You need to <code>import tactic.basic</code> for it.</p>



<a name="210952121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952121">(Sep 23 2020 at 02:00)</a>:</h4>
<p>(and have mathlib)</p>



<a name="210952147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952147">(Sep 23 2020 at 02:01)</a>:</h4>
<p>I'll look into that</p>



<a name="210952303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952303">(Sep 23 2020 at 02:04)</a>:</h4>
<p>actually, I have a more general question here... the constructors of <code>step</code> have two forms: ones where they literally spell out the shape of the type parameters, and ones where they essentially require congruence mod <code>step</code> (e.g., comp_f)</p>



<a name="210952385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952385">(Sep 23 2020 at 02:05)</a>:</h4>
<p>I'm trying to show it's decidable. The algorithm is essentially, "find a constructor that matches the value. If that constructor requires analogous parts of the parallel structure to be related by <code>step</code>, call it recursively"</p>



<a name="210952401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952401">(Sep 23 2020 at 02:05)</a>:</h4>
<p>and the tactics I'm writing seem... excessive for the simplicity of that algorithm</p>



<a name="210952452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952452">(Sep 23 2020 at 02:06)</a>:</h4>
<p>(oh: and of course, if there's no constructor that matches, demonstrate that in <code>is_false</code>)</p>



<a name="210952555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952555">(Sep 23 2020 at 02:08)</a>:</h4>
<p>Is there a better way than doing this kind of case analysis on the arguments to the relation? Is there some way of going more from the constructors of <code>step</code> to say, "whatever this value is, if I can unify it with one of the constructors, then yes, the type is inhabited"?</p>



<a name="210952711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952711">(Sep 23 2020 at 02:11)</a>:</h4>
<p>Probably you can pretty easily write a tactic that deals with all the easy cases for you (and with more effort a tactic that proves the decidability itself). AFAIK we don't have a tactic that does this off-the-shelf.</p>



<a name="210952913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952913">(Sep 23 2020 at 02:15)</a>:</h4>
<p>For example, </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">step_decidable</span> <span class="o">:</span>
    <span class="bp">Π</span> <span class="o">(</span><span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">),</span>
    <span class="n">decidable</span> <span class="o">(</span><span class="n">step</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">f</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>

<p>gives 40 goals, and this solves 32 of them:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">step_decidable</span> <span class="o">:</span>
    <span class="bp">Π</span> <span class="o">(</span><span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">),</span>
    <span class="n">decidable</span> <span class="o">(</span><span class="n">step</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">f</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">g</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">rintro</span> <span class="o">⟨⟩,</span> <span class="n">done</span> <span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">constructor</span><span class="o">,</span> <span class="n">done</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="210952981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210952981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210952981">(Sep 23 2020 at 02:16)</a>:</h4>
<p>(if you don't have mathlib, you can replace the <code>rintro</code> by <code>intro h, cases h</code>)</p>



<a name="210953025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/210953025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#210953025">(Sep 23 2020 at 02:17)</a>:</h4>
<p>nice! I had something like this, but that's nicer</p>



<a name="211205553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/211205553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#211205553">(Sep 25 2020 at 00:16)</a>:</h4>
<p>I'm still really struggling with this. I'm trying to prove that the "step" relation is antireflexive, but any time I try to work with \not (step f f) [i.e., try to do induction on it], I get this error</p>



<a name="211205647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/211205647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#211205647">(Sep 25 2020 at 00:18)</a>:</h4>
<p>Here's my code: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">val</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">car</span> <span class="o">:</span> <span class="n">val</span><span class="o">)</span> <span class="o">(</span><span class="n">cdr</span><span class="o">:</span> <span class="n">val</span><span class="o">),</span> <span class="n">val</span>

<span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">fn</span> <span class="o">:</span> <span class="n">val</span> <span class="bp">-&gt;</span> <span class="n">val</span> <span class="bp">-&gt;</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">fn</span> <span class="n">val.nil</span> <span class="n">val.nat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">fn</span> <span class="n">val.nat</span> <span class="n">val.nat</span>
<span class="bp">|</span> <span class="n">car</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">tcar</span> <span class="n">tcdr</span><span class="o">:</span> <span class="n">val</span><span class="o">},</span> <span class="n">fn</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">)</span> <span class="n">tcar</span>
<span class="bp">|</span> <span class="n">cdr</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">tcar</span> <span class="n">tcdr</span><span class="o">:</span> <span class="n">val</span><span class="o">},</span> <span class="n">fn</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">)</span> <span class="n">tcdr</span>
<span class="bp">|</span> <span class="n">nil</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">tin</span> <span class="o">:</span> <span class="n">val</span><span class="o">},</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">val.nil</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">(</span><span class="n">car</span> <span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tcar</span><span class="o">)</span> <span class="o">(</span><span class="n">cdr</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tcdr</span><span class="o">),</span> <span class="n">fn</span> <span class="n">tin</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tint</span> <span class="n">tout</span><span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fn</span> <span class="n">tint</span> <span class="n">tout</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tint</span><span class="o">),</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span>
<span class="bp">|</span> <span class="n">prec</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">trest</span> <span class="n">tout</span><span class="o">:</span> <span class="n">val</span><span class="o">}</span> <span class="o">(</span><span class="n">z_case</span> <span class="o">:</span> <span class="n">fn</span> <span class="n">trest</span> <span class="n">tout</span><span class="o">)</span> <span class="o">(</span><span class="n">s_case</span><span class="o">:</span> <span class="n">fn</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">val.nat</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">tout</span> <span class="n">trest</span><span class="o">))</span> <span class="n">tout</span><span class="o">),</span>
    <span class="n">fn</span> <span class="o">(</span><span class="n">val.cons</span> <span class="n">val.nat</span> <span class="n">trest</span><span class="o">)</span> <span class="n">tout</span>

<span class="kd">inductive</span> <span class="n">step</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tout</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">),</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">proj_car</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">}</span> <span class="o">{</span><span class="n">car</span><span class="o">:</span><span class="n">fn</span> <span class="n">tin</span> <span class="n">tcar</span><span class="o">}</span> <span class="o">{</span><span class="n">cdr</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tcdr</span><span class="o">},</span>
    <span class="n">step</span> <span class="o">(</span><span class="n">fn.comp</span> <span class="n">fn.car</span> <span class="o">(</span><span class="n">fn.cons</span> <span class="n">car</span> <span class="n">cdr</span><span class="o">))</span> <span class="n">car</span>
<span class="bp">|</span> <span class="n">proj_cdr</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tcar</span> <span class="n">tcdr</span><span class="o">}</span> <span class="o">{</span><span class="n">car</span><span class="o">:</span><span class="n">fn</span> <span class="n">tin</span> <span class="n">tcar</span><span class="o">}</span> <span class="o">{</span><span class="n">cdr</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tcdr</span><span class="o">},</span>
    <span class="n">step</span> <span class="o">(</span><span class="n">fn.comp</span> <span class="n">fn.cdr</span> <span class="o">(</span><span class="n">fn.cons</span> <span class="n">car</span> <span class="n">cdr</span><span class="o">))</span> <span class="n">cdr</span>
<span class="bp">|</span> <span class="n">comp_f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tint</span> <span class="n">tout</span><span class="o">}</span> <span class="o">{</span><span class="n">f1</span> <span class="n">f2</span><span class="o">:</span><span class="n">fn</span> <span class="n">tint</span> <span class="n">tout</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tint</span><span class="o">}</span>
    <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">step</span> <span class="n">f1</span> <span class="n">f2</span><span class="o">),</span>
    <span class="n">step</span> <span class="o">(</span><span class="n">fn.comp</span> <span class="n">f1</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">fn.comp</span> <span class="n">f2</span> <span class="n">g</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">step_antireflex</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tout</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">step</span> <span class="n">f</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">sorry</span>
<span class="kd">end</span><span class="bp">```</span>
</code></pre></div>



<a name="211205813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/211205813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#211205813">(Sep 25 2020 at 00:20)</a>:</h4>
<p>A specific example: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">step_antireflex</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tout</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">step</span> <span class="n">f</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="211205836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/211205836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Freyer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#211205836">(Sep 25 2020 at 00:21)</a>:</h4>
<p>... gives "induction tactic failed, argument <a href="https://github.com/leanprover-community/mathlib/issues/3">#3</a> of major premise type step f f is an index, but it occurs more than once"</p>



<a name="211207668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/211207668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#211207668">(Sep 25 2020 at 00:56)</a>:</h4>
<p>In order to do induction, you have to first generalize the indices so that they are distinct, with separate constraints</p>



<a name="211207977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/left-hand-side%20depends%20on%20right-hand-side/near/211207977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/left-hand-side.20depends.20on.20right-hand-side.html#211207977">(Sep 25 2020 at 01:02)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">step_antireflex</span> <span class="o">{</span><span class="n">tin</span> <span class="n">tout</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">fn</span> <span class="n">tin</span> <span class="n">tout</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">step</span> <span class="n">f</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">step</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="n">_</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">intros</span> <span class="n">g</span> <span class="n">e</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">iterate</span> <span class="mi">2</span> <span class="o">{</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">fn.sizeof</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">fn.sizeof</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">show</span> <span class="n">sizeof</span> <span class="bp">=</span> <span class="n">fn.sizeof</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">linarith</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">e</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h_ih</span> <span class="n">rfl</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
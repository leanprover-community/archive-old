---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/conditional.20lattice.20refactor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html">conditional lattice refactor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="286879641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286879641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286879641">(Jun 21 2022 at 08:12)</a>:</h4>
<p>I've decided to finally start work on matching the APIs on complete lattices and conditionally complete lattices</p>



<a name="286879714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286879714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286879714">(Jun 21 2022 at 08:12)</a>:</h4>
<p>Here's one sticking point I've quickly noticed: what's up with <code>complete_semilattice_Sup</code> and <code>complete_semilattice_Inf</code>?</p>



<a name="286879908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286879908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286879908">(Jun 21 2022 at 08:14)</a>:</h4>
<p>They unconditionally imply <code>complete_lattice</code>, so surely it makes no sense to have them in the typeclass hierarchy?</p>



<a name="286879919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286879919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286879919">(Jun 21 2022 at 08:14)</a>:</h4>
<p>Those two classes should be completely removed from the hierarchy, and <a href="https://leanprover-community.github.io/mathlib_docs/find/boolean_algebra.core">docs#boolean_algebra.core</a> as well. They are alternative constructors, not mathematically meaningful typeclasses.</p>



<a name="286879951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286879951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286879951">(Jun 21 2022 at 08:15)</a>:</h4>
<p>Then that's a good starting point for the refactor</p>



<a name="286879954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286879954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286879954">(Jun 21 2022 at 08:15)</a>:</h4>
<p>I'm on it</p>



<a name="286880807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286880807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286880807">(Jun 21 2022 at 08:24)</a>:</h4>
<p>Note that <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_semilattice_Sup">docs#complete_semilattice_Sup</a> was added somewhat recently in <a href="https://github.com/leanprover-community/mathlib/pull/6797">#6797</a> by <span class="user-mention" data-user-id="110087">@Scott Morrison</span>; I would wait for their opinion before pushing for removing it</p>



<a name="286880839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286880839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286880839">(Jun 21 2022 at 08:25)</a>:</h4>
<p>(Of course, you can still play around with removing it to understand what breaks before that)</p>



<a name="286881906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286881906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286881906">(Jun 21 2022 at 08:34)</a>:</h4>
<p>I opened a draft PR <a href="https://github.com/leanprover-community/mathlib/pull/14863">#14863</a></p>



<a name="286882374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286882374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286882374">(Jun 21 2022 at 08:38)</a>:</h4>
<p>I edited its description to link back here</p>



<a name="286887416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286887416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286887416">(Jun 21 2022 at 09:24)</a>:</h4>
<p>Ooh cool. Violeta, I think those typeclasses are meant to have a purpose but they are misdefined. I worked it out the other day but I can't remember where I got to - but essentially if you add the right caveat to le_Sup etc. they make sense.</p>



<a name="286887699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286887699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286887699">(Jun 21 2022 at 09:27)</a>:</h4>
<p>That to me just suggests that there's other potentially useful typeclasses, which doesn't change that the current ones should be removed.</p>



<a name="286887726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286887726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286887726">(Jun 21 2022 at 09:27)</a>:</h4>
<p>I'm curious as to what your proposal is though</p>



<a name="286887769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286887769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286887769">(Jun 21 2022 at 09:28)</a>:</h4>
<p>Oh I totally agree they need to be removed.</p>



<a name="286891500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286891500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286891500">(Jun 21 2022 at 10:04)</a>:</h4>
<p>OK, let me try and put my thoughts together.</p>
<p>You can think of many classes in the order hierarchy as "failing to be complete" in various ways, or "succeeding at being complete" in certain cases. Certain sets have Sups and Inf, by which I mean well-behaved ones, obviously: when I say "a set has an Inf" I mean "for that set <code>s</code>, <code>Inf s</code> is a glb for s<code>, a la </code>complete_lattice_of_Inf<code>, and obviously analogously for </code>Sup`.</p>
<p>For instance, an <code>order_top</code> has <code>Inf</code> for the empty set/<code>Sup</code> for <code>set.univ</code>. An <code>order_bot</code> vice versa. A <code>bounded_order</code> for both. A <code>lattice</code> has them both for every non-empty finite set. A <code>semilattice_inf</code> has only Inf for the same. You get the picture.</p>
<p>We even have some stuff that doesn't use the same notation but which fits into this view. An <code>omega_complete_partial_order</code> essentially has Sups for every chain. There are concepts which I think we don't have but which fit into this framework - a directed-complete partial order is a porder where each directed subset has a Sup.</p>
<p>Obviously, a <code>conditionally_complete_lattice</code> is a porder where every non-empty bounded above set has a Sup, and vice versa for Inf. So it also fits into this view. We also have <code>conditionally_complete_linear_order_bot</code>, which is described as "nonempty subset which is bounded above has a supremum, and every nonempty subset (necessarily bounded below) has an infimum", though this isn't quite true: an empty subset has a sensible <code>Sup</code> (see <code>is_lub_cSup'</code> and note the lack of requirement of <code>s</code> to be nonempty). So actually a <code>conditionally_complete_linear_order_bot</code> has "bounded above Sups and nonempty Infs", and indeed I think these are dual to one another? We don't seem to have a <code>conditionally_complete_linear_order_top</code> but I hope it's clear what that would be.</p>
<p><code>complete_semilattice_Inf</code> should be "you have as much <code>Inf</code> as you can without completing the lattice", I guess was my thought. If you have every <code>Inf</code> except the <code>Inf</code> of the empty set, I think that's actually <code>conditionally_complete_linear_order_bot</code>, though, and <code>every Inf for bounded below sets" should be "</code>conditionally_complete_linear_order_top`", though we don't have it, as I say.</p>
<p>My overall point is this, which I think you should take into account in this refactor: there is a general paradigm here where there is some sensible set of sets on which <code>Infs</code> or <code>Sups</code> make sense, and the lattice of this <code>set of sets</code> corresponds to the lattice of differently complete structures that we have.</p>
<p>We also have types like <code>with_bot</code> and <code>with_top</code>. These are a bit different. They are used sometimes in two different ways:</p>
<ul>
<li>Sometimes they are used like closure operators. That is to say, "with_top nat" is "doing the minimal you want to do to nat in order to make it an order_top". In theory, given any of the semicomplete structures mentioned above, and a partial order, you could apply a closure operator using that structure to your partial order in order to produce a new partial order that is in a precise sense minimal with respect to that structure. In the extreme case of "closure over <code>complete_lattice</code>", this is the Dedekind–MacNeille completion, which we have using <code>order.concept</code>, and I wonder (speculation!) that maybe the work of Yaël in <code>order.concept</code> might provide a general framework to define such a "closure via a semicompletion".</li>
<li>Sometimes we use <code>with_bot</code> etc. <em>not</em> like closure operators. <code>nat</code> is already an <code>order_bot</code>, but <code>with_bot nat</code> is a different type with its own uses! So here it is... I don't know how to say it, really just a type constructor but not a closure operator of any kind. My claim is not that this is bad, but that conceptually it's a different thing. While it would be work, perhaps more than it's worth, we could try to separate out these two different uses. I have a theory that they probably cause some trouble in some places.</li>
</ul>
<p>Separately I think to the above things, but interrelated with the first: some types have the property that for some sets, not only do they have Sups/Infs for some sets, but those Sups/Infs are, for some sets, actually Max/Min (which is to say, they are not just glb/lubs but greatest/least elements of the set). In other types, it might be the case that some sets always have a maximal element but not a greatest element - this I think is more different, but it's another property. And because a Sup is the "greatest of upper bounds", the presence of greatest and and least elements of at least some sets is tied up with Sup/Inf presence.</p>
<p>So, to summarise (I'm sorry this is long but I hope it is useful):</p>
<ul>
<li>There is a general paradigm where you have some "semicompleteness/conditional completeness property for a type", which is essentially some predicate on sets which says whether or not you have <code>Sups</code> and/or <code>Infs</code> for sets meeting that predicate. (Is this a filter? I don't understand filters, but it might be.)</li>
<li>Nearly every structure we have in the pure order hierarchy can be described this way.</li>
<li>Abstracting this common description might make it easier to use the hierarchy, understand how it fits together, and extend it in future.</li>
<li>"Closure with respect to a semicompleteness structure" is a meaningful concept and one we might be able to support.</li>
<li>There are a few lacunae or other issues to consider and this isn't a total view.</li>
</ul>
<p>Thanks for listening.</p>



<a name="286891896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286891896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286891896">(Jun 21 2022 at 10:08)</a>:</h4>
<p>Wrenna, do you know about categorical limits?</p>



<a name="286891915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286891915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286891915">(Jun 21 2022 at 10:08)</a>:</h4>
<p>Vaguely!</p>



<a name="286891982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286891982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286891982">(Jun 21 2022 at 10:09)</a>:</h4>
<p>I guess what I describe above might be that in a sense? But I didn't want to go <em>too</em> abstract.</p>



<a name="286892004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286892004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286892004">(Jun 21 2022 at 10:10)</a>:</h4>
<p>"Sups in different situations" are exactly limits (or colimits? who cares), and this is the right way to talk about them.</p>



<a name="286892065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286892065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286892065">(Jun 21 2022 at 10:10)</a>:</h4>
<p>I'm afraid you're reinventing category theory, that's it <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="286892251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286892251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286892251">(Jun 21 2022 at 10:12)</a>:</h4>
<p>Sure, I am not claiming to be doing anything new! And isn't it all category theory really? ;) But just as, say, in an algebraic concept "the algebraic closure of a field" is useful in and of itself, even though I'm sure it has a categorical interpretation, perhaps it is useful to have these things without simply saying "well, it's general abstract nonsense".</p>



<a name="286892314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286892314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286892314">(Jun 21 2022 at 10:13)</a>:</h4>
<blockquote>
<p>Abstracting this common description might make it easier to use the hierarchy, understand how it fits together, and extend it in future.</p>
</blockquote>
<p>This is what the files in <code>catgeory_theory</code> do.</p>



<a name="286892350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286892350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286892350">(Jun 21 2022 at 10:13)</a>:</h4>
<p>Well - this was a reply to Violeta so I shall see what she thinks.</p>



<a name="286892549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286892549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286892549">(Jun 21 2022 at 10:15)</a>:</h4>
<p>You should look up the correspondence between order and category concepts. Here's the ones I can think of on the spot:</p>
<ul>
<li>Preorders and categories</li>
<li>bottom/top element and initial/final object</li>
<li>sup/inf and binary limit/colimit</li>
<li>Sup/Inf and arbitrary limit/colimit</li>
<li>order dual and opposite category</li>
<li>Heyting algebras and cartesian closed categories</li>
</ul>



<a name="286893935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286893935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286893935">(Jun 21 2022 at 10:31)</a>:</h4>
<p>Yes, I do know about these things.</p>



<a name="286902679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286902679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286902679">(Jun 21 2022 at 12:05)</a>:</h4>
<p>I don't really understand category theory but that's a really cool insight into the order hierarchy</p>



<a name="286902817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286902817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286902817">(Jun 21 2022 at 12:07)</a>:</h4>
<p>That said, from a design perspective, I have no idea how we would actually implement this</p>



<a name="286902878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286902878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286902878">(Jun 21 2022 at 12:07)</a>:</h4>
<p>I don't know if you meant my post or Yaël's, though I guess your latter comment applies to either.</p>



<a name="286902906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286902906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286902906">(Jun 21 2022 at 12:07)</a>:</h4>
<p>I mean your post</p>



<a name="286902918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286902918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286902918">(Jun 21 2022 at 12:08)</a>:</h4>
<p>Ah - thank you then :D</p>



<a name="286903129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286903129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286903129">(Jun 21 2022 at 12:10)</a>:</h4>
<p>One idea I had - though it wasn't very popular - was to redefine Sup and Inf so that they go into the complete_lattice completion, and then essentially you're talking about "when is Sup/Inf a principal ideal over there". But that doesn't get to the heart of the matter. (It's a bit like embedding a field in its algebraic completion because then it's easier to talk about "the roots of a polynomial" even when they don't exist in the current field, I guess.)</p>



<a name="286903658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286903658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286903658">(Jun 21 2022 at 12:14)</a>:</h4>
<p>That would certainly be a huge change, I don't know what repercussions it might have to change their types like that</p>



<a name="286903685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286903685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286903685">(Jun 21 2022 at 12:14)</a>:</h4>
<p>Oh it would be massive, it's a terrible idea :D</p>



<a name="286906378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286906378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286906378">(Jun 21 2022 at 12:39)</a>:</h4>
<p>But the nice thing about that is that you don't have any kind of junk value for <code>Inf</code> or <code>Sup</code> - it has <em>some</em> meaning. From wikipedia:</p>
<p><code>The partially ordered set S is join-dense and meet-dense in the Dedekind–MacNeille completion; that is, every element of the completion is a join of some set of elements of S, and is also the meet of some set of elements in S. The Dedekind–MacNeille completion is characterized among completions of S by this property.</code></p>
<p>Because members of the completion are cuts, which you can think of as sets where the lower bound of their upper bounds is equal to the set (or the pair of that with the dual), if you think about this a little, those sets which are cuts are I think exactly those that have Sups (or Infs dually). So it really does measure "the degree of Sup/Inf failure".</p>



<a name="286907876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286907876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286907876">(Jun 21 2022 at 12:52)</a>:</h4>
<p>I guess I just feel like we have:<br>
<code>ωSup_le_ωSup_of_le</code><br>
<code>Sup_le_Sup</code><br>
<code>cSup_le_cSup</code></p>
<p>And these are all <em>the same theorem</em> - "on good sets, Sup is monotonic" - but we prove it in three unrelated ways. This is what indicates to me that you <em>could</em> do a deep refactor here. If someone wants to introduce a new notion of "semicomplete partial order" - and as noted, there are such notions - we want them to get all these theorems "for free", ideally.</p>



<a name="286935297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286935297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286935297">(Jun 21 2022 at 15:54)</a>:</h4>
<blockquote>
<p>There is a general paradigm where you have some "semicompleteness/conditional completeness property for a type", which is essentially some predicate on sets which says whether or not you have Sups and/or Infs for sets meeting that predicate.</p>
</blockquote>
<p>Probably best phrased in terms of <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_limits_of_shape">docs#category_theory.limits.has_limits_of_shape</a></p>



<a name="286985092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286985092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286985092">(Jun 21 2022 at 23:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330967">Wrenna Robson</span> <a href="#narrow/stream/113488-general/topic/conditional.20lattice.20refactor/near/286907876">said</a>:</p>
<blockquote>
<p>And these are all <em>the same theorem</em> - "on good sets, Sup is monotonic" - but we prove it in three unrelated ways. </p>
</blockquote>
<p>I fear that even if we proved this general theorem, we'd still want the specific instantiations depending on what the "good sets" are</p>



<a name="286985205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286985205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286985205">(Jun 21 2022 at 23:07)</a>:</h4>
<p>That said there should be a much greater effort in making sure these APIs look approximately the same</p>



<a name="286990881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286990881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286990881">(Jun 22 2022 at 00:33)</a>:</h4>
<p>The refactor builds!</p>



<a name="286990892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286990892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286990892">(Jun 22 2022 at 00:33)</a>:</h4>
<p>It definitely looks much cleaner IMO</p>



<a name="286991291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286991291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286991291">(Jun 22 2022 at 00:39)</a>:</h4>
<p>The other PR I made cleaning up the file builds too, it's on <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> to merge it</p>



<a name="286992021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286992021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286992021">(Jun 22 2022 at 00:53)</a>:</h4>
<p>There's still some cleanup I want to do to this file before moving on to actually match APIs</p>



<a name="286992022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286992022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286992022">(Jun 22 2022 at 00:53)</a>:</h4>
<p>Mostly tweak some <code>simp</code> attributes and remove some redundant or frankly pointless theorems</p>



<a name="286992023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/286992023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#286992023">(Jun 22 2022 at 00:53)</a>:</h4>
<p>There's still some cleanup I want to do to this file before moving on to actually match APIs</p>



<a name="287033684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287033684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287033684">(Jun 22 2022 at 10:29)</a>:</h4>
<p>Oh I definitely agree we'd want the specific instantiations.</p>



<a name="287033798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287033798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287033798">(Jun 22 2022 at 10:30)</a>:</h4>
<p>But as you say, it's about matching APIs and similar constructions. Well done on the initial refactor - this is the one just removing complete_semilattice_Inf?</p>



<a name="287034332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287034332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287034332">(Jun 22 2022 at 10:36)</a>:</h4>
<p>I think the next thing to do that would be useful is just creating a hasse diagram of the hierarchy here and identifying anything else that is a natural structure you'd want, or things like the omega_complete_partial_order which aren't currently in the hierarchy directly but have a natural place in it?</p>
<p>While in some ideal world, yes, some kind of nice categorical construction would be nice, at the very least we can get a clear picture of what the current state of affairs is. Sorry to maths wikipedia (would be good to get a good non-wiki source on this), but these pages are interesting:</p>
<p><a href="https://en.wikipedia.org/wiki/Complete_partial_order">https://en.wikipedia.org/wiki/Complete_partial_order</a><br>
<a href="https://en.wikipedia.org/wiki/Completeness_(order_theory)">https://en.wikipedia.org/wiki/Completeness_(order_theory)</a></p>
<p>The "Completeness in terms of adjunctions" section in the latter looks particularly interesting. Which also contains "The considerations in this section suggest a reformulation of (parts of) order theory in terms of category theory, where properties are usually expressed by referring to the relationships (morphisms, more specifically: adjunctions) between objects, instead of considering their internal structure. For more detailed considerations of this relationship see the article on the categorical formulation of order theory", although said article appears to have been deleted...</p>



<a name="287034472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287034472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287034472">(Jun 22 2022 at 10:38)</a>:</h4>
<p>(The "Introduction to Lattices and Order" book that Yael has mentioned before might provide a good source? Would be good to get feedback from multiple order theorists before doing anything wild maybe.)</p>



<a name="287038596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287038596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287038596">(Jun 22 2022 at 11:22)</a>:</h4>
<p>Just a side comment, but putting these three files (<code>complete_lattice</code>, <code>conditionally_complete_lattice</code>, and <code>omega_complete_lattice</code>) on the same folder would help us keep the API matched</p>



<a name="287038611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287038611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287038611">(Jun 22 2022 at 11:22)</a>:</h4>
<p>And also declutter the huge <code>order</code> folder</p>



<a name="287038802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287038802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287038802">(Jun 22 2022 at 11:24)</a>:</h4>
<p>I was thinking about a more general <code>lattice</code> folder, actually.</p>



<a name="287039508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287039508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287039508">(Jun 22 2022 at 11:30)</a>:</h4>
<p>Even then, maybe these specific files still deserve a subfolder?</p>



<a name="287039510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287039510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287039510">(Jun 22 2022 at 11:30)</a>:</h4>
<p>Even then, maybe these specific files still deserve a subfolder?</p>



<a name="287039511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287039511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287039511">(Jun 22 2022 at 11:30)</a>:</h4>
<p>The whole point is that they should have very similar lemmas, just with somewhat different hypotheses</p>



<a name="287039820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287039820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287039820">(Jun 22 2022 at 11:33)</a>:</h4>
<p>Highly unconvinced. Very similar files are rarely (never?) grouped alone in a subfolder. Instead, they are either spread through similar folders (eg the <code>.interval</code>  or <code>.pointwise</code> files) or mixed within a bigger folder (eg <code>algebra.big_operators.</code>).</p>



<a name="287048244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287048244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287048244">(Jun 22 2022 at 12:49)</a>:</h4>
<p>You mean <code>omega_complete_partial_order</code>.</p>



<a name="287048254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287048254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287048254">(Jun 22 2022 at 12:49)</a>:</h4>
<p>It isn't a lattice.</p>



<a name="287069864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287069864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287069864">(Jun 22 2022 at 15:24)</a>:</h4>
<p><span class="user-mention" data-user-id="459227">@Violeta Hernández</span> This page points out one reason we might keep these structures. <a href="https://ncatlab.org/nlab/show/suplattice">https://ncatlab.org/nlab/show/suplattice</a></p>
<p>Namely, while any <code>complete_semilattice_Sup</code> is a <code>complete_lattice</code>, a <code>Sup</code>-preserving map may not preserve Infs. So the type of structure-preserving maps from these things is different.</p>



<a name="287071024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287071024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287071024">(Jun 22 2022 at 15:32)</a>:</h4>
<p>We have no API whatsoever for maps preserving these structures though, and if we did, surely that would be orthogonal to the typeclasses themselves?</p>



<a name="287071139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287071139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287071139">(Jun 22 2022 at 15:33)</a>:</h4>
<p>e.g. group homomorphisms are defined separately from groups</p>



<a name="287071161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287071161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287071161">(Jun 22 2022 at 15:34)</a>:</h4>
<p>Aye, I am not sure if it's an issue in practice.</p>



<a name="287071287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287071287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287071287">(Jun 22 2022 at 15:34)</a>:</h4>
<p>But at least it is a "why would you ever define such a thing": as ever, the answer is categorical.</p>



<a name="287079759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287079759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287079759">(Jun 22 2022 at 16:34)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/Sup_hom">docs#Sup_hom</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/Inf_hom">docs#Inf_hom</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/SemilatticeSup">docs#SemilatticeSup</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/SemilatticeInf">docs#SemilatticeInf</a></p>



<a name="287106437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287106437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287106437">(Jun 22 2022 at 20:09)</a>:</h4>
<p>Oh nice</p>



<a name="287106560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287106560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287106560">(Jun 22 2022 at 20:10)</a>:</h4>
<p>Guess that settles it</p>



<a name="287120436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287120436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287120436">(Jun 22 2022 at 22:09)</a>:</h4>
<p>But the fact that the same objects with different maps form a different category is an important property and it <strong>does not</strong> mean that we should make the objects different.</p>



<a name="287546369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287546369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287546369">(Jun 27 2022 at 08:23)</a>:</h4>
<p>On this topic, I was thinking</p>



<a name="287546485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287546485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287546485">(Jun 27 2022 at 08:25)</a>:</h4>
<p>It might be clearer what the relation between these different lattices are if instead of having fields <code>Inf_le</code> and <code>le_Inf</code> separately in the classes, we had a single field <code>is_glb_Inf</code></p>



<a name="287546494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287546494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287546494">(Jun 27 2022 at 08:25)</a>:</h4>
<p>Same goes for <code>Sup</code></p>



<a name="287546830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287546830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287546830">(Jun 27 2022 at 08:28)</a>:</h4>
<p>For complete lattices, <code>is_glb (Inf s)</code> always, for conditionally complete lattices this happens for nonempty sets that are bounded above, for conditionally complete linear orders with a bottom element it happens when they're bounded above</p>



<a name="287546846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287546846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287546846">(Jun 27 2022 at 08:28)</a>:</h4>
<p>We can then deduce <code>le_Inf</code> and <code>Inf_le</code> from here</p>



<a name="287546859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287546859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287546859">(Jun 27 2022 at 08:29)</a>:</h4>
<p>If nothing else, this approach is certainly conceptually easier</p>



<a name="287546909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287546909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287546909">(Jun 27 2022 at 08:29)</a>:</h4>
<p>And since <code>is_glb (Inf s)</code> is def-eq to <code>le_Inf s \and Inf_le s</code> it shouldn't make any proofs harder</p>



<a name="287547065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287547065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287547065">(Jun 27 2022 at 08:30)</a>:</h4>
<p>It might fail to make them easier if there's no better ways to prove <code>is_glb</code> though</p>



<a name="287547350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287547350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287547350">(Jun 27 2022 at 08:33)</a>:</h4>
<p>The tendency is to rather split fields (<a href="https://github.com/leanprover-community/mathlib/pull/14556">#14556</a>) because it makes things easier to prove.</p>



<a name="287547876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287547876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287547876">(Jun 27 2022 at 08:38)</a>:</h4>
<p><code>is_glb (Inf s)</code> has type <code>α → Prop</code>; what are you intending as the second argument?</p>



<a name="287547920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287547920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287547920">(Jun 27 2022 at 08:39)</a>:</h4>
<p>Or did you mean <code>is_glb set.univ (Inf s)</code> or <code>is_glb s (Inf s)</code>?</p>



<a name="287692629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287692629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287692629">(Jun 28 2022 at 09:44)</a>:</h4>
<p>Surely <code>is_glb s (Inf s)</code>is the only thing that makes sense?</p>



<a name="287692656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287692656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287692656">(Jun 28 2022 at 09:44)</a>:</h4>
<p>Personally I think this has much to commend it.</p>



<a name="287693052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287693052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287693052">(Jun 28 2022 at 09:48)</a>:</h4>
<p>the split approach is essentially "Inf s \mem lower_bounds s" and "Inf s \mem upper_bounds (lower_bounds s)". It certainly makes sense to have these as their own theorems. But I'm not sure what's better in terms of defining the structure.</p>



<a name="287851334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287851334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287851334">(Jun 29 2022 at 13:18)</a>:</h4>
<p>I think that <code>is_glb_Inf</code> is a good idea because we already have API about <code>is_glb</code>/<code>is_lub</code>.</p>



<a name="287851497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287851497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287851497">(Jun 29 2022 at 13:19)</a>:</h4>
<p>In case of a <code>conditionally_complete_lattice</code>, the axiom should say that for any bounded from below nonempty set <code>s</code>, we have <code>is_glb s (Inf s)</code>.</p>



<a name="287851557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/287851557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#287851557">(Jun 29 2022 at 13:20)</a>:</h4>
<p>But I don't recommend you to start this refactor before running, e.g., a poll on Zulip.</p>



<a name="288302672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288302672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288302672">(Jul 03 2022 at 02:36)</a>:</h4>
<p>Here's an idea, might be a bad idea, might be a good idea, who knows</p>



<a name="288302753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288302753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288302753">(Jul 03 2022 at 02:39)</a>:</h4>
<p>We could create a structure <code>generalized_lattice</code> that looks like the current <code>conditional_lattice</code>, but with extra fields for the sets of sets for which <code>le_cSup</code>, etc. hold</p>



<a name="288302761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288302761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288302761">(Jul 03 2022 at 02:39)</a>:</h4>
<p>We can then create typeclasses for special cases</p>



<a name="288302810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288302810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288302810">(Jul 03 2022 at 02:40)</a>:</h4>
<p>If these sets are the universal set, it's a complete lattice, it they contain the sets of sets bounded above, then they're a conditional complete lattice, and so on</p>



<a name="288302826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288302826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288302826">(Jul 03 2022 at 02:41)</a>:</h4>
<p>A nice thing about this approach is that we can change the def-eqs: for instance, naturals are a conditionally complete lattice, but we might prefer to use the <code>set.finite</code> predicate instead of <code>bdd_above</code>, and on ordinals, we might prefer to use <code>small</code> instead</p>



<a name="288302894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288302894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288302894">(Jul 03 2022 at 02:43)</a>:</h4>
<p>This approach might also alleviate having to prove the same results over and over for these different types: we can prove whatever version is true in the most general case, then specialize</p>



<a name="288330535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288330535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288330535">(Jul 03 2022 at 14:35)</a>:</h4>
<p>I think that's not too far from what I was thinking about, and I like it.</p>



<a name="288330581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288330581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288330581">(Jul 03 2022 at 14:36)</a>:</h4>
<p>However, it shouldn't be called a generalized lattice.</p>



<a name="288330601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288330601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288330601">(Jul 03 2022 at 14:37)</a>:</h4>
<p>Because a lattice is (in particular) one of these where the sets that have this property etc. are the finite sets.</p>



<a name="288330654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288330654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288330654">(Jul 03 2022 at 14:38)</a>:</h4>
<p>Also it's worth thinking about how the presence of Sups and the presence of Infs is related. Obviously all Infs iff all Sups, but...</p>



<a name="288330684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288330684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288330684">(Jul 03 2022 at 14:39)</a>:</h4>
<p><code>generalized_conditionally_complete_partial_order</code> might work as a name maybe.</p>



<a name="288333498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288333498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288333498">(Jul 03 2022 at 15:39)</a>:</h4>
<p>That suggestion sounds a bit like refactoring <code>field</code> to allow other non-invertibility conditions, which I think I considered before but seemed dubious</p>



<a name="288335612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288335612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288335612">(Jul 03 2022 at 16:29)</a>:</h4>
<p>My opinion is that this is solving a problem we don't have.</p>



<a name="288335710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288335710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288335710">(Jul 03 2022 at 16:31)</a>:</h4>
<p>Our order theoretic library does not fine grain enough on what exactly we are allowed to take a supremum of? This is expected, because order theory is a simple special case of category theory. If you want this fine graining, use categories, not orders.</p>



<a name="288335791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288335791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288335791">(Jul 03 2022 at 16:33)</a>:</h4>
<p>In the opposite direction, you could go as far as ditching <code>lattice</code> because "it's just <code>generalized_conditionally_complete_partial_order α (range $ λ x : α × α, {x.1, x.2})</code> after all".</p>



<a name="288354617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288354617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288354617">(Jul 04 2022 at 00:12)</a>:</h4>
<p>I think that even if we did have a <code>generalized_conditionally_complete_partial_order</code>, we'd still want <code>lattice</code> and all the other special cases. The difference is that now we'd be proving a lot of theorems on <code>generalized_conditionally_complete_partial_order</code> and then transferring them to these special cases.</p>



<a name="288354626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288354626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288354626">(Jul 04 2022 at 00:12)</a>:</h4>
<p>I'm not sure if "just use categories" is a viable solution here. One because I don't know category theory <span aria-label="frown" class="emoji emoji-1f641" role="img" title="frown">:frown:</span> and two because surely we still have an interest in speaking in these structures as order structures?</p>



<a name="288355769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288355769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288355769">(Jul 04 2022 at 00:35)</a>:</h4>
<p>That's what I'm not sure about. We are going well without these hypothetical typeclasses.</p>



<a name="288356002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288356002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288356002">(Jul 04 2022 at 00:40)</a>:</h4>
<p>That's a fair point</p>



<a name="288356006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288356006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288356006">(Jul 04 2022 at 00:41)</a>:</h4>
<p>I guess we've done alright without a single unifying class</p>



<a name="288378175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378175">(Jul 04 2022 at 08:02)</a>:</h4>
<p>I do think we should consider refactoring <code>omega_complete_partial_order</code> so that it uses the Sup notation, rather than a different notation.</p>



<a name="288378243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378243">(Jul 04 2022 at 08:02)</a>:</h4>
<p>It doesn't use <code>Sup</code>?</p>



<a name="288378251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378251">(Jul 04 2022 at 08:02)</a>:</h4>
<p>That's a surprise given all we've discussed</p>



<a name="288378261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378261">(Jul 04 2022 at 08:02)</a>:</h4>
<p>(note: I've never actually touched that code)</p>



<a name="288378268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378268">(Jul 04 2022 at 08:02)</a>:</h4>
<p>let me just double-check</p>



<a name="288378289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378289">(Jul 04 2022 at 08:02)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/omega_complete_partial_order">docs#omega_complete_partial_order</a></p>



<a name="288378315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378315">(Jul 04 2022 at 08:03)</a>:</h4>
<p>(My computer is always slow first thing in the morning, like its owner.)</p>



<a name="288378394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378394">(Jul 04 2022 at 08:04)</a>:</h4>
<p>Yeah, we should totally use <code>Sup</code> there too</p>



<a name="288378475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378475">(Jul 04 2022 at 08:05)</a>:</h4>
<p>Well it just works a differently too because the domain of <code>ωSup</code> is chains.</p>



<a name="288378522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378522">(Jul 04 2022 at 08:05)</a>:</h4>
<p>Rather than, as <code>Sup</code> works everywhere else, the domain being sets, and then having theorems which say "when this set matches this predicate, Sup of it works"</p>



<a name="288378629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378629">(Jul 04 2022 at 08:06)</a>:</h4>
<p>Oh</p>



<a name="288378653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378653">(Jul 04 2022 at 08:06)</a>:</h4>
<p>In that case I'm not so sure anymore</p>



<a name="288378668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378668">(Jul 04 2022 at 08:06)</a>:</h4>
<p>well I think it may reflect the fact that it was designed differently</p>



<a name="288378702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378702">(Jul 04 2022 at 08:07)</a>:</h4>
<p>conceptually it really is the same.</p>



<a name="288378704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378704">(Jul 04 2022 at 08:07)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Complete_partial_order">https://en.wikipedia.org/wiki/Complete_partial_order</a></p>



<a name="288378734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378734">(Jul 04 2022 at 08:07)</a>:</h4>
<p>I maintain that we should be able to describe the three notions on here, of which I believe we have one (?)</p>



<a name="288378743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378743">(Jul 04 2022 at 08:07)</a>:</h4>
<p>I guess there's an alternate universe where suprema of conditionally complete lattices take in the subtype of bounded sets instead of sets</p>



<a name="288378747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378747">(Jul 04 2022 at 08:07)</a>:</h4>
<p>Yes.</p>



<a name="288378761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378761">(Jul 04 2022 at 08:08)</a>:</h4>
<p>Which I think would... be less good.</p>



<a name="288378832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378832">(Jul 04 2022 at 08:08)</a>:</h4>
<p>It would suck not being able to use the theorems on conditionally complete lattices on complete lattices</p>



<a name="288378838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378838">(Jul 04 2022 at 08:08)</a>:</h4>
<p>Yes</p>



<a name="288378841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378841">(Jul 04 2022 at 08:08)</a>:</h4>
<p>Although there's not really that many common theorems, to be fair</p>



<a name="288378858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378858">(Jul 04 2022 at 08:08)</a>:</h4>
<p>Mostly just easy ones like <code>Sup {a} = a</code> and such</p>



<a name="288378889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378889">(Jul 04 2022 at 08:09)</a>:</h4>
<p>Do we have any such situations with omega-complete partial orders?</p>



<a name="288378917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288378917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288378917">(Jul 04 2022 at 08:09)</a>:</h4>
<p>In terms of annoyances I've encountered, to be honest in the past it's mostly been things like "it's oddly hard to know what the right way to talk about the minimum of a set of natural numbers are", and that isn't (directly) an issue with Sup</p>



<a name="288379061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288379061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288379061">(Jul 04 2022 at 08:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="459227">Violeta Hernández</span> <a href="#narrow/stream/113488-general/topic/conditional.20lattice.20refactor/near/288378889">said</a>:</p>
<blockquote>
<p>Do we have any such situations with omega-complete partial orders?</p>
</blockquote>
<p>Well, every complete lattice is an omega-complete partial order, so we must have all the theorems of the latter on the former.</p>



<a name="288379215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288379215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288379215">(Jul 04 2022 at 08:12)</a>:</h4>
<p>But yeah - I don't think we have to do this refactor, but while I see Yael's complaint, I'm not necessarily saying we should be able to talk about arbitrary Sups - just that we should make sure we have every commonly-used notion of completeness and they should fit together nicely.</p>



<a name="288379305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/288379305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#288379305">(Jul 04 2022 at 08:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="330967">Wrenna Robson</span> <a href="#narrow/stream/113488-general/topic/conditional.20lattice.20refactor/near/288378475">said</a>:</p>
<blockquote>
<p>Well it just works a differently too because the domain of <code>ωSup</code> is chains.</p>
</blockquote>
<p>chains btw are omega-chains here, and they aren't actually sets because they're monotone functions from Nat to your type or whatnot</p>



<a name="289747425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289747425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289747425">(Jul 15 2022 at 16:04)</a>:</h4>
<p>My PR broke and I can't figure out why for the life of me</p>



<a name="289747478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289747478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289747478">(Jul 15 2022 at 16:04)</a>:</h4>
<p>Can someone check <a href="https://github.com/leanprover-community/mathlib/pull/14863">#14863</a> and tell me why it suddenly changes how the order in <code>upper_set</code>is defined?</p>



<a name="289748046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289748046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289748046">(Jul 15 2022 at 16:09)</a>:</h4>
<p>It's possible that the problem is not that the order is different, but that there are too many metavariables to infer the order.</p>



<a name="289748227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289748227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289748227">(Jul 15 2022 at 16:11)</a>:</h4>
<p>What happens if you use <code>@compl_subset_compl</code> instead?</p>



<a name="289750237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289750237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289750237">(Jul 15 2022 at 16:27)</a>:</h4>
<p>I'm almost sure the order changed, since changing the <code>≤</code> to <code>≥</code> fixes these lemmas</p>



<a name="289750294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289750294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289750294">(Jul 15 2022 at 16:28)</a>:</h4>
<p>I'll still try to provide everything explicitly, give me a sec</p>



<a name="289788304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289788304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289788304">(Jul 15 2022 at 21:58)</a>:</h4>
<p>Yeah look,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">compl_le_compl</span> <span class="o">:</span> <span class="n">s.compl</span> <span class="bp">≤</span> <span class="n">t.compl</span> <span class="bp">↔</span> <span class="n">s</span> <span class="bp">≥</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">compl_subset_compl</span>
</code></pre></div>
<p>this works, the original doesn't</p>



<a name="289788509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289788509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289788509">(Jul 15 2022 at 22:00)</a>:</h4>
<p>I think I see the issue</p>



<a name="289788586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289788586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289788586">(Jul 15 2022 at 22:01)</a>:</h4>
<p><code>upper_set</code> is getting its <code>≤</code> from <code>set_like.partial_order</code></p>



<a name="289788605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289788605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289788605">(Jul 15 2022 at 22:01)</a>:</h4>
<p>So it seems like my PR accidentally uncovered a diamond</p>



<a name="289788625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289788625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289788625">(Jul 15 2022 at 22:01)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span></p>



<a name="289802425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289802425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289802425">(Jul 16 2022 at 02:10)</a>:</h4>
<p>Oh wait, <code>set_like</code> provides a partial order by default? <span aria-label="grimacing" class="emoji emoji-1f62c" role="img" title="grimacing">:grimacing:</span></p>



<a name="289802734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289802734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289802734">(Jul 16 2022 at 02:17)</a>:</h4>
<p>Yep</p>



<a name="289802749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289802749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289802749">(Jul 16 2022 at 02:17)</a>:</h4>
<p>I presume that should be a definition rather than an instance?</p>



<a name="289802828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289802828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289802828">(Jul 16 2022 at 02:19)</a>:</h4>
<p>Or maybe the solution is to short-circuit typeclass inference in <code>upper_set</code>?</p>



<a name="289802833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289802833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289802833">(Jul 16 2022 at 02:19)</a>:</h4>
<p>We can probably strip that off because most set-like structures are actually complete lattices (so there's no need for a <code>partial_order</code> instance). If lemmas are stated in the generality of <code>set_like</code> using that default partial order, we can restate them using an order embedding or something of sort.</p>



<a name="289802972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289802972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289802972">(Jul 16 2022 at 02:22)</a>:</h4>
<p>You wanna go ahead? I could try fixing this diamond myself but I've never worked with <code>set_like</code> before and I don't want to screw something up</p>



<a name="289803176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289803176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289803176">(Jul 16 2022 at 02:27)</a>:</h4>
<p>You have at least until I wake tomorrow to try it out!</p>



<a name="289808282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289808282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289808282">(Jul 16 2022 at 04:45)</a>:</h4>
<p>I started a fix attempt at <a href="https://github.com/leanprover-community/mathlib/pull/15411">#15411</a>, but I have no idea if it will work</p>



<a name="289811657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289811657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289811657">(Jul 16 2022 at 06:15)</a>:</h4>
<p>The original point of set_like is "objects with canonical embedding to sets that preserves order and membership and coercion to sort"</p>



<a name="289811727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289811727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289811727">(Jul 16 2022 at 06:17)</a>:</h4>
<p>The current behavior is useful; if it's not useful to you, then it sounds like you need a weaker <code>less_set_like</code> class</p>



<a name="289811778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289811778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289811778">(Jul 16 2022 at 06:18)</a>:</h4>
<p>(or to rename the existing one)</p>



<a name="289811785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289811785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289811785">(Jul 16 2022 at 06:18)</a>:</h4>
<p>I'm glad to hear that because turning <code>set_like.partial_order</code> into a <code>def</code> breaks a lot of things I don't really understand</p>



<a name="289811801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289811801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289811801">(Jul 16 2022 at 06:19)</a>:</h4>
<p>So, the solution here would be to remove the <code>set_like</code> instance for <code>upper_set</code>?</p>



<a name="289811805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289811805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289811805">(Jul 16 2022 at 06:19)</a>:</h4>
<p>...or possibly, just use the order-dual to get the reverse ordering Yaël wants</p>



<a name="289811855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289811855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289811855">(Jul 16 2022 at 06:20)</a>:</h4>
<p>...and/or revert <a href="https://github.com/leanprover-community/mathlib/pull/14982">#14982</a></p>



<a name="289812202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289812202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289812202">(Jul 16 2022 at 06:30)</a>:</h4>
<p>Yeah, either we need a new typeclass for "a bit less set-like than set_like" to use for <code>upper_set</code>, or we should not have made <code>upper_set</code> less set-like in the first place</p>



<a name="289868427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289868427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289868427">(Jul 17 2022 at 06:48)</a>:</h4>
<p>What's the immediate solution though?</p>



<a name="289868430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289868430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289868430">(Jul 17 2022 at 06:48)</a>:</h4>
<p>This is blocking my PR for no good reason</p>



<a name="289868448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289868448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289868448">(Jul 17 2022 at 06:49)</a>:</h4>
<p>It shouldn't be hard to revert <a href="https://github.com/leanprover-community/mathlib/pull/14982">#14982</a> - we can then figure out what should or shouldn't be done long term</p>



<a name="289868501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289868501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289868501">(Jul 17 2022 at 06:50)</a>:</h4>
<p>I still think that just using the order dual of <code>upper_set</code> is the most elegant solution btw</p>



<a name="289868740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289868740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289868740">(Jul 17 2022 at 06:57)</a>:</h4>
<p>Using the order dual in the place where we state the isomorphism, you mean?</p>



<a name="289868815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289868815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289868815">(Jul 17 2022 at 06:59)</a>:</h4>
<p>A revert seems reasonable to me, but let's wait to hear from <span class="user-mention" data-user-id="387244">@Yaël Dillies</span></p>



<a name="289869187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289869187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289869187">(Jul 17 2022 at 07:08)</a>:</h4>
<p>Indeed, and if we want to use this order on filters, use the order dual too</p>



<a name="289869208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289869208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289869208">(Jul 17 2022 at 07:09)</a>:</h4>
<p>That's one of the justifications Yaël originally gave for this</p>



<a name="289869329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289869329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289869329">(Jul 17 2022 at 07:12)</a>:</h4>
<p>Filters already have this order</p>



<a name="289869336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289869336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289869336">(Jul 17 2022 at 07:12)</a>:</h4>
<p>I don't think you'll persuade anyone that changing the order on filters is a good idea</p>



<a name="289869478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289869478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289869478">(Jul 17 2022 at 07:16)</a>:</h4>
<p>Just to be clear; which is "your PR" in question?</p>



<a name="289874918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289874918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289874918">(Jul 17 2022 at 09:32)</a>:</h4>
<p>The original order on <code>upper_set</code> was the result of <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> being doubtful about not using the inclusion order, but the literature is clear that upper sets and filters should be ordered by reverse inclusion (and Bhavik changed his mind), so I would rather suggest either:</p>
<ul>
<li>Getting rid of the <code>set_like → partial_order</code> instance</li>
<li>Getting rid of the <code>set_like (upper_set α) α</code> instance</li>
</ul>



<a name="289875000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289875000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289875000">(Jul 17 2022 at 09:35)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/upper_set.set_like">docs#upper_set.set_like</a> is the offending instance I assume?</p>



<a name="289875053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289875053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289875053">(Jul 17 2022 at 09:36)</a>:</h4>
<p>If the literature is clear on this, can you edit the docstring to reference it for our choice?</p>



<a name="289990381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/conditional%20lattice%20refactor/near/289990381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/conditional.20lattice.20refactor.html#289990381">(Jul 18 2022 at 16:32)</a>:</h4>
<p>I think it makes sense to retain the <code>set_like → partial_order</code> instance (I've used it recently).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Highest.20universe.20in.20mathlib.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html">Highest universe in mathlib</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265998823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/265998823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#265998823">(Dec 24 2021 at 12:28)</a>:</h4>
<p>We all know we have infinitely many universes in Lean, and basically everything is universe-polymorphic in mathlib, but how many universes do we really need currently? That is, to which point can we squish down all universes in mathlib and still have everything typecheck? Kevin argued that <code>Type 1</code> was enough, but I suspect some constructions in category might something higher.</p>



<a name="265998859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/265998859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#265998859">(Dec 24 2021 at 12:29)</a>:</h4>
<p>Certainly <code>Type 2</code> will be good enough. I think that's what's needed for LTE.</p>



<a name="266004157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266004157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266004157">(Dec 24 2021 at 14:05)</a>:</h4>
<p>I must say I'm surprised we don't need anything higher!</p>



<a name="266008657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266008657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266008657">(Dec 24 2021 at 15:23)</a>:</h4>
<p>I'm not. If you're a set theorist then you think everything is a set so everything's in Type. Definitions like ordinals and the category of all sets/groups etc are called classes, and they're all in Type 1.</p>



<a name="266008672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266008672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266008672">(Dec 24 2021 at 15:23)</a>:</h4>
<p>Classically in mathematics you only deal with sets and classes</p>



<a name="266008877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266008877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266008877">(Dec 24 2021 at 15:27)</a>:</h4>
<p>Remember that historically mathematicians didn't even need sets! People like Gauss and Euler worked with terms and functions. Then Galois came along and said "I think it would be helpful if we could identify the permutation group of +-sqrt(2) with the permutation group of +-sqrt(3) because I think I'm on to something". It was only around then that we started needing to talk about some kind of holder type G for a collection of terms g. So in some sense before that we didn't even need Type. We just had concrete examples like the naturals, reals and complexes</p>



<a name="266008976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266008976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266008976">(Dec 24 2021 at 15:28)</a>:</h4>
<p>The push to develop abstract group theory and then abstract algebra and ideas like homomorphisms of groups are historically very recent. This is when people started to want to talk about maps between abstract types -- functions had of course existed for centuries before that but again only between concrete types such as the sine and cosine function on the reals</p>



<a name="266009043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266009043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266009043">(Dec 24 2021 at 15:30)</a>:</h4>
<p>So types became "things" and then set theory gave a name to the things, but Russell's paradox showed that you had to be careful so then we got things like ZFC and at that point mathematics was going on purely within Type.</p>



<a name="266009175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266009175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266009175">(Dec 24 2021 at 15:32)</a>:</h4>
<p>Then category theory and homological algebra and Grothendieck came along and then people wanted to start talking about abstract mathematical objects such as the category of all sets, which weren't even in Type. Grothendieck fixed this by adding an extra axiom to set theory to enable more than one universe of types, or of sets as he called them, and even then you don't need infinitely many, you just need to allow yourself to do the occasional universe bump. Hence Type 1</p>



<a name="266021888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266021888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266021888">(Dec 24 2021 at 20:10)</a>:</h4>
<p>I've been curious about this question for a while, so I decided to answer it for real instead of theorizing.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">open</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">inductive</span> <span class="n">level_spec</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">:</span> <span class="n">level</span> <span class="bp">→</span> <span class="n">level_spec</span>
<span class="bp">|</span> <span class="n">parametric</span> <span class="o">:</span> <span class="n">list</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">level</span> <span class="bp">→</span> <span class="n">level_spec</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">level.has_any_param</span> <span class="o">:</span> <span class="n">level</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.succ</span> <span class="n">l</span><span class="o">)</span>     <span class="o">:=</span>  <span class="n">l.has_any_param</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.max</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span>  <span class="o">:=</span>  <span class="n">l₁.has_any_param</span> <span class="bp">||</span>  <span class="n">l₂.has_any_param</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.imax</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:=</span>  <span class="n">l₁.has_any_param</span> <span class="bp">||</span>  <span class="n">l₂.has_any_param</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.param</span> <span class="n">_</span><span class="o">)</span>    <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">l</span>                  <span class="o">:=</span> <span class="n">ff</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">level.at_zero</span> <span class="o">:</span> <span class="n">level</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.succ</span> <span class="n">l</span><span class="o">)</span>     <span class="o">:=</span> <span class="n">l.at_zero</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.max</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">max</span> <span class="n">l₁.at_zero</span> <span class="n">l₂.at_zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.imax</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">l₂.at_zero</span> <span class="k">in</span> <span class="k">if</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">max</span> <span class="n">l₁.at_zero</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">_</span>                  <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">level_spec.at_zero</span> <span class="o">:</span> <span class="n">level_spec</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level_spec.const</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">l.at_zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level_spec.parametric</span> <span class="n">_</span> <span class="n">l</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">l.at_zero</span>

<span class="kd">meta</span> <span class="kd">mutual</span> <span class="kd">def</span> <span class="n">get_expr_level</span><span class="o">,</span> <span class="n">get_const_spec</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">environment</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ref</span> <span class="o">(</span><span class="n">name_map</span> <span class="n">level_spec</span><span class="o">))</span>
<span class="k">with</span> <span class="n">get_expr_level</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">level</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">level</span>
<span class="bp">|</span> <span class="n">v</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">v.fold</span> <span class="o">(</span><span class="n">pure</span> <span class="n">l</span><span class="o">)</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">_</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">expr.const</span> <span class="n">n</span> <span class="n">us</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">sp</span> <span class="bp">←</span> <span class="n">get_const_spec</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">sp</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">level_spec.const</span> <span class="n">l'</span> <span class="o">:=</span> <span class="n">pure</span> <span class="bp">$</span> <span class="n">l.max</span> <span class="n">l'</span>
    <span class="bp">|</span> <span class="n">level_spec.parametric</span> <span class="n">us'</span> <span class="n">l'</span> <span class="o">:=</span> <span class="n">pure</span> <span class="bp">$</span> <span class="n">l.max</span> <span class="bp">$</span> <span class="n">l'.instantiate</span> <span class="o">(</span><span class="n">us'.zip</span> <span class="n">us</span><span class="o">)</span>
    <span class="kd">end</span>
  <span class="bp">|</span> <span class="n">expr.sort</span> <span class="n">l'</span> <span class="o">:=</span> <span class="n">pure</span> <span class="bp">$</span> <span class="n">l.max</span> <span class="n">l'</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">pure</span> <span class="n">l</span>
  <span class="kd">end</span>
<span class="k">with</span> <span class="n">get_const_spec</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">level_spec</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">m</span> <span class="bp">←</span> <span class="n">read_ref</span> <span class="n">r</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">m.find</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">sp</span> <span class="o">:=</span> <span class="n">pure</span> <span class="n">sp</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">process_decl</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">us</span> <span class="o">:</span> <span class="n">list</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">level</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">level_spec</span> <span class="o">:=</span> <span class="o">(</span><span class="k">do</span>
      <span class="k">let</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">l.normalize</span><span class="o">,</span>
      <span class="k">let</span> <span class="n">sp</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">l.has_any_param</span> <span class="k">then</span> <span class="n">level_spec.parametric</span> <span class="n">us</span> <span class="n">l</span> <span class="k">else</span> <span class="n">level_spec.const</span> <span class="n">l</span><span class="o">,</span>
      <span class="n">m</span> <span class="bp">←</span> <span class="n">read_ref</span> <span class="n">r</span><span class="o">,</span>
      <span class="n">write_ref</span> <span class="n">r</span> <span class="o">(</span><span class="n">m.insert</span> <span class="n">n</span> <span class="n">sp</span><span class="o">),</span>
      <span class="n">pure</span> <span class="n">sp</span><span class="o">),</span>
    <span class="n">d</span> <span class="bp">←</span> <span class="n">env.get</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.defn</span> <span class="n">n</span> <span class="n">us</span> <span class="n">t</span> <span class="n">v</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span>
      <span class="n">get_expr_level</span> <span class="n">t</span> <span class="n">level.zero</span> <span class="bp">&gt;&gt;=</span> <span class="n">get_expr_level</span> <span class="n">v</span> <span class="bp">&gt;&gt;=</span> <span class="n">process_decl</span> <span class="n">n</span> <span class="n">us</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.thm</span> <span class="n">n</span> <span class="n">us</span> <span class="n">t</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
      <span class="n">get_expr_level</span> <span class="n">t</span> <span class="n">level.zero</span> <span class="bp">&gt;&gt;=</span> <span class="n">get_expr_level</span> <span class="n">v.get</span> <span class="bp">&gt;&gt;=</span> <span class="n">process_decl</span> <span class="n">n</span> <span class="n">us</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.cnst</span> <span class="n">n</span> <span class="n">us</span> <span class="n">t</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">get_expr_level</span> <span class="n">t</span> <span class="n">level.zero</span> <span class="bp">&gt;&gt;=</span> <span class="n">process_decl</span> <span class="n">n</span> <span class="n">us</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">declaration.ax</span> <span class="n">n</span> <span class="n">us</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">get_expr_level</span> <span class="n">t</span> <span class="n">level.zero</span> <span class="bp">&gt;&gt;=</span> <span class="n">process_decl</span> <span class="n">n</span> <span class="n">us</span>
    <span class="kd">end</span>
  <span class="kd">end</span>

<span class="kd">run_cmd</span>
  <span class="n">using_new_ref</span> <span class="n">mk_name_map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="k">do</span>
  <span class="n">env</span> <span class="bp">←</span> <span class="n">tactic.get_env</span><span class="o">,</span>
  <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="bp">←</span> <span class="n">env.fold</span> <span class="o">(</span><span class="n">pure</span> <span class="o">(</span><span class="n">name.anonymous</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">d</span> <span class="n">r</span><span class="o">,</span> <span class="o">(</span><span class="k">do</span>
    <span class="n">p</span> <span class="bp">←</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">d.to_name</span><span class="o">,</span>
    <span class="n">sp</span> <span class="bp">←</span> <span class="n">get_const_spec</span> <span class="n">env</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">sp.at_zero</span><span class="o">,</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">p.2</span> <span class="bp">&lt;</span> <span class="n">z</span> <span class="k">then</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="k">else</span> <span class="n">p</span><span class="o">),</span>
  <span class="n">trace</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
</code></pre></div>



<a name="266021896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266021896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266021896">(Dec 24 2021 at 20:10)</a>:</h4>
<p>For the core library, the output is <code>(sigma.mk.inj_eq, 3)</code>, which is to say, if you were to specialize every definition to every concrete universe, then the largest subterm of the form <code>Sort u</code> that appears in the hierarchy of definitions leading to <code>sigma.mk.inj_eq.{0, 0}</code> is <code>Sort 3</code>, aka <code>Type 2</code>. <code>sigma.mk.inj_eq</code> is the only definition that gets as high as <code>3</code>.</p>
<p>For mathlib, the output is <code>(measure_theory.L1.set_to_L1_congr_left', 4)</code>, and I'm checking now to see if there are any others at height 4. So the official answer seems to be that you need <code>Type 3</code> to compile mathlib, or alternatively, mathlib can be translated to work in ZFC with 4 inaccessible cardinals.</p>



<a name="266021966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266021966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266021966">(Dec 24 2021 at 20:12)</a>:</h4>
<p>It looks like there are a huge number of definitions at height 4 (and <code>measure_theory.L1.set_to_L1_congr_left'</code> is a random selection). I will look for minimal ones.</p>



<a name="266022673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266022673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266022673">(Dec 24 2021 at 20:30)</a>:</h4>
<p>Just to be clear here -- if a random definition takes four types in, in universes u v w x, that doesn't artificially push the bound up to 4?</p>



<a name="266022682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266022682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266022682">(Dec 24 2021 at 20:30)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/measure_theory.L1.set_to_L1_congr_left'">docs#measure_theory.L1.set_to_L1_congr_left'</a></p>



<a name="266022683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266022683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266022683">(Dec 24 2021 at 20:30)</a>:</h4>
<p>Here is the list of level 4 definitions that do not depend on any level 4 definitions (i.e. they are level 4 because they either directly use a large universe or reference a level 3 definition with a universe bump in the substitution):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ordinal.omin._match_1</span>
<span class="n">nhds_is_measurably_generated</span>
<span class="n">finprod_mem_def</span>
<span class="n">finprod_eq_prod_of_mul_support_subset</span>
<span class="n">add_monoid_hom.map_finsum</span>
<span class="n">pSet.definable</span>
<span class="n">pSet.arity.equiv._main</span>
<span class="n">finprod_mem_univ</span>
<span class="n">algebraic_geometry.LocallyRingedSpace.coproduct._proof_4</span>
<span class="n">finprod_mem_empty</span>
<span class="n">category_theory.types_glue._proof_1</span>
<span class="n">category_theory.types_glue._proof_2</span>
<span class="n">ordinal.lift.principal_seg._proof_1</span>
<span class="n">hahn_series.summable_family.hsum._proof_1</span>
<span class="n">smooth_partition_of_unity.mk</span>
<span class="n">partition_of_unity.mk</span>
<span class="n">bump_covering.to_pou_fun</span>
<span class="n">finprod_cond_nonneg</span>
<span class="n">finsum_eq_sum_of_support_subset</span>
<span class="n">partition_of_unity.sum_eq_one'</span>
<span class="n">partition_of_unity.sum_le_one'</span>
<span class="n">smooth_partition_of_unity.sum_eq_one'</span>
<span class="n">partition_of_unity.sum_nonneg</span>
<span class="n">smooth_partition_of_unity.sum_le_one'</span>
<span class="n">finsum_mem_def</span>
<span class="n">finsum_mem_univ</span>
<span class="n">finsum_mem_congr</span>
<span class="n">algebraic_geometry.Scheme.basic_open_is_open_immersion</span>
<span class="n">uchange</span>
<span class="n">finsum_mem_induction</span>
<span class="n">algebraic_geometry.LocallyRingedSpace.has_coequalizer.image_basic_open._proof_2</span>
<span class="n">algebraic_geometry.LocallyRingedSpace.has_coequalizer.image_basic_open._proof_4</span>
<span class="n">algebraic_geometry.LocallyRingedSpace.has_coequalizer.image_basic_open._proof_8</span>
<span class="n">algebraic_geometry.LocallyRingedSpace.has_coequalizer.coequalizer_π_app_is_local_ring_hom</span>
<span class="n">finsum_mem_empty</span>
<span class="n">algebraic_geometry.LocallyRingedSpace.is_open_immersion.forget_preserves_pullback_of_left</span>
<span class="n">algebraic_geometry.LocallyRingedSpace.coproduct._proof_3</span>
<span class="n">category_theory.subcanonical_types_grothendieck_topology</span>
<span class="n">algebraic_geometry.PresheafedSpace.is_open_immersion.to_LocallyRingedSpace._proof_4</span>
<span class="n">algebraic_geometry.LocallyRingedSpace.coequalizer._proof_3</span>
<span class="n">classical.all_definable._main._proof_1</span>
<span class="n">finsum_mem_zero</span>
<span class="n">monoid_hom.map_finprod</span>
<span class="n">pSet.embed._match_1</span>
<span class="n">finprod_mem_induction</span>
<span class="n">classical.all_definable._main._proof_2</span>
<span class="n">at_bot_is_measurably_generated</span>
<span class="n">ordinal.typein_iso._match_1</span>
<span class="n">ordinal.typein_iso._proof_1</span>
<span class="n">pSet.arity.equiv._main._meta_aux</span>
<span class="n">finsum_dmem</span>
<span class="n">finprod_mem_one</span>
<span class="n">finprod_mem_congr</span>
<span class="n">category_theory.flat_iff_Lan_flat</span>
<span class="n">finprod_dmem</span>
<span class="n">at_top_is_measurably_generated</span>
</code></pre></div>



<a name="266022699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266022699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266022699">(Dec 24 2021 at 20:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> No, having lots of universe parameters does not bump the level, but instantiating those parameters (directly or indirectly) with a <code>u+1</code> somewhere does</p>



<a name="266022747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266022747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266022747">(Dec 24 2021 at 20:32)</a>:</h4>
<p><code>measure_theory.L1.set_to_L1_congr_left'</code> just looks to me like some random technical lemma in measure theory that has nothing to do with universes</p>



<a name="266022759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266022759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266022759">(Dec 24 2021 at 20:32)</a>:</h4>
<p>The new list is probably more useful</p>



<a name="266022788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266022788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266022788">(Dec 24 2021 at 20:34)</a>:</h4>
<p>How the hack can something like <code>finsum_mem_empty</code> need a nontrivial amount of universes?</p>



<a name="266022798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266022798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266022798">(Dec 24 2021 at 20:34)</a>:</h4>
<p>One thing that is a bit dicey about any calculation like this is that if you just chop off the universe hierarchy, then not every term has a type. Right now, the program is asserting for every definition that its type and value have to be typecheckable; perhaps it would be better to skip the type for definitions and theorems</p>



<a name="266022841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266022841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266022841">(Dec 24 2021 at 20:34)</a>:</h4>
<p><code>finprod_mem_empty</code> needs four universes? I still don't think I understand the question :-)</p>



<a name="266023002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023002">(Dec 24 2021 at 20:38)</a>:</h4>
<p><code>finsum_mem_empty.{u_1, u_4}</code> has max universe <code>max (u_1+4) (u_4+2)</code></p>



<a name="266023016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023016">(Dec 24 2021 at 20:39)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finsum_mem_empty">docs#finsum_mem_empty</a></p>



<a name="266023092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023092">(Dec 24 2021 at 20:40)</a>:</h4>
<p>lol what is going on</p>



<a name="266023111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023111">(Dec 24 2021 at 20:41)</a>:</h4>
<p>Wow! Thanks, Mario.</p>



<a name="266023156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023156">(Dec 24 2021 at 20:42)</a>:</h4>
<ul>
<li><code>finsum_mem_empty.{u_1 u_4}</code> has max universe <code>max (u_1+4) (u_4+2)</code> because it uses <code>finsum.{u_4 u_1+1}</code></li>
<li><code>finsum.{u_1 u_2}</code> has max universe <code>max (u_1+2) (u_2+3)</code>, still not sure where this is coming from, I will make a program to unravel it</li>
</ul>



<a name="266023323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023323">(Dec 24 2021 at 20:46)</a>:</h4>
<p>lol I wrote <code>finprod_mem_empty</code></p>



<a name="266023338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023338">(Dec 24 2021 at 20:47)</a>:</h4>
<p>oh! Oh so the issue is <code>finsum</code>, not my lemma</p>



<a name="266023342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023342">(Dec 24 2021 at 20:47)</a>:</h4>
<p>You're in the highest universe, Kevin!</p>



<a name="266023412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023412">(Dec 24 2021 at 20:48)</a>:</h4>
<p>golly, I apparently wrote <code>finprod</code> too</p>



<a name="266023433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023433">(Dec 24 2021 at 20:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Highest.20universe.20in.20mathlib/near/266023156">said</a>:</p>
<blockquote>
<p>still not sure where this is coming from, I will make a program to unravel it</p>
</blockquote>
<p>The answer is Kevin <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="266023441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023441">(Dec 24 2021 at 20:49)</a>:</h4>
<p>I'm pretty sure that other people told me what to write in that definition :-)</p>



<a name="266023502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023502">(Dec 24 2021 at 20:50)</a>:</h4>
<p>What is all this plift stuff?</p>



<a name="266023654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023654">(Dec 24 2021 at 20:54)</a>:</h4>
<p>Here's the program for outputting the level of a definition and its direct dependencies:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">level_spec.level</span> <span class="o">:</span> <span class="n">level_spec</span> <span class="bp">→</span> <span class="n">level</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level_spec.const</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">l</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level_spec.parametric</span> <span class="n">_</span> <span class="n">l</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">l</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">level_spec.args</span> <span class="o">:</span> <span class="n">level_spec</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">name</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level_spec.const</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level_spec.parametric</span> <span class="n">us</span> <span class="n">_</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">us</span>

<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="kd">run_cmd</span>
  <span class="n">using_new_ref</span> <span class="n">mk_name_map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="k">do</span>
  <span class="n">env</span> <span class="bp">←</span> <span class="n">tactic.get_env</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">`</span><span class="n">finsum</span><span class="o">,</span>
  <span class="n">l</span> <span class="bp">←</span> <span class="n">get_const_spec</span> <span class="n">env</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">trace</span> <span class="o">(</span><span class="n">l.args</span><span class="o">,</span> <span class="n">l.level</span><span class="o">),</span>
  <span class="n">d</span> <span class="bp">←</span> <span class="n">env.get</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">map</span> <span class="o">:=</span> <span class="n">d.value.fold</span> <span class="n">mk_name_set</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">_</span> <span class="n">m</span><span class="o">,</span>
    <span class="k">if</span> <span class="n">e.is_constant</span> <span class="k">then</span> <span class="n">m.insert</span> <span class="n">e.const_name</span> <span class="k">else</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">map.fold</span> <span class="o">(</span><span class="n">pure</span> <span class="o">())</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">r</span><span class="o">,</span> <span class="k">do</span>
    <span class="n">r</span><span class="o">,</span>
    <span class="n">l</span> <span class="bp">←</span> <span class="n">get_const_spec</span> <span class="n">env</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">trace</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">l.args</span><span class="o">,</span> <span class="n">l.level</span><span class="o">)</span>
</code></pre></div>



<a name="266023749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023749">(Dec 24 2021 at 20:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Highest.20universe.20in.20mathlib/near/266022841">said</a>:</p>
<blockquote>
<p><code>finprod_mem_empty</code> needs four universes? I still don't think I understand the question :-)</p>
</blockquote>
<p>I don't think I understand most of these examples either ... is it possible that many of them are just "mistakes"?  People mis-using universes when writing the lemma/definition?</p>



<a name="266023832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023832">(Dec 24 2021 at 20:59)</a>:</h4>
<ul>
<li><code>finsum_mem_empty.{u_1 u_4}</code> has max universe <code>max (u_1+4) (u_4+2)</code> because it uses <code>finsum.{u_4 u_1+1}</code></li>
<li><code>finsum.{u_1 u_2}</code> has max universe <code>max (u_1+2) (u_2+3)</code>, because it uses <code>set.finite.to_finset.{u_2}</code></li>
<li><code>set.finite.to_finset.{u}</code> has max universe <code>u+3</code>, because it uses <code>set.finite.fintype.{u}</code></li>
<li><code>set.finite.fintype.{u}</code> has max universe <code>u+3</code>, because it uses <code>set.has_coe_to_sort.{u}</code></li>
<li><code>set.has_coe_to_sort.{u}</code> has max universe <code>u+3</code>, because it uses <code>has_coe_to_sort.mk.{(max (u+1) 1) u+2}</code></li>
<li><code>has_coe_to_sort.mk.{u v}</code> has max universe <code>max u (v+1)</code>, because its type uses <code>out_param.{v+1}</code></li>
<li><code>out_param.{u}</code> has max universe <code>u</code>, because it mentions <code>Sort u</code></li>
</ul>



<a name="266023921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023921">(Dec 24 2021 at 21:00)</a>:</h4>
<p>It seems that the index types alpha,beta,iota are allowed to be <code>Sort</code>s however <code>finset</code> takes a <code>Type</code>, that's what all the plift nonsense is all about.</p>



<a name="266023943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023943">(Dec 24 2021 at 21:01)</a>:</h4>
<p>I don't think that anything like that is going to cause spurious universe bumps</p>



<a name="266023956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023956">(Dec 24 2021 at 21:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">set.has_coe_to_sort.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">has</span> <span class="n">max</span> <span class="kd">universe</span> <span class="n">u</span><span class="bp">+</span><span class="mi">3</span><span class="o">,</span> <span class="n">because</span> <span class="n">it</span> <span class="n">uses</span> <span class="n">has_coe_to_sort.mk.</span><span class="o">{(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="mi">1</span><span class="o">)</span> <span class="n">u</span><span class="bp">+</span><span class="mi">2</span><span class="o">}</span>
</code></pre></div>
<p>lol what is this?</p>



<a name="266023958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023958">(Dec 24 2021 at 21:01)</a>:</h4>
<p>whether the indexing starts at 0 or 1 for a given universe variable doesn't really matter</p>



<a name="266023963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023963">(Dec 24 2021 at 21:01)</a>:</h4>
<p>yeah that one is a bit surprising</p>



<a name="266023968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266023968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266023968">(Dec 24 2021 at 21:01)</a>:</h4>
<p>but you can see it clearly in the pp.all</p>



<a name="266024163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266024163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266024163">(Dec 24 2021 at 21:06)</a>:</h4>
<p>Note that in the <code>has_coe_to_sort.mk</code> step, I'm actually looking at the <em>type</em> of the definition rather than the value (since it's a constructor). Looking at types can cause universe bumps, since <code>Type u : Type (u+1)</code> - if you insist that the type be well formed for the value to be then you will get no upper bound</p>



<a name="266024592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266024592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266024592">(Dec 24 2021 at 21:18)</a>:</h4>
<p>Here's another way to look at the derivation:</p>
<ul>
<li><code>finsum_mem_empty.{0 0}</code> uses <code>finsum.{0 1}</code></li>
<li><code>finsum.{0 1}</code> uses <code>set.finite.to_finset.{1}</code></li>
<li><code>set.finite.to_finset.{1}</code> uses <code>set.finite.fintype.{1}</code></li>
<li><code>set.finite.fintype.{1}</code> uses <code>set.has_coe_to_sort.{1}</code></li>
<li><code>set.has_coe_to_sort.{1}</code> uses <code>has_coe_to_sort.mk.{2 3}</code></li>
<li><code>has_coe_to_sort.mk.{2 3}</code> uses <code>out_param.{4}</code></li>
<li><code>out_param.{4}</code> contains <code>Sort 4</code></li>
</ul>
<p>The last two examples might help to understand what's happening:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">finsum_mem_empty.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">0</span><span class="o">}</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">finsum.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">1</span><span class="o">}</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">set.finite.to_finset.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">set.finite.fintype.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">set.has_coe_to_sort.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">has_coe_to_sort.mk.</span><span class="o">{</span><span class="mi">2</span> <span class="mi">3</span><span class="o">}</span>
<span class="c1">-- has_coe_to_sort.mk.{2 3} : Π {a : Type 1} {S : out_param.{4} (Type 2)}, (a → S) → has_coe_to_sort.{2 3} a S</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">out_param.</span><span class="o">{</span><span class="mi">4</span><span class="o">}</span>
<span class="c1">-- out_param.{4} : Type 3 → Type 3</span>
</code></pre></div>
<p><code>out_param</code> is just an identity function, but in order to apply the identity function to <code>Type 2</code> you need a <code>Type 3</code> to write the type of the argument</p>



<a name="266024621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266024621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266024621">(Dec 24 2021 at 21:19)</a>:</h4>
<p>If the uses of <code>set.has_coe_to_sort</code> were replaced by <code>subtype</code>, would this get rid of the +3 universe bump?</p>



<a name="266024694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266024694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266024694">(Dec 24 2021 at 21:21)</a>:</h4>
<p>here's a simplified example how you can get lots of bumping without really doing anything weird</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">id</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="o">(</span><span class="bp">@</span><span class="n">id</span> <span class="o">(</span><span class="kt">Type</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="kt">Type</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="kt">Type</span> <span class="mi">1</span><span class="o">))</span> <span class="kt">Type</span><span class="o">)</span> <span class="kt">Prop</span><span class="o">)</span> <span class="n">true</span>
</code></pre></div>



<a name="266025023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266025023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266025023">(Dec 24 2021 at 21:29)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> Yes, you have to eliminate the uses of <code>set.has_coe_to_sort</code> in dependents as well, but this version drops the level of <code>set.finite.fintype</code> from u+3 to u+1:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">set.finite'</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">subtype</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">set.finite'</span>

<span class="kd">lemma</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">set.finite_def'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">set.finite'</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fintype</span> <span class="o">(</span><span class="n">subtype</span> <span class="n">s</span><span class="o">))</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">h</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">h</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">h</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">h</span><span class="o">⟩⟩</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">set.finite.fintype'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">set.finite'</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">subtype</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">classical.choice</span> <span class="bp">$</span> <span class="n">set.finite_def'.1</span> <span class="n">h</span>
</code></pre></div>



<a name="266025137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266025137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266025137">(Dec 24 2021 at 21:31)</a>:</h4>
<p>Hmm, maybe <code>set.has_coe_to_sort</code> should be considered harmful ...</p>



<a name="266025197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266025197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266025197">(Dec 24 2021 at 21:33)</a>:</h4>
<p>Probably a better approach for determining the real axiomatic strength of mathlib would be to allow for higher universes that don't support inductive types at all. As long as you only use them in <code>id</code> applications like this that might be sufficient.</p>



<a name="266027209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266027209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266027209">(Dec 24 2021 at 22:23)</a>:</h4>
<p>Looking at this some more, <code>finsum.{0 1} :  Π {M α : Type}, ...</code> which looks normal, but it references</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">set.finite.to_finset.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">},</span> <span class="n">s.finite</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">α</span>
</code></pre></div>
<p>which seems gratuitous (why are we dealing with sets of elements in Type 1?). I suspect the reason is <code>plift : Sort u -&gt; Type u</code>. Perhaps we should try changing that to <code>plift : Sort u -&gt; Sort (max u 1)</code> and see what breaks</p>



<a name="266027340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266027340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266027340">(Dec 24 2021 at 22:26)</a>:</h4>
<p>Oh, that won't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[irreducible]</span> <span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">finsum</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">finite</span> <span class="o">(</span><span class="n">support</span> <span class="o">(</span><span class="n">f</span> <span class="bp">∘</span> <span class="n">plift.down</span><span class="o">))</span> <span class="k">then</span> <span class="bp">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">h.to_finset</span><span class="o">,</span> <span class="n">f</span> <span class="n">i.down</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>
<p>Here <code>support (f ∘ plift.down)</code> is needed because <code>support</code> takes a <code>Type u'</code>, and if you had a variant of <code>plift</code> returning <code>Sort (max v 1)</code> then it wouldn't unify with <code>Type u'</code> because <code>u' + 1 = max v 1</code> does not have a solution for <code>u'</code> in level arithmetic</p>



<a name="266028993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266028993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266028993">(Dec 24 2021 at 23:02)</a>:</h4>
<p>try <code>induction v</code>? ;-)</p>



<a name="266029011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266029011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266029011">(Dec 24 2021 at 23:02)</a>:</h4>
<p>Whose idea was it to sum over Props anyway?</p>



<a name="266034940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266034940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266034940">(Dec 25 2021 at 01:28)</a>:</h4>
<p>It was my idea</p>



<a name="266034960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266034960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266034960">(Dec 25 2021 at 01:29)</a>:</h4>
<p>This way you can write <code>\sum^f n &lt; 5, n</code></p>



<a name="266035141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266035141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266035141">(Dec 25 2021 at 01:34)</a>:</h4>
<p>We need pfinsum :-)</p>



<a name="266036956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266036956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266036956">(Dec 25 2021 at 02:28)</a>:</h4>
<p>Why? You won't get nice notation if you don't use the same <code>def</code> for sums over <code>n : nat</code> and <code>hn : n &lt; 5</code>.</p>



<a name="266036962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266036962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266036962">(Dec 25 2021 at 02:28)</a>:</h4>
<p>Do you really care about universe bump here?</p>



<a name="266041913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266041913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266041913">(Dec 25 2021 at 04:55)</a>:</h4>
<p>For me, I find <code>∑ᶠ n &lt; 5, n</code> more important than avoiding universe bumps.</p>



<a name="266071843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266071843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266071843">(Dec 25 2021 at 19:18)</a>:</h4>
<p>I have heard of people who believe in the Axiom of Choice up to some aleph-n (n = 2 or 3 I think?). I haven't heard of anyone who doesn't believe in at most 3 inaccessible cardinals. So I'm curious why we care</p>



<a name="266076291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Highest%20universe%20in%20mathlib/near/266076291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Highest.20universe.20in.20mathlib.html#266076291">(Dec 25 2021 at 21:25)</a>:</h4>
<p>Because I tell ZFC people that obviously it all works in ZFC?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/prod_multiset_count.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html">prod_multiset_count</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="202774761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202774761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202774761">(Jul 03 2020 at 07:20)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_multiset_count</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">s</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">=</span> <span class="err">∏</span> <span class="n">m</span> <span class="k">in</span> <span class="n">s</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">m</span> <span class="bp">^</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="n">count</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>


<p>What's the best way to prove this?</p>



<a name="202783178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202783178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202783178">(Jul 03 2020 at 09:15)</a>:</h4>
<p>Via a multiset is the union of <code>repeat a (count S a)</code> for <code>a \in S</code>?</p>



<a name="202783527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202783527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202783527">(Jul 03 2020 at 09:19)</a>:</h4>
<p>Maybe... I haven't spent that much time on this yet.</p>



<a name="202783577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202783577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202783577">(Jul 03 2020 at 09:20)</a>:</h4>
<p>I was just annoyed that it doesn't seem to be in the library yet... (-;</p>



<a name="202783784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202783784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202783784">(Jul 03 2020 at 09:23)</a>:</h4>
<p>I couldn't even find Union of a set/list of multisets?</p>



<a name="202787587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202787587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202787587">(Jul 03 2020 at 10:09)</a>:</h4>
<p>It's called <code>bind</code>.</p>



<a name="202788288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202788288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202788288">(Jul 03 2020 at 10:17)</a>:</h4>
<p>That's surely only a Union of a multiset of multisets?</p>



<a name="202788800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202788800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Amelia Livingston <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202788800">(Jul 03 2020 at 10:24)</a>:</h4>
<p><a href="https://gist.github.com/101damnations/e05039b6099b9e69f531cd8f3eb9c8be">here</a>'s emphatically not the best way to prove it</p>



<a name="202795318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202795318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202795318">(Jul 03 2020 at 11:50)</a>:</h4>
<p>Aah induction on the size of the corresponding finset. This reminds me of something that I don't know how to do. Amelia has added <code>{n : ℕ} (hn : s.to_finset.card = n)</code> as extra inputs to her proof, and in practice you will be able to give <code>rfl</code> as the <code>hn</code> input and not worry. If you're in the middle of some complicated thing and suddenly decide that you want to do induction on the length of a list, what do you do?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">basic</span>

<span class="c1">-- how to do induction on the length of a list?</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="o">[])</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">L</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">L</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">L</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">L</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">L</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">L</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">L</span><span class="bp">.</span><span class="n">length</span> <span class="k">with</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span> <span class="c1">-- induction tactic failed, failed to create new goal</span>

<span class="kn">end</span>
</code></pre></div>


<p>We could prove an auxiliary lemma with the extra input of a natural which is equal to the length of L, and then use that auxiliary lemma, but is there a way to do it without having to "start again" as it were?</p>



<a name="202795545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202795545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202795545">(Jul 03 2020 at 11:53)</a>:</h4>
<p>You can see an example in <a href="https://github.com/leanprover-community/mathlib/blob/53c15319008e3a11d5e8f6c90b64cb0b68f03fa1/src/analysis/normed_space/finite_dimension.lean#L79">https://github.com/leanprover-community/mathlib/blob/53c15319008e3a11d5e8f6c90b64cb0b68f03fa1/src/analysis/normed_space/finite_dimension.lean#L79</a></p>



<a name="202795726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202795726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202795726">(Jul 03 2020 at 11:55)</a>:</h4>
<p>Or in  a recent PR by <span class="user-mention" data-user-id="110064">@Kenny Lau</span> <br>
<a href="https://github.com/leanprover-community/mathlib/blob/cefc8c85895d5acdf79c659edec5fbc1d513b13b/src/field_theory/splitting_field.lean#L209">https://github.com/leanprover-community/mathlib/blob/cefc8c85895d5acdf79c659edec5fbc1d513b13b/src/field_theory/splitting_field.lean#L209</a></p>



<a name="202796450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202796450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202796450">(Jul 03 2020 at 12:04)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">multiset</span> <span class="n">finset</span>

<span class="kn">lemma</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_multiset_count</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">s</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">=</span> <span class="err">∏</span> <span class="n">m</span> <span class="k">in</span> <span class="n">s</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span> <span class="n">m</span> <span class="bp">^</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="n">count</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">s</span><span class="bp">.</span><span class="n">induction_on</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">prod_zero</span><span class="o">,</span> <span class="n">to_finset_zero</span><span class="o">,</span> <span class="n">prod_empty</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">s</span> <span class="n">ih</span><span class="o">,</span> <span class="n">by_cases</span> <span class="n">has</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span><span class="bp">.</span><span class="n">to_finset</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">prod_cons</span><span class="o">,</span> <span class="n">to_finset_cons</span><span class="o">,</span> <span class="n">insert_eq_of_mem</span> <span class="n">has</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span>
      <span class="err">←</span> <span class="n">insert_erase</span> <span class="n">has</span><span class="o">,</span> <span class="n">prod_insert</span> <span class="o">(</span><span class="n">not_mem_erase</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span> <span class="n">prod_insert</span> <span class="o">(</span><span class="n">not_mem_erase</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span>
      <span class="err">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">count_cons_self</span><span class="o">,</span> <span class="n">pow_succ</span><span class="o">],</span>
    <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">refine</span> <span class="n">prod_congr</span> <span class="n">rfl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span> <span class="n">rw</span> <span class="o">[</span><span class="n">count_cons_of_ne</span> <span class="o">(</span><span class="n">ne_of_mem_erase</span> <span class="n">hx</span><span class="o">)]</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">prod_cons</span><span class="o">,</span> <span class="n">to_finset_cons</span><span class="o">,</span> <span class="n">prod_insert</span> <span class="n">has</span><span class="o">,</span> <span class="n">count_cons_self</span><span class="o">],</span>
  <span class="n">rw</span> <span class="n">mem_to_finset</span> <span class="n">at</span> <span class="n">has</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">count_eq_zero_of_not_mem</span> <span class="n">has</span><span class="o">,</span> <span class="n">pow_one</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">ih</span><span class="o">,</span> <span class="n">refine</span> <span class="n">prod_congr</span> <span class="n">rfl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span> <span class="n">rw</span> <span class="n">mem_to_finset</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rw</span> <span class="n">count_cons_of_ne</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">exact</span> <span class="n">has</span> <span class="n">hx</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202796467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202796467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202796467">(Jul 03 2020 at 12:04)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">open</span> <span class="n">list</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="o">[])</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">L</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">L</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">L</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">L</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">L</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">L</span><span class="o">,</span>
  <span class="n">unfreezingI</span> <span class="o">{</span><span class="n">induction</span> <span class="n">h</span> <span class="o">:</span> <span class="n">L</span><span class="bp">.</span><span class="n">length</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span> <span class="n">generalizing</span> <span class="n">L</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">convert</span> <span class="n">h0</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">length_eq_zero</span> <span class="n">at</span> <span class="n">h</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">h1</span> <span class="n">d</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>


<p>I did my homework</p>



<a name="202796950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202796950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202796950">(Jul 03 2020 at 12:10)</a>:</h4>
<p>By the way <a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.to_finset_sum_count_eq/src">src#multiset.to_finset_sum_count_eq</a> looks pretty similar to what is needed here</p>



<a name="202797149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/prod_multiset_count/near/202797149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/prod_multiset_count.html#202797149">(Jul 03 2020 at 12:12)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/multiset.le_smul_erase_dup/src">src#multiset.le_smul_erase_dup</a> also does something similar</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
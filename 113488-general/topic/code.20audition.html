---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/code.20audition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html">code audition</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="197538100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197538100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197538100">(May 14 2020 at 11:10)</a>:</h4>
<p>I'm trying out lean, and I think it would be helpful if I can have some comments on my code. It compiles with lean 3.11.0. I'm mainly looking for advise on how to make things better. For example, I'm not really sure that I like my definition of <code>fold</code>, and I certainly don't like my definition of <code>assoc_concat</code>. </p>
<p>What I don't like about <code>fold</code> is that I refer to weird variables that are generated by lean. What I don't like about <code>assoc_concat</code> is that I have to do this calculation with a few reflexivity paths. I would have assumed that lean can calculate those automatically, but I wasn't able to make it do a direct <code>rewrite</code>.</p>
<p>Thank you in advance for your advice.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kn">inductive</span> <span class="n">list</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">list</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="bp">→</span> <span class="n">list</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="kn">definition</span> <span class="n">unit</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">nil</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">definition</span> <span class="n">fold</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
<span class="o">{</span> <span class="n">exact</span> <span class="n">b</span><span class="o">},</span>
<span class="o">{</span> <span class="n">exact</span> <span class="n">μ</span> <span class="n">x_a</span> <span class="n">x_ih</span><span class="o">}</span>
<span class="kn">end</span>

<span class="kn">definition</span> <span class="n">length</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">refine</span> <span class="n">fold</span> <span class="mi">0</span> <span class="bp">_</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">a</span> <span class="n">n</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">definition</span> <span class="n">sum_list_ℕ</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">refine</span> <span class="n">fold</span> <span class="mi">0</span> <span class="bp">_</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">definition</span> <span class="n">concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">refine</span> <span class="n">fold</span> <span class="n">id</span> <span class="bp">_</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">a</span> <span class="n">f</span> <span class="n">l</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">f</span> <span class="n">l</span><span class="o">),</span>
<span class="kn">end</span>

<span class="kn">definition</span> <span class="n">flatten</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">exact</span> <span class="n">fold</span> <span class="n">nil</span> <span class="n">concat</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">definition</span> <span class="n">reverse</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
<span class="o">{</span> <span class="n">exact</span> <span class="n">nil</span><span class="o">},</span>
<span class="o">{</span> <span class="n">exact</span> <span class="n">concat</span> <span class="n">x_ih</span> <span class="o">(</span><span class="n">unit</span> <span class="n">x_a</span><span class="o">)}</span>
<span class="kn">end</span>

<span class="kn">definition</span> <span class="n">assoc_concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">concat</span> <span class="n">x</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
<span class="o">{</span> <span class="n">reflexivity</span><span class="o">},</span>
<span class="o">{</span> <span class="k">calc</span>
    <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x_a</span> <span class="n">x_a_1</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">x_a</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x_a_1</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">reflexivity</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">x_a</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x_a_1</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">x_ih</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x_a</span> <span class="n">x_a_1</span><span class="o">)</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">reflexivity</span><span class="o">},</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">1</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">2</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">3</span> <span class="n">nil</span><span class="o">)))</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">4</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">5</span> <span class="n">nil</span><span class="o">))</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">sum_list_ℕ</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">1</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">2</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">3</span> <span class="n">nil</span><span class="o">)))</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">4</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">5</span> <span class="n">nil</span><span class="o">)))</span>

<span class="kn">end</span> <span class="n">list</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="197538952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197538952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197538952">(May 14 2020 at 11:20)</a>:</h4>
<p><span class="user-mention" data-user-id="253568">@Egbert Rijke</span> You can typically name new variables using <code>with foo bar</code>. So <code>induction x with x ih</code>.</p>



<a name="197539012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197539012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197539012">(May 14 2020 at 11:21)</a>:</h4>
<p>Ah, that's helpful! Thanks!</p>



<a name="197539456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197539456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197539456">(May 14 2020 at 11:27)</a>:</h4>
<p>I think <code>concat_assoc</code> would typically be written using the equation compiler. I think the syntax is actually quite similar to Agda?</p>



<a name="197539476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197539476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197539476">(May 14 2020 at 11:27)</a>:</h4>
<p>So</p>
<div class="codehilite"><pre><span></span><code><span class="n">statement</span> <span class="n">blabla</span>
<span class="bp">|</span> <span class="n">case</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="bp">|</span> <span class="n">case</span> <span class="mi">2</span> <span class="o">:=</span>
</code></pre></div>



<a name="197539553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197539553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197539553">(May 14 2020 at 11:28)</a>:</h4>
<p>But it means you'll have to move <code>x y z</code> to the right of the <code>:</code>.</p>



<a name="197539596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197539596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197539596">(May 14 2020 at 11:29)</a>:</h4>
<p><span class="user-mention" data-user-id="253568">@Egbert Rijke</span> Also... minor point, it seems that our naming conventions are slightly different. In mathlib it would be <code>concat_assoc</code> instead of <code>assoc_concat</code>.</p>



<a name="197539699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197539699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197539699">(May 14 2020 at 11:30)</a>:</h4>
<p>Here's a quick attempt to make things a little more "canonical Lean." I didn't go through all the declarations but tried to leave some comments.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">list</span>

<span class="c">/-</span><span class="cm"> we generally don&#39;t write definitions in tactic mode.</span>
<span class="cm">it&#39;s not a problem using tactics like intro and exact,</span>
<span class="cm">but more complicated tactics can produce terms that are hard to work with. -/</span>
<span class="n">def</span> <span class="n">unit</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">cons</span> <span class="n">a</span> <span class="n">nil</span>

<span class="c1">-- or:</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">def unit {A : Type} : A → list A :=</span>
<span class="cm">λ a, cons a nil</span>
<span class="cm">-/</span>

<span class="c">/-</span><span class="cm"> we usually write recursive definitions using pattern matching -/</span>
<span class="n">def</span> <span class="n">fold</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">μ</span> <span class="n">a</span> <span class="o">(</span><span class="n">fold</span> <span class="n">l</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> but if you really want to do this, you should name the variables from `induction` -/</span>
<span class="n">def</span> <span class="n">fold&#39;</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">x</span> <span class="k">with</span> <span class="n">a</span> <span class="bp">_</span> <span class="n">b&#39;</span><span class="o">,</span>
<span class="o">{</span> <span class="n">exact</span> <span class="n">b</span> <span class="o">},</span>
<span class="o">{</span> <span class="n">exact</span> <span class="n">μ</span> <span class="n">a</span> <span class="n">b&#39;</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm"> the $ lets us avoid parentheses around the last argument -/</span>
<span class="n">def</span> <span class="n">length</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">fold</span> <span class="mi">0</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="n">def</span> <span class="n">sum_list_ℕ</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">refine</span> <span class="n">fold</span> <span class="mi">0</span> <span class="bp">_</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">refine</span> <span class="n">fold</span> <span class="n">id</span> <span class="bp">_</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">a</span> <span class="n">f</span> <span class="n">l</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">f</span> <span class="n">l</span><span class="o">),</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm"> if your proof / definition is just a term, there&#39;s definitely no reason for tactic mode -/</span>
<span class="n">def</span> <span class="n">flatten</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="c1">--begin</span>
<span class="c1">--exact</span>
<span class="n">fold</span> <span class="n">nil</span> <span class="n">concat</span>
<span class="c1">--end</span>

<span class="n">def</span> <span class="n">reverse</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
<span class="o">{</span> <span class="n">exact</span> <span class="n">nil</span><span class="o">},</span>
<span class="o">{</span> <span class="n">exact</span> <span class="n">concat</span> <span class="n">x_ih</span> <span class="o">(</span><span class="n">unit</span> <span class="n">x_a</span><span class="o">)}</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm"> declarations whose type is a Prop are usually declared with `theorem` instead of `def` -/</span>
<span class="kn">theorem</span> <span class="n">assoc_concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">concat</span> <span class="n">x</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">induction</span> <span class="n">x</span><span class="o">,</span>
<span class="o">{</span> <span class="n">refl</span><span class="o">},</span>
<span class="o">{</span> <span class="k">calc</span>
    <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x_a</span> <span class="n">x_a_1</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">x_a</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x_a_1</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">x_a</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x_a_1</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">x_ih</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x_a</span> <span class="n">x_a_1</span><span class="o">)</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span><span class="o">},</span>
<span class="kn">end</span>


<span class="bp">#</span><span class="n">reduce</span> <span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">1</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">2</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">3</span> <span class="n">nil</span><span class="o">)))</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">4</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">5</span> <span class="n">nil</span><span class="o">))</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">sum_list_ℕ</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">1</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">2</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">3</span> <span class="n">nil</span><span class="o">)))</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">4</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">5</span> <span class="n">nil</span><span class="o">)))</span>

<span class="kn">end</span> <span class="n">list</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="197539727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197539727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197539727">(May 14 2020 at 11:30)</a>:</h4>
<p>Also, do you want to do everything in tactic mode? Things like</p>
<div class="codehilite"><pre><span></span><code><span class="n">statement</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">exact</span> <span class="n">foobar</span>
<span class="kn">end</span>
</code></pre></div>


<p>can just be turned into </p>
<div class="codehilite"><pre><span></span><code><span class="n">statement</span> <span class="o">:=</span>
<span class="n">foobar</span>
</code></pre></div>



<a name="197539874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197539874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197539874">(May 14 2020 at 11:32)</a>:</h4>
<p>If you like type classes</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">sum_list_ℕ</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">refine</span> <span class="n">fold</span> <span class="mi">0</span> <span class="bp">_</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>could become</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">sum</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">refine</span> <span class="n">fold</span> <span class="mi">0</span> <span class="bp">_</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="197540042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197540042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197540042">(May 14 2020 at 11:34)</a>:</h4>
<p>Here's an equation compiler version of <code>assoc_concat</code>, although whether this is canonical or not depends on who you ask. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">assoc_concat&#39;</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span>
  <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">concat</span> <span class="n">x</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:=</span>
  <span class="k">calc</span>
    <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">l</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">concat</span> <span class="n">l</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">assoc_concat&#39;</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
</code></pre></div>



<a name="197540200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197540200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197540200">(May 14 2020 at 11:37)</a>:</h4>
<p><span class="user-mention" data-user-id="253568">@Egbert Rijke</span> Note that Lean has "poor man's holes" compared to Agda.<br>
If you write</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">sum</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">fold</span> <span class="mi">0</span> <span class="bp">_</span> <span class="c1">-- &lt;- put cursor before the _</span>
</code></pre></div>


<p>then the editor will tell you the expected type.</p>



<a name="197540373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197540373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197540373">(May 14 2020 at 11:39)</a>:</h4>
<p>That is super useful, thank you both! </p>
<p>I especially like the definitions by pattern matching. Makes me feel more at home :)</p>



<a name="197540510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197540510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197540510">(May 14 2020 at 11:41)</a>:</h4>
<p>That's great (-;</p>



<a name="197540514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197540514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197540514">(May 14 2020 at 11:41)</a>:</h4>
<p>We like it when people feel at home</p>



<a name="197540654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197540654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197540654">(May 14 2020 at 11:43)</a>:</h4>
<p>And a slightly less verbose <code>assoc_concat</code>, keeping the same idea as your proof:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">assoc_concat&#39;</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span>
  <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">concat</span> <span class="n">x</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:=</span>
  <span class="k">show</span> <span class="n">cons</span> <span class="bp">_</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">=</span> <span class="n">cons</span> <span class="bp">_</span> <span class="o">(</span><span class="n">concat</span> <span class="bp">_</span> <span class="o">(</span><span class="n">concat</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)),</span>
  <span class="k">by</span> <span class="n">rw</span> <span class="n">assoc_concat&#39;</span>
</code></pre></div>



<a name="197540856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197540856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197540856">(May 14 2020 at 11:45)</a>:</h4>
<p>So in HoTT, I would write something like "the action on paths of the function <code>(cons a)</code> to <code>assoc_concat x y z</code>". But in Lean you never apply a function to an equality, do you?</p>



<a name="197542821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197542821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197542821">(May 14 2020 at 12:06)</a>:</h4>
<p>There's <code>congr_arg</code></p>



<a name="197542913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197542913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197542913">(May 14 2020 at 12:06)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#congr_arg">https://leanprover-community.github.io/mathlib_docs/core/init/logic.html#congr_arg</a></p>



<a name="197542959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197542959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197542959">(May 14 2020 at 12:06)</a>:</h4>
<p>Indeed you should be able to use it in place of <code>rw</code>.</p>



<a name="197543854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197543854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197543854">(May 14 2020 at 12:15)</a>:</h4>
<p>You can, but you need to give a little bit to help the HO unification.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">assoc_concat&#39;</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span>
  <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">concat</span> <span class="n">x</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">cons</span> <span class="bp">_</span><span class="o">)</span> <span class="err">$</span> <span class="n">assoc_concat&#39;</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>
</code></pre></div>



<a name="197545153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197545153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197545153">(May 14 2020 at 12:30)</a>:</h4>
<p>Another point that I didn't see mentioned yet: we typically try to write universe-polymorphic declarations and avoid unnecessary restriction to <code>Type</code> (<code>Type</code> is short for <code>Type 0</code>).</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="n">universes</span> <span class="n">u</span>

<span class="c">/-</span><span class="cm">- Linked list with elements of type `A`.  -/</span>
<span class="kn">inductive</span> <span class="n">list</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">list</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="bp">→</span> <span class="n">list</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="c">/-</span><span class="cm">- List containing just the single element `a`. -/</span>
<span class="n">def</span> <span class="n">unit</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">cons</span> <span class="n">a</span> <span class="n">nil</span>

<span class="c1">-- ...</span>

<span class="kn">end</span> <span class="n">list</span>

<span class="kn">end</span> <span class="n">hidden</span>
</code></pre></div>



<a name="197547880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197547880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197547880">(May 14 2020 at 12:55)</a>:</h4>
<p>What is precisely the advantage of a <code>$</code> over parentheses?</p>



<a name="197547915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197547915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moses Schönfinkel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197547915">(May 14 2020 at 12:55)</a>:</h4>
<p>Clarity.</p>



<a name="197548291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197548291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197548291">(May 14 2020 at 12:58)</a>:</h4>
<p>It saves a character; sometimes it's easier to see "everything that follows is the last argument" than to count/match parens. It's mostly personal preference.</p>



<a name="197548633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197548633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197548633">(May 14 2020 at 13:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110596">Rob Lewis</span> <a href="#narrow/stream/113488-general/topic/code.20audition/near/197540654">said</a>:</p>
<blockquote>
<p>And a slightly less verbose <code>assoc_concat</code>, keeping the same idea as your proof:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">assoc_concat&#39;</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span>
  <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">concat</span> <span class="n">x</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:=</span>
  <span class="k">show</span> <span class="n">cons</span> <span class="bp">_</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">=</span> <span class="n">cons</span> <span class="bp">_</span> <span class="o">(</span><span class="n">concat</span> <span class="bp">_</span> <span class="o">(</span><span class="n">concat</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)),</span>
  <span class="k">by</span> <span class="n">rw</span> <span class="n">assoc_concat&#39;</span>
</code></pre></div>


</blockquote>
<p>Another question :) Why does this work, but the following doesn't. </p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">assoc_concat&#39;</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span>
  <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">concat</span> <span class="n">x</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">assoc_concat&#39;</span>
</code></pre></div>



<a name="197552842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197552842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197552842">(May 14 2020 at 13:24)</a>:</h4>
<p>The <code>rw</code> tactic doesn't really do definitional unfolding. It will look for a subterm that syntactically matches the LHS of <code>assoc_concat</code>.</p>



<a name="197552929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197552929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197552929">(May 14 2020 at 13:24)</a>:</h4>
<p>If you use <code>show</code>, you tell Lean to convert the goal to something definitionally equal, where the LHS of <code>assoc_concat</code> does appear syntactically. So then you can rewrite.</p>



<a name="197555315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197555315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197555315">(May 14 2020 at 13:41)</a>:</h4>
<p>Another newbie question. What do I have to do in a <code>calc</code> if my equation holds, but it goes the other way (i.e. I need the inverse of the equality)?</p>



<a name="197555957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197555957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197555957">(May 14 2020 at 13:44)</a>:</h4>
<p>Do you mean that you have a goal <code>a=b</code> and a proof of <code>b=a</code> and you want to stitch them together?</p>



<a name="197556002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197556002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197556002">(May 14 2020 at 13:45)</a>:</h4>
<p>in tactic mode, <code>symmetry</code> will change the goal and <code>symmetry at h</code> will change the hypothesis</p>



<a name="197556212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197556212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197556212">(May 14 2020 at 13:46)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
<span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
<span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:</span> <span class="k">by</span> <span class="o">{</span><span class="n">symmetry</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h1</span><span class="o">,}</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:</span> <span class="n">h2</span>
</code></pre></div>



<a name="197556282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197556282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197556282">(May 14 2020 at 13:47)</a>:</h4>
<p>Yeah, that's what I wanted. I have a proof <code>p:b=a</code> and I need <code>a=b</code> somewhere in my calculation. Actually... lean just accepts <code>by rw p</code>. It is quite amazing!</p>



<a name="197556343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197556343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197556343">(May 14 2020 at 13:47)</a>:</h4>
<p>Oh, that's good to know too, that you can say <code>by {stuff, more stuff}</code> in a <code>calc</code> part of the proof. Thanks!</p>



<a name="197556448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197556448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197556448">(May 14 2020 at 13:48)</a>:</h4>
<p>or just <code>: h1.symm</code></p>



<a name="197556481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197556481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197556481">(May 14 2020 at 13:48)</a>:</h4>
<p>in my head I pretend that <code>rw</code> applies a depth-limited version of <code>refl</code> afterward. I don't know how far from literally true that is</p>



<a name="197583161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197583161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197583161">(May 14 2020 at 16:42)</a>:</h4>
<p>Thanks to everyone here it wasn't much effort to prove a few basic things about lists <span aria-label="thank you" class="emoji emoji-1f64f" role="img" title="thank you">:thank_you:</span> </p>
<p>Now the next thing to worry about... will it compile with lean 3.12.0 <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm"> This is a short tutorial on lean for the Logic in Computer Science course at the university</span>
<span class="cm">of Ljubljana. -/</span>

<span class="kn">namespace</span> <span class="n">logika_v_racunalnistvu</span>

<span class="c">/-</span><span class="cm"> We typically want to be universe polymorphic in lean, so we introduce a universe variable u. -/</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="c">/-</span><span class="cm"> Definitions of inductive types are made using the inductive keyword. Different constructors</span>
<span class="cm">   are separated by |. -/</span>

<span class="kn">inductive</span> <span class="n">list</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">list</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="bp">→</span> <span class="n">list</span>

<span class="c">/-</span><span class="cm"> We open the namespace list, so that we can use nil and cons directly. -/</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="c">/-</span><span class="cm"> We will now define some basic operations on lists. -/</span>

<span class="c">/-</span><span class="cm"> Direct definitions are made using the definition keyword, followed by := -/</span>

<span class="kn">definition</span> <span class="n">unit</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">cons</span> <span class="n">a</span> <span class="n">nil</span>

<span class="c">/-</span><span class="cm"> A shorthand for definition is def, which may also be used. -/</span>

<span class="c">/-</span><span class="cm"> Since the type of lists is an inductive type, we can make inductive definitions on list</span>
<span class="cm">using pattern matching. The syntax is analogous to the syntax of the inductive type itself.</span>
<span class="cm">Note that in pattern matching definitions, we don&#39;t use := at the end of the specification. -/</span>

<span class="n">def</span> <span class="n">fold</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">b</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">μ</span> <span class="n">a</span> <span class="o">(</span><span class="n">fold</span> <span class="n">l</span><span class="o">)</span>

<span class="n">def</span> <span class="n">functor_list</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">B</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cons</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">length</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">fold</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sum_list_ℕ</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">fold</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span>

<span class="n">def</span> <span class="n">concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">fold</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">f</span> <span class="n">l</span><span class="o">,</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">f</span> <span class="n">l</span><span class="o">))</span>

<span class="n">def</span> <span class="n">flatten</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">A</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span> <span class="o">:=</span>
<span class="n">fold</span> <span class="n">nil</span> <span class="n">concat</span>

<span class="n">def</span> <span class="n">reverse</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> We have now finished defining our basic operations on lists. Let us check by some examples</span>
<span class="cm">   that the operations indeed do what they are supposed to do. With your mouse, hover over the</span>
<span class="cm">   #reduce keyword to see what each term reduces to. -/</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">1</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">2</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">3</span> <span class="n">nil</span><span class="o">)))</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">4</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">5</span> <span class="n">nil</span><span class="o">))</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">sum_list_ℕ</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">1</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">2</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">3</span> <span class="n">nil</span><span class="o">)))</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">4</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">5</span> <span class="n">nil</span><span class="o">)))</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">1</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">2</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">3</span> <span class="n">nil</span><span class="o">)))</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">4</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">5</span> <span class="n">nil</span><span class="o">)))</span>

<span class="c">/-</span><span class="cm"> Of course, if you really want to know that your operations behave as expected, you should</span>
<span class="cm">   prove the relevant properties about them. This is what we will do next. -/</span>

<span class="kn">theorem</span> <span class="n">identity_law_functor_list</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="n">functor_list</span> <span class="n">id</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">functor_list</span> <span class="n">id</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span>
        <span class="bp">=</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">id</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">identity_law_functor_list</span>

<span class="kn">theorem</span> <span class="n">composition_law_functor_list</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="n">functor_list</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">functor_list</span> <span class="n">g</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">functor_list</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span>
        <span class="bp">=</span> <span class="n">cons</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">functor_list</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">cons</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">g</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">composition_law_functor_list</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">functor_list</span> <span class="n">g</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">f</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"> We begin with the properties concatenation. Concatenation of lists is an associative</span>
<span class="cm">   operation, and it satisfies the left and right unit laws.universe</span>

<span class="cm">   In order to prove associativity, we note that since concatenation is defined by induction</span>
<span class="cm">   on the left argument, we will again use induction on the left argument to prove this</span>
<span class="cm">   propoerty. The proof is presented by pattern matching.</span>

<span class="cm">   In the proof we will use the built-in equation compiler. We just calculate as if we were</span>
<span class="cm">   working on a sheet of paper, and each time we mention the reason why the equality holds. -/</span>

<span class="kn">theorem</span> <span class="n">assoc_concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">concat</span> <span class="n">x</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span>
        <span class="bp">=</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">l</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">reflexivity</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">concat</span> <span class="n">l</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">assoc_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">concat</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">reflexivity</span>

<span class="kn">theorem</span> <span class="n">left_unit_law_concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="n">concat</span> <span class="n">nil</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
    <span class="n">eq</span><span class="bp">.</span><span class="n">refl</span>

<span class="kn">theorem</span> <span class="n">right_unit_law_concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="n">concat</span> <span class="n">x</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">show</span> <span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">nil</span><span class="o">)</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">rw</span> <span class="n">right_unit_law_concat</span>

<span class="c">/-</span><span class="cm"> Next, we prove the elementary properties of the length function. -/</span>

<span class="kn">theorem</span> <span class="n">length_nil</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="n">length</span> <span class="o">(</span><span class="bp">@</span><span class="n">nil</span> <span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">length_unit</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">length</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
    <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">length_concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="n">length</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">length</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">length</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="n">y</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">length</span> <span class="o">(</span><span class="n">concat</span> <span class="n">nil</span> <span class="n">y</span><span class="o">)</span>
        <span class="bp">=</span> <span class="n">length</span> <span class="n">y</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">length</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">zero_add</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">length</span> <span class="n">nil</span> <span class="bp">+</span> <span class="n">length</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">length_nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">length</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span>
        <span class="bp">=</span> <span class="n">length</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">length</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">length</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">length_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">length</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">length</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_add</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">length</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span> <span class="bp">+</span> <span class="n">length</span> <span class="n">y</span> <span class="o">:</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"> Next, we prove the elemenatary properties of the flatten function. -/</span>

<span class="kn">theorem</span> <span class="n">flatten_unit</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">unit</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
    <span class="n">right_unit_law_concat</span>

<span class="kn">theorem</span> <span class="n">length_flatten</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">A</span><span class="o">)),</span> <span class="n">length</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">sum_list_ℕ</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">length</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">length</span> <span class="o">(</span><span class="n">flatten</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span>
        <span class="bp">=</span> <span class="n">length</span> <span class="o">(</span><span class="n">concat</span> <span class="n">a</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">length</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">length</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">length_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">length</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">sum_list_ℕ</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">length</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">length_flatten</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">sum_list_ℕ</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">length</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">flatten_concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">A</span><span class="o">)),</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">flatten</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span>
        <span class="bp">=</span> <span class="n">concat</span> <span class="n">a</span> <span class="o">(</span><span class="n">flatten</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="n">a</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">y</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">flatten_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="n">a</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">assoc_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">flatten</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">flatten_flatten</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">A</span><span class="o">))),</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">flatten</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">flatten</span> <span class="o">(</span><span class="n">flatten</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span>
        <span class="bp">=</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">concat</span> <span class="n">a</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">flatten</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">flatten_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">flatten</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">flatten</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">flatten_flatten</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"> Next, we prove the elementary properties of list reversal. -/</span>

<span class="kn">theorem</span> <span class="n">unit_reverse</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">reverse</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">unit</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">length_reverse</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="n">length</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">length</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">length</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span>
        <span class="bp">=</span> <span class="n">length</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">length</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">length</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">length_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">length</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">length_unit</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">length</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">length_reverse</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">length</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">reverse_concat</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="n">y</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">reverse</span> <span class="o">(</span><span class="n">concat</span> <span class="n">nil</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">reverse</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">reflexivity</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">y</span><span class="o">)</span> <span class="n">nil</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">right_unit_law_concat</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">reverse</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span>
        <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">concat</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">reverse_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">assoc_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">reverse_flatten</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">A</span><span class="o">)),</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">reverse</span> <span class="n">x</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">reverse</span> <span class="o">(</span><span class="n">flatten</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span>
        <span class="bp">=</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">concat</span> <span class="n">a</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">flatten</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">reverse_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">flatten</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">reverse</span> <span class="n">x</span><span class="o">)))</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">reverse_flatten</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">flatten</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">reverse</span> <span class="n">x</span><span class="o">)))</span> <span class="o">(</span><span class="n">flatten</span> <span class="o">(</span><span class="n">unit</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">a</span><span class="o">)))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">flatten_unit</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">reverse</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">unit</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">a</span><span class="o">)))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">flatten_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">cons</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">reverse</span> <span class="n">x</span><span class="o">)))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">flatten</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">functor_list</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)))</span> <span class="o">:</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">reverse_reverse</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">),</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">calc</span>
    <span class="n">reverse</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span>
        <span class="bp">=</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">reverse_concat</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">reverse</span> <span class="o">(</span><span class="n">reverse</span> <span class="n">x</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">unit_reverse</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">concat</span> <span class="o">(</span><span class="n">unit</span> <span class="n">a</span><span class="o">)</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">reverse_reverse</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">x</span> <span class="o">:</span> <span class="n">rfl</span>

<span class="kn">end</span> <span class="n">list</span>

<span class="kn">end</span> <span class="n">logika_v_racunalnistvu</span>
</code></pre></div>



<a name="197584095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584095">(May 14 2020 at 16:48)</a>:</h4>
<p>Nice! Note that lean has all the nice functional programming trigraphs for functors and monads... I don't know if you like those (-;</p>



<a name="197584117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584117">(May 14 2020 at 16:48)</a>:</h4>
<p>You'll need the <code>functor</code> and <code>monad</code> type classes.</p>



<a name="197584142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584142">(May 14 2020 at 16:48)</a>:</h4>
<p>(But I don't know if you want to mention and/or use type classes in this tutorial.)</p>



<a name="197584155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584155">(May 14 2020 at 16:49)</a>:</h4>
<p>Looks nice! You might also want to mention explicitly that in recursive definitions, arguments to the left of the colon are fixed and not written at the recursive calls.</p>



<a name="197584162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584162">(May 14 2020 at 16:49)</a>:</h4>
<p>Cool, I don't know what trigraphs are, but I know what a monad is :)</p>



<a name="197584323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584323">(May 14 2020 at 16:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> That's a good thing to mention to the students. Thanks!</p>



<a name="197584473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584473">(May 14 2020 at 16:51)</a>:</h4>
<p><span class="user-mention" data-user-id="253568">@Egbert Rijke</span> Things like <code>&lt;$&gt;</code> and <code>&gt;&gt;=</code></p>



<a name="197584514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584514">(May 14 2020 at 16:52)</a>:</h4>
<p>Aren't those standard? I dunno...</p>



<a name="197584596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584596">(May 14 2020 at 16:52)</a>:</h4>
<p>they're the same as the haskell ones</p>



<a name="197584614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584614">(May 14 2020 at 16:52)</a>:</h4>
<p>Maybe, but I don't know these either. I'm not a programmer :)</p>



<a name="197584626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584626" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584626">(May 14 2020 at 16:52)</a>:</h4>
<p>More importantly it has <code>do</code> notation... ah.</p>



<a name="197584784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197584784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197584784">(May 14 2020 at 16:53)</a>:</h4>
<p>But are you saying that lean can automatically handle the functoriality of the list operator?</p>



<a name="197585553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197585553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197585553">(May 14 2020 at 16:59)</a>:</h4>
<p>No, but it gives you nice notation</p>



<a name="197585565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197585565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197585565">(May 14 2020 at 16:59)</a>:</h4>
<p>Doesn't Agda have that?</p>



<a name="197585724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197585724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Egbert Rijke <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197585724">(May 14 2020 at 17:00)</a>:</h4>
<p>Not that I know of</p>



<a name="197585747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197585747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197585747">(May 14 2020 at 17:00)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)#Definition">https://en.wikipedia.org/wiki/Monad_(functional_programming)#Definition</a></p>



<a name="197585758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197585758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197585758">(May 14 2020 at 17:00)</a>:</h4>
<p>Also uses that notation</p>



<a name="197609107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/code%20audition/near/197609107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/code.20audition.html#197609107">(May 14 2020 at 19:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="253568">Egbert Rijke</span> <a href="#narrow/stream/113488-general/topic/code.20audition/near/197556282">said</a>:</p>
<blockquote>
<p>Yeah, that's what I wanted. I have a proof <code>p:b=a</code> and I need <code>a=b</code> somewhere in my calculation. Actually... lean just accepts <code>by rw p</code>. It is quite amazing!</p>
</blockquote>
<p>In the middle of a <code>calc</code> block you see things like <code>... = b : sorry</code> and at the <code>sorry</code> the goal is <code>a = b</code>. If you have <code>p : b = a</code> then replacing the <code>sorry</code> with <code>by rw p</code> will work because the goal <code>a = b</code> will be rewritten to <code>a = a</code> which will then be closed with <code>refl</code> because <code>rw</code> tries <code>refl</code> after every invocation. But you can't just replace <code>sorry</code> with <code>p</code>, although you could replace it with <code>eq.symm p</code>; moreover, because the type of <code>p</code> is <code>eq a b</code>, you could also replace it with <code>p.symm</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html">"Proofs by reflectivity" in Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="281798899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281798899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281798899">(May 10 2022 at 09:28)</a>:</h4>
<p>When reading about something proved in Coq, I've seen often the term "proofs by reflectivity". I don't <em>really</em> understand what they are, and I was wondering what the Lean analogue was?</p>



<a name="281800367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281800367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281800367">(May 10 2022 at 09:44)</a>:</h4>
<p>It sounds like a confusion between "proof by reflexivity" and "proof by reflection", although often proofs by reflection arrange for the core hard step to be an application of <code>rfl</code> so in that sense it's also a "proof by reflexivity"</p>



<a name="281800452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281800452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281800452">(May 10 2022 at 09:45)</a>:</h4>
<p>The basic idea is to write whatever you want to check as a <code>bool</code> function and prove that it is equal to <code>tt</code> by <code>rfl</code>, which forces the kernel to unfold the definition and progress the computation to completion in order to show that it is (or isn't) definitionally equal to <code>tt</code></p>



<a name="281800454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281800454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281800454">(May 10 2022 at 09:45)</a>:</h4>
<p>Sorry, I mean proofs by reflection I think.</p>



<a name="281800571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281800571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281800571">(May 10 2022 at 09:46)</a>:</h4>
<p>Oh, I see, that's interesting. And hence produce a proof of the underlying <code>Prop</code>?</p>



<a name="281800749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281800749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281800749">(May 10 2022 at 09:48)</a>:</h4>
<p>I don't think I've seen that kind of thing in Lean directly, though maybe just not in the stuff I look at.</p>



<a name="281801324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281801324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281801324">(May 10 2022 at 09:54)</a>:</h4>
<p>Coq's kernel is much better at computation than Lean( 3)'s, so for Lean it's much more practical to compute a proof in the elaborator.</p>



<a name="281801345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281801345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281801345">(May 10 2022 at 09:55)</a>:</h4>
<p>However, in Mathlib we do have an experimental <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#ring2">tactic#ring2</a> which works by reflection.</p>



<a name="281801378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281801378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281801378">(May 10 2022 at 09:55)</a>:</h4>
<p>Here's a simple example of the technique:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_nonempty</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">def</span> <span class="n">all</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">&amp;&amp;</span> <span class="n">all</span> <span class="n">l</span>

<span class="kd">theorem</span> <span class="n">all_of_all</span> <span class="o">{</span><span class="n">α</span> <span class="n">p</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">@</span><span class="n">all</span> <span class="n">α</span> <span class="n">p</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="n">h</span> <span class="n">x</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">all</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span> <span class="n">h</span> <span class="n">x</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">h'</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">all</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">all_of_all</span> <span class="n">h.2</span> <span class="n">_</span> <span class="n">h'</span>

<span class="kd">theorem</span> <span class="n">nonempty_of_nonempty</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">@</span><span class="n">is_nonempty</span> <span class="n">α</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">tt</span><span class="o">),</span> <span class="n">l</span> <span class="bp">≠</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">h</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">h</span>

<span class="kd">theorem</span> <span class="n">all_nonempty'</span> <span class="o">:</span> <span class="n">all</span> <span class="n">is_nonempty</span> <span class="o">[[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]]</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">theorem</span> <span class="n">all_nonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">[[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]],</span> <span class="n">x</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">nonempty_of_nonempty</span> <span class="o">(</span><span class="n">all_of_all</span> <span class="n">all_nonempty'</span> <span class="n">x</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>



<a name="281801502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281801502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281801502">(May 10 2022 at 09:56)</a>:</h4>
<p>In mathlib we use a slightly different variation on the technique, where we associate to propositions a proof that the proposition is equivalent to a boolean, and then we can force that boolean to true using <code>dec_trivial</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">all_nonempty</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">[[</span><span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]],</span> <span class="n">x</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="281801720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281801720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281801720">(May 10 2022 at 09:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean/near/281801324">said</a>:</p>
<blockquote>
<p>Coq's kernel is much better at computation than Lean( 3)'s, so for Lean it's much more practical to compute a proof in the elaborator.</p>
</blockquote>
<p>By the way this is still true of lean 4, the kernel evaluator is still not very optimized. There are talks of a more efficient reduction engine (a Krivine machine) but this has not been done and probably isn't a near term goal</p>



<a name="281804564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281804564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281804564">(May 10 2022 at 10:28)</a>:</h4>
<p>Thanks Mario - great examples.</p>
<p>The fact that Coq's kernel does computation better is I guess why most (all?) cryptography stuff I look at is done in it. Which is a shame because I wish I could have the features and ease-of-use of mathlib with computation too...</p>



<a name="281804718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281804718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281804718">(May 10 2022 at 10:30)</a>:</h4>
<p>I don't know how hard "code generation" stuff like Fiat Crypto would be to do in Lean, if it's even possible.</p>



<a name="281805501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281805501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281805501">(May 10 2022 at 10:39)</a>:</h4>
<p>There are several things to tease apart here. Heavy computation <em>in the kernel</em> is not good, but on the other hand regular type checking is fine and that's what is used in tactics like <code>norm_num</code>. Also <code>#eval</code> has gotten a lot faster, and in lean 4 you can compile things natively, so "code generation" is certainly possible</p>



<a name="281805543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281805543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281805543">(May 10 2022 at 10:39)</a>:</h4>
<p>I think it would be a mistake to draw the conclusion that "lean is not good at computation" from this</p>



<a name="281805662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281805662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281805662">(May 10 2022 at 10:41)</a>:</h4>
<p>If I had my way kernels wouldn't ever do any computation at all, it is a misuse of the system IMO</p>



<a name="281805895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281805895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281805895">(May 10 2022 at 10:43)</a>:</h4>
<p>(More specifically, kernels should not do anything that is worse than linear time complexity in one step. The complexity of one step in DTT can have an astronomical complexity beyond anything I have words to describe)</p>



<a name="281806065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806065">(May 10 2022 at 10:44)</a>:</h4>
<p>Aha - thanks.</p>



<a name="281806084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806084">(May 10 2022 at 10:45)</a>:</h4>
<p>Sorry - lots of concepts here and not all of which I'm familiar with :)</p>



<a name="281806127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806127">(May 10 2022 at 10:45)</a>:</h4>
<p>What does Lean 4 compile to?</p>



<a name="281806217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806217">(May 10 2022 at 10:46)</a>:</h4>
<p>You could say it compiles to C, but I think it is more accurate to just think of it as compiling straight to machine code like other compiled languages</p>



<a name="281806407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806407">(May 10 2022 at 10:48)</a>:</h4>
<p>this is a bit different from "code generation" a la Coq where we have a reasonably clean source-to-source translation into some other functional programming language</p>



<a name="281806425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806425">(May 10 2022 at 10:49)</a>:</h4>
<p>the generated C code is not particularly easy to follow</p>



<a name="281806441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806441">(May 10 2022 at 10:49)</a>:</h4>
<p>Fiat Crypto is Coq that generates verified C, which is wacky. Especially because you then have to, uh, compile it, and who knows what that compiler does.</p>



<a name="281806530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806530">(May 10 2022 at 10:50)</a>:</h4>
<p>A big concern is cryptography code of course is avoiding branching/keeping code constant time when it depends on secrets. Is that something that's enforceable in Lean4 compilation?</p>



<a name="281806559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806559">(May 10 2022 at 10:50)</a>:</h4>
<p>yeah I'm not a fan of that kind of architecture, but compiling to verified x86 / other ISA means that you probably lose out on decades of optimization work</p>



<a name="281806614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806614">(May 10 2022 at 10:51)</a>:</h4>
<p>Lean4 uses an off the shelf compiler after generating C code so you can levy those same complaints at it</p>



<a name="281806657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806657">(May 10 2022 at 10:52)</a>:</h4>
<p>no, lean4 has no concept of runtime complexity in the language, much less constant time compilation</p>



<a name="281806721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806721">(May 10 2022 at 10:52)</a>:</h4>
<p>you could write your own compiler for a custom DSL though</p>



<a name="281806735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806735">(May 10 2022 at 10:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean/near/281806614">said</a>:</p>
<blockquote>
<p>Lean4 uses an off the shelf compiler after generating C code so you can levy those same complaints at it</p>
</blockquote>
<p>Sure, but that at least is known. The concern with FC stuff is that someone takes the C it generates and misuses it.</p>



<a name="281806757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806757">(May 10 2022 at 10:53)</a>:</h4>
<p>misuses in what way?</p>



<a name="281806785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806785">(May 10 2022 at 10:53)</a>:</h4>
<p>who knows. people find so many ways to write cryptography badly.</p>



<a name="281806813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806813">(May 10 2022 at 10:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean/near/281806657">said</a>:</p>
<blockquote>
<p>no, lean4 has no concept of runtime complexity in the language, much less constant time compilation</p>
</blockquote>
<p>Well, avoiding branching at least I guess is what I meant.</p>



<a name="281806869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806869">(May 10 2022 at 10:54)</a>:</h4>
<p>well that's one of the hard parts in crypto, you have to anticipate everything that can go wrong and this is hard</p>



<a name="281806930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806930">(May 10 2022 at 10:54)</a>:</h4>
<p>Right - I guess I'm talking about the related-but-different thing of "if you provide a thing, people will use it - how much should you worry about people using it wrongly". This goes double if you claims something is "verified".</p>



<a name="281806941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281806941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281806941">(May 10 2022 at 10:55)</a>:</h4>
<p>I don't think it is possible to promise no branching from a C compiler, it is free to compile anything satisfying the as-if rule wrt the C semantics</p>



<a name="281807068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281807068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281807068">(May 10 2022 at 10:56)</a>:</h4>
<p>the only feasible way I see to avoid branching is to generate the assembly directly and restrict your grammar to things you know compile a certain way</p>



<a name="281807148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281807148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281807148">(May 10 2022 at 10:57)</a>:</h4>
<p>I think this is what the Project Everest/Vale/EverCrypt people might do.</p>



<a name="281807271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%22Proofs%20by%20reflectivity%22%20in%20Lean/near/281807271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.22Proofs.20by.20reflectivity.22.20in.20Lean.html#281807271">(May 10 2022 at 10:58)</a>:</h4>
<p>At some point I might have to learn F* but - crucially - I don't want to ;) (it's fine, it's just not as pleasing to me as, say, Lean code generally is)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
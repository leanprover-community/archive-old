---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Typeclasses.20for.20morphisms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html">Typeclasses for morphisms</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="213184033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213184033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213184033">(Oct 13 2020 at 16:45)</a>:</h4>
<p>I've been finding bundled morphisms very irritating to write lemmas about. Consider:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- the actual lemma</span>
<span class="kd">lemma</span> <span class="n">zero_hom.map_single_apply</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">zero_hom</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">finsupp.single</span> <span class="n">j</span> <span class="n">v</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finsupp.single</span> <span class="n">j</span> <span class="o">(</span><span class="n">f</span> <span class="n">v</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp.single_apply</span><span class="o">,</span> <span class="n">finsupp.single_apply</span><span class="o">,</span> <span class="n">apply_ite</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.map_zero</span><span class="o">]</span>

<span class="c1">-- the tedious copy paste operation</span>
<span class="kd">lemma</span> <span class="n">add_monoid_hom.map_single_apply</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→+</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">finsupp.single</span> <span class="n">j</span> <span class="n">v</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finsupp.single</span> <span class="n">j</span> <span class="o">(</span><span class="n">f</span> <span class="n">v</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">f.to_zero_hom.map_single_apply</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
<span class="kd">lemma</span> <span class="n">ring_hom.map_single_apply</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→+*</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">finsupp.single</span> <span class="n">j</span> <span class="n">v</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finsupp.single</span> <span class="n">j</span> <span class="o">(</span><span class="n">f</span> <span class="n">v</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">f.to_add_monoid_hom.map_single_apply</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
<span class="kd">lemma</span> <span class="n">alg_hom.map_single_apply</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">γ</span><span class="o">]</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">finsupp.single</span> <span class="n">j</span> <span class="n">v</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="n">finsupp.single</span> <span class="n">j</span> <span class="o">(</span><span class="n">f</span> <span class="n">v</span><span class="o">)</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">f.to_ring_hom.map_single_apply</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
</code></pre></div>

<p>While I only have to write an interesting proof once, I'm then forced to manually copy across  the lemma to every single derived <code>hom</code> structure if I want it to be useful - something that wouldn't be necessary if type class inference were involved.</p>



<a name="213195920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213195920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213195920">(Oct 13 2020 at 18:18)</a>:</h4>
<p>Earlier we migrated from the typeclass approach because Lean can't effectively use <code>is_add_monoid_hom.map_add</code> as a <code>simp</code> lemma.</p>



<a name="213196081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213196081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213196081">(Oct 13 2020 at 18:19)</a>:</h4>
<p>Clearly, we need more automation here but I don't know how to implement it (read: my <code>meta</code> programming skills are not good enough for the job).</p>



<a name="213197044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213197044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213197044">(Oct 13 2020 at 18:27)</a>:</h4>
<p>I think there was a suggestion at one point that if <code>structure B extends A</code> and <code>f : B</code> and there is <code>A.foo</code> but no <code>B.foo</code> then <code>f.foo</code> means <code>f.to_A.foo</code>.</p>



<a name="213197068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213197068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213197068">(Oct 13 2020 at 18:27)</a>:</h4>
<p>I don't know if this is something planned for Lean 4 though.</p>



<a name="213197823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213197823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213197823">(Oct 13 2020 at 18:32)</a>:</h4>
<p>also, I guess there might be minor details which this doesn't address, e.g. the lemma <code>add_monoid_hom.map_single_apply</code> above is stated in terms of <code>add_monoid_hom</code>'s coercion to function but its definition would be stated in terms of <code>zero_hom</code>'s coercion to function</p>



<a name="213199168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213199168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213199168">(Oct 13 2020 at 18:42)</a>:</h4>
<p>We also need to automatically make <code>(f : ring_hom).to_monoid_hom.map_mul</code> it a <code>simp</code> lemma. I think, it should be easier to have a command "import the following lemmas using this projection".</p>



<a name="213199240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213199240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213199240">(Oct 13 2020 at 18:42)</a>:</h4>
<p>Or "import all lemmas about <code>f.to_monoid_hom</code> marked with an attribute"</p>



<a name="213199327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213199327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213199327">(Oct 13 2020 at 18:43)</a>:</h4>
<p>The command should be clever enough to replace <code>[monoid M]</code> with <code>[ring R]</code> and <code>[comm_monoid M]</code> with <code>[comm_ring R]</code>.</p>



<a name="213226690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213226690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213226690">(Oct 13 2020 at 22:45)</a>:</h4>
<p>Relatedly I'd like to be able to write <code>rw monoid_hom.map_mul</code> and have it match <code>ring_hom</code> too</p>



<a name="213227010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213227010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213227010">(Oct 13 2020 at 22:49)</a>:</h4>
<p>That's funny, I never rewrite stuff like that -- I always rewrite stuff like <code>f.map_mul</code> (so basically it's guaranteed to use the right one)</p>



<a name="213227143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213227143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213227143">(Oct 13 2020 at 22:51)</a>:</h4>
<p>I suppose my actual case was where I just wanted to do all of them in a <code>simp_rw</code></p>



<a name="213227210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213227210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213227210">(Oct 13 2020 at 22:52)</a>:</h4>
<p>I think it's also useful when you have some structure extending, say, a <code>monoid_hom</code>.</p>



<a name="213227238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213227238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213227238">(Oct 13 2020 at 22:52)</a>:</h4>
<p>It's annoying to write <code>f.to_monoid_hom.map_mul</code> or whatever</p>



<a name="213227315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213227315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213227315">(Oct 13 2020 at 22:53)</a>:</h4>
<p>Right, but that has the same solution as the original problem</p>



<a name="213228891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/213228891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#213228891">(Oct 13 2020 at 23:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/213227010">said</a>:</p>
<blockquote>
<p>That's funny, I never rewrite stuff like that -- I always rewrite stuff like <code>f.map_mul</code> (so basically it's guaranteed to use the right one)</p>
</blockquote>
<p>Trouble with this is sometimes <code>f</code> is really long</p>



<a name="214313541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/214313541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#214313541">(Oct 23 2020 at 13:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/213195920">said</a>:</p>
<blockquote>
<p>Earlier we migrated from the typeclass approach because Lean can't effectively use <code>is_add_monoid_hom.map_add</code> as a <code>simp</code> lemma.</p>
</blockquote>
<p>Can you elaborate a bit on why that's true? Why can lean use things like <code>inv_inv</code> as simp lemmas, which also depend on typeclass resolution?<br>
Is the issue <code>has_coe_to_fun</code>?</p>



<a name="214328851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/214328851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#214328851">(Oct 23 2020 at 15:36)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/is_add_monoid_hom.map_add">docs#is_add_monoid_hom.map_add</a> has no <code>coe_fn</code> in it. OTOH,  <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.map_add">docs#add_monoid_hom.map_add</a> has <code>@coe_fn (add_monoid_hom)</code>, and <code>simp</code> can match on it.</p>



<a name="214328894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/214328894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#214328894">(Oct 23 2020 at 15:37)</a>:</h4>
<p>Similarly, <code>simp</code> can match <code>has_inv.inv</code> in <code>inv_inv</code>,  then start searching for the instance.</p>



<a name="214329641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/214329641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#214329641">(Oct 23 2020 at 15:43)</a>:</h4>
<p>But simp can't match <code>[is_add_monoid_hom f]</code> in <code>is_add_monoid_hom.map_add</code>?</p>



<a name="214330369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/214330369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#214330369">(Oct 23 2020 at 15:50)</a>:</h4>
<p>It looks at <code>my_fun (a + b)</code>. It doesn't know that <code>my_fun</code> is a homomorphism at this moment.</p>



<a name="214330677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/214330677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#214330677">(Oct 23 2020 at 15:52)</a>:</h4>
<p>My thinking was that it would match against the lemma statement of <code>is_add_monoid_hom.map_add</code> as its statement matches <code>f (a + b)</code>, then find the predicate <code>[is_add_monoid_hom f]</code> as the second step. Is that not how simp matching works?</p>



<a name="214335362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/214335362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#214335362">(Oct 23 2020 at 16:32)</a>:</h4>
<p><code>simp</code> works well if it can match on the head symbol.</p>



<a name="215428568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215428568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215428568">(Nov 03 2020 at 09:24)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> encountered <a href="https://github.com/leanprover-community/mathlib/pull/4874#discussion_r516126899">an instance where the unbundled type classes make sense</a>. Consider:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">matrix.is_zero_hom_map_zero</span>
  <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">is_zero_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">matrix</span> <span class="n">n</span> <span class="n">n</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>
<p>Since the head symbol is <code>matrix.map</code>, this is a useful <code>simp</code> lemma, correct? The current <code>is_foo_hom</code> typeclasses do not have instances <code>(f : foo_hom) : is_foo_hom f</code>, unfortunately, so we cannot use the unbundled predicate yet. The alternative would be to copy the declaration for each <code>foo_hom</code>, which doesn't sound very scalable. </p>
<p>So here is my modest proposal for uniting the unbundled and bundled dichotomy:</p>
<ul>
<li>create an <code>is_foo_hom</code> typeclass for each <code>foo_hom</code> that doesn't have one yet</li>
<li>add <code>instance (f : foo_hom) : is_foo_hom f</code> and nothing more, except:</li>
<li>whenever <code>bar_hom</code> extends <code>foo_hom</code>, <code>is_bar_hom</code> should extend <code>is_foo_hom</code></li>
<li>instead of defining <code>@[simp] lemma foo_hom.map_qux (f : foo_hom) : coe_fn f qux = quux</code>, define <code>@[simp] lemma is_foo_hom.map_qux {foo_hom_like : Type*} (f : foo_hom_like) [is_foo_hom f] : coe_fn f qux = quux</code>.</li>
</ul>
<p>Thoughts?</p>



<a name="215428981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215428981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215428981">(Nov 03 2020 at 09:28)</a>:</h4>
<p>I don't understand your last bullet point - the lemma involves the derived structure <code>bar_hom</code>, which surely results in the same duplication we're trying to avoid?</p>



<a name="215429079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215429079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215429079">(Nov 03 2020 at 09:29)</a>:</h4>
<p>Ah, the trick is the <code>{bar_hom : Type*}</code> parameter: for any type whose inhabitants are <code>foo_hom</code>s, we have the lemma. I see how the name is confusing, let me rephrase it...</p>



<a name="215429171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215429171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215429171">(Nov 03 2020 at 09:30)</a>:</h4>
<p>"if bar_hom extends foo_hom" - is this solved by just having <code>is_bar_hom</code> extend <code>is_foo_hom</code>?</p>



<a name="215429255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215429255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215429255">(Nov 03 2020 at 09:31)</a>:</h4>
<p>You're right <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="215429438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215429438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215429438">(Nov 03 2020 at 09:33)</a>:</h4>
<p>So would the rule become "inputs should use typeclass homs, outputs bundled homs", or is it more subtle?</p>



<a name="215429655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215429655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215429655">(Nov 03 2020 at 09:35)</a>:</h4>
<p>That sounds like a good rule of thumb, maybe qualified with "an input <code>f</code> should be an unbundled hom if it does not appear as a head symbol"? Or just arrange things so that they don't appear in that position?</p>



<a name="215429747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215429747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215429747">(Nov 03 2020 at 09:36)</a>:</h4>
<p>Perhaps <code>lift</code>-like operations need to stay bundled to ensure coherence? I don't know.</p>



<a name="215430371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215430371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215430371">(Nov 03 2020 at 09:42)</a>:</h4>
<p>Wouldn't it be nicer to have some kind of tactic framework if we have bundled definitions that all satisfy the same kind of properties, to generate all the basic lemmas for the structure? For instance, there are many equiv-like structures. If we could tag them with <code>@equiv</code>, it could generate things like <code>apply_symm_apply</code> and the likes (currently, I see 9 instances of Lemma/Theorem <code>apply_symm_apply</code> in mathlib, for 9 different <code>equiv</code>-like structures). I have the impression that your problem belongs to the same kind of question: a framework to generate a basic skeleton that comes again and again.</p>



<a name="215430673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215430673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215430673">(Nov 03 2020 at 09:45)</a>:</h4>
<p>(I should say that I am not over-enthusiastic over the idea to rely again on non-bundled stuff, because for me the move to bundled stuff made things really better. But if you find a nice way to solve your problem using them, and if this could scale to equivs and the likes, maybe it just means that your way of using them is just more clever than what we did before!)</p>



<a name="215430773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215430773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215430773">(Nov 03 2020 at 09:46)</a>:</h4>
<p>"as a head symbol" means "not <code>coe_fun f arg</code>? Is <code>f</code> even the head symbol there anyway?</p>



<a name="215430834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215430834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215430834">(Nov 03 2020 at 09:47)</a>:</h4>
<p>If generating lemmas with tactics works well (and I don't have to write it), I'm also for it. Although it feels like we're working against Lean to get what we want, instead of using typeclasses for what they were intended.</p>



<a name="215430931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215430931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215430931">(Nov 03 2020 at 09:48)</a>:</h4>
<p>Does the whole head symbol problem go away if we're using <code>[is_hom f_type]</code> instead of <code>[is_hom f]</code>?</p>



<a name="215431382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215431382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215431382">(Nov 03 2020 at 09:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215430773">said</a>:</p>
<blockquote>
<p>"as a head symbol" means "not <code>coe_fun f arg</code>? Is <code>f</code> even the head symbol there anyway?</p>
</blockquote>
<p>In that case, <code>coe_fun</code> is the head symbol. The reason for the qualification is that many tactics categorize lemmas based on the head symbol. So when <code>simp</code> traverses the subexpressions, it can do a quick equality-of-symbols check to see if this subexpression is relevant, rather than doing a big unification with each possible <code>simp</code> lemma. Similarly for <code>library_search</code>, etc.</p>



<a name="215431448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215431448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215431448">(Nov 03 2020 at 09:53)</a>:</h4>
<p>So <code>[is_zero_hom f] : f 0 = 0</code> is problematic, but <code>[is_zero_hom (coe_fn f)] : coe_fn f 0 = 0</code> would work.</p>



<a name="215431591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215431591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215431591">(Nov 03 2020 at 09:54)</a>:</h4>
<p>I have a meeting in a couple of minutes, in 90 minutes or so I can try writing a concrete example to see if this idea holds any water.</p>



<a name="215431846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215431846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215431846">(Nov 03 2020 at 09:57)</a>:</h4>
<p>If f is not a function, then surely automatic coercion means it is never a head symbol, and the coercion is?</p>



<a name="215432066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215432066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215432066">(Nov 03 2020 at 09:59)</a>:</h4>
<p>Right, but <code>is_zero_hom</code> would take <code>f : α → β</code> as an argument (it needs to since you can't easily get the domain/codomain from a general <code>has_coe_to_fn</code> instance). But then you'd be tempted to "generalize" <code>is_zero_hom.map_zero</code> to adding <code>f : α → β</code> as an argument to your lemma instead of <code>f : is_foo_hom_like</code>.</p>



<a name="215440129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215440129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215440129">(Nov 03 2020 at 11:21)</a>:</h4>
<p>Bah, <code>has_coe_to_fun</code> as a typeclass argument doesn't work well at all:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">class</span> <span class="n">is_zero_hom</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_zero'</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">is_zero_hom.map_zero</span> <span class="o">{</span><span class="n">zero_hom_like</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_coe_to_fun</span> <span class="n">zero_hom_like</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">zero_hom_like</span><span class="o">)</span> <span class="o">[</span><span class="n">is_zero_hom</span> <span class="o">(</span><span class="n">coe_fn</span> <span class="n">f</span><span class="o">)]</span> <span class="o">:</span> <span class="c1">-- error: expected `? -&gt; ?`, got `has_coe_to_fun.F f`</span>
  <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">is_zero_hom.map_zero'</span>
</code></pre></div>



<a name="215440740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215440740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215440740">(Nov 03 2020 at 11:27)</a>:</h4>
<p>Can you make <code>is_zero_hom</code> extend <code>has_coe_to_fun</code> somehow?</p>



<a name="215440762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215440762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215440762">(Nov 03 2020 at 11:27)</a>:</h4>
<p>Or use <code>(f : M → N)</code> instead of <code>coe_fn f</code>?</p>



<a name="215440873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215440873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215440873">(Nov 03 2020 at 11:28)</a>:</h4>
<p>I'm trying something like the first option now:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">is_hom</span> <span class="o">(</span><span class="n">hom</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">hom</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">hom</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">is_hom.to_coe_fn</span> <span class="o">[</span><span class="n">is_hom</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="n">hom</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">is_hom.coe</span> <span class="o">}</span>

<span class="kd">class</span> <span class="n">is_zero_hom</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">is_hom</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="215440896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215440896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215440896">(Nov 03 2020 at 11:28)</a>:</h4>
<p>But I suspect that <code>M</code> and <code>N</code> should be <code>out_param</code>s for <code>is_zero_hom</code></p>



<a name="215441595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215441595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215441595">(Nov 03 2020 at 11:36)</a>:</h4>
<p>This seems to work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.hom</span>

<span class="c">/-</span><span class="cm"></span>

<span class="cm">/-- Homomorphism that preserves zero -/</span>
<span class="cm">structure zero_hom (M : Type*) (N : Type*) [has_zero M] [has_zero N] :=</span>
<span class="cm">(to_fun : M → N)</span>
<span class="cm">(map_zero' : to_fun 0 = 0)</span>

<span class="cm">/-- Homomorphism that preserves addition -/</span>
<span class="cm">structure add_hom (M : Type*) (N : Type*) [has_add M] [has_add N] :=</span>
<span class="cm">(to_fun : M → N)</span>
<span class="cm">(map_add' : ∀ x y, to_fun (x + y) = to_fun x + to_fun y)</span>

<span class="cm">/-- Bundled add_monoid homomorphisms; use this for bundled add_group homomorphisms too. -/</span>
<span class="cm">structure add_monoid_hom (M : Type*) (N : Type*) [add_monoid M] [add_monoid N]</span>
<span class="cm">extends zero_hom M N, add_hom M N</span>

<span class="cm">-/</span>

<span class="kd">class</span> <span class="n">is_hom_type</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">hom</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">hom</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">is_hom_type.to_coe_fn</span> <span class="o">[</span><span class="n">is_hom_type</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="n">hom</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">is_hom_type.coe</span> <span class="o">}</span>

<span class="kd">class</span> <span class="n">is_zero_hom</span> <span class="o">{</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">is_hom_type</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_zero</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">is_zero_hom.map_zero</span>

<span class="kd">instance</span> <span class="n">zero_hom.is_hom_type</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_hom_type</span> <span class="o">(</span><span class="n">zero_hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">zero_hom.is_zero_hom</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">zero_hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_zero_hom</span> <span class="n">f</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">f.map_zero'</span><span class="o">⟩</span>

<span class="kd">class</span> <span class="n">is_add_hom</span> <span class="o">{</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_add</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">is_hom_type</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">add_hom.is_hom</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_hom_type</span> <span class="o">(</span><span class="n">add_hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">add_hom.is_add_hom</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">add_hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_add_hom</span> <span class="n">f</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">f.map_add'</span><span class="o">⟩</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">is_add_hom.map_add</span>

<span class="kd">class</span> <span class="n">is_add_monoid_hom</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">is_hom_type</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span><span class="o">)</span>
<span class="kd">extends</span> <span class="n">is_zero_hom</span> <span class="n">f</span><span class="o">,</span> <span class="n">is_add_hom</span> <span class="n">f</span>

<span class="kd">instance</span> <span class="n">add_monoid_hom.is_hom</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_hom_type</span> <span class="o">(</span><span class="n">add_monoid_hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f</span><span class="o">⟩</span>

<span class="kd">instance</span> <span class="n">add_monoid_hom.is_add_monoid_hom</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→+</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_add_monoid_hom</span> <span class="n">f</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_zero</span> <span class="o">:=</span> <span class="n">f.map_zero'</span><span class="o">,</span>
  <span class="n">map_add</span> <span class="o">:=</span> <span class="n">f.map_add'</span> <span class="o">}</span>

<span class="kn">section</span> <span class="n">test</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="n">simp</span><span class="o">]</span> <span class="n">add_zero</span> <span class="n">add_hom.map_add</span> <span class="n">add_monoid_hom.map_add</span> <span class="n">add_monoid_hom.map_zero</span> <span class="n">zero_hom.map_zero</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→+</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→+</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g.comp</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">squeeze_simp</span>

<span class="kd">end</span> <span class="n">test</span>
</code></pre></div>



<a name="215442874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215442874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215442874">(Nov 03 2020 at 11:50)</a>:</h4>
<p>Having <code>is_zero_hom</code> extend <code>is_hom</code> didn't work?</p>



<a name="215442994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215442994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215442994">(Nov 03 2020 at 11:51)</a>:</h4>
<p>The names are a bit confusing, but <code>is_hom</code> is a predicate on the type <code>hom</code>, while <code>is_zero_hom</code> is a predicate on an element <code>f : hom</code>. So extending is not what we want. I will rename <code>is_hom -&gt; is_hom_type</code>.</p>



<a name="215443387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215443387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215443387">(Nov 03 2020 at 11:55)</a>:</h4>
<blockquote>
<p>while is_zero_hom is a predicate on an element f : hom.</p>
</blockquote>
<p>Why is this better than having it be a predicate on <code>hom</code> itself?</p>



<a name="215443524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215443524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215443524">(Nov 03 2020 at 11:56)</a>:</h4>
<p>That is,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">is_zero_hom</span> <span class="o">{</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="o">[</span><span class="n">has_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">is_hom_type</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span><span class="o">),</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="215443992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215443992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215443992">(Nov 03 2020 at 12:01)</a>:</h4>
<p>I get an error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">is_hom</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">hom</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">hom</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">is_hom.to_coe_fn</span> <span class="o">[</span><span class="n">is_hom</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="n">hom</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">is_hom.coe</span> <span class="o">}</span>

<span class="kd">class</span> <span class="n">is_zero_hom</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">is_hom</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span><span class="o">),</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">is_add_hom</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">has_add</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">N</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">is_hom</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">is_add_monoid_hom</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span>
<span class="kd">extends</span> <span class="n">is_zero_hom</span> <span class="n">hom</span><span class="o">,</span> <span class="n">is_add_hom</span> <span class="n">hom</span> <span class="c1">-- don't know how to synthesize placeholder `(out_param Type*)`</span>
</code></pre></div>



<a name="215444033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215444033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215444033">(Nov 03 2020 at 12:01)</a>:</h4>
<p>Let's try making <code>M</code> and <code>N</code> explicit then...</p>



<a name="215444243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215444243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215444243">(Nov 03 2020 at 12:04)</a>:</h4>
<p>Yup, that also works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.hom</span>

<span class="c">/-</span><span class="cm"></span>

<span class="cm">/-- Homomorphism that preserves zero -/</span>
<span class="cm">structure zero_hom (M : Type*) (N : Type*) [has_zero M] [has_zero N] :=</span>
<span class="cm">(to_fun : M → N)</span>
<span class="cm">(map_zero' : to_fun 0 = 0)</span>

<span class="cm">/-- Homomorphism that preserves addition -/</span>
<span class="cm">structure add_hom (M : Type*) (N : Type*) [has_add M] [has_add N] :=</span>
<span class="cm">(to_fun : M → N)</span>
<span class="cm">(map_add' : ∀ x y, to_fun (x + y) = to_fun x + to_fun y)</span>

<span class="cm">/-- Bundled add_monoid homomorphisms; use this for bundled add_group homomorphisms too. -/</span>
<span class="cm">structure add_monoid_hom (M : Type*) (N : Type*) [add_monoid M] [add_monoid N]</span>
<span class="cm">extends zero_hom M N, add_hom M N</span>

<span class="cm">-/</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kd">class</span> <span class="n">is_hom</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">hom</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">hom</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">instance</span> <span class="n">is_hom.to_coe_fn</span> <span class="o">[</span><span class="n">is_hom</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="n">hom</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">is_hom.coe</span> <span class="o">}</span>

<span class="kd">class</span> <span class="n">is_zero_hom</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">has_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">is_hom</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span><span class="o">),</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">is_zero_hom.map_zero</span>

<span class="kd">instance</span> <span class="n">zero_hom.is_zero_hom</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_zero_hom</span> <span class="o">(</span><span class="n">zero_hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.to_fun</span><span class="o">,</span>
  <span class="n">map_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.map_zero'</span> <span class="o">}</span>

<span class="kd">class</span> <span class="n">is_add_hom</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">has_add</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">N</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">is_hom</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">add_hom.is_add_hom</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_add_hom</span> <span class="o">(</span><span class="n">add_hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.to_fun</span><span class="o">,</span>
  <span class="n">map_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.map_add'</span> <span class="o">}</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">is_add_hom.map_add</span>

<span class="kd">class</span> <span class="n">is_add_monoid_hom</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span>
<span class="kd">extends</span> <span class="n">is_zero_hom</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">,</span> <span class="n">is_add_hom</span> <span class="n">hom</span> <span class="n">M</span> <span class="n">N</span>

<span class="kd">instance</span> <span class="n">add_monoid_hom.is_add_monoid_hom</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_add_monoid_hom</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→+</span> <span class="n">N</span><span class="o">)</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.to_fun</span><span class="o">,</span>
  <span class="n">map_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.map_zero'</span><span class="o">,</span>
  <span class="n">map_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.map_add'</span> <span class="o">}</span>

<span class="kn">section</span> <span class="n">test</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="n">simp</span><span class="o">]</span> <span class="n">add_zero</span> <span class="n">add_hom.map_add</span> <span class="n">add_monoid_hom.map_add</span> <span class="n">add_monoid_hom.map_zero</span> <span class="n">zero_hom.map_zero</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→+</span> <span class="n">N</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→+</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g.comp</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">squeeze_simp</span>

<span class="kd">end</span> <span class="n">test</span>
</code></pre></div>



<a name="215444331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215444331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215444331">(Nov 03 2020 at 12:04)</a>:</h4>
<p>Is <code>add_monoid_hom.is_hom </code> needed there?</p>



<a name="215444371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215444371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215444371">(Nov 03 2020 at 12:05)</a>:</h4>
<p>We can delete it, indeed.</p>



<a name="215444695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215444695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215444695">(Nov 03 2020 at 12:08)</a>:</h4>
<p>And I suppose</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">{</span><span class="n">hom1</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">hom2</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">is_add_monoid_hom</span> <span class="n">hom1</span> <span class="n">M</span> <span class="n">N</span><span class="o">]</span>
  <span class="o">[</span><span class="n">is_add_monoid_hom</span> <span class="n">hom2</span> <span class="n">N</span> <span class="n">M</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom1</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">hom2</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">squeeze_simp</span>
</code></pre></div>
<p>is how you'd write your example with the new typeclasses, so that it works "by magic" on ring_homs too</p>



<a name="215445187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215445187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215445187">(Nov 03 2020 at 12:13)</a>:</h4>
<p>Indeed, something like that. I wanted to make sure that <code>comp</code> worked well which is why I included it. Since that was an important motivation to bundle homs (if I understand the history correctly).</p>



<a name="215445297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215445297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215445297">(Nov 03 2020 at 12:14)</a>:</h4>
<p>Unfortunately that's rather hard to read snice the "type" of f and g is no longer inline</p>



<a name="215445347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215445347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215445347">(Nov 03 2020 at 12:15)</a>:</h4>
<p>Maybe <code>is_hom</code> should include <code>id</code>, <code>comp</code> and <code>ext</code>, to look more like <code>category_theory.bundled_hom</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">bundled_hom</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">β</span><span class="o">),</span> <span class="n">hom</span> <span class="n">Iα</span> <span class="n">Iβ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">id</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">),</span> <span class="n">hom</span> <span class="n">I</span> <span class="n">I</span><span class="o">)</span>
<span class="o">(</span><span class="n">comp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">Iγ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">γ</span><span class="o">),</span>
  <span class="n">hom</span> <span class="n">Iβ</span> <span class="n">Iγ</span> <span class="bp">→</span> <span class="n">hom</span> <span class="n">Iα</span> <span class="n">Iβ</span> <span class="bp">→</span> <span class="n">hom</span> <span class="n">Iα</span> <span class="n">Iγ</span><span class="o">)</span>
<span class="o">(</span><span class="n">hom_ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">β</span><span class="o">),</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">Iα</span> <span class="n">Iβ</span><span class="o">)</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">id_to_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">),</span> <span class="n">to_fun</span> <span class="n">I</span> <span class="n">I</span> <span class="o">(</span><span class="n">id</span> <span class="n">I</span><span class="o">)</span> <span class="bp">=</span> <span class="n">_root_.id</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">comp_to_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">Iγ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">Iα</span> <span class="n">Iβ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">Iβ</span> <span class="n">Iγ</span><span class="o">),</span>
  <span class="n">to_fun</span> <span class="n">Iα</span> <span class="n">Iγ</span> <span class="o">(</span><span class="n">comp</span> <span class="n">Iα</span> <span class="n">Iβ</span> <span class="n">Iγ</span> <span class="n">g</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">Iβ</span> <span class="n">Iγ</span> <span class="n">g</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">Iα</span> <span class="n">Iβ</span> <span class="n">f</span><span class="o">)</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</code></pre></div>



<a name="215445457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215445457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215445457">(Nov 03 2020 at 12:16)</a>:</h4>
<p>(Luckily we wouldn't have <code>c : Type u → Type u</code> forcing everything into the same universe!)</p>



<a name="215445508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215445508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215445508">(Nov 03 2020 at 12:17)</a>:</h4>
<p>I just had a go at using something like <code>class is_hom (hom : Type u₂ → Type u₃ → Type u₁)</code>, but I don't think it works out</p>



<a name="215445630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215445630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215445630">(Nov 03 2020 at 12:18)</a>:</h4>
<p>You can't instantiate that kind of <code>is_hom</code> for <code>zero_hom</code>, since not all <code>Type u</code>s have a zero :(</p>



<a name="215445639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215445639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215445639">(Nov 03 2020 at 12:18)</a>:</h4>
<p>Exactly</p>



<a name="215445719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215445719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215445719">(Nov 03 2020 at 12:19)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled_hom">docs#category_theory.bundled_hom</a> since I'm lazy</p>



<a name="215445848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215445848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215445848">(Nov 03 2020 at 12:21)</a>:</h4>
<p>I see the <code>c α</code> arguments end up holding the type-classes</p>



<a name="215446097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215446097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215446097">(Nov 03 2020 at 12:24)</a>:</h4>
<p>I don't see how you can get <code>comp</code> in a structure in any sensible way - how do I write <code>comp</code> for <code>(A → B) → (B → C) → (A → C)</code> if all three types live in different universes? I'd need a universe quantifier in a field, which isn't allowed</p>



<a name="215446268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215446268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215446268">(Nov 03 2020 at 12:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215445457">said</a>:</p>
<blockquote>
<p>(Luckily we wouldn't have <code>c : Type u → Type u</code> forcing everything into the same universe!)</p>
</blockquote>
<p>That is, I don't see how you plan to lift the restriction you mention in this comment</p>



<a name="215446467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215446467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215446467">(Nov 03 2020 at 12:28)</a>:</h4>
<p>You are correct, we cannot add a good definition for <code>id</code> or <code>comp</code>. <code>ext</code> works though:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">is_hom</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">hom</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">ext</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">coe</span><span class="o">)</span>
</code></pre></div>



<a name="215446642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215446642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215446642">(Nov 03 2020 at 12:30)</a>:</h4>
<p>I guess we can have <code>has_comp (homMN homNO : Type*) (homMO : out_param Type*)</code> and <code>has_id</code> typeclasses with the coherence conditions in there, but that would be an inference disaster. :(</p>



<a name="215448584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215448584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215448584">(Nov 03 2020 at 12:50)</a>:</h4>
<p>Related: <a href="#narrow/stream/113488-general/topic/universes/near/214217753">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217753</a></p>



<a name="215450836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215450836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215450836">(Nov 03 2020 at 13:13)</a>:</h4>
<p>The main problem with "use <code>coe_fn</code> as the head symbol" trick is that <a href="https://leanprover-community.github.io/mathlib_docs/find/has_coe_to_fun">docs#has_coe_to_fun</a> does not allow us to require "type <code>hom_type</code> has coercion to <code>M → N</code>".</p>



<a name="215450947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215450947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215450947">(Nov 03 2020 at 13:14)</a>:</h4>
<p>This happens because <code>F</code> is a part of the output, not an <code>out_param</code></p>



<a name="215451572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215451572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215451572">(Nov 03 2020 at 13:20)</a>:</h4>
<p>Is this something that lean4 could change the mechanics of, or would the <code>out_param</code> choice be worse in other ways?</p>



<a name="215455570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215455570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215455570">(Nov 03 2020 at 13:54)</a>:</h4>
<p>The <code>is_hom</code> class is supposed to fix that issue by putting the requirement in there. The only drawback is that the <code>has_coe_to_fun</code> instance must derive from <code>is_hom</code> for <code>simp</code> to work correctly?</p>



<a name="215455602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215455602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215455602">(Nov 03 2020 at 13:55)</a>:</h4>
<p>Or would there be another issue I'm missing?</p>



<a name="215457773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215457773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215457773">(Nov 03 2020 at 14:11)</a>:</h4>
<p>In algebra also, the move to bundled homs has been very nice. I would like to challenge the idea that having about 10 <code>map_zero</code> lemmas "doesn't scale". I think it's scaling really nicely. It is linear in the number of interesting collections of bundled morphisms, and this collection is not going to grow too much bigger in the near future -- the algebraic hierarchy is not going to massively expand randomly because someone discovers a fundamental new class of objects like groups, rings etc. I'm not saying I'm against the idea of bringing back <code>is_ring_hom</code> but remember that the reason we removed it is that it doesn't work very well; Lean 3 didn't like it.</p>



<a name="215457969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215457969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215457969">(Nov 03 2020 at 14:12)</a>:</h4>
<blockquote>
<p>I think it's scaling really nicely. It is linear in the number of interesting collections of bundled morphisms</p>
</blockquote>
<p>The problem is that it's bilinear (<code>O(N*M)</code>) not just <code>O(N)</code>; it's also linear in the number of interesting things you can apply morphisms to - sums over finsets, sums over finsupp, mapping over a matrix, ... The github comment linked to in <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215428568">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215428568</a> gives an example of this.</p>



<a name="215459410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215459410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215459410">(Nov 03 2020 at 14:24)</a>:</h4>
<p>I'm definitely not planning on replacing <code>ring_hom</code> with unbundled structures. If you like your bundled homs, you can keep them :)</p>



<a name="215459477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215459477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215459477">(Nov 03 2020 at 14:25)</a>:</h4>
<p>Another way we can phrase <code>is_ring_hom x</code> without referring to unbundled stuff is "this type has a coherent definition of <code>coe : x -&gt; ring_hom</code>".</p>



<a name="215459976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215459976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215459976">(Nov 03 2020 at 14:28)</a>:</h4>
<p>I am similarly opposed to using lots of unbundled hom classes. However, you can achieve the original goal without too much work: have an <code>is_zero_hom f</code> class, and instances <code>(f : A -&gt;*+ B) : is_zero_hom f</code> and so on. There is no quadratic growth of lemmas that way</p>



<a name="215460110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460110">(Nov 03 2020 at 14:29)</a>:</h4>
<p>I think that's what <span class="user-mention" data-user-id="238446">@Anne Baanen</span>'s example above does?</p>



<a name="215460148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460148">(Nov 03 2020 at 14:30)</a>:</h4>
<p>I see anne suggesting a lot more than that</p>



<a name="215460259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460259">(Nov 03 2020 at 14:30)</a>:</h4>
<p>Do you object to the contents of this message? <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215444243">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215444243</a></p>



<a name="215460316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460316">(Nov 03 2020 at 14:31)</a>:</h4>
<p>yes, I don't think this should be a generic <code>is_hom</code></p>



<a name="215460363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460363">(Nov 03 2020 at 14:31)</a>:</h4>
<p>this will make the typeclass problem a lot harder</p>



<a name="215460440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460440">(Nov 03 2020 at 14:32)</a>:</h4>
<p><code>is_hom</code> is only there as a trick to make <code>has_coe_to_fun</code> happy, it's not intended as API I think</p>



<a name="215460503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460503">(Nov 03 2020 at 14:32)</a>:</h4>
<p>it still interposes on the coe typeclass problem that we use everywhere</p>



<a name="215460616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460616">(Nov 03 2020 at 14:33)</a>:</h4>
<p>I'm not sure what you mean by that - is your claim that the existance of <code>is_hom</code> will break typeclass resolution somewhere else? Slow it down? Or something else?</p>



<a name="215460637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460637">(Nov 03 2020 at 14:33)</a>:</h4>
<p>it will slow it down</p>



<a name="215460725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460725">(Nov 03 2020 at 14:34)</a>:</h4>
<p>Is the issue that all <code>has_coe_to_fun</code> lookup will try looking for <code>is_hom</code> instances?</p>



<a name="215460815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460815">(Nov 03 2020 at 14:35)</a>:</h4>
<p>yes, as well as back chaining through <code>is_zero_hom</code>, <code>is_add_hom</code> and all the rest</p>



<a name="215460929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215460929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215460929">(Nov 03 2020 at 14:36)</a>:</h4>
<p>But typeclass resolution already does this for things like <code>has_add</code>, right? Why are we concerned about reusing the same mechanism?</p>



<a name="215461043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215461043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215461043">(Nov 03 2020 at 14:36)</a>:</h4>
<p>At risk of constructing a straw man, this sounds a bit like "I don't like the idea of <code>monoid A</code> because it will slow down type-class inference for <code>has_mul A</code> (by back-chaining through cancel_monoid, ring, ...)"</p>



<a name="215461123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215461123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215461123">(Nov 03 2020 at 14:37)</a>:</h4>
<p>This is an actual problem though, monoid -&gt; has_mul is not exempt</p>



<a name="215461234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215461234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215461234">(Nov 03 2020 at 14:38)</a>:</h4>
<p>What I don't want is to open a whole new world of stuff for typeclass inference to explore</p>



<a name="215461389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215461389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215461389">(Nov 03 2020 at 14:39)</a>:</h4>
<p>so "foundational" typeclass instances like the <code>is_hom -&gt; has_coe_to_fun</code> one here that have no content on their own can singlehandedly double the size of the search</p>



<a name="215461690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215461690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215461690">(Nov 03 2020 at 14:41)</a>:</h4>
<p>it would be nice if we had a performance monitor for typeclass searches, so we can quantify performance regressions</p>



<a name="215461815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215461815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215461815">(Nov 03 2020 at 14:42)</a>:</h4>
<p>I'm pretty sure it's responsible for half of mathlib's compile time (the other half being VM evaluation)</p>



<a name="215461965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215461965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215461965">(Nov 03 2020 at 14:43)</a>:</h4>
<p>My suggestion is the same as the first two points of Anne's first post, without the "except"</p>



<a name="215462105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215462105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215462105">(Nov 03 2020 at 14:44)</a>:</h4>
<p>with that approach you won't be searching for an <code>is_zero_hom</code> class unless you actually apply <code>matrix.is_zero_hom_map_zero</code></p>



<a name="215462170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215462170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215462170">(Nov 03 2020 at 14:45)</a>:</h4>
<p>so it's not going to make things worse for an unrelated file</p>



<a name="215462637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215462637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215462637">(Nov 03 2020 at 14:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215461965">said</a>:</p>
<blockquote>
<p>My suggestion is the same as the first two points of Anne's first post, without the "except"</p>
</blockquote>
<p>How would you define <code>is_add_hom</code> then?</p>



<a name="215462731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215462731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215462731">(Nov 03 2020 at 14:49)</a>:</h4>
<p>only if it comes up for something else</p>



<a name="215462833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215462833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215462833">(Nov 03 2020 at 14:50)</a>:</h4>
<p>and there would not be an instance <code>[is_add_hom f] : is_zero_hom f</code></p>



<a name="215462863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215462863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215462863">(Nov 03 2020 at 14:50)</a>:</h4>
<p>this keeps the typeclass problem very local</p>



<a name="215462937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215462937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215462937">(Nov 03 2020 at 14:51)</a>:</h4>
<p>So now I need a <code>is_zero_hom</code> instance for <code>add_monoid_hom</code>, <code>ring_hom</code>, <code>algebra_hom</code>, <code>linear_map</code>?</p>



<a name="215462952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215462952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215462952">(Nov 03 2020 at 14:51)</a>:</h4>
<p>yes</p>



<a name="215463013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463013">(Nov 03 2020 at 14:51)</a>:</h4>
<p>So the work is now quadratic in the depth of the hom heirarchy</p>



<a name="215463026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463026">(Nov 03 2020 at 14:51)</a>:</h4>
<p>yes, it's quadratic in 5</p>



<a name="215463060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463060">(Nov 03 2020 at 14:51)</a>:</h4>
<p>Which I suppose is slightly better than the bilinear case we have now</p>



<a name="215463080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463080">(Nov 03 2020 at 14:52)</a>:</h4>
<p>however, individual typeclass problems are only linear in 5</p>



<a name="215463304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463304">(Nov 03 2020 at 14:53)</a>:</h4>
<p>honestly, if I could have direct instances A -&gt; B for every pair of classes A and B in the hierarchy that would be far better than the current exponential situation</p>



<a name="215463337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463337">(Nov 03 2020 at 14:53)</a>:</h4>
<p>Why is the current situation exponential anyway?</p>



<a name="215463419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463419">(Nov 03 2020 at 14:54)</a>:</h4>
<p>unfortunately the way lean 3 typeclass inference works adding those shortcut instances only raises the base of the exponential</p>



<a name="215463429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463429">(Nov 03 2020 at 14:54)</a>:</h4>
<p>If my heirarchy were a single branch of a tree, then surely a "get typeclass from parent" approach is also linear</p>



<a name="215463469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463469">(Nov 03 2020 at 14:54)</a>:</h4>
<p>it's not a tree, it's a dag, and lean basically searches all paths in it</p>



<a name="215463501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463501">(Nov 03 2020 at 14:55)</a>:</h4>
<p>so shortcut instances are incredibly bad for the algorithm</p>



<a name="215463565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463565">(Nov 03 2020 at 14:55)</a>:</h4>
<p>Is this comparison accurate to find <code>has_coe_to_fun add_monoid_hom</code></p>
<p>Before:</p>
<ul>
<li>Loop over <code>has_coe_to_fun</code> until we find a match:<ul>
<li><code>zero_hom.has_coe_to_fun</code></li>
<li><code>add_hom.has_coe_to_fun</code></li>
<li><code>mul_hom.has_coe_to_fun</code></li>
<li><code>add_monoid_hom.has_coe_to_fun</code></li>
</ul>
</li>
</ul>
<p>With the post I link to above:</p>
<ul>
<li>Loop over <code>has_coe_to_fun</code> until we find a match:<ul>
<li><code>is_hom.has_coe_to_fun</code>, loop over <code>is_hom</code> until we find a match<ul>
<li><code>is_mul_hom.is_hom</code>, loop over <code>is_mul_hom</code> until we find a match<ul>
<li><code>is_monoid_hom.is_mul_hom</code><br>
     * <code>monoid_hom.is_monoid_hom</code></li>
</ul>
</li>
<li><code>is_zero_hom.is_hom</code>, loop over <code>is_zero_hom</code> until we find a match<ul>
<li><code>is_add_monoid_hom.is_zero_hom</code><br>
     * <code>add_monoid_hom.is_add_monoid_hom</code></li>
</ul>
</li>
<li><code>is_add_hom.is_hom</code>, loop over <code>is_add_hom</code> until we find a match<ul>
<li><code>is_add_monoid_hom.is_add_hom</code><br>
     * <code>add_monoid_hom.is_add_monoid_hom</code>(I assume inference then checks for consistency?)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>



<a name="215463747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463747">(Nov 03 2020 at 14:56)</a>:</h4>
<p>Ignoring diamonds, it looks to me like the overhead is linear in the depth of the tree, which doesn't seem too bad</p>



<a name="215463852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463852">(Nov 03 2020 at 14:57)</a>:</h4>
<p>is <code>is_hom</code> just replacing all <code>has_coe_to_fun</code> instances then?</p>



<a name="215463943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215463943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215463943">(Nov 03 2020 at 14:58)</a>:</h4>
<p>Yes, for the bundled morphisms. Things like <code>finsupp</code> and <code>dfinsupp</code> will keep using <code>has_coe_to_fun</code> directly of course</p>



<a name="215464104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464104">(Nov 03 2020 at 14:59)</a>:</h4>
<p>you have <code>is_add_monoid_hom.is_zero_hom</code>, does that mean there is also <code>is_add_monoid_hom</code>?</p>



<a name="215464214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464214">(Nov 03 2020 at 15:00)</a>:</h4>
<p>so <code>add_monoid_hom.is_add_monoid_hom</code> is getting tested twice</p>



<a name="215464273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464273">(Nov 03 2020 at 15:00)</a>:</h4>
<p>Yes, because there is a diamond</p>



<a name="215464308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464308">(Nov 03 2020 at 15:01)</a>:</h4>
<p>and everything under that diamond will be doubled</p>



<a name="215464319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464319">(Nov 03 2020 at 15:01)</a>:</h4>
<p>Indeed</p>



<a name="215464346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464346">(Nov 03 2020 at 15:01)</a>:</h4>
<p>it sounds like there is still a lurking exponential in this plan then</p>



<a name="215464367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464367">(Nov 03 2020 at 15:01)</a>:</h4>
<p>Does lean keep looking for a match in other branches even after it finds one?</p>



<a name="215464417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464417">(Nov 03 2020 at 15:02)</a>:</h4>
<p>no, but a success can come anywhere in the tree, and unsuccessful searches have to run the gamut</p>



<a name="215464496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464496">(Nov 03 2020 at 15:02)</a>:</h4>
<p>unsuccessful searches include unsuspecting files that have nothing to do with homs</p>



<a name="215464522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464522">(Nov 03 2020 at 15:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215461815">said</a>:</p>
<blockquote>
<p>I'm pretty sure [typeclass searches are] responsible for half of mathlib's compile time (the other half being VM evaluation)</p>
</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/pull/4832#discussion_r515558103">interesting you should say that...</a></p>



<a name="215464621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464621">(Nov 03 2020 at 15:03)</a>:</h4>
<p>Is the search breadth-first or depth-first?</p>



<a name="215464643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464643">(Nov 03 2020 at 15:03)</a>:</h4>
<p>depth first</p>



<a name="215464701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464701">(Nov 03 2020 at 15:04)</a>:</h4>
<p>it really is objectively not a very good algorithm</p>



<a name="215464798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464798">(Nov 03 2020 at 15:04)</a>:</h4>
<p>Is it objectively hard to improve it for <code>lean-3.24.0</code>?</p>



<a name="215464818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464818">(Nov 03 2020 at 15:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> has a paper on the new typeclass algorithm in lean 4</p>



<a name="215464852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464852">(Nov 03 2020 at 15:05)</a>:</h4>
<p>Can we backport it?</p>



<a name="215464902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464902">(Nov 03 2020 at 15:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/215464798">said</a>:</p>
<blockquote>
<p>Is it objectively hard to improve it for <code>lean-3.24.0</code>?</p>
</blockquote>
<p>It's possible</p>



<a name="215464933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464933">(Nov 03 2020 at 15:05)</a>:</h4>
<p>If lean 4 fixes things, would it be better to use the design with less human overhead, and hope that the performance issue goes away eventually?</p>



<a name="215464963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215464963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215464963">(Nov 03 2020 at 15:05)</a>:</h4>
<p>it would require some work and people will probably consider it wasted in light of lean 4</p>



<a name="215465107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215465107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215465107">(Nov 03 2020 at 15:06)</a>:</h4>
<p>it's difficult to ignore exponential factors even "temporarily"</p>



<a name="215465129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215465129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215465129">(Nov 03 2020 at 15:06)</a>:</h4>
<p>I have no idea how hard it is to do something like that... If it is 1 week of work, it might be worth it. We could consider it part of the port to Lean 4...</p>



<a name="215465235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215465235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215465235">(Nov 03 2020 at 15:07)</a>:</h4>
<p>How easy is it to check whether the effect is actually exponential?</p>



<a name="215465243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215465243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215465243">(Nov 03 2020 at 15:07)</a>:</h4>
<p>also we still don't even have a release date for lean 4 and many things are still up in the air so I'm not a fan of arguments for an uncertain future</p>



<a name="215465304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215465304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215465304">(Nov 03 2020 at 15:08)</a>:</h4>
<p>There are simple typeclass problems you can set up that have literal exponential search length</p>



<a name="215465342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215465342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215465342">(Nov 03 2020 at 15:08)</a>:</h4>
<p>For sure - my question is how we prove that the change suggested above is one of them</p>



<a name="215465455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215465455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215465455">(Nov 03 2020 at 15:09)</a>:</h4>
<p>For a fixed size of course it's not exponential, it's just slightly bigger</p>



<a name="215465514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215465514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215465514">(Nov 03 2020 at 15:09)</a>:</h4>
<p>but it scales worse and mathlib has real scaling issues in this area</p>



<a name="215465645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215465645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215465645">(Nov 03 2020 at 15:10)</a>:</h4>
<p>The danger of exponential searches is significantly reduced since we have caching now.</p>



<a name="215465723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215465723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215465723">(Nov 03 2020 at 15:11)</a>:</h4>
<p>Both Lean 3's and Lean 4's type class algorithms are Turing-complete, I don't think either of them provide good performance guarantees.</p>



<a name="215467815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215467815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215467815">(Nov 03 2020 at 15:26)</a>:</h4>
<p>As it turns out there are lots of diamonds in the heirarchy of morphisms: <a href="/user_uploads/3121/IEnLI5rauyMvvl0_a3susEFO/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/IEnLI5rauyMvvl0_a3susEFO/image.png" title="image.png"><img src="/user_uploads/3121/IEnLI5rauyMvvl0_a3susEFO/image.png"></a></div>



<a name="215467853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215467853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215467853">(Nov 03 2020 at 15:26)</a>:</h4>
<p>/me is not surprised <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="215467885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215467885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215467885">(Nov 03 2020 at 15:26)</a>:</h4>
<p>Where gray arrows are the ones that aren't actual <code>extends</code> clauses</p>



<a name="215468103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215468103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215468103">(Nov 03 2020 at 15:28)</a>:</h4>
<p><span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span> The graph suggests that we are missing arrows from <code>alg_hom</code> to <code>add_equiv</code> and from <code>ring_hom</code> to <code>equiv</code>.</p>



<a name="215468465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215468465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215468465">(Nov 03 2020 at 15:30)</a>:</h4>
<p>Perhaps clearer with the equivs separated:</p>
<p><a href="/user_uploads/3121/7Z3Syav1HfQ5w_dCmVKwUDTf/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/7Z3Syav1HfQ5w_dCmVKwUDTf/image.png" title="image.png"><img src="/user_uploads/3121/7Z3Syav1HfQ5w_dCmVKwUDTf/image.png"></a></div>



<a name="215468567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215468567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215468567">(Nov 03 2020 at 15:31)</a>:</h4>
<p>Yes, the reason this is a problem is because there are <em>in fact</em> many diamonds in most typeclass problems, it's not a theoretical concern</p>



<a name="215468808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215468808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215468808">(Nov 03 2020 at 15:33)</a>:</h4>
<p>Note also that N is 8 not 5 for <code>zero_hom</code></p>



<a name="215469233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215469233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215469233">(Nov 03 2020 at 15:36)</a>:</h4>
<p>12 counting diamonds</p>



<a name="215469425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215469425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215469425">(Nov 03 2020 at 15:37)</a>:</h4>
<p>For type class resolution, shouldn't only the number of edges matter?</p>



<a name="215469530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215469530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215469530">(Nov 03 2020 at 15:38)</a>:</h4>
<p>Ah, which is 13</p>



<a name="215469541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215469541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215469541">(Nov 03 2020 at 15:38)</a>:</h4>
<p>I'm counting nodes</p>



<a name="215469576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215469576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215469576">(Nov 03 2020 at 15:38)</a>:</h4>
<p>Shouldn't caching prevent a node being visited twice?</p>



<a name="215469648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215469648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215469648">(Nov 03 2020 at 15:39)</a>:</h4>
<p>possibly; there are situations where it won't because of undetermined metavariables I think</p>



<a name="215469712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215469712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215469712">(Nov 03 2020 at 15:39)</a>:</h4>
<p>not to mention if you have a sequence of typeclasses like <code>foo n -&gt; foo (n + 1)</code></p>



<a name="215469908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/215469908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#215469908">(Nov 03 2020 at 15:41)</a>:</h4>
<p>I forgot about gabriel's (heroic!) work to add caching, which solves many of the problems in this area, but because of the free form nature of typeclasses it's hard to get good guarantees</p>



<a name="228745545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/228745545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#228745545">(Mar 04 2021 at 10:06)</a>:</h4>
<p>Are the discrimination trees in Lean 4 going to solve this issue? If we have</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">-&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="o">[</span><span class="n">is_group_hom</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span>
</code></pre></div>
<p>should this just work in Lean 4? Because if I understand it correctly, <code>simp</code> will not just look at the head symbol, but also at <code>*</code>, a bit further down the tree.</p>



<a name="228745772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/228745772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#228745772">(Mar 04 2021 at 10:08)</a>:</h4>
<p>Even if it did, presumably we'll still be stuck with function composition?</p>



<a name="228745932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/228745932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#228745932">(Mar 04 2021 at 10:09)</a>:</h4>
<p>(<a href="https://leanprover-community.github.io/mathlib_docs/notes.html#no%20instance%20on%20morphisms">https://leanprover-community.github.io/mathlib_docs/notes.html#no%20instance%20on%20morphisms</a>)</p>



<a name="230332072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/230332072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#230332072">(Mar 15 2021 at 11:54)</a>:</h4>
<p>I had a bit of time last week to test this idea for real, but didn't get around to writing out a report. Because the topic came up in a <a href="#narrow/stream/270676-lean4/topic/Notation.20in.20structures">lean4 thread</a>, here's my observations:</p>



<a name="230333223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/230333223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#230333223">(Mar 15 2021 at 12:04)</a>:</h4>
<ul>
<li>Overall, using the <a href="https://github.com/leanprover-community/mathlib/compare/hom-classes#diff-918830029f29ce7761f69f9336d49d7397a07b37cfe8b2aaa174326749e54c71R72">hom typeclasses</a> works quite well with tactics, you can just write <code>simp [map_mul f]</code> without worrying whether <code>f</code> is a <code>mul_hom</code>, <code>monoid_hom</code>, <code>monoid_with_zero_hom</code>, <code>ring_hom</code>, ...</li>
<li>The <code>to_fun</code> class caused a few weird timeouts in <code>simp</code>, until I disabled the simp lemma <a href="#narrow/stream/113488-general/topic/Why.20is.20.60coe_fn_coe_base.60.20a.20.60simp.60.20lemma.3F"><code>coe_fn_coe_base</code></a></li>
<li><code>has_coe_to_fun</code> causes the expected type to be elaborated a bit too late, so you have to <a href="https://github.com/leanprover-community/mathlib/compare/hom-classes#diff-e355ee55b3ed90b500def3834cca1cee3c92474a5b00d9e365cb26410fccb13c">insert type hints</a> when there is reduction going on in the type. I expect this will be better in Lean 4 because it can delay subgoals (is this correct?)</li>
<li>I wanted to time whether <code>simp</code> gets faster because it doesn't go through all <code>foo_hom.map_bar</code> lemmas for every <code>coe_fn</code>, but didn't have the time yet</li>
<li>There is still a bit of boilerplate because you have to define the <code>foo_hom</code> structure and the <code>foo_hom_class</code> with the appropriate instances, but this is only linear in the number of <code>foo</code>s and should be automatable.</li>
</ul>



<a name="230333654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/230333654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#230333654">(Mar 15 2021 at 12:08)</a>:</h4>
<p>This pattern of having <code>structure foo</code> and <code>class foo_class</code> feels like it's essentially building the virtual "method" dispatch of C++, where <code>foo_class</code> is sort of like the vtable.</p>



<a name="230333782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/230333782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#230333782">(Mar 15 2021 at 12:09)</a>:</h4>
<p>I would say it's more like the <code>class Foo</code> + <code>interface IFoo</code> pattern in Java, but yes, basically that :)</p>



<a name="230335312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/230335312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#230335312">(Mar 15 2021 at 12:23)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> Thanks a lot for looking into this!</p>



<a name="258736093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/258736093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#258736093">(Oct 22 2021 at 16:26)</a>:</h4>
<p>I revived my experiment and opened <a href="https://github.com/leanprover-community/mathlib/issues/9888">#9888</a>. It still needs some cleaning up, but the basic idea seems to work well.</p>



<a name="258738465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/258738465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#258738465">(Oct 22 2021 at 16:44)</a>:</h4>
<p>This is very interesting to see -- I hadn't realized morphisms have the same sort of design considerations as graphs! In an <a href="https://github.com/leanprover-community/mathlib/blob/simple_graphs/src/combinatorics/simple_graph.lean">old branch</a> for simple graphs I came up with the same design.  I didn't think I could justify the complexity quite yet (nor did I think about it as the class+interface pattern), so we went with the more straightforward definition first, though I do plan to revisit this once we have more types of combinatorial objects.</p>
<p>These are the definitions in that branch:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">simple_graphs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">symmetric</span> <span class="o">(</span><span class="n">adj</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">irreflexive</span> <span class="o">(</span><span class="n">adj</span> <span class="n">G</span><span class="o">))</span>

<span class="kd">structure</span> <span class="n">from_rel</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">rel</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">rel</span><span class="o">)</span>
<span class="o">(</span><span class="n">irr</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">rel</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graphs</span> <span class="o">(</span><span class="n">from_rel</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">adj</span> <span class="o">:=</span> <span class="n">from_rel.rel</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="n">from_rel.sym</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="n">from_rel.irr</span> <span class="o">}</span>
</code></pre></div>
<p>To talk about a particular generic graph you could do <code>{α : Type u} [simple_graphs α] (G : α)</code>.  (I think I like the <code>simple_graph_class</code> and <code>simple_graph</code> naming convention better.)  One downside is it seems this design pattern loses out on a lot of dot notation...</p>



<a name="258738839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/258738839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#258738839">(Oct 22 2021 at 16:46)</a>:</h4>
<p>Do you think that we need <code>[*_hom_class]</code>? Why not just <code>[map_zero_class]</code> <code>[map_add_class]</code> etc?</p>



<a name="258739579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/258739579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#258739579">(Oct 22 2021 at 16:52)</a>:</h4>
<p>An attribute can create a <code>fun_like</code> instance and <code>[map*_class]</code> instances.</p>



<a name="258740169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/258740169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#258740169">(Oct 22 2021 at 16:56)</a>:</h4>
<p>The drawback of only having <code>map_{one,mul,zero,add}_class</code>es is that terms can grow exponentially big. This is also one of the reasons <code>monoid</code> bundles everything into one class instead of something like <code>[has_one] [has_mul] [mul_assoc] [mul_one]</code>.</p>



<a name="258740363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/258740363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#258740363">(Oct 22 2021 at 16:57)</a>:</h4>
<p><a href="https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html">https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html</a></p>



<a name="258741528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/258741528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#258741528">(Oct 22 2021 at 17:05)</a>:</h4>
<p>In this example <code>group</code> takes <code>monoid</code> as a parameter.</p>



<a name="258743008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/258743008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#258743008">(Oct 22 2021 at 17:15)</a>:</h4>
<p>Does the same happen with <code>[map_*_class]</code>? Why?</p>



<a name="258743397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/258743397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#258743397">(Oct 22 2021 at 17:18)</a>:</h4>
<p>OTOH, with <code>*_hom_class</code>, in order to apply <code>map_add</code>, Lean has to go up in the TC hierarchy to an appropriate class, then insert <code>*_hom_class.to_*_hom_class.....map_add</code> in the proof term instead of something like <code>linear_map.map_add_class</code>.</p>



<a name="258764300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/258764300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#258764300">(Oct 22 2021 at 19:48)</a>:</h4>
<p>I agree, I think we might be able to get away with separate classes for each <code>map</code> method after all</p>



<a name="261149164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/261149164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#261149164">(Nov 11 2021 at 15:42)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/9888">#9888</a> builds (see commit <a href="https://github.com/leanprover-community/mathlib/commit/4c51e75fe10fd6e74fb3ceb4aa0f5c5ecbbe3412"><code>4c51e75fe10fd6e74fb3ceb4aa0f5c5ecbbe3412</code></a>), so I went ahead and cleaned up the commits; hopefully that didn't break anything.</p>



<a name="261149653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/261149653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#261149653">(Nov 11 2021 at 15:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/258743008">said</a>:</p>
<blockquote>
<p>Does the same happen with <code>[map_*_class]</code>? Why?</p>
</blockquote>
<p>Good question! Perhaps not, since there won't be a class depending on the fields of all previous classes, in the way <code>comm_group</code> depends on everything in <code>group</code>. I'll see if I can make a good comparison.</p>



<a name="261150317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/261150317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#261150317">(Nov 11 2021 at 15:52)</a>:</h4>
<p>Still, by completely separating into <code>map_*_class</code>es, we turn this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">hom_eval₂</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring_hom_class</span> <span class="n">G</span> <span class="n">S</span> <span class="n">T</span><span class="o">]</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="o">(</span><span class="n">p.eval₂</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p.eval₂</span> <span class="o">(</span><span class="n">g.comp</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">_</span>
</code></pre></div>
<p>into this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">hom_eval₂</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">map_add_class</span> <span class="n">G</span> <span class="n">S</span> <span class="n">T</span><span class="o">]</span> <span class="o">[</span><span class="n">map_zero_class</span> <span class="n">G</span> <span class="n">S</span> <span class="n">T</span><span class="o">]</span> <span class="o">[</span><span class="n">map_mul_class</span> <span class="n">G</span> <span class="n">S</span> <span class="n">T</span><span class="o">]</span> <span class="o">[</span><span class="n">map_one_class</span> <span class="n">G</span> <span class="n">S</span> <span class="n">T</span><span class="o">]</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="o">(</span><span class="n">p.eval₂</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p.eval₂</span> <span class="o">(</span><span class="n">g.comp</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">_</span>
</code></pre></div>
<p>which I wouldn't like to do...</p>



<a name="262610804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/262610804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#262610804">(Nov 24 2021 at 16:29)</a>:</h4>
<p>Updated <a href="https://github.com/leanprover-community/mathlib/issues/9888">#9888</a> to resolve a merge conflict.</p>



<a name="262611021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/262611021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#262611021">(Nov 24 2021 at 16:31)</a>:</h4>
<p>I also tried to use unbundled classes see <a href="https://github.com/leanprover-community/mathlib/commit/7799c4922f53e0993b70df8a140a8c175c0f5bc3">commit <code>7799c4922f</code></a>, but I'm getting some errors I don't understand:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">monoid_with_zero_hom.comp</span> <span class="o">[</span><span class="n">mul_zero_one_class</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_zero_one_class</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_zero_one_class</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="n">monoid_with_zero_hom</span> <span class="n">N</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">hmn</span> <span class="o">:</span> <span class="n">monoid_with_zero_hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">monoid_with_zero_hom</span> <span class="n">M</span> <span class="n">P</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">hnp</span> <span class="bp">∘</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">map_zero'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">,</span> <span class="n">map_mul</span><span class="o">]</span> <span class="o">}</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">▶ 621:25-621:26: error:</span>
<span class="cm">invalid rewrite tactic, failed to synthesize type class instance for</span>
<span class="cm">  mul_hom_class (monoid_with_zero_hom M N) M N</span>
<span class="cm">state:</span>
<span class="cm">M : Type u_1,</span>
<span class="cm">N : Type u_2,</span>
<span class="cm">P : Type u_3,</span>
<span class="cm">_inst_1 : mul_zero_one_class M,</span>
<span class="cm">_inst_2 : mul_zero_one_class N,</span>
<span class="cm">_inst_3 : mul_zero_one_class P,</span>
<span class="cm">hnp : monoid_with_zero_hom N P,</span>
<span class="cm">hmn : monoid_with_zero_hom M N,</span>
<span class="cm">x y : M</span>
<span class="cm">⊢ ⇑hnp (⇑hmn (x * y)) = (⇑hnp ∘ ⇑hmn) x * (⇑hnp ∘ ⇑hmn) y</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="262611279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/262611279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#262611279">(Nov 24 2021 at 16:33)</a>:</h4>
<p>What does <code>set_option pp.implicit true</code> show as the message? And what does <code>#check @the_instance_you_expect_it_to_find</code> give?</p>



<a name="262611470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/262611470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#262611470">(Nov 24 2021 at 16:34)</a>:</h4>
<p><code>#print monoid_with_zero_hom.mul_hom_class</code> is an instance, as expected, and it can be found when explicitly calling <code>apply_instance</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Composition of `monoid_with_zero_hom`s as a `monoid_with_zero_hom`. -/</span>
<span class="kd">def</span> <span class="n">monoid_with_zero_hom.comp</span> <span class="o">[</span><span class="n">mul_zero_one_class</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_zero_one_class</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_zero_one_class</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="n">monoid_with_zero_hom</span> <span class="n">N</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">hmn</span> <span class="o">:</span> <span class="n">monoid_with_zero_hom</span> <span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">monoid_with_zero_hom</span> <span class="n">M</span> <span class="n">P</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">hnp</span> <span class="bp">∘</span> <span class="n">hmn</span><span class="o">,</span> <span class="n">map_zero'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">,</span> <span class="bp">@@</span><span class="n">map_mul</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">id</span> <span class="n">_</span><span class="o">)],</span>
    <span class="n">swap</span> <span class="mi">3</span><span class="o">,</span> <span class="o">{</span> <span class="n">apply_instance</span> <span class="o">},</span>
    <span class="n">simp</span>
  <span class="kd">end</span><span class="o">}</span>
</code></pre></div>



<a name="262611581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/262611581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#262611581">(Nov 24 2021 at 16:35)</a>:</h4>
<p><code>pp.implicit</code> gives a totally normal instance:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">rewrite</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
  <span class="bp">@</span><span class="n">mul_hom_class</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid_with_zero_hom</span> <span class="n">M</span> <span class="n">N</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span><span class="o">)</span> <span class="n">M</span> <span class="n">N</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">mul_one_class.to_has_mul</span> <span class="n">M</span> <span class="o">(</span><span class="bp">@</span><span class="n">mul_zero_one_class.to_mul_one_class</span> <span class="n">M</span> <span class="n">_inst_1</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">mul_zero_class.to_has_mul</span> <span class="n">N</span> <span class="o">(</span><span class="bp">@</span><span class="n">mul_zero_one_class.to_mul_zero_class</span> <span class="n">N</span> <span class="n">_inst_2</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">monoid_with_zero_hom.fun_like</span> <span class="n">M</span> <span class="n">N</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span><span class="o">)</span>
</code></pre></div>



<a name="262611733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/262611733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#262611733">(Nov 24 2021 at 16:36)</a>:</h4>
<p>Also:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="k">have</span> <span class="o">:</span> <span class="bp">@</span><span class="n">mul_hom_class</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid_with_zero_hom</span> <span class="n">M</span> <span class="n">N</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span><span class="o">)</span> <span class="n">M</span> <span class="n">N</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">mul_one_class.to_has_mul</span> <span class="n">M</span> <span class="o">(</span><span class="bp">@</span><span class="n">mul_zero_one_class.to_mul_one_class</span> <span class="n">M</span> <span class="n">_inst_1</span><span class="o">))</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">mul_zero_class.to_has_mul</span> <span class="n">N</span> <span class="o">(</span><span class="bp">@</span><span class="n">mul_zero_one_class.to_mul_zero_class</span> <span class="n">N</span> <span class="n">_inst_2</span><span class="o">))</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">monoid_with_zero_hom.fun_like</span> <span class="n">M</span> <span class="n">N</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="c1">-- works</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">function.comp_app</span><span class="o">,</span> <span class="n">map_mul</span><span class="o">],</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="262611824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/262611824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#262611824">(Nov 24 2021 at 16:36)</a>:</h4>
<p>Although replacing <code>have</code> with <code>haveI</code> will make it work amazingly enough!</p>



<a name="262612650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/262612650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#262612650">(Nov 24 2021 at 16:42)</a>:</h4>
<p>In any case, as long as we don't have any way to abbreviate <code>[fun_like F A B] [mul_hom_class F A B] [one_hom_class F A B] [add_hom_class F A B] [zero_hom_class F A B]</code> into something as concise as <code>[ring_hom_class F A B]</code>, I don't think unbundling is the way to go.</p>



<a name="262612786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/262612786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#262612786">(Nov 24 2021 at 16:43)</a>:</h4>
<p>(I'd be okay with unbundling the <code>extends has_coe_to_fun</code> or <code>extends fun_like</code> parts into a parameter - that would separate data from proofs.)</p>



<a name="262613922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/262613922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#262613922">(Nov 24 2021 at 16:51)</a>:</h4>
<p>In a related note, I have been running into issues where <code>ideal.quotient</code>, <code>submodule.quotient</code> and <code>subgroup.quotient</code> don't behave identically although they have equivalent definitions. What if we made a <code>subgroup_class</code> extending <code>set_like</code> and defined <code>quotient</code> in terms of that...</p>



<a name="289620897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289620897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289620897">(Jul 14 2022 at 17:12)</a>:</h4>
<p>Here's where we're at now:</p>
<p><a href="/user_uploads/3121/Cz9XGib5V_Tp4jzUWSJaHzuj/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/Cz9XGib5V_Tp4jzUWSJaHzuj/image.png" title="image.png"><img src="/user_uploads/3121/Cz9XGib5V_Tp4jzUWSJaHzuj/image.png"></a></div>



<a name="289620974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289620974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289620974">(Jul 14 2022 at 17:12)</a>:</h4>
<p>can you upload a higher quality verison of that?</p>



<a name="289621071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289621071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289621071">(Jul 14 2022 at 17:13)</a>:</h4>
<p>It's in the center of <a href="https://gist.githubusercontent.com/eric-wieser/479c49a306430d9d8a896f105ef32178/raw/32f67356bac21dda2c9a80a99d6cef602b643d96/out-small.svg">https://gist.githubusercontent.com/eric-wieser/479c49a306430d9d8a896f105ef32178/raw/32f67356bac21dda2c9a80a99d6cef602b643d96/out-small.svg</a></p>



<a name="289621213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289621213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289621213">(Jul 14 2022 at 17:14)</a>:</h4>
<p>weird that some of them don't extend <code>fun_like</code>...</p>



<a name="289621244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289621244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289621244">(Jul 14 2022 at 17:14)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/order_hom_class">docs#order_hom_class</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous_map_class">docs#continuous_map_class</a></p>



<a name="289621256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289621256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289621256">(Jul 14 2022 at 17:15)</a>:</h4>
<p>That's a data parsing error because <code>order_hom_class</code> is an abbreviation</p>



<a name="289621352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289621352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289621352">(Jul 14 2022 at 17:15)</a>:</h4>
<p>continuous_map_class does too, but it seems in a new-style way?</p>



<a name="289621565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289621565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289621565">(Jul 14 2022 at 17:17)</a>:</h4>
<p>That one's a mystery to me</p>



<a name="289621600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289621600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289621600">(Jul 14 2022 at 17:17)</a>:</h4>
<p>Feel free to try and adjust <a href="https://gist.github.com/eric-wieser/479c49a306430d9d8a896f105ef32178">the script</a></p>



<a name="289621799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289621799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289621799">(Jul 14 2022 at 17:19)</a>:</h4>
<p>What about the arrows that terminate into space here?<br>
<a href="/user_uploads/3121/1ul2Y0SJmjwH6nybdeX1VPAX/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/1ul2Y0SJmjwH6nybdeX1VPAX/image.png" title="image.png"><img src="/user_uploads/3121/1ul2Y0SJmjwH6nybdeX1VPAX/image.png"></a></div>



<a name="289621987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289621987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289621987">(Jul 14 2022 at 17:20)</a>:</h4>
<p>Click on them</p>



<a name="289622053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses%20for%20morphisms/near/289622053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Typeclasses.20for.20morphisms.html#289622053">(Jul 14 2022 at 17:21)</a>:</h4>
<p>I see, so the TC "values" are the arrow ends, the boxes are the defs of the class</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Type.20theory.20of.20Lean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html">Type theory of Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="163918718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163918718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#163918718">(Apr 22 2019 at 17:05)</a>:</h4>
<p>I just delivered my master's thesis on lean's type theory, and the talk was recorded: <a href="https://www.youtube.com/watch?v=3sKrSNhSxik" target="_blank" title="https://www.youtube.com/watch?v=3sKrSNhSxik">https://www.youtube.com/watch?v=3sKrSNhSxik</a> . It builds up the motivation for all the complexity in DTT, so if you have a basic understanding of how proof judgments are presented you should be able to follow it. The repo with the full thesis is <a href="https://github.com/digama0/lean-type-theory/releases" target="_blank" title="https://github.com/digama0/lean-type-theory/releases">https://github.com/digama0/lean-type-theory/releases</a> .</p>
<div class="youtube-video message_inline_image"><a data-id="3sKrSNhSxik" href="https://www.youtube.com/watch?v=3sKrSNhSxik" target="_blank" title="https://www.youtube.com/watch?v=3sKrSNhSxik"><img src="https://i.ytimg.com/vi/3sKrSNhSxik/default.jpg"></a></div>



<a name="163919331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163919331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#163919331">(Apr 22 2019 at 17:13)</a>:</h4>
<p>Congrats!</p>



<a name="163921544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163921544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#163921544">(Apr 22 2019 at 17:41)</a>:</h4>
<p><a href="http://phdcomics.com/comics/archive.php?comicid=590" target="_blank" title="http://phdcomics.com/comics/archive.php?comicid=590">http://phdcomics.com/comics/archive.php?comicid=590</a></p>



<a name="163921817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163921817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#163921817">(Apr 22 2019 at 17:44)</a>:</h4>
<p>Who would have believed to see this before Lean 4?</p>



<a name="163990778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163990778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#163990778">(Apr 23 2019 at 13:41)</a>:</h4>
<p>Congrats!</p>



<a name="163998787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163998787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#163998787">(Apr 23 2019 at 15:13)</a>:</h4>
<blockquote>
<p>f == g -&gt; x == y -&gt; f x == g y is unprovable</p>
</blockquote>
<p>Oops, so that's why I couldn't do it when I tried recently. Do you know if this is consistent as an added axiom?</p>



<a name="164012424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164012424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#164012424">(Apr 23 2019 at 17:48)</a>:</h4>
<p>Don't add axioms! It's not really how Lean works, and support for them is poor. If you need it, add a variable. But people in general try to avoid <code>heq</code> completely. Why do you think you need it at all?</p>



<a name="164075006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164075006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#164075006">(Apr 24 2019 at 12:15)</a>:</h4>
<p>I agree that adding axioms is probably undesirable, but it would be interesting to see whether this one is consistent with Lean from a purely type-theoretical point of view</p>



<a name="164135260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164135260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#164135260">(Apr 25 2019 at 01:29)</a>:</h4>
<p>It's consistent, because it follows from injectivity of pi</p>



<a name="164135468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164135468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#164135468">(Apr 25 2019 at 01:34)</a>:</h4>
<p>Are you saying that adding injectivity of pi is sufficient to prove it? Is there a down side to having that axiom?</p>



<a name="164141399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164141399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#164141399">(Apr 25 2019 at 04:02)</a>:</h4>
<p>One downside, as Carlo mentioned to me, is that it breaks the types-as-sets model, and the types-as-cardinalities model</p>



<a name="164141401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164141401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#164141401">(Apr 25 2019 at 04:03)</a>:</h4>
<p>plus axioms always have computation / canonicity troubles</p>



<a name="164141757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164141757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#164141757">(Apr 25 2019 at 04:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">axiom</span> <span class="n">pi_injective₁</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α&#39;</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β&#39;</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">α&#39;</span>

<span class="kn">axiom</span> <span class="n">pi_injective₂</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="n">β&#39;</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β&#39;</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">β&#39;</span> <span class="n">a</span>

<span class="kn">theorem</span> <span class="n">heq_congr</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α&#39;</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β&#39;</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">α&#39;</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">==</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">==</span> <span class="n">g</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">pi_injective₁</span> <span class="o">(</span><span class="n">type_eq_of_heq</span> <span class="n">h₁</span><span class="o">),</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">funext</span> <span class="err">$</span> <span class="n">pi_injective₂</span> <span class="o">(</span><span class="n">type_eq_of_heq</span> <span class="n">h₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">=</span> <span class="n">β&#39;</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">refl</span>
<span class="kn">end</span>
</pre></div>



<a name="164180129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164180129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#164180129">(Apr 25 2019 at 15:23)</a>:</h4>
<blockquote>
<p>Who would have believed to see this before Lean 4?</p>
</blockquote>
<p>That was a very narrow win...</p>



<a name="164182699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164182699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#164182699">(Apr 25 2019 at 15:49)</a>:</h4>
<p>Do you have a release date for Lean 4?</p>



<a name="164182809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164182809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#164182809">(Apr 25 2019 at 15:50)</a>:</h4>
<p>We didn't need a release to see it</p>



<a name="168054681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/168054681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#168054681">(Jun 13 2019 at 15:16)</a>:</h4>
<p>What about functional extensionality over <code>heq</code>? I think it doesn't hold in pure CiC, but maybe it's provable in Lean's theory (or in Lean+<code>pi_injective</code>)? Something like</p>
<div class="codehilite"><pre><span></span><span class="kn">axiom</span> <span class="n">heq_funext</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span><span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">g</span>
</pre></div>



<a name="168055176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/168055176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#168055176">(Jun 13 2019 at 15:22)</a>:</h4>
<p>This looks provable in Lean</p>



<a name="168055581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/168055581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#168055581">(Jun 13 2019 at 15:27)</a>:</h4>
<p>Here is my unoptimized proof</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">heq_funext</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span><span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">g</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintro</span> <span class="n">rfl</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">type_eq_of_heq</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="n">a</span> <span class="n">heq</span><span class="bp">.</span><span class="n">rfl</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">subst</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">heq_of_eq</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq_of_heq</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="n">a</span> <span class="n">heq</span><span class="bp">.</span><span class="n">rfl</span><span class="o">)</span>
<span class="kn">end</span>
</pre></div>



<a name="168056685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/168056685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#168056685">(Jun 13 2019 at 15:38)</a>:</h4>
<p>Thanks!</p>



<a name="168056776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/168056776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#168056776">(Jun 13 2019 at 15:39)</a>:</h4>
<p>Golfed </p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">heq_funext</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span><span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">function</span><span class="bp">.</span><span class="n">hfunext</span>
</pre></div>



<a name="168056972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/168056972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#168056972">(Jun 13 2019 at 15:41)</a>:</h4>
<p><span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span> I was looking for this in <code>heq</code> parts of the library</p>



<a name="168057117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/168057117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#168057117">(Jun 13 2019 at 15:43)</a>:</h4>
<p>Alternatively</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">heq_funext</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span><span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span><span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">g</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">library_search</span>
</pre></div>



<a name="168058476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/168058476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#168058476">(Jun 13 2019 at 15:58)</a>:</h4>
<p><code>library_search</code> is still not my first instinct with these sorts of things, and it probably should be. Sometimes I think "probably I need <code>import mathlib</code> for the search to work".</p>



<a name="168058579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/168058579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#168058579">(Jun 13 2019 at 15:59)</a>:</h4>
<p>Of course, Chris' triumph should be seen within the context of the hours of pain he had when trying to deal with <code>heq</code> last year.</p>



<a name="248716554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/248716554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#248716554">(Aug 07 2021 at 13:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Can the types of Lean be regarded as sets in some usual sense? I mean, in mathlib the <code>module</code> (vector space) axioms are defined by saying that the "add" and "scalar multiplication" functions are Lean functions. If I'm formalizing math that was originally defined with set theory, as a lot of math has been, can I just replace all sets with types? Or should I define set theory inside Lean in some particular way first.</p>



<a name="248718467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/248718467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#248718467">(Aug 07 2021 at 14:17)</a>:</h4>
<p>No, in general the sets you're not set operations (union, intersection... but not cartesian product or sum) with should be types.</p>



<a name="248718783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/248718783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#248718783">(Aug 07 2021 at 14:25)</a>:</h4>
<p>I feel it would be useful to have a guide for how to formalize math that was previously defined in set theory.</p>



<a name="248719097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/248719097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#248719097">(Aug 07 2021 at 14:32)</a>:</h4>
<p>The one line summary is <code>Type</code> = set, <code>set</code> = subset.</p>



<a name="248719103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/248719103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#248719103">(Aug 07 2021 at 14:33)</a>:</h4>
<p>i think it's hard to get too specific, but really the main guidance what Reid just said.</p>



<a name="248719587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/248719587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#248719587">(Aug 07 2021 at 14:44)</a>:</h4>
<p>(I don't have anything to add for the general situation, Reid is right)</p>



<a name="248726293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/248726293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#248726293">(Aug 07 2021 at 17:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="241097">Juho Kupiainen</span> <a href="#narrow/stream/113488-general/topic/Type.20theory.20of.20Lean/near/248718783">said</a>:</p>
<blockquote>
<p>I feel it would be useful to have a guide for how to formalize math that was previously defined in set theory.</p>
</blockquote>
<p>The main trick is to realize you are lying to yourself. The math you are thinking of have not been "previously defined in set theory". They have been defined outside of any formal foundation. However they are usually expressed using a vocabulary that is inspired by set theory, but this is a very superficial connection with set theory. When using Lean you can mostly ignore foundational details (unless you want to formalize computer science). You'll get used to it very quickly.</p>



<a name="248729540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/248729540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Type.20theory.20of.20Lean.html#248729540">(Aug 07 2021 at 18:36)</a>:</h4>
<p>In particular, "A ring is a set equipped with an addition, a multiplication..." is what we say, "A ring is a collection of stuff equipped with an addition..." is what we mean, and "A ring is a type equipped with..." is what we say in Lean, but it's all the same thing.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
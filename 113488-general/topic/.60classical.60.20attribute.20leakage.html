---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/.60classical.60.20attribute.20leakage.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html">`classical` attribute leakage</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="282726128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726128">(May 18 2022 at 00:46)</a>:</h4>
<p>I'm wondering whether it's intended that the new <code>classical</code> tactic adds the <code>instance</code> attribute to <code>classical.prop_decidable</code> globally. The tactic is adding it non-persistently, but that only means that it's scoped to the <code>section</code>/<code>namespace</code> (it's the difference between the <code>local attribute</code> and <code>attribute</code> commands.)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.interactive</span>

<span class="c1">-- Fails</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo1</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">end</span>

<span class="c1">-- Succeeds</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo2</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">classical</span><span class="o">,</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">end</span>

<span class="c1">-- Succeeds?</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo3</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">end</span>
</code></pre></div>
<p>(ping <span class="user-mention" data-user-id="310045">@Eric Wieser</span>)</p>



<a name="282726224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726224">(May 18 2022 at 00:48)</a>:</h4>
<p>Oh darn, I wasn't sure what persistent meant (I don't think there's a docstring), and thought I'd tested it as ok</p>



<a name="282726246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726246">(May 18 2022 at 00:49)</a>:</h4>
<p>I would guess we want to use <del>docs#bracket</del> <em>whatever the spelling of try/finally is</em> to add and remove the attribute</p>



<a name="282726477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726477">(May 18 2022 at 00:52)</a>:</h4>
<p>Yeah, I was just trying to write <code>by_classical { ... }</code> that'd do that</p>



<a name="282726502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726502">(May 18 2022 at 00:53)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.finally">docs#tactic.finally</a> is what I meant</p>



<a name="282726560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726560">(May 18 2022 at 00:54)</a>:</h4>
<p>I wonder if there's ever a situation where with nested tactic blocks, the inner tactic block executes <em>after</em> the outer one.</p>



<a name="282726566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726566">(May 18 2022 at 00:54)</a>:</h4>
<p>In that case the inner one won't get the instances</p>



<a name="282726588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726588">(May 18 2022 at 00:55)</a>:</h4>
<p>I don't follow; can't you just restore the previous attribute?</p>



<a name="282726601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726601">(May 18 2022 at 00:55)</a>:</h4>
<p>Or do nothing if the attribute is already there</p>



<a name="282726663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726663">(May 18 2022 at 00:56)</a>:</h4>
<p>Regarding the notation, I was thinking about something slightly different; a <code>classical! expr</code> notation  to allow <code>classical! if p then y else n</code></p>



<a name="282726923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282726923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282726923">(May 18 2022 at 01:00)</a>:</h4>
<p>Although actually for that, maybe</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">classically</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">P</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">classically</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">classical.dec</span>
</code></pre></div>
<p>is a better spelling</p>



<a name="282727284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282727284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282727284">(May 18 2022 at 01:06)</a>:</h4>
<p>Here's a seemingly working <code>with_classical { ... }</code> block:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.interactive</span>

<span class="kn">namespace</span> <span class="n">tactic</span>

<span class="sd">/-- Temporarily give the `instance` attribute to a declaration with</span>
<span class="sd">a given priority then restore the original attribute settings. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">with_instance</span> <span class="o">(</span><span class="n">c_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">prio</span> <span class="o">:</span> <span class="n">option</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">old</span> <span class="bp">←</span> <span class="n">try_core</span> <span class="o">(</span><span class="n">tactic.has_attribute</span> <span class="bp">`</span><span class="kd">instance</span> <span class="n">c_name</span><span class="o">),</span>
   <span class="n">tactic.set_basic_attribute</span> <span class="bp">`</span><span class="kd">instance</span> <span class="n">c_name</span> <span class="n">ff</span> <span class="n">prio</span><span class="o">,</span>
   <span class="n">tactic.finally</span> <span class="n">tac</span> <span class="bp">$</span>
     <span class="k">match</span> <span class="n">old</span> <span class="k">with</span>
     <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">tactic.unset_attribute</span> <span class="bp">`</span><span class="kd">instance</span> <span class="n">c_name</span>
     <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">persistent</span><span class="o">,</span> <span class="n">prio</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tactic.set_basic_attribute</span> <span class="bp">`</span><span class="kd">instance</span> <span class="n">c_name</span> <span class="n">persistent</span> <span class="n">prio</span>
     <span class="kd">end</span>

<span class="kn">namespace</span> <span class="n">interactive</span>
<span class="n">setup_tactic_parser</span>

<span class="sd">/-- Have the effect of `open_locale classical` for the duration of</span>
<span class="sd">the given tactic block. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">with_classical</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">parser.itactic</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">with_instance</span> <span class="bp">`</span><span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">some</span> <span class="mi">9</span><span class="o">)</span> <span class="bp">$</span>
<span class="n">with_instance</span> <span class="bp">`</span><span class="n">decidable_eq_of_decidable_le</span> <span class="o">(</span><span class="n">some</span> <span class="mi">8</span><span class="o">)</span> <span class="bp">$</span>
<span class="n">t</span>

<span class="kd">end</span> <span class="n">interactive</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="c1">-- Succeeds</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo1</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">with_classical</span> <span class="o">{</span> <span class="n">apply_instance</span> <span class="o">}</span> <span class="kd">end</span>

<span class="c1">-- Fails (good!)</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo2</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">end</span>
</code></pre></div>



<a name="282727492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282727492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282727492">(May 18 2022 at 01:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/.60classical.60.20attribute.20leakage/near/282726923">said</a>:</p>
<blockquote>
<p>Although actually for that, maybe</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">classically</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">P</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">classically</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">classical.dec</span>
</code></pre></div>
<p>is a better spelling</p>
</blockquote>
<p>That's an interesting idea for classical <code>if</code>, though it might get in the way rewrites... Making it <code>@[reducible]</code> might help somewhat.</p>



<a name="282727550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282727550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282727550">(May 18 2022 at 01:11)</a>:</h4>
<p>Could you use <code>bracket</code>? e.g. <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.with_local_reducibility/src">src#tactic.with_local_reducibility</a></p>



<a name="282728076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282728076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282728076">(May 18 2022 at 01:21)</a>:</h4>
<p>It looks like <code>bracket a b c = a &gt;&gt; finally b c</code> so yes -- is there a reason to?</p>



<a name="282728788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282728788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282728788">(May 18 2022 at 01:36)</a>:</h4>
<p>I guess I would have said it is the more idiomatic way to express this kind of intent, but otherwise I suppose not</p>



<a name="282729342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282729342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282729342">(May 18 2022 at 01:46)</a>:</h4>
<p>Is it possible to create a tactic block in a <code>pexpr</code>? I wanted to see if it was possible to implement Eric's <code>classical!</code> user notation.</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.interactive</span>

<span class="kn">namespace</span> <span class="n">tactic</span>

<span class="sd">/-- Temporarily give the `instance` attribute to a declaration with</span>
<span class="sd">a given priority then restore the original attribute settings. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">with_instance</span> <span class="o">(</span><span class="n">c_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">prio</span> <span class="o">:</span> <span class="n">option</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">old</span> <span class="bp">←</span> <span class="n">try_core</span> <span class="o">(</span><span class="n">tactic.has_attribute</span> <span class="bp">`</span><span class="kd">instance</span> <span class="n">c_name</span><span class="o">),</span>
   <span class="n">bracket</span> <span class="o">(</span><span class="n">tactic.set_basic_attribute</span> <span class="bp">`</span><span class="kd">instance</span> <span class="n">c_name</span> <span class="n">ff</span> <span class="n">prio</span><span class="o">)</span> <span class="n">tac</span> <span class="bp">$</span>
     <span class="k">match</span> <span class="n">old</span> <span class="k">with</span>
     <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">tactic.unset_attribute</span> <span class="bp">`</span><span class="kd">instance</span> <span class="n">c_name</span>
     <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">persistent</span><span class="o">,</span> <span class="n">prio</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tactic.set_basic_attribute</span> <span class="bp">`</span><span class="kd">instance</span> <span class="n">c_name</span> <span class="n">persistent</span> <span class="n">prio</span>
     <span class="kd">end</span>

<span class="kn">namespace</span> <span class="n">interactive</span>
<span class="n">setup_tactic_parser</span>

<span class="sd">/-- Have the effect of `open_locale classical` for the duration of</span>
<span class="sd">the given tactic block. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">with_classical</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">parser.itactic</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">with_instance</span> <span class="bp">`</span><span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">some</span> <span class="mi">9</span><span class="o">)</span> <span class="bp">$</span>
<span class="n">with_instance</span> <span class="bp">`</span><span class="n">decidable_eq_of_decidable_le</span> <span class="o">(</span><span class="n">some</span> <span class="mi">8</span><span class="o">)</span> <span class="bp">$</span>
<span class="n">t</span>

<span class="kd">reserve</span> <span class="kd">notation</span> <span class="bp">`</span><span class="n">classical</span><span class="bp">!`</span><span class="o">:</span><span class="mi">0</span>

<span class="kd">@[user_notation]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">by_classical_notation</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">parse</span> <span class="bp">$</span> <span class="n">tk</span> <span class="s2">"classical!"</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">parser.pexpr</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">parser</span> <span class="n">pexpr</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">trace</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">return</span> <span class="n">t</span>
  <span class="c1">-- is it possible to do something that does what it seems like this should mean?</span>
  <span class="c1">--return ``(by with_classical { exact %%t })</span>
  <span class="c1">-- it appears that tactics inside quotations execute immediately</span>

<span class="kd">end</span> <span class="n">interactive</span>


<span class="kd">end</span> <span class="n">tactic</span>
</code></pre></div>
</div></div>



<a name="282746777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282746777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282746777">(May 18 2022 at 06:59)</a>:</h4>
<p>Where is <a href="https://leanprover-community.github.io/mathlib_docs/find/bracket">docs#bracket</a> defined?</p>



<a name="282746799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282746799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282746799">(May 18 2022 at 06:59)</a>:</h4>
<p>I looked for it and couldn't find it</p>



<a name="282749111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282749111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282749111">(May 18 2022 at 07:28)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/interaction_monad.bracket">docs#interaction_monad.bracket</a> (btw, <code>with_instance</code> in the code block just above is using it)</p>



<a name="282749837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/282749837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#282749837">(May 18 2022 at 07:37)</a>:</h4>
<p>(I was going to use it in the original PR but couldn't see the effect; I just thought I imagined it when the doc link didn't work!)</p>



<a name="283239984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/283239984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#283239984">(May 22 2022 at 16:23)</a>:</h4>
<p>Hmm, <code>bracket</code> doesn't work here as it would nee dto modify the syntax of <code>classical</code></p>



<a name="284194373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284194373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284194373">(May 27 2022 at 23:07)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>, do you have any opinions about what we should do here?</p>



<a name="284194393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284194393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284194393">(May 27 2022 at 23:07)</a>:</h4>
<p>Maybe there's some "at end of tactic" hook we can use like the "step" hook?</p>



<a name="284204481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284204481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284204481">(May 28 2022 at 02:37)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Interesting idea. I've been reading through the tactic parser source code to see what features we might be able to use.</p>
<p>The extent of a tactic appears to be handled by the <code>execute_with</code> field of <a href="https://leanprover-community.github.io/mathlib_docs/find/interactive.executor">docs#interactive.executor</a>, where the default implementation for plain old tactic blocks is doing nothing. So, if we could inject cleanup routines here then that would probably work, but we probably shouldn't touch the main interactive tactic... (But if we were ok with doing that, we could add state to the <code>config_type</code> field recording whether we need to do clean up for <code>classical</code>.)</p>
<p>One option is that we could make a custom <code>classical</code> tactic class, so then you would write <code>begin [classical] ... end</code>, and then <code>execute_with</code> would be responsible for bracketing the attribute manipulation. However, as far as I can tell custom tactic classes have their own namespace for interactive tactics and there's no way to include interactive tactics from another tactic class, short of copying them all over. That's what the natural number game does (but we don't want to do that since the tactic set changes depending on what you've got imported).</p>
<p>Maybe there could be a systematic way to let one tactic class use interactive tactics from another tactic class. This seems to be the place where name lookup happens: <a href="https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/tactic_notation.cpp#L136">https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/tactic_notation.cpp#L136</a></p>
<p>I thought that perhaps it could be made to respect aliases similar to how name lookup works in the elaborator ("aliases" are not to be confused with the <code>alias</code> command -- these are the aliases used to implement <code>open</code> and <code>export</code>). You can <code>export</code> names from one namespace to another, but you probably would need to refresh the aliases to the <code>classical.interactive</code> namespace when you import more tactics...</p>



<a name="284215960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284215960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284215960">(May 28 2022 at 07:32)</a>:</h4>
<blockquote>
<p>So, if we could inject cleanup routines here then that would probably work, but we probably shouldn't touch the main interactive tactic...</p>
</blockquote>
<p>It's a hack, but we can even do it from within mathlib:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">my_executor</span> <span class="o">:</span> <span class="n">interactive.executor</span> <span class="n">tactic</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">config_type</span> <span class="o">:=</span> <span class="n">unit</span><span class="o">,</span>
  <span class="n">execute_with</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">block</span><span class="o">,</span> <span class="k">do</span>
    <span class="n">tactic.trace</span> <span class="s2">"record state of classical"</span><span class="o">,</span>
    <span class="n">block</span><span class="o">,</span>
    <span class="n">tactic.trace</span> <span class="s2">"restore initial state"</span> <span class="o">}</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">vm_override</span> <span class="n">my_executor</span><span class="o">]</span> <span class="n">interactive.executor_tactic</span>
</code></pre></div>



<a name="284243466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284243466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284243466">(May 28 2022 at 19:01)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Gabriel's hack seems to work perfectly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">tactic</span>

<span class="sd">/-- Execute a tactic that might modify the given attribute for hte given declaration and then</span>
<span class="sd">restore the original attribute state. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">with_local_attribute</span> <span class="o">(</span><span class="n">c_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">attr</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">old</span> <span class="bp">←</span> <span class="n">try_core</span> <span class="o">(</span><span class="n">tactic.has_attribute</span> <span class="n">attr</span> <span class="n">c_name</span><span class="o">),</span>
   <span class="n">finally</span> <span class="n">tac</span> <span class="bp">$</span> <span class="k">do</span>
     <span class="c">/-</span><span class="cm"> I haven't checked, but I think it might be more efficient to only</span>
<span class="cm">        change it back if it's different... -/</span>
     <span class="n">new</span> <span class="bp">←</span> <span class="n">try_core</span> <span class="o">(</span><span class="n">tactic.has_attribute</span> <span class="n">attr</span> <span class="n">c_name</span><span class="o">),</span>
     <span class="n">when</span> <span class="o">(</span><span class="n">new</span> <span class="bp">≠</span> <span class="n">old</span><span class="o">)</span> <span class="bp">$</span> <span class="k">do</span>
       <span class="k">match</span> <span class="n">old</span> <span class="k">with</span>
       <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">tactic.unset_attribute</span> <span class="n">attr</span> <span class="n">c_name</span>
       <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">persistent</span><span class="o">,</span> <span class="n">prio</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tactic.set_basic_attribute</span> <span class="n">attr</span> <span class="n">c_name</span> <span class="n">persistent</span> <span class="n">prio</span>
       <span class="kd">end</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mathlib_tactic_executor</span> <span class="o">:</span> <span class="n">interactive.executor</span> <span class="n">tactic</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">config_type</span> <span class="o">:=</span> <span class="n">unit</span><span class="o">,</span>
  <span class="n">execute_with</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">block</span><span class="o">,</span>
    <span class="n">tactic.with_local_attribute</span> <span class="bp">`</span><span class="n">classical.prop_decidable</span> <span class="bp">`</span><span class="kd">instance</span> <span class="bp">$</span>
    <span class="n">tactic.with_local_attribute</span> <span class="bp">`</span><span class="n">classical.decidable_eq_of_decidable</span> <span class="bp">`</span><span class="kd">instance</span> <span class="bp">$</span>
    <span class="n">block</span> <span class="o">}</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">vm_override</span> <span class="n">mathlib_tactic_executor</span><span class="o">]</span> <span class="n">interactive.executor_tactic</span>

<span class="c1">-- Fails</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo1</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">end</span>

<span class="c1">-- Succeeds</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo2</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">classical</span><span class="o">,</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">end</span>

<span class="c1">-- Fails! (good!)</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo3</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">end</span>
</code></pre></div>



<a name="284243625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284243625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284243625">(May 28 2022 at 19:04)</a>:</h4>
<p>Incidentally, I remember someone had the idea a couple months ago of experimenting with a version of tactic blocks that would automatically do <code>assumption</code> or <code>refl</code> at the end -- this is a way you could try taking that idea for a spin.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">mathlib_tactic_executor'</span> <span class="o">:</span> <span class="n">interactive.executor</span> <span class="n">tactic</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">config_type</span> <span class="o">:=</span> <span class="n">unit</span><span class="o">,</span>
  <span class="n">execute_with</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">block</span><span class="o">,</span>
    <span class="k">do</span> <span class="n">a</span> <span class="bp">←</span> <span class="n">block</span><span class="o">,</span> <span class="n">tactic.assumption</span><span class="o">,</span> <span class="n">return</span> <span class="n">a</span> <span class="o">}</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">vm_override</span> <span class="n">mathlib_tactic_executor'</span><span class="o">]</span> <span class="n">interactive.executor_tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="kd">end</span> <span class="c1">-- tada!</span>
</code></pre></div>



<a name="284243727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284243727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284243727">(May 28 2022 at 19:06)</a>:</h4>
<p>Presumably something like <code>try {classical, tactic.fail}, apply_instance</code> still picks up the classical instance?</p>



<a name="284243813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284243813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284243813">(May 28 2022 at 19:08)</a>:</h4>
<p>Nope, the inner tactic block seems to get its own <code>execute_with</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo3</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">try</span> <span class="o">{</span> <span class="n">classical</span> <span class="o">},</span> <span class="n">apply_instance</span><span class="o">,</span> <span class="kd">end</span> <span class="c1">-- fails at `apply_instance`</span>
</code></pre></div>



<a name="284243827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284243827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284243827">(May 28 2022 at 19:09)</a>:</h4>
<p>Even if it didn't get its own <code>execute_with</code>, <code>try</code> would discard the tactic state with the classical instances.  A better challenge would be <code>have : 1 = 1, { classical, refl }, apply_instance</code>.</p>



<a name="284243911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284243911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284243911">(May 28 2022 at 19:10)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span>  You can see the nested <code>execute_explicit</code> if you do this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">tactic.trace</span> <span class="o">(</span><span class="bp">``</span><span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">try</span> <span class="o">{</span> <span class="n">classical</span> <span class="o">},</span> <span class="n">apply_instance</span> <span class="o">}))</span>
</code></pre></div>



<a name="284243928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284243928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284243928">(May 28 2022 at 19:11)</a>:</h4>
<p>This is a complicated way of saying:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="n">raw</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">try</span> <span class="o">{</span> <span class="n">classical</span> <span class="o">},</span> <span class="n">apply_instance</span> <span class="o">}</span>
</code></pre></div>



<a name="284243931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/284243931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#284243931">(May 28 2022 at 19:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Success:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">foo3</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="kd">begin</span> <span class="k">have</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span> <span class="n">apply_instance</span> <span class="kd">end</span> <span class="c1">-- fails at `apply_instance`</span>
</code></pre></div>



<a name="323012486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323012486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323012486">(Jan 23 2023 at 12:55)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>, did you ever get around to PRing this?</p>



<a name="323012647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323012647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323012647">(Jan 23 2023 at 12:56)</a>:</h4>
<p>I noticed that the leakage is worse than I thought; it leaks out of proof fields within <code>def</code>s too, not just out of definitions that use <code>by classical; exact</code></p>



<a name="323029856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323029856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323029856">(Jan 23 2023 at 14:13)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> I didn't. I wasn't comfortable being responsible for doing a <code>vm_override</code> for the tactic executor!</p>
<p>Maybe it's worth setting it up locally and periodically seeing how bad the leakage is and fix up any errors, but then create a PR with only these fixes?</p>



<a name="323030060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323030060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323030060">(Jan 23 2023 at 14:14)</a>:</h4>
<p>The fix is usually pretty ugly though, it involves either;</p>
<ul>
<li>Adding <code>async</code> around the proof term to contain the leakage</li>
<li>Replacing <code>classical</code> with <code>letI := ...</code></li>
</ul>



<a name="323204084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323204084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323204084">(Jan 24 2023 at 09:40)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="112680">@Johan Commelin</span></p>



<a name="323205890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323205890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323205890">(Jan 24 2023 at 09:50)</a>:</h4>
<p>I think we want this hack in place because it brings the behavior closed to that of mathlib4</p>



<a name="323205901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323205901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323205901">(Jan 24 2023 at 09:50)</a>:</h4>
<p>Which will ease porting</p>



<a name="323209187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323209187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323209187">(Jan 24 2023 at 10:06)</a>:</h4>
<p>Do we really need to have it in place on master, or is it enough to enable it locally on a branch, fix the build, and then remove it?</p>



<a name="323213454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323213454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323213454">(Jan 24 2023 at 10:27)</a>:</h4>
<p>What's the downside of having it on master?</p>



<a name="323215350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323215350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323215350">(Jan 24 2023 at 10:36)</a>:</h4>
<p>It's ugly?</p>



<a name="323217128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323217128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323217128">(Jan 24 2023 at 10:45)</a>:</h4>
<p>Having <code>classical</code> leaking is arguably more ugly, and unless the workaround is on master we have nothing to detect future leakage in CI</p>



<a name="323217229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323217229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323217229">(Jan 24 2023 at 10:46)</a>:</h4>
<p>It also causes a pervasive slowdown of all tactic blocks in mathlib, though I haven't measured exactly how much it costs.</p>



<a name="323217352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323217352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323217352">(Jan 24 2023 at 10:47)</a>:</h4>
<p>What causes this slowdown? The fix or the non-fix?</p>



<a name="323217367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323217367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323217367">(Jan 24 2023 at 10:47)</a>:</h4>
<p>The fix</p>



<a name="323217404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323217404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323217404">(Jan 24 2023 at 10:47)</a>:</h4>
<p>Because it runs a tiny bit of code at the start and end of every tactic blocks</p>



<a name="323219425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323219425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323219425">(Jan 24 2023 at 10:57)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/18275">https://github.com/leanprover-community/mathlib/pull/18275</a></p>



<a name="323236699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323236699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323236699">(Jan 24 2023 at 12:21)</a>:</h4>
<p>A lot of these fixes seem very close to the tide (if not already underwater); should I PR those without the meta change or downstream fixes, so that they're available to mathlib3port asap?</p>



<a name="323267616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323267616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323267616">(Jan 24 2023 at 14:35)</a>:</h4>
<p>People might already be aware, but since it wasn't mentioned: in mathlib4 <code>classical</code> is actually a scoping tactic, and mathport has to do heroics to rewrite it because it's not written as a scoping tactic in lean 3. This would be a lot simpler if the syntax was just <code>classical { tacs }</code></p>



<a name="323267810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323267810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323267810">(Jan 24 2023 at 14:35)</a>:</h4>
<p>and that would also avoid the need to hack the interactive mode to do the cleanup action after the block</p>



<a name="323267970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323267970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323267970">(Jan 24 2023 at 14:36)</a>:</h4>
<p>Do scoping tactics have new syntax in Lean 4?</p>



<a name="323268109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268109">(Jan 24 2023 at 14:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">try</span> <span class="n">tac</span>
<span class="n">try</span>
  <span class="n">tac</span>
<span class="n">try</span> <span class="n">tac1</span><span class="bp">;</span> <span class="n">tac2</span>
<span class="n">try</span>
  <span class="n">tac1</span>
  <span class="n">tac2</span>
</code></pre></div>



<a name="323268235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268235">(Jan 24 2023 at 14:37)</a>:</h4>
<p>these are the equivalent of <code>try { tac }</code> and <code>try { tac1, tac2 }</code> respectively</p>



<a name="323268238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268238">(Jan 24 2023 at 14:37)</a>:</h4>
<p>I'm confused then, because I've seen mathlib4 proofs that seem to use <code>classical</code> like a regular tactic.</p>



<a name="323268341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268341">(Jan 24 2023 at 14:37)</a>:</h4>
<p>And <code>{ }</code> still exists but it always(?) means <code>focus1</code>, so watch out for that!</p>



<a name="323268360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268360">(Jan 24 2023 at 14:38)</a>:</h4>
<p>in particular</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">try</span>
<span class="n">tac</span>
</code></pre></div>
<p>is also <code>try { tac }</code></p>



<a name="323268494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268494">(Jan 24 2023 at 14:38)</a>:</h4>
<p>so if you don't indent it <code>classical</code> can kind of look like a non-scoping tactic</p>



<a name="323268551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268551">(Jan 24 2023 at 14:38)</a>:</h4>
<p>Is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">try</span>
<span class="n">tac</span>
<span class="n">tac2</span>
</code></pre></div>
<p><code>try { tac, tac2 }</code> or <code> try {tac}, tac2</code></p>



<a name="323268588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268588">(Jan 24 2023 at 14:38)</a>:</h4>
<p>the first</p>



<a name="323268691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268691">(Jan 24 2023 at 14:39)</a>:</h4>
<p>if you don't indent the block then you can't put anything after the block</p>



<a name="323268767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268767">(Jan 24 2023 at 14:39)</a>:</h4>
<p>I think I rejected the "use <code>classical { }</code> everywhere" approach because changing ~850 uses is really painful</p>



<a name="323268794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323268794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323268794">(Jan 24 2023 at 14:39)</a>:</h4>
<p>which happens to be the desired behavior for <code>classical</code> usually</p>



<a name="323269003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269003">(Jan 24 2023 at 14:40)</a>:</h4>
<p>is living with the status quo an option? Or using <code>classical!</code> which is not a scoping tactic</p>



<a name="323269114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269114">(Jan 24 2023 at 14:40)</a>:</h4>
<blockquote>
<p>is living with the status quo an option?</p>
</blockquote>
<p>We should apply the fixes (<a href="https://github.com/leanprover-community/mathlib/pull/18277">#18277</a>) whether or not we decide to keep the hack</p>



<a name="323269138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269138">(Jan 24 2023 at 14:40)</a>:</h4>
<p><code>classical!</code> had its own problems</p>



<a name="323269253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269253">(Jan 24 2023 at 14:41)</a>:</h4>
<p>the problems with <code>classical!</code> are all local though</p>



<a name="323269544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269544">(Jan 24 2023 at 14:42)</a>:</h4>
<p>Yes, but <code>classical!</code> can make things very annoying to prove, and make people say "why can't everything just be classical"</p>



<a name="323269579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269579">(Jan 24 2023 at 14:42)</a>:</h4>
<p>??</p>



<a name="323269689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269689">(Jan 24 2023 at 14:43)</a>:</h4>
<p>as a porting mechanism, we can just speculatively add <code>!</code> to all the classical proofs and revert the ones that break</p>



<a name="323269731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269731">(Jan 24 2023 at 14:43)</a>:</h4>
<p>That's not the problem though</p>



<a name="323269758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269758">(Jan 24 2023 at 14:43)</a>:</h4>
<p>and use a scoping tactic for those that remain</p>



<a name="323269771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269771">(Jan 24 2023 at 14:43)</a>:</h4>
<p>The problem is that there are proofs in mathlib3 that need <code>classical</code>, but don't actually have it</p>



<a name="323269809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269809">(Jan 24 2023 at 14:43)</a>:</h4>
<p>And they get by because the use of <code>classical</code> leaked from the previous lemma</p>



<a name="323269930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323269930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323269930">(Jan 24 2023 at 14:44)</a>:</h4>
<p>Mathlib4 plugs that leak, and now the subsequent <code>classical</code>-less proofs are broken</p>



<a name="323270049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323270049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323270049">(Jan 24 2023 at 14:44)</a>:</h4>
<p>it seems like this is the fault of the mathlib3 <code>classical</code> tactic, and we should avoid it</p>



<a name="323270170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323270170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323270170">(Jan 24 2023 at 14:45)</a>:</h4>
<p><code>classical!</code> works as a substitute in the majority of cases, and <code>with_classical</code> will solve the rest</p>



<a name="323270274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323270274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323270274">(Jan 24 2023 at 14:45)</a>:</h4>
<p>Does <code>with_classical</code> exist?</p>



<a name="323270323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323270323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323270323">(Jan 24 2023 at 14:45)</a>:</h4>
<p>that is to say <code>classical</code> but as a scoping tactic</p>



<a name="323270379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323270379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323270379">(Jan 24 2023 at 14:45)</a>:</h4>
<p>containing the cleanup actions discussed up-thread</p>



<a name="323270511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323270511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323270511">(Jan 24 2023 at 14:46)</a>:</h4>
<p>so you don't need to do the cleanup actions as part of every interactive block</p>



<a name="323270759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323270759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323270759">(Jan 24 2023 at 14:47)</a>:</h4>
<p>Yes, I think the following strategy works:</p>
<ul>
<li>Finish up adding the missing classicals in my PR</li>
<li>Replace all uses of <code>classical</code> with <code>classical!</code></li>
<li>Replace the ones that don't work with <code>with_classical</code></li>
<li>Make it a lint error to use <code>classical</code> or <code>classical!</code> in any new mathlib3 code; the former is bad for porting, the latter is bad for mathematicians</li>
</ul>



<a name="323270924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323270924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323270924">(Jan 24 2023 at 14:48)</a>:</h4>
<p>I think after steps 1-3 we can just rename <code>with_classical</code> to <code>classical</code> and make <code>classical,</code> a parse error</p>



<a name="323271112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323271112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323271112">(Jan 24 2023 at 14:48)</a>:</h4>
<p>I don't have a feel for how much work step 3 is</p>



<a name="323271302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323271302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323271302">(Jan 24 2023 at 14:49)</a>:</h4>
<p>I think we won't know until we see the fallout from steps 1-2</p>



<a name="323271334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60classical%60%20attribute%20leakage/near/323271334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60classical.60.20attribute.20leakage.html#323271334">(Jan 24 2023 at 14:49)</a>:</h4>
<p>Absolutely, and thankfully step 2 is easy</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
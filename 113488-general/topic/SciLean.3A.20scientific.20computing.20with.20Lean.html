---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html">SciLean: scientific computing with Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="268135865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268135865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268135865">(Jan 15 2022 at 17:10)</a>:</h4>
<p>For quite some time I have been working on a library that would allow writing scientific computing code in Lean. As Lean can formalize mathematics, I think it is an ideal programming language for math heavy code such as physics simulation or machine learning. Either as a way more powerful glue code, like Python, or leverage its meta programming capabilities, like Julia, or why not to turn Lean into computer algebra system, like Mathematica, if it already understands lots of mathematics.</p>
<p>I have finally arrived to a point where it makes sense to <a href="https://github.com/lecopivo/SciLean">share my code</a>.</p>
<p>Currently, I have only one working example worth mentioning and it is a simulation of wave equation, <a href="https://github.com/lecopivo/SciLean/blob/master/examples/WaveEquation.lean">full code</a>:</p>
<p>Wave equation can be defined through its Hamiltonian</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">H</span> <span class="o">(</span><span class="n">m</span> <span class="n">k</span> <span class="o">:</span> <span class="n">‚Ñù</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">p</span> <span class="o">:</span> <span class="n">‚Ñù</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="bp">Œî</span><span class="n">x</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">‚Ñù</span><span class="o">)</span><span class="bp">/</span><span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">‚Ñù</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">Œî</span><span class="n">x</span><span class="bp">/</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">m</span><span class="o">))</span> <span class="bp">*</span> <span class="bp">‚à•</span><span class="n">p</span><span class="bp">‚à•¬≤</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">Œî</span><span class="n">x</span> <span class="bp">*</span> <span class="n">k</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">‚àë</span> <span class="n">i</span><span class="o">,</span> <span class="bp">‚à•</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="bp">-</span> <span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">]</span><span class="bp">‚à•¬≤</span><span class="o">)</span>
</code></pre></div>
<p>(it is already discretized in space)</p>
<p>The simulation of such Hamiltonian system with Runge-Kutta 4 can be implemented with the following code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">solver</span> <span class="o">(</span><span class="n">m</span> <span class="n">k</span> <span class="o">:</span> <span class="n">‚Ñù</span><span class="o">)</span> <span class="o">(</span><span class="n">steps</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Impl</span> <span class="o">(</span><span class="n">ode_solve</span> <span class="o">(</span><span class="n">HamiltonianSystem</span> <span class="o">(</span><span class="n">H</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span><span class="o">)))</span> <span class="o">:=</span>
<span class="kd">by</span>
  <span class="c1">-- Unfold Hamiltonian definition and compute gradients</span>
  <span class="n">simp</span><span class="o">[</span><span class="n">HamiltonianSystem</span><span class="o">,</span> <span class="n">H</span><span class="o">]</span>
  <span class="n">autograd</span>
  <span class="n">autograd</span>

  <span class="c1">-- Apply RK4 method</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">ode_solve_fixed_dt</span> <span class="n">runge_kutta4_step</span><span class="o">]</span>
  <span class="n">lift_limit</span> <span class="n">steps</span> <span class="s2">"Number of ODE solver steps."</span><span class="bp">;</span> <span class="gr">admit</span><span class="bp">;</span> <span class="n">simp</span>

  <span class="n">finish_impl</span>
</code></pre></div>
<p>Roughly speaking:</p>
<ol>
<li><code>simp[HamiltonianSystem, H]; autograd; autograd</code> expands definitions and preform symbolic differentiation</li>
<li><code>rw [ode_solve_fixed_dt runge_kutta4_step]</code> replaces <code>noncomputable</code> function <code>ode_solve</code> with Runge-Kutta 4 integration scheme</li>
<li><code>lift_limit steps "Number of ODE solver steps."; admit; simp</code> says we are computing the specification only in an approximate sense and we choose <code>steps</code> integration steps</li>
</ol>
<p>This then produces this animation<br>
<a href="/user_uploads/3121/ts63y6cQx0HCjRuOCZJMOze_/wave.gif">wave.gif</a> </p>
<p>See the <a href="https://github.com/lecopivo/SciLean#example-simulation-of-harmonic-oscillator">readme</a> file for more detailed explanation. (It assumes you do not know Lean, so something might sound silly)</p>
<hr>
<p>The current state of the library is that I have a solid base which is capable automatically prove that function is smooth, linear or has adjoint and it can also automatically compute differentials, adjoints and gradients. To a very limited degree it can also automatically invert functions, but that is currently only used in computing adjoints of expressions involving sums, as you sometimes need to reindex sums.</p>
<p>There is tons of directions I would like to explore: </p>
<ol>
<li>
<p>Variational calculus <br>
   The above example shows wave equation that has already been discretized in space. I want to start with the continuous version of Hamiltonian and choose the space discretization in similar fashion as I picked the time discretization with RK4.<br>
   I have some rudimentary <a href="https://github.com/lecopivo/SciLean/blob/master/test/variational_calculus.lean#L21">results with functional derivative</a>. For this purpose I have smooth/linear lambda abstraction, i.e. you can write <code>Œª (x : X) (r : ‚Ñù) ‚ä∏ r*x</code> the <code>‚ä∏</code> indicate it is a linear function in every argument. Writing <code>Œª (r : ‚Ñù) ‚ä∏ r*r</code> produces error as the function is not linear.  <a href="https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Categories/Lin/Hom.lean#L135">example code</a></p>
</li>
<li>
<p>Numerical Algebra<br>
   I have already shared some of the results <a href="#narrow/stream/270676-lean4/topic/Interface.20for.20containers">here</a>, it mainly provides high level interface for array/tensor like objects.<br>
  Together with <span class="user-mention" data-user-id="451983">@Arthur Paulino</span>  we are working on a <a href="https://github.com/lecopivo/lean4-karray">library</a> that would allow somewhat automatically generating C code for unboxed arrays like FloatArray. Hopefully this will also extends to GPUs.<br>
  Wrapping existing linear solvers is also highly desirable.</p>
</li>
<li>
<p>Symbolic manipulation with polynomials <br>
   I want to do some computations with polynomials, differential forms and tensor products.<br>
   One big result I want is computational isomorphism between polynomials of <code>n+1</code> variables and polynomials in one variable but values in polynomials with <code>n</code> variables  i.e. <code>ùìü[‚Ñù‚Åø‚Å∫¬π, ‚Ñù] ‚âÖ ùìü[‚Ñù, ùìü[‚Ñù‚Åø, ‚Ñù]]</code>. This way, I can easily get Horner form of a polynomial(crucial for fast evaluation) in several variables just from Horner form of polynomial in one variable.<br>
  Some incoherent experimentation in this direction is <a href="https://github.com/lecopivo/SciLean/tree/master/SciLean/Math/Symbolic">here</a></p>
</li>
<li>
<p>(semi)Prismatic sets<br>
   In physics simulation, meshes are everywhere. Most commonly triangular or simplicial meshes. I want to have unified treatment of these and want to include meshes with quads, hexes, prisms and pyramids. I call these <code>prisms</code> and they can be generated by a <code>point</code> and two operations: <code>cone</code> and <code>prod</code>. I have inductive definition <a href="https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Data/Mesh/Prism.lean#L6">here</a>, for example line segment is <code>cone point</code>, square is product of two segments <code>prod (cone points) (cone point)</code>. The inclusion map of one Prism to another is represented by the inductive type <code>Prism.Face</code> and composition is <code>Face.ofFace</code>. This forms direct analog of simplex category(containing only inclusions). So I would like to define (semi)prismatic sets as presheaf over Prism category. This should be the core tool for dealing with meshes on top of which I can start building finite element/difference/volume code.</p>
</li>
<li>
<p>Machine learning<br>
   I have defined the code for <a href="https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Operators/Calculus/Basic.lean#L47">forward</a> and <a href="https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Operators/Calculus/Basic.lean#L56">reverse</a> mode differential operators and their core simplification identities, <a href="https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Operators/Calculus/ForwardDiff.lean#L27">forward</a> and <a href="https://github.com/lecopivo/SciLean/blob/db8acbe19286ea211677d20060f511193f037090/SciLean/Operators/Calculus/ReverseDiff.lean#L21">reverse</a>.  These identities are expressing nothing more then functionality of (co)tangent map between manifolds. The task is to generalize the <a href="https://github.com/lecopivo/SciLean/blob/master/SciLean/Operators/Calculus/Differential.lean">identities</a> I have for normal differential to these two differential operators. Then we can hopefully unleash it on my <a href="https://github.com/lecopivo/SciLean/blob/master/examples/VGG.lean">mockup of VGG</a> and hopefully get back-propagation.</p>
</li>
</ol>
<hr>
<p>I'm happy to hear any comments, suggestions. Or if anyone is interested in any of these topics I'm happy for any helping hand :) </p>
<p>However, the current thing I should focus on is probably optimizing order/priority of all simp lemmas and type class instances. As timeouts are sometimes really bad and I'm constantly running into infinite loops.</p>



<a name="268136159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268136159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ya√´l Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268136159">(Jan 15 2022 at 17:15)</a>:</h4>
<p>Wow, that's great! This is part of my Cambridge computing project, so I'll refrain to look at the code <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="268136902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268136902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268136902">(Jan 15 2022 at 17:30)</a>:</h4>
<p>Is this the first "real" project depending on Mathlib4?</p>



<a name="268137687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268137687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268137687">(Jan 15 2022 at 17:46)</a>:</h4>
<p>That's some decent amount of work <span aria-label="open mouth" class="emoji emoji-1f62e" role="img" title="open mouth">:open_mouth:</span> <br>
The usability of a machine learning lib is highly dependent on the existence of model deployment tools or at least a nice interactive REPL environment, so I think it would be a lower priority target at the moment</p>



<a name="268145725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268145725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268145725">(Jan 15 2022 at 20:34)</a>:</h4>
<p>Another big direction I want to take is to use diffeological spaces to work with manifolds. Currently, I'm working only with convenient vector spaces and smooth maps between them. Therefore, I can't for example say what is a smooth map between spaces of all invertible functions. At some point I want to formulate fluid simulation as a geodesic path on the space of all volume preserving maps.</p>
<p>(I'm not actually fully formalizing all the math, not even providing full definitions, but I'm just peeking in to books and making sure it can be fully formalized at some point. Right now, I'm focusing on the computational aspect of it.)</p>
<p>I have very limited understanding of diffeology, so having someone who understands it would be nice. My current idea is to maybe to work only with diffeological spaces that are quotients of vector spaces and smooth map would be defined as a quotient of a smooth map. Not sure sure if this is a completely valid but should preserve reasonably well the computational aspect. It also naturally reflects how we usually work computationally with manifolds. For example, a point on a sphere is modeled as (x,y,z) with a condition |(x,y,z)| = 1. From time to time you have to project the point back on the sphere. This projection exactly defines the relation with which you take the quotient. Computationally, this is way way better then covering sphere with some maps and working with those. </p>
<p>Also I know there are some problems with tangent spaces of a general diffeological spaces that I do not fully understand. This probably gives some condition on the relation with which I would do the quotient. Maybe defining the relation based on a function satisfying implicit function theorem?</p>



<a name="268148954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268148954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268148954">(Jan 15 2022 at 21:50)</a>:</h4>
<p>I think it's really great that someone tries to do numerical analysis in Lean! I had no idea that diffeological spaces could be useful in numerical maths. I only very vaguely know them as an esoteric corner of differential geometry. I wasn't aware of any link with anything else than diffeological spaces applied to diffeological spaces.</p>



<a name="268149656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268149656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268149656">(Jan 15 2022 at 22:06)</a>:</h4>
<p>For example this paper on differentiable programming: <a href="https://dl.acm.org/doi/10.1145/3434284">ùúÜ‚Çõ: computable semantics for differentiable programming with higher-order functions and datatypes</a> uses diffeological spaces as a tool for soundness of their method.</p>
<p>I'm mostly following the first chapter of <a href="https://www.mat.univie.ac.at/~michor/apbookh-ams.pdf">The Convenient Setting of Global Analysis</a>. I especially like the part of the introduction:</p>
<blockquote>
<p>An eminent mathematician once said that for infinite dimensional calculus each<br>
serious application needs its own foundation. By a serious application one obviously<br>
means some application of a hard inverse function theorem. These theorems can<br>
be proved, if by assuming enough a priori estimates one creates enough Banach<br>
space situation for some modified iteration procedure to converge. Many authors<br>
try to build their platonic idea of an a priori estimate into their differential calculus.<br>
We think that this makes the calculus inapplicable and hides the origin of the a<br>
priori estimates. We believe that the calculus itself should be as easy to use as<br>
possible, and that all further assumptions (which most often come from ellipticity<br>
of some nonlinear partial differential equation of geometric origin) should be treated<br>
separately, in a setting depending on the specific problem</p>
</blockquote>
<p>This totally aligns with my experience from my studies, mostly analysis and PDEs, and the total disconnect on how mathematicians and physicist treat similar problems.</p>
<p>All transformations in SciLean can be(hopefully will be one day) formally argued by using convenient calculus (or diffeological spaces). To actually prove any kind of convergence of the generated algorithms you then have to go and manually provide some apriory estimates, choose correct Banach/Sobolev space etc. However, this is not a task I'm particularly interested in and it is super hard(yes looking at you Navier-Stokes).</p>



<a name="268149835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268149835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268149835">(Jan 15 2022 at 22:10)</a>:</h4>
<p>My hope is to automatically prove consistency i.e. if the algorithm converges then it actually solves the specified problem.</p>
<p>However, the overruling principle is to minimize the human time it takes to go from formal specification of the problem to the actually executable code.</p>



<a name="268178397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268178397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268178397">(Jan 16 2022 at 11:03)</a>:</h4>
<p>This is really surprising to me. It would be really super nice if this were actually useful. But I fear you'll have a very hard time finding experts here. Maybe you should email the authors of this paper and try to get them interested?</p>



<a name="268179936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268179936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268179936">(Jan 16 2022 at 11:47)</a>:</h4>
<p>I will try that, but maybe I should read that paper properly first :)</p>



<a name="268195086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268195086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268195086">(Jan 16 2022 at 16:54)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> I'll mention that Ben Sherman (the first author of the paper) knows Lean -- he was an intern at Galois when we were working on formalizing a distributed protocol.</p>



<a name="268195119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268195119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268195119">(Jan 16 2022 at 16:55)</a>:</h4>
<p>Cool! Thanks a lot.</p>



<a name="268601196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/SciLean%3A%20scientific%20computing%20with%20Lean/near/268601196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/SciLean.3A.20scientific.20computing.20with.20Lean.html#268601196">(Jan 19 2022 at 20:49)</a>:</h4>
<p>ASCII art is cool but fully raytraced animations are cooler. I wrote a plugin for Houdini, software for visual effects similar to Blender,  and now I can use Lean a scripting language in it. Visualization of the wave simulation: <a href="/user_uploads/3121/Z0lCO-Jjyo_Y8n_HOinDitGW/wave.mp4">wave.mp4</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
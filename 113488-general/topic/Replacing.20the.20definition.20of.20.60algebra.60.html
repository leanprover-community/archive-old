---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html">Replacing the definition of `algebra`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="235947738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235947738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235947738">(Apr 24 2021 at 06:50)</a>:</h4>
<p>The current definition of an algebra has a severe problem: if you have type <code>X</code> with an existing <code>module R X</code> structure, it's impossible to put an <code>algebra R X</code> structure on it in such a way that the <code>module R X</code> structure derived from that <code>algebra R X</code> will be definitionally equal to the original one.</p>
<p>(I ran into this just now trying to prove Schur's lemma in an <code>R</code>-linear category with finite dimensional hom spaces: every <code>X  ‚ü∂ Y</code> has a <code>module R (X ‚ü∂ Y)</code>, but we also need to talk about the <code>algebra R (X ‚ü∂ X)</code> structures.)</p>
<p>Oliver Nash and I were trying a few weeks ago to replace this definition, moving to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">smul_mul_assoc'</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="o">(</span><span class="n">t</span> <span class="bp">‚Ä¢</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">‚Ä¢</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span>
<span class="o">(</span><span class="n">mul_smul_comm'</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">t</span> <span class="bp">‚Ä¢</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">‚Ä¢</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span>
</code></pre></div>
<p>Unfortunately it was proving a lot of work. About three weeks ago we ground to a halt, and in the intervening time <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>'s diamond refactoring PRs have arrived, and I'm not at all confident I can bring the existing half-working <a href="https://github.com/leanprover-community/mathlib/tree/replace_algebra_def">branch#replace_algebra_def</a> up to master (I've just tried, and pushed, but who knows what state it is in... It's going to have further collisions with <a href="https://github.com/leanprover-community/mathlib/issues/7255">#7255</a>.)</p>



<a name="235947761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235947761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235947761">(Apr 24 2021 at 06:51)</a>:</h4>
<p>This alternative definition also has the nice feature that it generalises immediately to nonassociative and nonunital settings, unlike the current design.</p>



<a name="235947804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235947804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235947804">(Apr 24 2021 at 06:52)</a>:</h4>
<p>I'm definitely game to work on this some more, but I thought it might be worth doing some coordination here first.</p>



<a name="235947850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235947850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235947850">(Apr 24 2021 at 06:53)</a>:</h4>
<p>Perhaps the best strategy is actually to abandon the existing <a href="https://github.com/leanprover-community/mathlib/tree/replace_algebra_def">branch#replace_algebra_def</a> (this makes me sad, and will probably make <span class="user-mention" data-user-id="240862">@Oliver Nash</span> even sadder, as he'd done a lot of work here!), and start over, after both <a href="https://github.com/leanprover-community/mathlib/issues/7255">#7255</a> and <span class="user-mention" data-user-id="238446">@Anne Baanen</span>'s <a href="https://github.com/leanprover-community/mathlib/issues/7322">#7322</a>.</p>



<a name="235947895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235947895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235947895">(Apr 24 2021 at 06:54)</a>:</h4>
<p>Advice, complaints, or promises to contribute to the next attempt all welcome. :-)</p>



<a name="235951473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235951473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235951473">(Apr 24 2021 at 08:02)</a>:</h4>
<p>I don't understand your first comment - surely <code>smul := has_scalar.smul</code> ensures definitional equality?</p>



<a name="235956072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235956072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235956072">(Apr 24 2021 at 09:10)</a>:</h4>
<p>Hmm, okay, you're absolutely right, my problem in Schur's lemma is not about <code>algebra</code>. It is something even more basic, where I have an <code>add_comm_group</code> which is also a <code>ring</code>, and Lean can't see that it's only an <code>add_comm_group</code> in one way. :-(</p>



<a name="235956168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235956168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235956168">(Apr 24 2021 at 09:13)</a>:</h4>
<p>If anyone feels like having a look at <code>findim_endomorphism_simple_eq_one</code> in <code>schur.lean</code> on <a href="https://github.com/leanprover-community/mathlib/tree/schur2">branch#schur2</a>, I am stumped. If I can just get the <code>obtain</code> line to work everything is fine.</p>



<a name="235961565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235961565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235961565">(Apr 24 2021 at 10:59)</a>:</h4>
<p>I had a look. The thing that creates problem is that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">findim_endomorphism_simple_eq_one</span>
  <span class="o">[</span><span class="n">linear</span> <span class="bp">ùïú</span> <span class="n">C</span><span class="o">]</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">[</span><span class="n">simple.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">I</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="bp">ùïú</span> <span class="o">(</span><span class="n">X</span> <span class="bp">‚ü∂</span> <span class="n">X</span><span class="o">)]</span> <span class="o">:</span>

<span class="bp">@</span><span class="n">finite_dimensional</span> <span class="bp">ùïú</span> <span class="o">(</span><span class="bp">@</span><span class="n">End</span> <span class="n">C</span> <span class="o">(</span><span class="bp">@</span><span class="n">category.to_category_struct</span> <span class="n">C</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">X</span><span class="o">)</span> <span class="n">_inst_4</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">preadditive.category_theory.End.add_comm_group</span> <span class="n">C</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span> <span class="n">X</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">linear.category_theory.End.module</span> <span class="n">C</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span> <span class="bp">ùïú</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="bp">ùïú</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="bp">ùïú</span> <span class="n">_inst_4</span><span class="o">))</span>
       <span class="n">_inst_6</span>
       <span class="n">X</span><span class="o">)</span>
  <span class="bp">=</span>
  <span class="bp">@</span><span class="n">finite_dimensional</span> <span class="bp">ùïú</span> <span class="o">(</span><span class="bp">@</span><span class="n">End</span> <span class="n">C</span> <span class="o">(</span><span class="bp">@</span><span class="n">category.to_category_struct</span> <span class="n">C</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">X</span><span class="o">)</span> <span class="n">_inst_4</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_add_comm_group</span> <span class="o">(</span><span class="bp">@</span><span class="n">End</span> <span class="n">C</span> <span class="o">(</span><span class="bp">@</span><span class="n">category.to_category_struct</span> <span class="n">C</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">X</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">preadditive.category_theory.End.ring</span> <span class="n">C</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span> <span class="n">X</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">algebra.to_semimodule</span> <span class="bp">ùïú</span> <span class="o">(</span><span class="bp">@</span><span class="n">End</span> <span class="n">C</span> <span class="o">(</span><span class="bp">@</span><span class="n">category.to_category_struct</span> <span class="n">C</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">X</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring</span> <span class="bp">ùïú</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="bp">ùïú</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="bp">ùïú</span> <span class="n">_inst_4</span><span class="o">)))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="o">(</span><span class="bp">@</span><span class="n">End</span> <span class="n">C</span> <span class="o">(</span><span class="bp">@</span><span class="n">category.to_category_struct</span> <span class="n">C</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="n">X</span><span class="o">)</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">preadditive.category_theory.End.ring</span> <span class="n">C</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span> <span class="n">X</span><span class="o">))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">linear.category_theory.End.algebra</span> <span class="n">C</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span> <span class="bp">ùïú</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="bp">ùïú</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="bp">ùïú</span> <span class="n">_inst_4</span><span class="o">))</span>
          <span class="n">_inst_6</span>
          <span class="n">X</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>
<p>fails. If you try to <code>congr</code> it away, you see that the first problem it encounters is with two <code>add_comm_group</code> which are obvisouly the same, but where Lean can not see it. Probably for lack of beta-reduction (or whatever greek letter is meant here): two structures have the same fields which are all defeq, but the structures themselves are not defeq. A way out is to make sure that the first structure is also an assembly of stuff, and not a monolithic structure, by replacing the line 89 of <code>preadditive/default.lean</code> with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">End</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="bp">..</span> <span class="n">preadditive.hom_group</span> <span class="n">X</span> <span class="n">X</span> <span class="o">}</span>
</code></pre></div>
<p>Once this is done, Lean can see that both <code>add_comm_group</code>s are defeq. Then it runs into the second problem that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">linear.category_theory.End.module</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">algebra.to_semimodule</span>
</code></pre></div>
<p>is not defeq either. I have not yet investigated this one.</p>



<a name="235961742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235961742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235961742">(Apr 24 2021 at 11:02)</a>:</h4>
<p>Thanks very much <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> for having a look at this (I've been banging my head on this!!)</p>



<a name="235961745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235961745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235961745">(Apr 24 2021 at 11:02)</a>:</h4>
<p>I found that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">obtain</span> <span class="o">‚ü®</span><span class="n">c</span><span class="o">,</span> <span class="n">nu</span><span class="o">‚ü©</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">exists_spectrum_of_is_alg_closed_of_finite_dimensional</span> <span class="bp">ùïú</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">End</span> <span class="n">X</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
    <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">I</span><span class="o">,</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span> <span class="o">})</span> <span class="o">(</span><span class="n">End.of</span> <span class="n">f</span><span class="o">),</span>
</code></pre></div>



<a name="235961751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235961751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235961751">(Apr 24 2021 at 11:02)</a>:</h4>
<p>works, if I run</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="n">add_comm_group</span> <span class="n">semimodule</span> <span class="n">distrib_mul_action</span> <span class="n">mul_action</span> <span class="n">has_scalar</span>
</code></pre></div>
<p>before embarking on the proof.</p>



<a name="235961794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235961794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235961794">(Apr 24 2021 at 11:03)</a>:</h4>
<p>Then <code>ext</code> blasts through to the fields, and <code>refl</code> verifies they really do match up.</p>



<a name="235961803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235961803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235961803">(Apr 24 2021 at 11:03)</a>:</h4>
<p>This exactly fits with your diagnosis.</p>



<a name="235961877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235961877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235961877">(Apr 24 2021 at 11:04)</a>:</h4>
<p>I'll see if your <code>{ .. }</code> trick (which I'm not sure whether I love or loath... :-) can solve the semimodule problem too.</p>



<a name="235961995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235961995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235961995">(Apr 24 2021 at 11:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235947850">said</a>:</p>
<blockquote>
<p>Perhaps the best strategy is actually to abandon the existing <a href="https://github.com/leanprover-community/mathlib/tree/replace_algebra_def">branch#replace_algebra_def</a> (this makes me sad, and will probably make <span class="user-mention silent" data-user-id="240862">Oliver Nash</span> even sadder, as he'd done a lot of work here!), and start over, after both <a href="https://github.com/leanprover-community/mathlib/issues/7255">#7255</a> and <span class="user-mention silent" data-user-id="238446">Anne Baanen</span>'s <a href="https://github.com/leanprover-community/mathlib/issues/7322">#7322</a>.</p>
</blockquote>
<p>While I note that Eric has pointed out that we actually can solve the defeq problem by clobbering <code>smul</code>, I still plan to try to change the definition of <code>algebra</code> and I agree that we should probably just abandon <a href="https://github.com/leanprover-community/mathlib/tree/replace_algebra_def">branch#replace_algebra_def</a>. I'm hoping to start again with a fresh branch in a week or so, hopefully after <a href="https://github.com/leanprover-community/mathlib/issues/7255">#7255</a> and <a href="https://github.com/leanprover-community/mathlib/issues/7322">#7322</a> have landed.</p>



<a name="235962013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962013">(Apr 24 2021 at 11:07)</a>:</h4>
<p>It's totally doable, just a matter of being persistent enough.</p>



<a name="235962152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962152">(Apr 24 2021 at 11:09)</a>:</h4>
<p>I am really starting to wonder it we should ditch once and for all old style structures, and go for new style structures. It should solve this problem as the structures would not be a bunch of random fields, but nice functions to the substructures that the structure extends, that we could arrange for equality in this kind of situation. Of course, this would be a crazy refactor, but we will probably have to do it at some point (both to solve our performance problems, this kind of issue, and to port to Lean 4)...</p>



<a name="235962286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962286">(Apr 24 2021 at 11:11)</a>:</h4>
<p><span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span> Oh boy. :-) We should have listened to Leo back in ... 2017?</p>



<a name="235962559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962559">(Apr 24 2021 at 11:16)</a>:</h4>
<p>I wonder if we could write some code to perform such a refactor. It would be an awesome validation of the value of digital formalisation if it could be done. Most of the effort for a human carrying out such a task would be pretty  automatic and I bet that even when there is a choice to be made, it's usually from a smallish list so I could imagine some localised brute force approach would work.</p>



<a name="235962609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962609">(Apr 24 2021 at 11:17)</a>:</h4>
<p>Don't new style structures make this problem go away for only one "canonical" path through the algebra heirarchy DAG?</p>



<a name="235962667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962667">(Apr 24 2021 at 11:18)</a>:</h4>
<p>And leave exactly the same problem for non-canonical paths</p>



<a name="235962684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962684">(Apr 24 2021 at 11:18)</a>:</h4>
<p>I still think most of it should be human-driven, since there are choices to be made (i.e., what is the most important path along which we will go down the instances -- this is what one should extend) and what is more accessory. But I think it wouldn't be that bad, in fact.</p>



<a name="235962702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962702">(Apr 24 2021 at 11:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235962609">said</a>:</p>
<blockquote>
<p>Don't new style structures make this problem go away for only one "canonical" path through the algebra heirarchy DAG?</p>
</blockquote>
<p>Yes, exactly, it only solves the problem along the canonical paths. Which we should choose wisely to minimize the number of issues.</p>



<a name="235962788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962788">(Apr 24 2021 at 11:20)</a>:</h4>
<p>My impression is that the problem we're seeing here is due to different paths being taken in different places</p>



<a name="235962849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962849">(Apr 24 2021 at 11:21)</a>:</h4>
<p>So making one or the other canonical won't help</p>



<a name="235962874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235962874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235962874">(Apr 24 2021 at 11:21)</a>:</h4>
<p>No, here it is really: define an <code>add_comm_group</code> instance <code>foo</code> on something, then defining a <code>ring</code> instance <code>bar</code> with <code>{ ..., .. foo}</code>, and then <code>bar.to_add_comm_group</code> is not defeq to <code>foo</code>.</p>



<a name="235965638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235965638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235965638">(Apr 24 2021 at 12:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235962152">said</a>:</p>
<blockquote>
<p>I am really starting to wonder it we should ditch once and for all old style structures, and go for new style structures. </p>
</blockquote>
<p>Really I'm not competent to judge. But Leo, who thought about the whole system more than anyone else by several order of magnitude, has a very strong opinion about this. I don't see how he could tell us more clearly that he thinks we should be using new structures.</p>



<a name="235966907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235966907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235966907">(Apr 24 2021 at 12:32)</a>:</h4>
<p>One could imagine a "bit by bit" refactor where leaves are turned into new structures first. </p>
<p>What would a typical refactor look like, turning an old structure into a new structure? I personally don't know the difference between old structures and new structures, it's just some CS thing as far as I am concerned. One would delete the <code>old_structure_cmd</code> line, and then everything breaks, and then one redefines the structure causing the problem and/or adds a bunch of projection lemmas which used to be generated and now aren't?</p>



<a name="235967164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235967164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235967164">(Apr 24 2021 at 12:36)</a>:</h4>
<p>Here's a concrete question. It seems to me that <code>topology.algebra.open_subgroup</code> is only imported by <code>topology.algebra.nonarchimedean</code>, which is not imported by anything. Does it make sense to see what happens if we delete <code>set_option old_structure_cmd true</code> in that file and refactor? Or does the whole thing have to be done in one go?</p>



<a name="235968080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235968080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235968080">(Apr 24 2021 at 12:53)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7355">#7355</a> It wasn't that hard to change <code>open_subgroup</code>. What difficulties will one run into in general? Ones of the form I saw (<code>cases U</code> changed behaviour) or far nastier ones? One down, about 50 to go!</p>



<a name="235968449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235968449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235968449">(Apr 24 2021 at 13:00)</a>:</h4>
<p>One type of the change that will come up - if you change <code>comm_group</code> to new style, you'll have to add a  new <code>mul_comm</code> field.</p>



<a name="235969018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969018">(Apr 24 2021 at 13:08)</a>:</h4>
<p>OK so I just deleted all of them in one go (the vast majority are in <code>src/algebra</code> BTW) and the first thing that breaks is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`. -/</span>
<span class="kd">@[ancestor add_semigroup add_zero_class]</span>
<span class="kd">class</span> <span class="n">add_monoid</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">add_semigroup</span> <span class="n">M</span><span class="o">,</span> <span class="n">add_zero_class</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">nsmul</span> <span class="o">:</span> <span class="n">‚Ñï</span> <span class="bp">‚Üí</span> <span class="n">M</span> <span class="bp">‚Üí</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">nsmul_rec</span><span class="o">)</span>
<span class="o">(</span><span class="n">nsmul_zero'</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="n">x</span><span class="o">,</span> <span class="n">nsmul</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">.</span> <span class="n">try_refl_tac</span><span class="o">)</span>
<span class="o">(</span><span class="n">nsmul_succ'</span> <span class="o">:</span> <span class="bp">‚àÄ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">‚Ñï</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span> <span class="n">nsmul</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">nsmul</span> <span class="n">n</span> <span class="n">x</span> <span class="bp">.</span> <span class="n">try_refl_tac</span><span class="o">)</span>
</code></pre></div>
<p>I get an error on <code>add_zero_class M</code> in <code>extends add_semigroup M, add_zero_class M</code> and the error is</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>invalid 'structure' header, field 'to_has_add' from 'add_zero_class' has already been declared
</code></pre></div>
<p>So this means...what?  add_semigroups and add_zero_classes both have an <code>add</code>, I guess, but the actual complaint is that <code>add_semigroup.to_has_add</code> and <code>add_zero_class.to_has_add</code> both exist. </p>
<p>Is one fix for this to literally not <code>extend</code> anything and just to write all the fields all over again and then just define the projections manually?</p>



<a name="235969462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969462">(Apr 24 2021 at 13:15)</a>:</h4>
<p>That's the only fix - you only get to extend things that don't overlap</p>



<a name="235969476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969476">(Apr 24 2021 at 13:15)</a>:</h4>
<p>So you have to decide which is most canonical</p>



<a name="235969535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969535">(Apr 24 2021 at 13:16)</a>:</h4>
<p>Eg, <code>comm_ring</code> can only extend one of <code>ring</code>, and <code>comm_semiring</code></p>



<a name="235969558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969558">(Apr 24 2021 at 13:17)</a>:</h4>
<p>I suspect the correct choice is always the one with more data, in this case <code>ring</code> which has neg and sub</p>



<a name="235969632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969632">(Apr 24 2021 at 13:18)</a>:</h4>
<p>Right. So for example with <code>add_monoid</code> it seems the thing to extend is <code>add_zero_class</code> and then add <code>assoc</code> manually. I'm currently trying to figure out how to prove a monoid is a semigroup.</p>



<a name="235969678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969678">(Apr 24 2021 at 13:19)</a>:</h4>
<p>ooh suddenly loads of errors disappeared. This is quite satisfying. This is going to be a major but do-able refactor.</p>



<a name="235969733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969733">(Apr 24 2021 at 13:20)</a>:</h4>
<p>It might be worth agreeing on canonical paths before going too far with this</p>



<a name="235969759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969759">(Apr 24 2021 at 13:20)</a>:</h4>
<p>Eg, get a graphviz file with the instance heirarchy, and agree on the correct spanning tree and highlight it in a different color.</p>



<a name="235969761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969761">(Apr 24 2021 at 13:20)</a>:</h4>
<p>Yes this is why I started, to try and understand what the main issues were.</p>



<a name="235969823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235969823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235969823">(Apr 24 2021 at 13:21)</a>:</h4>
<p>And to be quite honest the other reason I'm interested is that I trust Leo.</p>



<a name="235970238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235970238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235970238">(Apr 24 2021 at 13:29)</a>:</h4>
<p>So I think the biggest impact of this change would be that we end up with tens of copies of <code>(mul/add)_(assoc_comm)</code></p>



<a name="235970249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235970249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235970249">(Apr 24 2021 at 13:29)</a>:</h4>
<p>A custom <code>newish_structure</code> command could generate those and the projections automatically though</p>



<a name="235970991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235970991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235970991">(Apr 24 2021 at 13:42)</a>:</h4>
<p>Lol, we have to decide which of <code>cancel_monoid -&gt; left_cancel_monoid -&gt; monoid</code> and <code>cancel_monoid -&gt; right_cancel_monoid -&gt; monoid</code> is canonical</p>



<a name="235971314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235971314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235971314">(Apr 24 2021 at 13:48)</a>:</h4>
<p>Yeah, it is difficult to do this in my head. I am now staring at <code>cancel_comm_monoid</code> and trying to figure out whether I should be going to <code>left_cancel_monoid</code> or <code>comm_monoid</code>. In fact I realise now I don't understand what is going on. Presumably we still need the four theorems that a cancel_monoid is a left/right_cancel_monoid and a left/right_cancel_monoid is a monoid? And presumably they all have to be instances? I'm just showing my ignorance of the problem.</p>



<a name="235971807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235971807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235971807">(Apr 24 2021 at 13:58)</a>:</h4>
<p>OK so on the <code>delete-old-structures</code> branch I deleted all old_structure_cmds and I fixed what looked like one of the most challenging files -- algebra/group/defs (of course I'll have broken a lot of the files it depends on). You can see what the diff looks like <a href="https://github.com/leanprover-community/mathlib/compare/delete-old-structures?expand=1#diff-9860a3e2f558fa016e7026f97d27d9196714b9948782edcc6b572689d674d839">here</a></p>



<a name="235971930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235971930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235971930">(Apr 24 2021 at 14:00)</a>:</h4>
<p>Yes, anything you remove from <code>extends</code> has to be added as an instance</p>



<a name="235971973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235971973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235971973">(Apr 24 2021 at 14:00)</a>:</h4>
<p>You could avoid tie breaking by saying neither left nor right is canonical, and have <code>cancel_monoid</code> extend <code>monoid</code></p>



<a name="235976491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235976491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian K√ºlshammer <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235976491">(Apr 24 2021 at 15:01)</a>:</h4>
<p>Given that mathlib (currently) seems to favour left modules, I would choose <code>left_cancel_monoid</code>.</p>



<a name="235977096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/235977096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#235977096">(Apr 24 2021 at 15:04)</a>:</h4>
<p>Anyway, there won't be a lot of things extending <code>cancel_monoid</code>, so this shouldn't really matter. There are essentially two kinds of classes: those that really play a role in the main hierarchy, and those that are merely gadgets to be able to state theorems in the right generality. The gadgets should probably never appear in the main hierarchy: there should be instances from the main classes to the gadgets, and theorems proved assuming the right gadget class.</p>



<a name="236029460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236029460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236029460">(Apr 25 2021 at 02:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235970249">said</a>:</p>
<blockquote>
<p>A custom <code>newish_structure</code> command could generate those and the projections automatically though</p>
</blockquote>
<p>As one of the main proponents for old structures, I should probably say something about this. The main technical problem with new structures as currently implemented in lean 3 is that they outright reject diamond inheritance. What I think it should do instead is that given <code>extends A, B, C</code> it will classify the superclasses according to whether they contain any fields also present in any superclasses earlier in the list (in which case they are marked non-canonical). All canonical superclasses are embedded, and non-canonical superclasses get a pack/unpack parent instance. That way, this is the same as new structures when there are no diamonds, and the same as old structures when there are diamonds, and when there is a mix it just does the right thing</p>



<a name="236029529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236029529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236029529">(Apr 25 2021 at 02:12)</a>:</h4>
<p>This doesn't change the observation made up-thread that we should be careful to make sure we get the right spanning tree of canonical extensions</p>



<a name="236079708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236079708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236079708">(Apr 25 2021 at 17:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235969733">said</a>:</p>
<blockquote>
<p>It might be worth agreeing on canonical paths before going too far with this</p>
</blockquote>
<p>I don't understand what this means. If foo extends bar1 and bar2, and both bar1 and bar2 extend bar, then we still surely need all the theorems foo -&gt; bar1, foo -&gt; bar2, bar1 -&gt; bar and bar2 -&gt; bar, so surely a defeq diamond is inevitable? Are we talking about priorities? I am a complete amateur at type class inference, I have little understanding of how it works and little understanding of the difference between old and new structures and little understanding of the issues in this thread, but I am interested to learn, not least because I can now finally announce that Oliver Nash is going to be my post-doc for the next three years and I'd like to understand what he's doing!</p>



<a name="236080045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080045">(Apr 25 2021 at 17:19)</a>:</h4>
<p>The issue isn't about defeq diamonds, but rather about minimizing the number of non-compositional(? - we need a name for this) instances, that is, instances where bar1 is not literally a member of foo and so we have to explode foo into fields and put them back together to produce an instance of bar1. These instances are large when foo has many fields and so we want to keep them to a minimum, but composition is necessarily diamond-free so they can't all be compositional instances</p>



<a name="236080143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080143">(Apr 25 2021 at 17:20)</a>:</h4>
<p>An example: <code>semiring</code> could either extend <code>monoid_with_zero</code> and <code>has_one</code>, or it could extend <code>add_comm_monoid</code> and <code>monoid</code>. The second choice is clearly better than the first, since you will encounter much more often reductions of semirings to monoids and add_comm_monoids than to the more exotic <code>monoid_with_zero</code>.</p>



<a name="236080353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080353">(Apr 25 2021 at 17:23)</a>:</h4>
<p>PS this from the <a href="https://arxiv.org/abs/2001.04301">tabled typeclass resolution</a> paper (the number is the number of routes to has_add, other than the 0 on has_add which is presumably an edge case)</p>
<p><a href="/user_uploads/3121/KpPoEfmPtZN8J2V0uq33SpF3/routes_to_has_add.png">routes_to_has_add.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/KpPoEfmPtZN8J2V0uq33SpF3/routes_to_has_add.png" title="routes_to_has_add.png"><img src="/user_uploads/3121/KpPoEfmPtZN8J2V0uq33SpF3/routes_to_has_add.png"></a></div>



<a name="236080459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080459">(Apr 25 2021 at 17:25)</a>:</h4>
<p>Here's a simple demonstration of the difference between old style and new style. In both cases I'm simulating what <code>extends</code> would do if you didn't have the keyword:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">bar1</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">bar2</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>

<span class="c1">-- new structure style inheritance</span>
<span class="kn">namespace</span> <span class="n">new_structure</span>
<span class="kd">class</span> <span class="n">foo</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_bar1</span> <span class="o">:</span> <span class="n">bar1</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="o">(</span><span class="n">to_bar2</span> <span class="o">:</span> <span class="n">bar2</span> <span class="n">Œ±</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">foo.bar1</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">[</span><span class="n">foo</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">bar1</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="n">foo.to_bar1</span>
<span class="kd">instance</span> <span class="n">foo.bar2</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">[</span><span class="n">foo</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">bar2</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="n">foo.to_bar2</span>
<span class="kd">end</span> <span class="n">new_structure</span>

<span class="c1">-- old structure style inheritance</span>
<span class="kn">namespace</span> <span class="n">old_structure</span>
<span class="kd">class</span> <span class="n">foo</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">foo.bar1</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">[</span><span class="n">foo</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">bar1</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:=</span> <span class="n">foo.x</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">foo.y</span><span class="o">}</span>
<span class="kd">instance</span> <span class="n">foo.bar2</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">[</span><span class="n">foo</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">bar2</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{</span><span class="n">z</span> <span class="o">:=</span> <span class="n">foo.z</span><span class="o">,</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">foo.w</span><span class="o">}</span>
<span class="kd">end</span> <span class="n">old_structure</span>
</code></pre></div>



<a name="236080619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080619">(Apr 25 2021 at 17:28)</a>:</h4>
<p>And here's an example where <code>bar1</code> uses new style inheritance and <code>bar2</code> uses old style inheritance (they can't both use new style in this case because of the shared field <code>x</code>):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">bar1</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">bar2</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">mixed_structure</span>
<span class="kd">class</span> <span class="n">foo</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_bar1</span> <span class="o">:</span> <span class="n">bar1</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">foo.bar1</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">[</span><span class="n">foo</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">bar1</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="n">foo.to_bar1</span>
<span class="kd">instance</span> <span class="n">foo.bar2</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">[</span><span class="n">foo</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">bar2</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:=</span> <span class="n">bar1.x</span><span class="o">,</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">foo.z</span><span class="o">}</span>
<span class="kd">end</span> <span class="n">mixed_structure</span>
</code></pre></div>



<a name="236080623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080623">(Apr 25 2021 at 17:28)</a>:</h4>
<p><del>Oh! I thought that the interesting question was when you wanted to extend things which had overlapping fields. But here this is not the case</del>(written before 2nd example). OK so now I understand the difference between old structures and new structures (indeed I was just re-reading the <a href="https://github.com/leanprover/lean/wiki/Refactoring-structures">wiki page about this</a> to try and get up to speed). Now why does this matter?</p>



<a name="236080651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080651">(Apr 25 2021 at 17:29)</a>:</h4>
<p>I should probably try to write a blog post about this, because it's the only way I will make any sense of it, and I have learnt from a lot of previous experience that if I learn something and then forget it again (something which happens all too often at my age) then I can re-learn it very efficiently if I've written it down in my own words.</p>



<a name="236080659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080659">(Apr 25 2021 at 17:29)</a>:</h4>
<p>The achilles heel of new style structures is that you can't use them when there are overlapping fields (or rather you can still use the same method but you get the wrong result because you end up with two copies of the overlapped fields)</p>



<a name="236080714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080714">(Apr 25 2021 at 17:30)</a>:</h4>
<p>in the first example there are no overlaps so new structures work fine</p>



<a name="236080733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080733">(Apr 25 2021 at 17:30)</a>:</h4>
<p>Right, but my understanding is that the argument is that we should now consider new style structures because it may or may not solve some problem or other.</p>



<a name="236080756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080756">(Apr 25 2021 at 17:31)</a>:</h4>
<p>Right, so the question is how to be as new-structure-like as we can subject to the constraint that new style diamonds are impossible</p>



<a name="236080906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080906">(Apr 25 2021 at 17:33)</a>:</h4>
<p>I don't understand Scott's first claim at the top of this thread:</p>
<blockquote>
<p>The current definition of an algebra has a severe problem: if you have type <code>X</code> with an existing <code>module R X</code> structure, it's impossible to put an <code>algebra R X</code> structure on it in such a way that the <code>module R X</code> structure derived from that <code>algebra R X</code> will be definitionally equal to the original one.</p>
</blockquote>
<p>Maybe I should start by trying to do this exercise and understanding why this fails.</p>



<a name="236080918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236080918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236080918">(Apr 25 2021 at 17:33)</a>:</h4>
<p>In the <code>mixed_structure</code> example, I have broken the symmetry between the two parent structures by embedding <code>bar1</code> as a field of <code>foo</code> and recombining fields for <code>bar2</code>. For lack of a better name I'm calling the <code>bar1</code> kind "compositional inheritance" and <code>bar2</code> non-compositional. We want as many compositional edges in the structure graph as possible, but the compositional edges have to be diamond free</p>



<a name="236081012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236081012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236081012">(Apr 25 2021 at 17:34)</a>:</h4>
<p>I'm afraid I have this rather unfashionable trait in me whereby I like to understand stuff by seeing explicit examples, rather than just eating up the axioms and then becoming an expert :-/</p>



<a name="236081144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236081144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236081144">(Apr 25 2021 at 17:36)</a>:</h4>
<p>Ah, I haven't been talking about that issue, just new structures in general</p>



<a name="236081164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236081164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236081164">(Apr 25 2021 at 17:36)</a>:</h4>
<p>Right but I'm keen to learn about everything right now</p>



<a name="236081181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236081181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236081181">(Apr 25 2021 at 17:36)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/algebra/src">src#algebra</a></p>



<a name="236081316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236081316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236081316">(Apr 25 2021 at 17:39)</a>:</h4>
<p>I'm not sure I see the problem either. Although you won't get the module structure itself to be the same, all the projections can still be defeq to the old ones, and this is all we generally expect (it's difficult to get defeq of the instances themselves in most cases)</p>



<a name="236081845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236081845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236081845">(Apr 25 2021 at 17:47)</a>:</h4>
<p>but I thought we want defeq instances?</p>
<p>If every structure were completely flat, this would be impossible right, because eta reduction for structures is not definitional (if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>‚àà</mo><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">z\in\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚àà</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> then <code>{re := z.re, im := z.im} = z</code> can't be proved by <code>rfl</code>). But surely it is going to be pretty much impossible to make everything definitional here?</p>



<a name="236081948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236081948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236081948">(Apr 25 2021 at 17:48)</a>:</h4>
<p>So here's an example of what I think scott is talking about</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">bar1</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">bar2</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>
<span class="kd">class</span> <span class="n">foo</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">Œ±</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">foo.bar1</span> <span class="o">(</span><span class="n">Œ±</span><span class="o">)</span> <span class="o">[</span><span class="n">foo</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">bar1</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:=</span> <span class="n">foo.x</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">foo.y</span><span class="o">}</span>
<span class="kd">instance</span> <span class="n">foo.bar2</span> <span class="o">(</span><span class="n">Œ±</span><span class="o">)</span> <span class="o">[</span><span class="n">foo</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="n">bar2</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:=</span> <span class="n">foo.x</span><span class="o">,</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">foo.z</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">bla</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Œ±</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">B</span> <span class="o">:</span> <span class="n">bar1</span> <span class="o">(</span><span class="n">bla</span> <span class="n">Œ±</span><span class="o">)]</span>
<span class="kn">include</span> <span class="n">B</span>

<span class="kd">instance</span> <span class="n">bla.foo</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">(</span><span class="n">bla</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">z</span> <span class="o">:=</span> <span class="n">bar1.x</span><span class="o">,</span> <span class="bp">..</span><span class="o">‚Äπ</span><span class="n">bar1</span> <span class="o">(</span><span class="n">bla</span> <span class="n">Œ±</span><span class="o">)‚Ä∫}</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">foo.bar1</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">bla.foo</span> <span class="n">Œ±</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">bar1.x</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">foo.bar1</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">bla.foo</span> <span class="n">Œ±</span> <span class="n">B</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">bar1.x</span> <span class="n">_</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">bar1.y</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">foo.bar1</span> <span class="n">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">bla.foo</span> <span class="n">Œ±</span> <span class="n">B</span><span class="o">))</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">bar1.y</span> <span class="n">_</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="236082144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236082144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236082144">(Apr 25 2021 at 17:52)</a>:</h4>
<p>Now you might call this a non-defeq diamond, but this is actually fairly common in the hierarchy and mostly harmless. That is, we would classify this as a defeq diamond because all projections are defeq, even though the instances themselves are not</p>



<a name="236082183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236082183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236082183">(Apr 25 2021 at 17:52)</a>:</h4>
<p>An example we have in mathlib is cancel_monoid extending both left_cancel_monoid and right_cancel_monoid as an old structure, both of which live over monoid. If we manage to make ourselves a monoid instance on a type, and then manage to extend it to a left_cancel_monoid and to a right_cancel_monoid, then type class inference might well be able to spit out the original monoid structure from the left_cancel_monoid. But if we then put the cancel_monoid instance into the type class inference machine, there is surely no way that both implications cancel_monoid -&gt; left_cancel_monoid and cancel_monoid -&gt; right_cancel_monoid can produce structures which are defeq to the ones we have already.</p>



<a name="236082230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236082230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236082230">(Apr 25 2021 at 17:53)</a>:</h4>
<p>Oh so this is <em>allowed</em>? I thought that this was exactly what Scott was complaining about! This is not the issue we are trying to solve? As far as I can see it's surely provably unsolvable?</p>



<a name="236082235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236082235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236082235">(Apr 25 2021 at 17:54)</a>:</h4>
<p>Right, the issue is that we don't have eta for structures. It's basically impossible to make the first <code>example</code> work, unless <code>bar1</code> happens to be a compositional superclass of <code>foo</code>. But as we've established it's not possible for everything to be compositional superclasses so new structures are going to end up making a new distinction that wasn't visible before matter</p>



<a name="236082348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236082348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236082348">(Apr 25 2021 at 17:55)</a>:</h4>
<p>To be sure it's a bit of a pain when you have non-defeq instances like this, because if you apply an unknown function on the instances (like <code>nat.cast</code>) then you have to unfold it enough to know that the function only uses the projections out of the instance, not the instances themselves</p>



<a name="236082624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236082624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236082624">(Apr 25 2021 at 18:00)</a>:</h4>
<p>OK re-reading the thread and these comments have been very helpful -- thanks. So really this is not about diamonds, it's about something else, if "diamond" is being interpreted as "not even equal if you include eta reduction".</p>



<a name="236082768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Replacing%20the%20definition%20of%20%60algebra%60/near/236082768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60.html#236082768">(Apr 25 2021 at 18:02)</a>:</h4>
<p>The thing is, the more complicated definitions we pile on top of a structure the harder it becomes to prove that the function uses only projections, because all the higher level definitions will take an instance argument directly. In this case I think the definition in question is <code>finite_dimensional</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
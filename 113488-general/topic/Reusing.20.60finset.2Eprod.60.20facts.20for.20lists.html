---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html">Reusing `finset.prod` facts for lists</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="183934979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183934979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183934979">(Dec 20 2019 at 13:26)</a>:</h4>
<p>Hi, is there any good way to reuse facts about <code>finset.prod</code> for lists? E.g., I'd like to have something like <code>∀ l : list α, (fin_range (length l)).prod (λ i, l.nth_le i.1 i.2) = l.prod</code>.</p>



<a name="183935029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183935029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183935029">(Dec 20 2019 at 13:27)</a>:</h4>
<p>My problem is that it's not easy to apply general facts about products/sums over <code>finset</code>s (e.g., AM-GM inequality) to get a similar inequality for products/sums over lists.</p>



<a name="183935119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183935119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183935119">(Dec 20 2019 at 13:28)</a>:</h4>
<p>With lists it's much easier to apply it to specific numbers (e.g., to deduce AM-GM for 2, 3, 4 numbers out of the general case).</p>



<a name="183944815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183944815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183944815">(Dec 20 2019 at 15:25)</a>:</h4>
<p>I guess that theorem is possible (assuming the multiplication is commutative and associative), but the LHS looks pretty hard to work with</p>



<a name="183944884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183944884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183944884">(Dec 20 2019 at 15:26)</a>:</h4>
<p>You can always coerce a list to a finset and apply the prod operation there</p>



<a name="183948835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183948835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183948835">(Dec 20 2019 at 16:08)</a>:</h4>
<p>Does coercion remove duplicates?</p>



<a name="183948915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183948915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183948915">(Dec 20 2019 at 16:09)</a>:</h4>
<p>I guess it does.</p>



<a name="183951638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183951638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183951638">(Dec 20 2019 at 16:42)</a>:</h4>
<p>You could coerce to a multiset and apply the prod operation there.</p>



<a name="183954911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183954911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183954911">(Dec 20 2019 at 17:20)</a>:</h4>
<p>For every <code>list A</code> there's a function <code>fin n - &gt; A</code>, so you can <code>finset.sum univ</code> over this function.</p>



<a name="183956353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183956353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183956353">(Dec 20 2019 at 17:39)</a>:</h4>
<p>...and that's the reason why nobody bothers to build any more infrastructure for sums over lists and multisets ;-)</p>



<a name="183963235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183963235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183963235">(Dec 20 2019 at 19:06)</a>:</h4>
<p>That's true for multisets. You still need lists for non commutative products.</p>



<a name="183985762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183985762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183985762">(Dec 21 2019 at 00:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> I wrote one such function above. However I'd like to have a theorem like <code>∀ l : list α, (fin_range (length l)).prod (λ i, l.nth_le i.1 i.2) = l.prod</code> or <code>∀ (l : list α) (f : α → β), (fin_range (length l)).prod (λ i, f(l.nth_le) i.1 i.2) = (l.map f).prod</code> to be able to transfer facts from sums/prods over a finset to sums/prods of <code>list.map</code>.</p>



<a name="183986178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183986178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183986178">(Dec 21 2019 at 00:15)</a>:</h4>
<p>Another way to deduce <code>∀ a b c wa wb wc : nnreal, wa + wb + wc = 1 → a^wa * b^wb * c^wc ≤ wa * a + wb * b + wc * c</code> from <code>∀ {α : Type*} (s : finset α) (w z : α → ℝ≥0) (hw' : s.sum w = 1) : (s.prod (λ i, (z i) ^ (w i))) ≤ s.sum (λ i, w i * z i)</code> is welcome. Here I assume <code>has_pow nnreal nnreal := ⟨λ x r, nnreal.of_real (x:ℝ)^(r:ℝ)⟩</code>.</p>



<a name="183988075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183988075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183988075">(Dec 21 2019 at 00:59)</a>:</h4>
<p>With lists I can do this:</p>
<div class="codehilite"><pre><span></span><span class="n">noncomputable</span> <span class="kn">instance</span> <span class="n">nnreal</span><span class="bp">.</span><span class="n">has_pow_nnreal</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">p</span> <span class="n">r</span><span class="o">,</span> <span class="n">nnreal</span><span class="bp">.</span><span class="n">of_real</span> <span class="err">$</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span><span class="err">^</span><span class="o">(</span><span class="n">r</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">list</span><span class="bp">.</span><span class="n">am_gm_weighted</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">×</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">map</span> <span class="n">prod</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span> <span class="err">^</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">×</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">≤</span>
    <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">fst</span> <span class="bp">*</span> <span class="n">i</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">×</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">))</span><span class="bp">.</span><span class="n">sum</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">am_gm3</span> <span class="o">(</span><span class="n">w₁</span> <span class="n">w₂</span> <span class="n">w₃</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="n">w₁</span> <span class="bp">+</span> <span class="n">w₂</span> <span class="bp">+</span> <span class="n">w₃</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">x₁</span> <span class="n">x₂</span> <span class="n">x₃</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x₁</span> <span class="err">^</span> <span class="n">w₁</span> <span class="bp">*</span> <span class="n">x₂</span> <span class="err">^</span> <span class="n">w₂</span> <span class="bp">*</span> <span class="n">x₃</span> <span class="err">^</span> <span class="n">w₃</span> <span class="bp">≤</span> <span class="n">w₁</span> <span class="bp">*</span> <span class="n">x₁</span> <span class="bp">+</span> <span class="n">w₂</span> <span class="bp">*</span> <span class="n">x₂</span> <span class="bp">+</span> <span class="n">w₃</span> <span class="bp">*</span> <span class="n">x₃</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">]</span> <span class="kn">using</span> <span class="n">list</span><span class="bp">.</span><span class="n">am_gm_weighted</span> <span class="o">[(</span><span class="n">w₁</span><span class="o">,</span> <span class="n">x₁</span><span class="o">),</span> <span class="o">(</span><span class="n">w₂</span><span class="o">,</span> <span class="n">x₂</span><span class="o">),</span> <span class="o">(</span><span class="n">w₃</span><span class="o">,</span> <span class="n">x₃</span><span class="o">)]</span> <span class="o">(</span><span class="k">by</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">hw</span><span class="o">)</span>
</pre></div>


<p>However I can't quickly deduce <code>am_gm3</code> from</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">finset</span><span class="bp">.</span><span class="n">am_gm_weighted</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">sum</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">z</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="o">(</span><span class="n">w</span> <span class="n">i</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">s</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">z</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>



<a name="183988196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183988196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183988196">(Dec 21 2019 at 01:01)</a>:</h4>
<p><code>∀ l : list α, (fin_range (length l)).prod (λ i, l.nth_le i.1 i.2) = l.prod</code> doesn't compile -- Lean can't find <code>⊢ has_one (fin (length l))</code>. These things should surely be easy to prove by induction on <code>l</code> right?</p>



<a name="183988511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183988511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183988511">(Dec 21 2019 at 01:08)</a>:</h4>
<div class="codehilite"><pre><span></span>failed to synthesize type class instance for
x r : ℝ≥0
⊢ has_pow ℝ ℝ
</pre></div>


<p>I can't get anything to work</p>



<a name="183988625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183988625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183988625">(Dec 21 2019 at 01:10)</a>:</h4>
<p>But I see your point. A finset is not enough here because of duplicates. You need to use this <code>finset.sum univ</code> trick of Chris I guess.</p>



<a name="183988868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183988868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183988868">(Dec 21 2019 at 01:17)</a>:</h4>
<p>I think we need an ergonomic way to form "fin n -&gt; A" vectors from concrete lists of values, i.e. vector.cons</p>



<a name="183988871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183988871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183988871">(Dec 21 2019 at 01:17)</a>:</h4>
<p>that would solve this problem</p>



<a name="183989159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183989159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183989159">(Dec 21 2019 at 01:25)</a>:</h4>
<p>I also can't find an instance of <code>has_pow nnreal nnreal</code>. Was this added at some point?</p>



<a name="183989173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183989173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183989173">(Dec 21 2019 at 01:25)</a>:</h4>
<p>No, that's why I define it in my code.</p>



<a name="183989175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183989175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183989175">(Dec 21 2019 at 01:25)</a>:</h4>
<p>that's not very MWE</p>



<a name="183989384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183989384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183989384">(Dec 21 2019 at 01:30)</a>:</h4>
<p>For an MWE, let's one can try to deduce</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">list</span><span class="bp">.</span><span class="n">prod_mul</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="bp">.</span><span class="n">fst</span> <span class="bp">*</span> <span class="n">i</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">=</span> <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">map</span> <span class="n">prod</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="bp">*</span> <span class="o">(</span><span class="n">l</span><span class="bp">.</span><span class="n">map</span> <span class="n">prod</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>from the corresponding fact about <code>finset</code>s</p>



<a name="183989422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183989422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183989422">(Dec 21 2019 at 01:31)</a>:</h4>
<p>Or, say, deduce <code>∀ a b c x y z, (a * b * c) * (x * y * z) = ((a * x) * (b * y) * (c * z))</code> from <code>finset.prod_mul_distrib</code>.</p>



<a name="183990732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183990732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183990732">(Dec 21 2019 at 02:06)</a>:</h4>
<p>actually, I was going to show how to prove your original theorem, the am_gm for 3 things from the general am_gm on finsets</p>



<a name="183990920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183990920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183990920">(Dec 21 2019 at 02:11)</a>:</h4>
<p>Here is what I have for a <code>real</code> - <code>finset</code> version:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">finset</span><span class="bp">.</span><span class="n">am_gm_weighted</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">w</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hw&#39;</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">sum</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hz</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">z</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">s</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">z</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="o">(</span><span class="n">w</span> <span class="n">i</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">s</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">z</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>



<a name="183991185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reusing%20%60finset.prod%60%20facts%20for%20lists/near/183991185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reusing.20.60finset.2Eprod.60.20facts.20for.20lists.html#183991185">(Dec 21 2019 at 02:18)</a>:</h4>
<p>This seems to work well:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group_power</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">nnreal</span> <span class="n">data</span><span class="bp">.</span><span class="n">fin</span>

<span class="kn">section</span> <span class="kn">end</span>
<span class="n">open_locale</span> <span class="n">nnreal</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">nnreal</span><span class="bp">.</span><span class="n">has_pow_nnreal</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span>

<span class="kn">axiom</span> <span class="n">finset</span><span class="bp">.</span><span class="n">am_gm_weighted</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="bp">≥</span><span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">sum</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">z</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="o">(</span><span class="n">w</span> <span class="n">i</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">s</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">*</span> <span class="n">z</span> <span class="n">i</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">finset</span><span class="bp">.</span><span class="n">prod_fin_succ</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">prod</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">:</span><span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">theorem</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_fin_succ</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">:</span><span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="bp">.</span><span class="n">succ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">am_gm3</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">wa</span> <span class="n">wb</span> <span class="n">wc</span> <span class="o">:</span> <span class="n">nnreal</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">wa</span> <span class="bp">+</span> <span class="n">wb</span> <span class="bp">+</span> <span class="n">wc</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">a</span><span class="err">^</span><span class="n">wa</span> <span class="bp">*</span> <span class="n">b</span><span class="err">^</span><span class="n">wb</span> <span class="bp">*</span> <span class="n">c</span><span class="err">^</span><span class="n">wc</span> <span class="bp">≤</span> <span class="n">wa</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">wb</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">wc</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">am_gm_weighted</span> <span class="o">(</span><span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">_</span><span class="o">)</span>
    <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">cons</span> <span class="n">wa</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">cons</span> <span class="n">wb</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">wc</span><span class="o">)))</span>
    <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">cons</span> <span class="n">a</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">cons</span> <span class="n">b</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">c</span><span class="o">))),</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">prod_fin_succ</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_fin_succ</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
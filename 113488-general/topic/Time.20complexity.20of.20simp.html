---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Time.20complexity.20of.20simp.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html">Time complexity of simp</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="323085679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323085679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323085679">(Jan 23 2023 at 18:09)</a>:</h4>
<p>What is the time complexity of <code>simp</code> search? If there are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> theorems marked as <code>@[simp]</code> and the "size" of the statement being simplified is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>, I guess the time complexity is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, is that correct?</p>



<a name="323098400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323098400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323098400">(Jan 23 2023 at 19:15)</a>:</h4>
<p>Are you assuming that the proof has exactly one simplification step?</p>



<a name="323099580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323099580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323099580">(Jan 23 2023 at 19:21)</a>:</h4>
<p>Yes</p>



<a name="323104290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323104290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323104290">(Jan 23 2023 at 19:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113488-general/topic/Time.20complexity.20of.20simp/near/323085679">said</a>:</p>
<blockquote>
<p>What is the time complexity of <code>simp</code> search? If there are $n$ theorems marked as <code>@[simp]</code> and the "size" of the statement being simplified is $m$, I guess the time complexity is $O(m\log n)$, is that correct?</p>
</blockquote>
<p>Where does the log n comes from?</p>



<a name="323104422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323104422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323104422">(Jan 23 2023 at 19:47)</a>:</h4>
<p>Does simp use some binary search? If so, with what order?</p>



<a name="323109761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323109761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323109761">(Jan 23 2023 at 20:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> <a href="#narrow/stream/113488-general/topic/Time.20complexity.20of.20simp/near/323104290">said</a>:</p>
<blockquote>
<p>Where does the log n comes from?</p>
</blockquote>
<p>Each expression can be serialized to a list of identifiers (global identifiers, local lambda arguments, metavariables). The simp set is a map from expressions (represented as lists; patterns) to proofs (or other simp info), which can be represented as a tree. Searching in such tree has <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> time complexity.</p>



<a name="323110149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323110149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323110149">(Jan 23 2023 at 20:18)</a>:</h4>
<p>This is how it <em>could</em> be implemented. I have no idea how the actual implementation is done.</p>



<a name="323112511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323112511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323112511">(Jan 23 2023 at 20:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113488-general/topic/Time.20complexity.20of.20simp/near/323109761">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="466334">Shreyas Srinivas</span> <a href="#narrow/stream/113488-general/topic/Time.20complexity.20of.20simp/near/323104290">said</a>:</p>
<blockquote>
<p>Where does the log n comes from?</p>
</blockquote>
<p>Each expression can be serialized to a list of identifiers (global identifiers, local lambda arguments, metavariables). The simp set is a map from expressions (represented as lists; patterns) to proofs (or other simp info), which can be represented as a tree. Searching in such tree has $O(\log n)$ time complexity.</p>
</blockquote>
<p>There are two flaws I can see with this argument. You are assuming that you only have to search on root to leaf path (or constantly many). That only makes sense if you have some criterion for choosing between multiple child nodes at each node. The second flaw is this: Unless your goal is very specific to the point that the simp set tree can be pruned in this manner, you don't get O(log n)</p>



<a name="323173333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323173333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323173333">(Jan 24 2023 at 06:27)</a>:</h4>
<p>But we do have a criterion for choosing between multiple child nodes at each node. Maybe you don't understand how the data structure I described looks like? In theory, we may follow multiple paths simultaneously, but the number of paths would be proportional to the number of metavariables in the patterns, which can be considered a constant. If you are interested in how <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span> simplification search would work in practice, I can provide you a link to the implementation (in a different theorem prover).</p>
<p>Can I get the answer from someone who knows how Lean's simp work? Does simp try to match every possible theorem from the simp set with every possible sub-expression from the statement being simplified (which would be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">)</span></span></span></span>), or does it use some more clever approach?</p>



<a name="323177275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323177275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shreyas Srinivas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323177275">(Jan 24 2023 at 07:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> <a href="#narrow/stream/113488-general/topic/Time.20complexity.20of.20simp/near/323173333">said</a>:</p>
<blockquote>
<p>But we do have a criterion for choosing between multiple child nodes at each node. Maybe you don't understand how the data structure I described looks like? In theory, we may follow multiple paths simultaneously, but the number of paths would be proportional to the number of metavariables in the patterns, which can be considered a constant. If you are interested in how $\log n$ simplification search would work in practice, I can provide you a link to the implementation (in a different theorem prover).</p>
<p>Can I get the answer from someone who knows how Lean's simp work? Does simp try to match every possible theorem from the simp set with every possible sub-expression from the statement being simplified (which would be $O(mn)$), or does it use some more clever approach?</p>
</blockquote>
<p>Are you talking about a trie like structure?</p>



<a name="323177594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323177594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323177594">(Jan 24 2023 at 07:03)</a>:</h4>
<p>yes</p>



<a name="323181400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323181400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323181400">(Jan 24 2023 at 07:34)</a>:</h4>
<p><code>iff</code> and <code>eq</code> lemmas are indexed by simp depending on the head of their LHS. <code>iff</code> lemmas are preprocessed to become equalities (this changed semirecently, so I might be wrong for this bit).</p>



<a name="323182046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323182046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323182046">(Jan 24 2023 at 07:38)</a>:</h4>
<p>I don't think it's indexed any further, so the time complexity should be something like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \sqrt n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="padding-left:0.833em;">n</span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, assuming there are about as many different heads as there are lemmas per head. If we were doing a more careful analysis, we would probably find that the number of lemmas per head follows some kind of Zipf law, with a few being very commonplace, eg <a href="https://leanprover-community.github.io/mathlib_docs/find/coe_fn">docs#coe_fn</a> which shows up as the head of all hom coercion lemmas.</p>



<a name="323190906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323190906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323190906">(Jan 24 2023 at 08:33)</a>:</h4>
<p>some speculations here: <a href="#narrow/stream/113538-CI/topic/build.20time.20bot/near/304405602">https://leanprover.zulipchat.com/#narrow/stream/113538-CI/topic/build.20time.20bot/near/304405602</a></p>



<a name="323260257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Time%20complexity%20of%20simp/near/323260257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Time.20complexity.20of.20simp.html#323260257">(Jan 24 2023 at 14:08)</a>:</h4>
<p>In Lean 4, <code>simp</code> uses a discrimination tree, which I think is close to the data structure you're describing. In Lean 3, it doesn't (it uses 'keyed matching' instead), which is why Lean 3 <code>simp</code> doesn't cope well with large lemma databases.</p>
<p>However, even with discrimination trees, we must do additional work because the matching should be module defeq. In Lean (3 and 4), <code>simp</code> uses <code>reducible</code> transparency and by convention there are no <code>reducible</code> recursive definitions, which makes the matching tractable: basically, you normalise both the pattern expression (before you insert it into the discrimination tree) and the query expression (when you do the lookup). But this means that there's no straightforward complexity bound on the search.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
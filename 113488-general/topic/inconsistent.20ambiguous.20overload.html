---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/inconsistent.20ambiguous.20overload.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html">inconsistent ambiguous overload</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265376523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265376523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265376523">(Dec 17 2021 at 23:37)</a>:</h4>
<p>I have this code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">order.filter.partial</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">filter</span>
<span class="kn">open</span> <span class="n">has_sup</span> <span class="n">has_top</span> <span class="n">has_mem</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">structure</span> <span class="n">convergence_space</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">converges</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pure_converges</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span><span class="o">,</span> <span class="n">converges</span> <span class="o">(</span><span class="n">pure</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_converges</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span><span class="o">},</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span> <span class="bp">-&gt;</span> <span class="k">forall</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">converges</span> <span class="n">l'</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">converges</span> <span class="n">l</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- l &lt;= l' means l' ⊆ l</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="n">convergence_space</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">class</span><span class="o">]</span> <span class="n">convergence_space</span>

<span class="kd">def</span> <span class="n">converges</span> <span class="o">[</span><span class="n">p</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">a</span><span class="o">]</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">p.converges</span> <span class="n">l</span> <span class="n">x</span>

<span class="kn">open</span> <span class="n">convergence_space</span>

<span class="kd">def</span> <span class="n">is_open</span> <span class="o">[</span><span class="n">convergence_space</span> <span class="n">a</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">forall</span> <span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">mem</span> <span class="n">x</span> <span class="n">s</span> <span class="bp">-&gt;</span> <span class="n">converges</span> <span class="n">l</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">mem</span> <span class="n">s</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">is_closed</span> <span class="o">[</span><span class="n">convergence_space</span> <span class="n">a</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">forall</span> <span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">mem</span> <span class="n">s</span> <span class="n">l</span> <span class="bp">-&gt;</span> <span class="n">converges</span> <span class="n">l</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">mem</span> <span class="n">x</span> <span class="n">s</span>
</code></pre></div>
<p>For some reason, Lean is confused about the <code>converges l x</code> in the definition of <code>is_closed</code>. Why does it work with <code>is_open</code> and not with <code>is_closed</code>?</p>



<a name="265376972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265376972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265376972">(Dec 17 2021 at 23:44)</a>:</h4>
<p>You have a typo in the last line</p>



<a name="265376982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265376982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265376982">(Dec 17 2021 at 23:44)</a>:</h4>
<p><code>mem s l</code> should be <code>mem x s</code></p>



<a name="265377032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377032">(Dec 17 2021 at 23:45)</a>:</h4>
<p>well, at least that's why one works and not the other</p>



<a name="265377048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377048">(Dec 17 2021 at 23:45)</a>:</h4>
<p>Why would that be typo?</p>



<a name="265377080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377080">(Dec 17 2021 at 23:45)</a>:</h4>
<p>I suspect this is a unification problem, given that changing the implication order fixes it. Try giving the types of <code>l</code> and <code>x</code> explicitly.</p>



<a name="265377143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377143">(Dec 17 2021 at 23:46)</a>:</h4>
<p>I was just commenting on why <code>is_open</code> works but not the other.... I don't actually know what the mathematical content is</p>



<a name="265377165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377165">(Dec 17 2021 at 23:46)</a>:</h4>
<p>typo wasn't the right word, I guess.</p>



<a name="265377208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377208">(Dec 17 2021 at 23:47)</a>:</h4>
<p>I don't know why you're so against using unicode <span class="user-mention" data-user-id="416322">@Bernd Losert</span> ... it makes your code very hard to read.</p>



<a name="265377302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377302">(Dec 17 2021 at 23:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/inconsistent.20ambiguous.20overload/near/265377080">said</a>:</p>
<blockquote>
<p>I suspect this is a unification problem, given that changing the implication order fixes it. Try giving the types of <code>l</code> and <code>x</code> explicitly.</p>
</blockquote>
<p>Didn't help.</p>



<a name="265377329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377329">(Dec 17 2021 at 23:49)</a>:</h4>
<p>This</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_closed</span> <span class="o">[</span><span class="n">convergence_space</span> <span class="n">a</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">forall</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">mem</span> <span class="n">s</span> <span class="n">l</span> <span class="bp">-&gt;</span> <span class="n">converges</span> <span class="n">l</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">mem</span> <span class="n">x</span> <span class="n">s</span>
</code></pre></div>
<p>works for me...</p>



<a name="265377406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377406">(Dec 17 2021 at 23:50)</a>:</h4>
<p>Oops. I did it for <code>is_open</code> instead of <code>is_closed</code>. Yep, it helps.</p>



<a name="265377412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377412">(Dec 17 2021 at 23:51)</a>:</h4>
<p>Could this be a bug?</p>



<a name="265377418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377418">(Dec 17 2021 at 23:51)</a>:</h4>
<p>It's not a bug.</p>



<a name="265377445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377445">(Dec 17 2021 at 23:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/inconsistent.20ambiguous.20overload/near/265377208">said</a>:</p>
<blockquote>
<p>I don't know why you're so against using unicode <span class="user-mention silent" data-user-id="416322">Bernd Losert</span> ... it makes your code very hard to read.</p>
</blockquote>
<p>Nothing against Unicode. I'm just working with a crappy font inside a VM from the shell, so no fancy Unicode for me for now.</p>



<a name="265377518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377518">(Dec 17 2021 at 23:52)</a>:</h4>
<p>Do you not want to install lean on your own machine?</p>



<a name="265377531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377531">(Dec 17 2021 at 23:52)</a>:</h4>
<p>We're fairly honest people <span aria-label="smiling devil" class="emoji emoji-1f608" role="img" title="smiling devil">:smiling_devil:</span></p>



<a name="265377537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377537">(Dec 17 2021 at 23:52)</a>:</h4>
<p>This machine isn't mine. I will be ditching it soon.</p>



<a name="265377558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377558">(Dec 17 2021 at 23:53)</a>:</h4>
<p>Ah ok, fair enough.</p>



<a name="265377584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377584">(Dec 17 2021 at 23:53)</a>:</h4>
<p>Hmm... I guess we have another one of those gotchas. The number of gotchas seems to be increasing every day.</p>



<a name="265377649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377649">(Dec 17 2021 at 23:54)</a>:</h4>
<p>In any case, it's not a bug because when you write <code>mem s l</code> without specifying what <code>l</code> should be, then lean has no way of telling the type of <code>l</code>. In the <code>is_open</code> case, the first place where <code>l</code> appears is in <code>converges</code>, and then lean knows that it has to be a filter. In the <code>is_closed</code> case, there are many options, since <code>mem s l</code> is the first thing that lean finds.</p>



<a name="265377726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377726">(Dec 17 2021 at 23:55)</a>:</h4>
<p>In general, the error messages should be relatively helpful, so, in time, you will be able to know how to work around these "gotchas".</p>



<a name="265377728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377728">(Dec 17 2021 at 23:55)</a>:</h4>
<p>I see. I guess it could be smarter by looking at the entire type instead of the first thing only.</p>



<a name="265377814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377814">(Dec 17 2021 at 23:56)</a>:</h4>
<p>I think I'll just stick to writing <code>[p : convergence_space a]</code> and <code>p.converges</code>.</p>



<a name="265377832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377832">(Dec 17 2021 at 23:56)</a>:</h4>
<blockquote>
<p>The number of gotchas seems to be increasing every day.</p>
</blockquote>
<p>I don't know if they're so much "gotchas" as simply the fact that lean has a pretty steep learning curve. I would urge you to start trying to understand the error messages you're seeing. They often tell you what's wrong, once you understand what they're saying. (Oh Adam beat me to it  :-) )</p>



<a name="265377894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377894">(Dec 17 2021 at 23:57)</a>:</h4>
<p>I understood the error message. I was just wondering why it worked in the <code>is_open</code> case but not in the <code>is_closed</code> case.</p>



<a name="265377983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265377983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265377983">(Dec 17 2021 at 23:59)</a>:</h4>
<p>The "gotchas" are part of the steep learning curve it seems.</p>



<a name="265378005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378005">(Dec 17 2021 at 23:59)</a>:</h4>
<p>Writing <code>p.converges</code> is not the solution</p>



<a name="265378199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378199">(Dec 18 2021 at 00:01)</a>:</h4>
<p>I've been using that so far without issues. Before I was doing <code>@converges a p</code>.</p>



<a name="265378208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378208">(Dec 18 2021 at 00:01)</a>:</h4>
<p>That would be like writing <code>e.to_has_mul.mul x y</code> for <code>e : group G</code> instead of just <code>x * y</code>.</p>



<a name="265378281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378281">(Dec 18 2021 at 00:02)</a>:</h4>
<p>If I had a nice notation for <code>converges</code>,  I would agree.</p>



<a name="265378348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378348">(Dec 18 2021 at 00:03)</a>:</h4>
<p>The <code>p.converges</code> actually reads better. In the literature, you find <code>F p-converges to x</code>, so it is similar.</p>



<a name="265378413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378413">(Dec 18 2021 at 00:04)</a>:</h4>
<p>Okay, but you wouldn't write <code>U is-t-open in X</code> for a set <code>X</code> with a topology <code>t</code>, rather you would just say <code>U is open in X</code>.</p>



<a name="265378477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378477">(Dec 18 2021 at 00:04)</a>:</h4>
<p>If you always want to refer to <code>p</code>, then <code>convergence_space</code> should be just a structure, and not a class.</p>



<a name="265378490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378490">(Dec 18 2021 at 00:05)</a>:</h4>
<p>Yep. In the literature on convergence spaces, you also see <code>F converges to x in (X,p)</code>.</p>



<a name="265378610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378610">(Dec 18 2021 at 00:06)</a>:</h4>
<p>The trick is not to stick to the literature, the trick is to learn how to write idiomatic lean code</p>



<a name="265378635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378635">(Dec 18 2021 at 00:06)</a>:</h4>
<p>We're rewriting the literature</p>



<a name="265378659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378659">(Dec 18 2021 at 00:06)</a>:</h4>
<p>I didn't want to refer to <code>p</code> at all, but it caused so many issues that using it is better now.</p>



<a name="265378677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378677">(Dec 18 2021 at 00:07)</a>:</h4>
<p>Can you give me an example where it's an issue?</p>



<a name="265378719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378719">(Dec 18 2021 at 00:07)</a>:</h4>
<p>Remember "I can't make it work" is very different to "it can't be made to work"</p>



<a name="265378737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378737">(Dec 18 2021 at 00:07)</a>:</h4>
<p>In almost all the proofs I've written, I would get error messages saying "cannot instantiate type class instance" or something like that.</p>



<a name="265378799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378799">(Dec 18 2021 at 00:08)</a>:</h4>
<p>I made the error go away by using <code>@converges</code> and then I switched to using <code>p.converges</code>.</p>



<a name="265378856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378856">(Dec 18 2021 at 00:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="416322">Bernd Losert</span> <a href="#narrow/stream/113488-general/topic/inconsistent.20ambiguous.20overload/near/265378737">said</a>:</p>
<blockquote>
<p>In almost all the proofs I've written, I would get error messages saying "cannot instantiate type class instance" or something like that.</p>
</blockquote>
<p>This is just lean telling you that you didn't specify a convergence space structure to use, so it has no way of knowing what to do.</p>



<a name="265378945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378945">(Dec 18 2021 at 00:10)</a>:</h4>
<p>Yes. That's what it is, so I have to specify it and things are much better now after doing so.</p>



<a name="265378952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265378952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265378952">(Dec 18 2021 at 00:10)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>gives an error because I didn't tell lean what <code>has_mul G</code> to use.</p>



<a name="265379006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265379006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265379006">(Dec 18 2021 at 00:11)</a>:</h4>
<p>Yep.</p>



<a name="265379157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265379157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265379157">(Dec 18 2021 at 00:13)</a>:</h4>
<p>There were some cases where it complained even though the instance was there. This seems to happen only in tactic mode. I suspect this is a limitation of Lean and it explains why you have things like introsI, letI, etc.</p>



<a name="265379230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265379230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265379230">(Dec 18 2021 at 00:14)</a>:</h4>
<p>Yeah, when an instance is under a binder, then it can get annoying, at least in lean3. Lean4 is supposed to fix all that.</p>



<a name="265379262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265379262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265379262">(Dec 18 2021 at 00:15)</a>:</h4>
<p>That also seems to come from you putting stuff to the right of the colon while it could have been to the left.</p>



<a name="265379298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265379298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265379298">(Dec 18 2021 at 00:15)</a>:</h4>
<p>Nah. That was unrelated.</p>



<a name="265379399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265379399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265379399">(Dec 18 2021 at 00:17)</a>:</h4>
<p>Again, an example would be helpful.</p>



<a name="265379474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265379474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265379474">(Dec 18 2021 at 00:18)</a>:</h4>
<p>Let me try the partial_order proof. I think that one was troublesome.</p>



<a name="265379617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265379617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265379617">(Dec 18 2021 at 00:21)</a>:</h4>
<p>That's a different story, because when you're talking about the poset of convergence space structures, you need to speak about more than one such structure, so typeclasses don't help here. I suggest looking at the code for the lattice of topologies that we have in mathlib</p>



<a name="265379892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265379892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265379892">(Dec 18 2021 at 00:26)</a>:</h4>
<p>Nope. It wasn't that one. It was this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">order.filter.partial</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">filter</span>
<span class="kn">open</span> <span class="n">has_sup</span> <span class="n">has_top</span> <span class="n">has_mem</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">structure</span> <span class="n">convergence_space</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">converges</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pure_converges</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span><span class="o">,</span> <span class="n">converges</span> <span class="o">(</span><span class="n">pure</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_converges</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span><span class="o">},</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span> <span class="bp">-&gt;</span> <span class="k">forall</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">converges</span> <span class="n">l'</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">converges</span> <span class="n">l</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- l &lt;= l' means l' ⊆ l</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="n">convergence_space</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">class</span><span class="o">]</span> <span class="n">convergence_space</span>

<span class="kn">open</span> <span class="n">convergence_space</span>

<span class="kd">def</span> <span class="n">convergence_space.induced</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">[</span><span class="n">convergence_space</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">converges</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">l</span> <span class="n">x</span><span class="o">,</span> <span class="n">converges</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">pure_converges</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">filter.map_pure</span><span class="o">,</span> <span class="n">pure_converges</span><span class="o">],</span>
  <span class="n">le_converges</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">le1</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">converges</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">le2</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">,</span> <span class="n">apply</span> <span class="n">map_mono</span> <span class="n">le1</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_converges</span> <span class="n">le2</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>



<a name="265379988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265379988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265379988">(Dec 18 2021 at 00:28)</a>:</h4>
<p>fixed</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">order.filter.partial</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">filter</span>
<span class="kn">open</span> <span class="n">has_sup</span> <span class="n">has_top</span> <span class="n">has_mem</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">class</span> <span class="n">convergence_space</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">converges</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pure_converges</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span><span class="o">,</span> <span class="n">converges</span> <span class="o">(</span><span class="n">pure</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_converges</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span><span class="o">},</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span> <span class="bp">-&gt;</span> <span class="k">forall</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">converges</span> <span class="n">l'</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">converges</span> <span class="n">l</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- l &lt;= l' means l' ⊆ l</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="n">convergence_space</span>

<span class="kn">open</span> <span class="n">convergence_space</span>

<span class="kd">def</span> <span class="n">convergence_space.induced</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">[</span><span class="n">convergence_space</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">converges</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">l</span> <span class="n">x</span><span class="o">,</span> <span class="n">converges</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">pure_converges</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">filter.map_pure</span><span class="o">,</span> <span class="n">pure_converges</span><span class="o">],</span>
  <span class="n">le_converges</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">le1</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">converges</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">le2</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">,</span> <span class="n">apply</span> <span class="n">map_mono</span> <span class="n">le1</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_converges</span> <span class="n">le2</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>



<a name="265380024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380024">(Dec 18 2021 at 00:29)</a>:</h4>
<p>Sure, using <code>class</code> fixes it, but then in the proof of <code>partial_order</code> I have to resort to using <code>@converges</code>.</p>



<a name="265380039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380039">(Dec 18 2021 at 00:29)</a>:</h4>
<p>So it's a trade off.</p>



<a name="265380118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380118">(Dec 18 2021 at 00:30)</a>:</h4>
<p>The point is that you will only prove a partial order once, but you want to use a convergence space structure many many times without referring to it explicitly. So you need to decide which tradeoff is less painful, and I claim that using <code>class convergence_space ...</code> is the right way to go.</p>



<a name="265380141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380141">(Dec 18 2021 at 00:31)</a>:</h4>
<p>Or, you could be a bit more careful with your variables.</p>



<a name="265380207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380207">(Dec 18 2021 at 00:32)</a>:</h4>
<p>You may be right. I'll need to flesh out more code and see what happens.</p>



<a name="265380313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380313">(Dec 18 2021 at 00:34)</a>:</h4>
<p>The issue with your code here is that <code>convergence_space.converges</code> has an explicit first variable of type <code>convergence_space a</code>.</p>



<a name="265380362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380362">(Dec 18 2021 at 00:35)</a>:</h4>
<p>E.g. the following works</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">order.filter.partial</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">filter</span>
<span class="kn">open</span> <span class="n">has_sup</span> <span class="n">has_top</span> <span class="n">has_mem</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">structure</span> <span class="n">convergence_space</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">converges'</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pure_converges</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span><span class="o">,</span> <span class="n">converges'</span> <span class="o">(</span><span class="n">pure</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_converges</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span><span class="o">},</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span> <span class="bp">-&gt;</span> <span class="k">forall</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">converges'</span> <span class="n">l'</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">converges'</span> <span class="n">l</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- l &lt;= l' means l' ⊆ l</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">class</span><span class="o">,</span> <span class="n">ext</span><span class="o">]</span> <span class="n">convergence_space</span>

<span class="kn">open</span> <span class="n">convergence_space</span>

<span class="kd">lemma</span> <span class="n">converges</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">convergence_space</span> <span class="n">a</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="n">converges'</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="n">f</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">convergence_space.induced</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">[</span><span class="n">convergence_space</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">a</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">converges</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">l</span> <span class="n">x</span><span class="o">,</span> <span class="n">converges</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">pure_converges</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">filter.map_pure</span><span class="o">,</span> <span class="n">pure_converges</span><span class="o">],</span>
  <span class="n">le_converges</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">l</span> <span class="n">l'</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">le1</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">converges</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">le2</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l'</span><span class="o">,</span> <span class="n">apply</span> <span class="n">map_mono</span> <span class="n">le1</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">le_converges</span> <span class="n">le2</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>



<a name="265380389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380389">(Dec 18 2021 at 00:35)</a>:</h4>
<p>Uh, <code>converges</code> should be a <code>def</code>, right?</p>



<a name="265380448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380448">(Dec 18 2021 at 00:36)</a>:</h4>
<p>It's prop valued</p>



<a name="265380449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380449">(Dec 18 2021 at 00:36)</a>:</h4>
<p>So?</p>



<a name="265380457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380457">(Dec 18 2021 at 00:36)</a>:</h4>
<p>It's Prop-valued, but it's not a Prop.</p>



<a name="265380464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380464">(Dec 18 2021 at 00:37)</a>:</h4>
<p>I'm confused</p>



<a name="265380469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380469">(Dec 18 2021 at 00:37)</a>:</h4>
<p>A prop is a prop</p>



<a name="265380475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380475">(Dec 18 2021 at 00:37)</a>:</h4>
<p>But <code>Prop</code> is not a Prop.</p>



<a name="265380485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380485">(Dec 18 2021 at 00:37)</a>:</h4>
<p>It's a <code>Type 0</code></p>



<a name="265380489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380489">(Dec 18 2021 at 00:37)</a>:</h4>
<p>Oh duh</p>



<a name="265380490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380490">(Dec 18 2021 at 00:37)</a>:</h4>
<p>Sorry</p>



<a name="265380492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380492">(Dec 18 2021 at 00:37)</a>:</h4>
<p>It should be a def.</p>



<a name="265380561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380561">(Dec 18 2021 at 00:38)</a>:</h4>
<p>Yeah you're right</p>



<a name="265380579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380579">(Dec 18 2021 at 00:38)</a>:</h4>
<p>That's what it was in my first post.</p>



<a name="265380591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380591">(Dec 18 2021 at 00:39)</a>:</h4>
<p>What's this partial order structure example? I'm not sure about all the context but <code>convergence_space</code> should definitely be a class</p>



<a name="265380631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380631">(Dec 18 2021 at 00:39)</a>:</h4>
<p>One sec...</p>



<a name="265380741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380741">(Dec 18 2021 at 00:41)</a>:</h4>
<p>Mario, I think it's given by implication on converges</p>



<a name="265380752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380752">(Dec 18 2021 at 00:41)</a>:</h4>
<p>This is what I have now:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">order.filter.partial</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">filter</span>
<span class="kn">open</span> <span class="n">has_sup</span> <span class="n">has_top</span> <span class="n">has_mem</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">structure</span> <span class="n">convergence_space</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">converges</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">a</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pure_converges</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">x</span><span class="o">,</span> <span class="n">converges</span> <span class="o">(</span><span class="n">pure</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_converges</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">l</span> <span class="n">l'</span><span class="o">},</span> <span class="n">l</span> <span class="bp">&lt;=</span> <span class="n">l'</span> <span class="bp">-&gt;</span> <span class="k">forall</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">converges</span> <span class="n">l'</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">converges</span> <span class="n">l</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- l &lt;= l' means l' ⊆ l</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="n">convergence_space</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="kd">class</span><span class="o">]</span> <span class="n">convergence_space</span>

<span class="kn">open</span> <span class="n">convergence_space</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_le</span> <span class="o">(</span><span class="n">convergence_space</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">le</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span> <span class="k">forall</span> <span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">q.converges</span> <span class="n">l</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">p.converges</span> <span class="n">l</span> <span class="n">x</span>
<span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">convergence_space</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">le_refl</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">p</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p.converges</span> <span class="n">l</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">le_trans</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">le1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&lt;=</span> <span class="n">q</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">le2</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&lt;=</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">l</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">x</span> <span class="o">:</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">r.converges</span> <span class="n">l</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">le1</span> <span class="o">(</span><span class="n">le2</span> <span class="n">h</span><span class="o">))</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">le_antisymm</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">convergence_space</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">le1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&lt;=</span> <span class="n">q</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">le2</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&lt;=</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">l</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">iff.intro</span> <span class="n">le2</span> <span class="n">le1</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">convergence_space.has_le</span>
<span class="o">}</span>
</code></pre></div>



<a name="265380970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265380970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265380970">(Dec 18 2021 at 00:44)</a>:</h4>
<p>If I change it to <code>class</code>, I have to write:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_le</span> <span class="o">(</span><span class="n">convergence_space</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">le</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span> <span class="k">forall</span> <span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="bp">@</span><span class="n">converges</span> <span class="n">a</span> <span class="n">q</span> <span class="n">l</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="bp">@</span><span class="n">converges</span> <span class="n">a</span> <span class="n">p</span> <span class="n">l</span> <span class="n">x</span>
<span class="o">}</span>
</code></pre></div>



<a name="265381500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265381500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265381500">(Dec 18 2021 at 00:52)</a>:</h4>
<p>Oh, that partial order. Yes, when dealing with the space of all convergence spaces you will need another notation to make the argument explicit. In topologies, this is done with a local notation. I would suggest something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span> <span class="kd">class</span> <span class="n">convergence_space</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">converges</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">pure_converges</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">converges</span> <span class="o">(</span><span class="n">pure</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_converges</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{{</span><span class="n">l</span> <span class="n">l'</span><span class="o">}},</span> <span class="n">l</span> <span class="bp">≤</span> <span class="n">l'</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="o">{{</span><span class="n">x</span><span class="o">}},</span> <span class="n">converges</span> <span class="n">l'</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">converges</span> <span class="n">l</span> <span class="n">x</span><span class="o">)</span> <span class="c1">-- l &lt;= l' means l' ⊆ l</span>

<span class="kn">open</span> <span class="n">convergence_space</span>

<span class="kn">section</span>
<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`</span><span class="n">convs</span><span class="bp">`</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">converges</span> <span class="n">_</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_le</span> <span class="o">(</span><span class="n">convergence_space</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span> <span class="bp">∀</span> <span class="o">{{</span><span class="n">l</span> <span class="n">x</span><span class="o">}},</span> <span class="n">convs</span> <span class="n">q</span> <span class="n">l</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">convs</span> <span class="n">p</span> <span class="n">l</span> <span class="n">x</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">convergence_space</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le_refl</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">l</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">le_trans</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">pq</span> <span class="n">qr</span> <span class="n">l</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">pq</span> <span class="o">(</span><span class="n">qr</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">le_antisymm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">pq</span> <span class="n">qp</span><span class="o">,</span> <span class="kd">by</span> <span class="n">ext</span> <span class="n">l</span> <span class="n">x</span><span class="bp">;</span> <span class="n">exact</span> <span class="o">⟨</span><span class="bp">@</span><span class="n">qp</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="bp">@</span><span class="n">pq</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="bp">..</span><span class="n">convergence_space.has_le</span> <span class="o">}</span>

<span class="kd">end</span>
</code></pre></div>



<a name="265381607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265381607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265381607">(Dec 18 2021 at 00:54)</a>:</h4>
<p>Also, when writing lean you should really get used to unicode. There are lots of things that can't be worked around with ascii notation, and every lean input method I am aware of has built in abbreviation expansion</p>



<a name="265381784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265381784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265381784">(Dec 18 2021 at 00:57)</a>:</h4>
<p>I see. So instead of a <code>structure</code> with a <code>def converges</code>, I can use <code>class</code> with notation for <code>@converges</code>.</p>



<a name="265381855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265381855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265381855">(Dec 18 2021 at 00:58)</a>:</h4>
<p>I started using <code>structure</code> because I was copying the topologies code by the way.</p>



<a name="265381898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265381898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265381898">(Dec 18 2021 at 00:59)</a>:</h4>
<p>With <a href="https://leanprover-community.github.io/mathlib_docs/find/topological_space">docs#topological_space</a> we have an external API and we don't really refer to the fields in the structure defining a topological space. Your case is different because you want to actually use the <code>converges</code> field.</p>



<a name="265382075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265382075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265382075">(Dec 18 2021 at 01:01)</a>:</h4>
<p>Yes. That wasn't apparent to me though when I started.</p>



<a name="265382088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/inconsistent%20ambiguous%20overload/near/265382088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/inconsistent.20ambiguous.20overload.html#265382088">(Dec 18 2021 at 01:01)</a>:</h4>
<p>Anyways, thanks alot everyone. Always appreciated.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
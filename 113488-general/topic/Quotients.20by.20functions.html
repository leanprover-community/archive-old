---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Quotients.20by.20functions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html">Quotients by functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265979669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265979669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265979669">(Dec 24 2021 at 05:56)</a>:</h4>
<p>I'm interested in quotienting a set by a function, so that if <code>f a = f b</code>, then the corresponding quotients are equal. This seems like a common enough use case to have its own dedicated name and theorems. Is this something that exists?</p>



<a name="265979747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265979747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265979747">(Dec 24 2021 at 05:59)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/setoid.ker">docs#setoid.ker</a> is the setoid for that</p>



<a name="265979877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265979877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265979877">(Dec 24 2021 at 06:00)</a>:</h4>
<p>What's the difference between a <code>setoid</code> and a <code>quot</code>? Being honest, I don't really fully understand either of them.</p>



<a name="265979958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265979958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265979958">(Dec 24 2021 at 06:02)</a>:</h4>
<p><code>setoid</code> is just an equivalence relation, and you still need to feed it to <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient">docs#quotient</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/quot">docs#quot</a></p>



<a name="265980037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265980037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265980037">(Dec 24 2021 at 06:04)</a>:</h4>
<p>Ah thanks, I think I'm getting the hang of it</p>



<a name="265980044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265980044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265980044">(Dec 24 2021 at 06:04)</a>:</h4>
<p>What <code>quotient</code> does is give you the <code>⟦a⟧</code> syntax, using some implicit argument magic to turn it into the correct <code>quot.mk</code> incantation.</p>



<a name="265980218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265980218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265980218">(Dec 24 2021 at 06:09)</a>:</h4>
<p>But it's also somewhat awkward because <code>quotient</code> lemmas expect the <code>setoid</code> to come from a typeclass instance. Depending on what you're doing, you might either use <code>setoid.ker</code> to define a <code>setoid</code> instance for your type, or you might write things like <code>quot.mk (setoid.ker f).rel a</code> directly.</p>



<a name="265980274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265980274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265980274">(Dec 24 2021 at 06:10)</a>:</h4>
<p>Like, <a href="https://leanprover-community.github.io/mathlib_docs/find/setoid.ker_apply_mk_out">docs#setoid.ker_apply_mk_out</a> looks nice in the documentation, but it takes some contortions to use the <code>quotient</code> interface:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ker_apply_mk_out</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="kd">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">setoid.ker</span> <span class="n">f</span><span class="bp">;</span> <span class="n">exact</span> <span class="bp">⟦</span><span class="n">a</span><span class="bp">⟧.</span><span class="n">out</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="265980397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265980397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265980397">(Dec 24 2021 at 06:13)</a>:</h4>
<p>Yeah, I'm having to make a lot of arguments explicit here</p>



<a name="265980578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265980578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265980578">(Dec 24 2021 at 06:17)</a>:</h4>
<p>I'm not sure if this helps, but the convention I adapted the last time I used a quotient was to define a type that had all the operations on them along with proofs they preserved the equivalence relation.  Then I defined the quotient type and the operations on the quotient type using <code>quotient.lift</code>.</p>



<a name="265980671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265980671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265980671">(Dec 24 2021 at 06:19)</a>:</h4>
<p>Here's some <a href="https://github.com/joehendrix/lean-containers/blob/ef6ff0533eada75f18922039f8312badf12e6124/data/containers/set.lean#L117-L137">relevant code</a> for building finite sets on top of ordered trees.</p>



<a name="265981277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265981277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265981277">(Dec 24 2021 at 06:32)</a>:</h4>
<p>There are also these sorts of tricks you can do, which let you work with quotients of the same type by multiple different functions, while still giving you access to lemmas like <code>quotient.eq</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.setoid.basic</span>

<span class="kd">def</span> <span class="n">with_fmod</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span>

<span class="kd">instance</span> <span class="n">with_fmod.setoid</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">setoid</span> <span class="o">(</span><span class="n">with_fmod</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">setoid.ker</span> <span class="n">f</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">fmod</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">quotient</span> <span class="o">(</span><span class="n">with_fmod.setoid</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="n">x</span><span class="bp">⟧</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fmod</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">fmod</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dunfold</span> <span class="n">fmod</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">quotient.eq</span><span class="o">,</span> <span class="bp">←</span> <span class="n">setoid.ker_def</span><span class="o">],</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265986536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265986536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265986536">(Dec 24 2021 at 08:24)</a>:</h4>
<p>If the instance arguments are annoying, use <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient.mk'">docs#quotient.mk'</a> and the other primed definitions instead</p>



<a name="265992872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265992872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265992872">(Dec 24 2021 at 10:29)</a>:</h4>
<p>Naïve question: is there any reason to prefer the quotient by <code>f</code> over <a href="https://leanprover-community.github.io/mathlib_docs/find/set.range">docs#set.range</a>?</p>



<a name="265995462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Quotients%20by%20functions/near/265995462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Quotients.20by.20functions.html#265995462">(Dec 24 2021 at 11:22)</a>:</h4>
<p>Yes, because you can extract both <code>a</code> and <code>f a</code> computably from terms of the former</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
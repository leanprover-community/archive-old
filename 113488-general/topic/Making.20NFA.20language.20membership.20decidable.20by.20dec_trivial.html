---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html">Making NFA language membership decidable by dec_trivial</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="320198145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320198145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Correnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320198145">(Jan 09 2023 at 11:05)</a>:</h4>
<p>Hi all,<br>
I am currently working on formalizing results on finite word automaton (also with <span class="user-mention" data-user-id="263407">@Laurent Bartholdi</span> ) and, ideally, we would like to be able to compute with automata to prove language membership automatically  (by <code>dec_trivial</code>  for example).</p>
<p>The current definition (provided by <span class="user-mention" data-user-id="267202">@Fox Thomson</span> ) of NFAs in mathlib uses sets and does not make any assumption on the decidability of the underlying types:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- An NFA is a set of states (`σ`), a transition function from state to state labelled by the</span>
<span class="sd">  alphabet (`step`), a starting state (`start`) and a set of acceptance states (`accept`).</span>
<span class="sd">  Note the transition function sends a state to a `set` of states. These are the states that it</span>
<span class="sd">  may be sent to. -/</span>
<span class="kd">structure</span> <span class="n">NFA</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">step</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">σ</span><span class="o">)</span>
<span class="o">(</span><span class="n">start</span> <span class="o">:</span> <span class="n">set</span> <span class="n">σ</span><span class="o">)</span>
<span class="o">(</span><span class="n">accept</span> <span class="o">:</span> <span class="n">set</span> <span class="n">σ</span><span class="o">)</span>
</code></pre></div>
<p>Therefore, if we want to prove a statement of the form <code>my_word \in NFA.accepts my_automata</code>, we have to unfold all the definitions and do the proof manually where we ideally would like to just do a <code>dec_trivial</code>.</p>
<p>In a proof assistant like Coq, I would start with a definition of automata based on lists of elements of a decidable type rather than sets <br>
and simply compute. I am a complete beginner with Lean butI I feel like it's not the idiomatic Lean way to achieve this goal and that I should try to use type classes instead. Any idea/advice on how to do that the <em>Lean way</em> without changing the definitions ?</p>



<a name="320198561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320198561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320198561">(Jan 09 2023 at 11:07)</a>:</h4>
<p>Salut ! The idiomatic way to do this would be to show that <code>A.accepts</code> is decidable if <code>∀ a b, decidable_pred (∈ A.step a b)</code>, <code>decidable_pred (∈ A.start)</code>, <code>decidable_pred (∈ A.accept)</code></p>



<a name="320199178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320199178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320199178">(Jan 09 2023 at 11:11)</a>:</h4>
<p>Then whenever you have a "decidable automata", you can prove the three starting instances <code>step</code>, <code>start</code>, <code>accept</code> and Lean will provide you the <code>accepts</code> one. That might sound like you need to write three times the number of automata you want to evaluate, but in practice I assume you will write a <code>NFA</code> constructor starting from a <code>list</code> (as your message alludes to), in which case you can write three generic decidability instances that will take care of everything for you.</p>



<a name="320199598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320199598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320199598">(Jan 09 2023 at 11:13)</a>:</h4>
<p>Do you have a repository?</p>



<a name="320200960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320200960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Correnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320200960">(Jan 09 2023 at 11:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial/near/320198561">said</a>:</p>
<blockquote>
<p>Salut ! The idiomatic way to do this would be to show that <code>A.accepts</code> is decidable if <code>∀ a b, decidable_pred (∈ A.step a b)</code>, <code>decidable_pred (∈ A.start)</code>, <code>decidable_pred (∈ A.accept)</code></p>
</blockquote>
<p>Thanks for the answer ! Proving these lemmas if the sets are built from lists should be straightforward. I'm not sure how to tell lean to exploit these lemmas tho.</p>



<a name="320201125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320201125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Correnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320201125">(Jan 09 2023 at 11:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial/near/320199598">said</a>:</p>
<blockquote>
<p>Do you have a repository?</p>
</blockquote>
<p>Only a local one ^^ (for now)</p>



<a name="320201167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320201167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320201167">(Jan 09 2023 at 11:22)</a>:</h4>
<p>If I were you, I wouldn't aim for full automation. Instead, I'd let the programmer provide the non-deterministic choices and automate making a proof from that.</p>



<a name="320201266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320201266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320201266">(Jan 09 2023 at 11:23)</a>:</h4>
<p>I think the instance that <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> suggests is still a good idea</p>



<a name="320201290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320201290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320201290">(Jan 09 2023 at 11:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">A.accept</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.step</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.start</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.accept</span><span class="o">)]</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.accepts</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">decidable_of_iff</span> <span class="n">some_equivalent_thing_here</span> <span class="n">your_proof_that_it_is_equivalent</span>
</code></pre></div>
<p>is how I would start.</p>



<a name="320201553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320201553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320201553">(Jan 09 2023 at 11:24)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/NFA.accepts">docs#NFA.accepts</a> is a <code>language</code> not a predicate</p>



<a name="320201612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320201612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320201612">(Jan 09 2023 at 11:25)</a>:</h4>
<p>Fixed!</p>



<a name="320201868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320201868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320201868">(Jan 09 2023 at 11:26)</a>:</h4>
<p>Also σ needs to be finite</p>



<a name="320202449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320202449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320202449">(Jan 09 2023 at 11:29)</a>:</h4>
<p>Only <code>A.accept</code> does</p>



<a name="320202848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320202848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320202848">(Jan 09 2023 at 11:31)</a>:</h4>
<p>This might be a good start:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">decidable_pred_mem_eval_from</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">)</span>
  <span class="o">[</span><span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.step</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.start</span><span class="o">)]</span>
  <span class="o">(</span><span class="n">S</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.eval_from</span> <span class="n">S</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">delta</span> <span class="n">eval_from</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="n">decidable_pred_mem_eval</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.step</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.start</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.accept</span><span class="o">)]</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.eval</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">NFA.decidable_pred_mem_eval_from</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">instance</span> <span class="n">decidable_pred_mem_accepts</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.step</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.start</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.accept</span><span class="o">)]</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">A.accept</span><span class="o">)]</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.accepts</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">accepts</span><span class="o">],</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="320202996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320202996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320202996">(Jan 09 2023 at 11:32)</a>:</h4>
<p>Isn't <code>dsimp</code> in a decidability instance bad because the <code>eq.rec</code>s won't reduce?</p>



<a name="320203180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320203180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320203180">(Jan 09 2023 at 11:33)</a>:</h4>
<p><code>dsimp</code> doesn't use <code>eq.rec</code>, it uses <code>id</code></p>



<a name="320203198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320203198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320203198">(Jan 09 2023 at 11:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial/near/320201167">said</a>:</p>
<blockquote>
<p>If I were you, I wouldn't aim for full automation. Instead, I'd let the programmer provide the non-deterministic choices and automate making a proof from that.</p>
</blockquote>
<p>Just to explain the difference with this approach, non-deterministic choices would involve writing tactic code, probably in the form of a <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#norm_num">tactic#norm_num</a> extension. This is probably the best solution long term (because Lean is so bad at computing), but much harder to implement and we want the decidability instances either way. So as long as you're not evaluating automata with 100 states or something, I would recommend against it.</p>



<a name="320203442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320203442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320203442">(Jan 09 2023 at 11:34)</a>:</h4>
<p>But also, it's usually easiest to write these instances using bad defeqs, and then clean them up once you've worked out what you need</p>



<a name="320203496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320203496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320203496">(Jan 09 2023 at 11:34)</a>:</h4>
<p>Yes, absolutely.</p>



<a name="320203911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320203911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Correnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320203911">(Jan 09 2023 at 11:36)</a>:</h4>
<p>Thanks a lot for all the helpful advices ! I'll work on it ^^</p>



<a name="320203984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320203984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320203984">(Jan 09 2023 at 11:37)</a>:</h4>
<p>Decidability is finicky so keep asking questions if you have more!</p>



<a name="320204336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320204336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320204336">(Jan 09 2023 at 11:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial/near/320202449">said</a>:</p>
<blockquote>
<p>Only <code>A.accept</code> does</p>
</blockquote>
<p>I take it back, this causes annoying typeclass problems.</p>



<a name="320205187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320205187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320205187">(Jan 09 2023 at 11:43)</a>:</h4>
<p>I got sniped by this:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">fintype.decidable_mem_bUnion</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">decidable</span> <span class="o">(</span><span class="n">b</span> <span class="bp">∈</span> <span class="bp">⋃</span> <span class="n">a</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">),</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">decidable_of_iff'</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">),</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="n">set.mem_Union₂</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">decidable_pred_mem_step_set</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">σ</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">)</span>
  <span class="o">[</span><span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.step</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]</span>
  <span class="o">(</span><span class="n">S</span> <span class="n">l</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">S</span><span class="o">)]</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.step_set</span> <span class="n">S</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">fintype.decidable_mem_bUnion</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">instance</span> <span class="n">decidable_pred_mem_eval_from</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">σ</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">)</span>
  <span class="o">[</span><span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.step</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">S</span><span class="o">)]</span> <span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.eval_from</span> <span class="n">S</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfreezingI</span> <span class="o">{</span><span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">x</span> <span class="n">xs</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">S</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">‹</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">S</span><span class="o">)›</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">ih</span> <span class="o">(</span><span class="n">A.step_set</span> <span class="n">S</span> <span class="n">x</span><span class="o">),</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="n">decidable_pred_mem_eval</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">σ</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">)</span>
  <span class="o">[</span><span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.step</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.start</span><span class="o">)]</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.eval</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">NFA.decidable_pred_mem_eval_from</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>

<span class="kd">instance</span> <span class="n">decidable_pred_mem_accepts</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">σ</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">NFA</span> <span class="n">α</span> <span class="n">σ</span><span class="o">)</span>
  <span class="o">[</span><span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.step</span> <span class="n">a</span> <span class="n">b</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.start</span><span class="o">)]</span>
  <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.accept</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">A.accepts</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">fintype.decidable_exists_fintype</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code>
</code></pre></div>
</div></div>



<a name="320205477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320205477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320205477">(Jan 09 2023 at 11:45)</a>:</h4>
<p>I suspect that <code>decidable_of_iff' (∃ i ∈ S, x ∈ A.step i l) set.mem_Union₂</code> should be a lemma along the lines of <code>fintype.decidable_mem_bUnion</code></p>



<a name="320205678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320205678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320205678">(Jan 09 2023 at 11:46)</a>:</h4>
<p>Doesn't seem to exist.</p>



<a name="320206484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320206484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320206484">(Jan 09 2023 at 11:50)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">fintype.decidable_mem_bUnion</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">decidable</span> <span class="o">(</span><span class="n">b</span> <span class="bp">∈</span> <span class="bp">⋃</span> <span class="n">a</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">),</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">decidable_of_iff'</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">),</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="n">set.mem_Union₂</span>
</code></pre></div>



<a name="320206606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320206606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320206606">(Jan 09 2023 at 11:51)</a>:</h4>
<p>And could we have the same for <code>finset.sup</code>/<code>finset.inf</code>/<code>finset.bUnion</code>?</p>



<a name="320206864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320206864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320206864">(Jan 09 2023 at 11:52)</a>:</h4>
<p>Can you also not have <code>s : Π a (h : p a), set β</code> in <code>fintype.decidable_mem_bUnion</code>?</p>



<a name="320207357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320207357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320207357">(Jan 09 2023 at 11:55)</a>:</h4>
<p>I think that behaves poorly if <code>s</code> is non-dependent</p>



<a name="320207472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Making%20NFA%20language%20membership%20decidable%20by%20dec_trivial/near/320207472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial.html#320207472">(Jan 09 2023 at 11:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Making.20NFA.20language.20membership.20decidable.20by.20dec_trivial/near/320206606">said</a>:</p>
<blockquote>
<p>And could we have the same for <code>finset.sup</code>/<code>finset.inf</code>/<code>finset.bUnion</code>?</p>
</blockquote>
<p>Or even for <code>list.foldl</code>, which appeared above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">fintype.decidable_pred_mem_list_foldl</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">sf</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">s</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">s</span> <span class="n">a</span><span class="o">,</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">sf</span> <span class="n">s</span> <span class="n">a</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">l.foldl</span> <span class="n">sf</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfreezingI</span> <span class="o">{</span><span class="n">induction</span> <span class="n">l</span> <span class="k">with</span> <span class="n">x</span> <span class="n">xs</span> <span class="n">ih</span> <span class="n">generalizing</span> <span class="n">s</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">‹</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">s</span><span class="o">)›</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">ih</span> <span class="o">(</span><span class="n">sf</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html">Simply Typed Lambda Calculus in mathlib</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="308706067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308706067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308706067">(Nov 09 2022 at 02:23)</a>:</h4>
<p>I noticed recently there's no formalization for simply typed lambda calculus in the mathlib. I'm a fairly inexperienced Lean user, but I do have a formalization that I did for a project <a href="https://github.com/xoers/stlc-lean/blob/main/src/stlc.lean">here</a>. I would be really interested in trying to get this to a place where it could live in the mathlib. There are a bunch of auxillary lemmas, but the main "theorem-worthy" results I have right now are proofs of Unicity of typing, Progress, and Preservation. (There are also a couple of results I proved only because they were asked as a homework question in one of my classes - lines 300 to 565 are probably not worth putting in the mathlib) Besides concerns of style which obviously needs to be improved, I have a couple of questions:</p>
<ol>
<li>
<p>Is this even a reasonable foundation for STLC in Lean? If not, why not and how can I improve it?</p>
</li>
<li>
<p>Is this a thing that belongs in the mathlib?</p>
</li>
<li>
<p>If the answers to the previous two questions were yes, how would I decide the "canonical" version of STLC to work with. What types should I include? How should substituion be defined? etc.</p>
</li>
</ol>
<p>Thank you so much and I would be eager for any feedback about my code or otherwise!</p>



<a name="308726589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308726589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308726589">(Nov 09 2022 at 06:50)</a>:</h4>
<p>I'm not an expert on lambda calculus at all. But I think such things could definitely go in mathlib.</p>



<a name="308727015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308727015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308727015">(Nov 09 2022 at 06:55)</a>:</h4>
<p>Does this development need anything at all of the current theory in mathlib?</p>



<a name="308728993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308728993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308728993">(Nov 09 2022 at 07:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib/near/308727015">said</a>:</p>
<blockquote>
<p>Does this development need anything at all of the current theory in mathlib?</p>
</blockquote>
<p>Sorry, what do you mean by this?</p>



<a name="308729378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308729378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308729378">(Nov 09 2022 at 07:16)</a>:</h4>
<p>Are you depending on parts of mathlib?</p>



<a name="308729429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308729429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308729429">(Nov 09 2022 at 07:17)</a>:</h4>
<p>It looks like you depend on some tactics, and maybe a few things about <code>option</code>?</p>



<a name="308729526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308729526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308729526">(Nov 09 2022 at 07:18)</a>:</h4>
<p>Ah ok, yes that's exactly right. I use some of the mathlib tactics such as <code>induction'</code> and <code>split_ifs</code>.  I'm realizing now that the option import was from an earlier version and I no longer need it so mathlib dependencies are limited to just tactics.</p>



<a name="308741346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308741346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuyang Zhao <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308741346">(Nov 09 2022 at 08:52)</a>:</h4>
<p>I've heard <a href="https://www.research.ed.ac.uk/en/publications/type-and-scope-safe-programs-and-their-proofs">another definition</a> from others, which translates into lean is something like the following (there are some missed things), but I'm not sure it's better.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.basic</span>

<span class="c">/-</span><span class="cm">! # Simply typed λ-calculus -/</span>

<span class="kd">universes</span> <span class="n">u</span>

<span class="kn">namespace</span> <span class="n">lambda_calculus</span>

<span class="kd">structure</span> <span class="n">simply_typed</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">base_types</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">))</span>

<span class="kn">namespace</span> <span class="n">simply_typed</span>

<span class="kd">inductive</span> <span class="n">type</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">simply_typed</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">base_type</span> <span class="o">{</span><span class="n">T</span><span class="o">}</span> <span class="o">(</span><span class="n">hT</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">∈</span> <span class="n">L.base_types</span><span class="o">)</span> <span class="o">:</span> <span class="n">type</span>
<span class="bp">|</span> <span class="n">fun_type</span> <span class="o">:</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">type</span> <span class="bp">→</span> <span class="n">type</span>
<span class="kn">export</span> <span class="n">type</span>

<span class="n">localized</span> <span class="s2">"infixr (name := fun_type) ` ⥤ `:10 := lambda_calculus.simply_typed.type.fun_type"</span>
  <span class="k">in</span> <span class="n">lambda_calculus.simply_typed</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">simply_typed.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span>

<span class="kd">abbreviation</span> <span class="n">context</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">L.type</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">L</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">context.cons</span> <span class="o">(</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">L.context</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">L.type</span><span class="o">)</span> <span class="o">:</span> <span class="n">L.context</span> <span class="o">:=</span> <span class="n">α</span> <span class="o">::</span> <span class="bp">Γ</span>

<span class="n">localized</span> <span class="s2">"infixl (name := context.cons) ` ◂ `:75 := lambda_calculus.simply_typed.context.cons"</span>
  <span class="k">in</span> <span class="n">lambda_calculus.simply_typed</span>

<span class="kd">inductive</span> <span class="n">var</span> <span class="o">:</span> <span class="n">L.context</span> <span class="bp">→</span> <span class="n">L.type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">z</span> <span class="o">{</span><span class="bp">Γ</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span>            <span class="n">var</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">◂</span> <span class="n">α</span><span class="o">)</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">s</span> <span class="o">{</span><span class="bp">Γ</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">Γ</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">var</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">◂</span> <span class="n">β</span><span class="o">)</span> <span class="n">α</span>

<span class="kd">def</span> <span class="n">v0</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">simply_typed</span><span class="o">}</span> <span class="o">{</span><span class="bp">Γ</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">var</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">◂</span> <span class="n">α</span><span class="o">)</span> <span class="n">α</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">var.z</span> <span class="n">L</span> <span class="bp">Γ</span> <span class="n">α</span>

<span class="kd">inductive</span> <span class="n">term</span> <span class="o">:</span> <span class="n">L.context</span> <span class="bp">→</span> <span class="n">L.type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">{</span><span class="bp">Γ</span> <span class="n">α</span><span class="o">}</span>   <span class="o">:</span> <span class="n">var</span> <span class="bp">Γ</span> <span class="n">α</span>                     <span class="bp">→</span> <span class="n">term</span> <span class="bp">Γ</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">{</span><span class="bp">Γ</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">◂</span> <span class="n">α</span><span class="o">)</span> <span class="n">β</span>              <span class="bp">→</span> <span class="n">term</span> <span class="bp">Γ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">β</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="bp">Γ</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">Γ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">Γ</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">Γ</span> <span class="n">β</span>

<span class="n">localized</span> <span class="s2">"prefix (name := term.var) `#`:1500 := lambda_calculus.simply_typed.term.var"</span>
  <span class="k">in</span> <span class="n">lambda_calculus.simply_typed</span>
<span class="n">localized</span> <span class="s2">"prefix (name := term.abs) `ƛ `:10 := lambda_calculus.simply_typed.term.abs"</span>
  <span class="k">in</span> <span class="n">lambda_calculus.simply_typed</span>
<span class="n">localized</span> <span class="s2">"infixl (name := term.app) ` · `:1000 := lambda_calculus.simply_typed.term.app"</span>
  <span class="k">in</span> <span class="n">lambda_calculus.simply_typed</span>

<span class="kd">variables</span> <span class="o">{</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">L.context</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="n">L.type</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">combinator</span>
<span class="kd">def</span> <span class="n">I</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">Γ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">ƛ</span> <span class="bp">#</span><span class="n">v0</span>
<span class="kd">def</span> <span class="n">K</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">Γ</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">β</span> <span class="bp">⥤</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">ƛ</span> <span class="o">(</span><span class="bp">ƛ</span> <span class="bp">#</span><span class="n">v0.s</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">L</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">Γ</span> <span class="o">((</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">β</span> <span class="bp">⥤</span> <span class="n">γ</span><span class="o">)</span> <span class="bp">⥤</span> <span class="o">(</span><span class="n">α</span> <span class="bp">⥤</span> <span class="n">β</span><span class="o">)</span> <span class="bp">⥤</span> <span class="n">α</span> <span class="bp">⥤</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">ƛ</span> <span class="bp">ƛ</span> <span class="bp">ƛ</span> <span class="o">(</span><span class="bp">#</span><span class="n">v0.s.s</span> <span class="bp">·</span> <span class="bp">#</span><span class="n">v0</span><span class="o">)</span> <span class="bp">·</span> <span class="o">(</span><span class="bp">#</span><span class="n">v0.s</span> <span class="bp">·</span> <span class="bp">#</span><span class="n">v0</span><span class="o">)</span>
<span class="kd">end</span> <span class="n">combinator</span>

<span class="kd">end</span> <span class="n">simply_typed</span>

<span class="kd">end</span> <span class="n">lambda_calculus</span>
</code></pre></div>
</div></div>



<a name="308750834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308750834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308750834">(Nov 09 2022 at 09:49)</a>:</h4>
<p><span class="user-mention" data-user-id="483794">@zbatt</span> I should maybe walk back my statement a bit. As I said I'm not an expert on lambda calculus at all. It is my opinion that some type theoretic stuff should be welcome in mathlib. But for the particular details, I would rather defer to someone more knowledgeable.</p>



<a name="308765127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308765127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308765127">(Nov 09 2022 at 11:18)</a>:</h4>
<p>I think a formalization of lambda calculus / type theory suffers from a similar problem as that of graph theory: there are many different (non-equivalent) formulations, and it depends on your goals which formulation you want to use.<br>
A difference with graph theory is that eventually quite some mathematical results will use graphs, but I think the usage of a formalization of (simply) typed lambda calculus will be quite limited. </p>
<p>Some choices you have to make when formalizing type theory. Of course there is the question of simply typed lambda calculus vs dependent type theory, but even in simply typed lambda calculus, there are many questions:</p>
<ul>
<li>What are your base types?</li>
<li>How do you encode variables (named, de Bruijn variables, locally nameless, ...)?</li>
<li>Do lambda abstractions come with their type?</li>
<li>Do you want to define well-typed terms in terms of raw terms, or do you want to directly define the "well-typed terms in context Γ with type A" directly as an inductive definition?</li>
</ul>
<p>My preference is to wait with including type theory/lambda calculus in mathlib, until someone does a relatively big formalization and shows that their formalization is actually usable, or maybe until multiple (groups of) people want to work on it independently...</p>
<p>Btw, <span class="user-mention" data-user-id="483794">@zbatt</span>: one thing in your formalization that is not very standard is that you allow for infinite contexts.</p>



<a name="308799236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308799236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308799236">(Nov 09 2022 at 14:31)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> what about putting it in <code>achive</code> instead?</p>



<a name="308802300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308802300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308802300">(Nov 09 2022 at 14:45)</a>:</h4>
<p>If the code quality is good, I'm fine with that.</p>



<a name="308802605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308802605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308802605">(Nov 09 2022 at 14:47)</a>:</h4>
<p>Although that might send the wrong message that lambda calculus does not belong to mathlib, which is not the message I want to send...</p>



<a name="308829629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308829629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> zbatt <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308829629">(Nov 09 2022 at 16:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> <a href="#narrow/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib/near/308765127">said</a>:</p>
<blockquote>
<p>I think a formalization of lambda calculus / type theory suffers from a similar problem as that of graph theory: there are many different (non-equivalent) formulations, and it depends on your goals which formulation you want to use.<br>
A difference with graph theory is that eventually quite some mathematical results will use graphs, but I think the usage of a formalization of (simply) typed lambda calculus will be quite limited. </p>
<p>You have to make many choices when formalizing type theory. Of course there is the question of simply typed lambda calculus vs dependent type theory, but even in simply typed lambda calculus, there are many questions:</p>
<ul>
<li>What are your base types?</li>
<li>How do you encode variables (named, de Bruijn variables, locally nameless, ...)?</li>
<li>Do lambda abstractions come with their type?</li>
<li>Do you want to define well-typed terms in terms of raw terms, or do you want to directly define the "well-typed terms in context Γ with type A" directly as an inductive definition?</li>
</ul>
<p>My preference is to wait with including type theory/lambda calculus in mathlib, until someone does a relatively big formalization and shows that their formalization is actually usable, or maybe until multiple (groups of) people want to work on it independently...</p>
<p>Btw, <span class="user-mention silent" data-user-id="483794">zbatt</span>: one thing in your formalization that is not very standard is that you allow for infinite contexts.</p>
</blockquote>
<p>That makes a lot of sense. I definitely am not the person that should be making those decisions about the canonical formalization of this. I was hoping that maybe there was some standard I was unaware of which is part of the reason I posted this, but if not, those decisions should absolutely be made by someone with more experience.</p>
<p>And thanks for the note about infinite contexts! I'll be sure to get around to updating that.</p>



<a name="308967217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308967217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308967217">(Nov 10 2022 at 11:24)</a>:</h4>
<p>In general I think it is a bad idea to define untyped terms first. I would always do it intrinsically, see attached.  <a href="/user_uploads/3121/VndJOyU8Rn0qrBCGCykA0puP/stl.lean">stl.lean</a></p>



<a name="308967947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Simply%20Typed%20Lambda%20Calculus%20in%20mathlib/near/308967947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thorsten Altenkirch <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Simply.20Typed.20Lambda.20Calculus.20in.20mathlib.html#308967947">(Nov 10 2022 at 11:29)</a>:</h4>
<p>This certainly works very well in agda using dependently typed pattern matching, I don't know how well this fits into Lean.<br>
However, I would argue that this is conceptually the right definition, since there is no reason to define untyped terms if you are interested in typed ones. We have also done this for dependent types, e.g. see <a href="https://dl.acm.org/doi/abs/10.1145/2837614.2837638">https://dl.acm.org/doi/abs/10.1145/2837614.2837638</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html">Easiest way to do casework on factors of  nat</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="303342058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303342058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Praneeth Kolichala <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303342058">(Oct 11 2022 at 00:14)</a>:</h4>
<p>What is the easiest way to go prove something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">∣</span> <span class="mi">100</span> <span class="bp">↔</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">4</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">5</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">10</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">20</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">25</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">50</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">100</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>(really only the forward direction is important; backwards should be trivial by <code>cases</code> and <code>norm_num</code> or something).</p>
<p>The motivation is that I was thinking about how I would formalize the solutions to certain competition problems, and this kind of casework occurs somewhat frequently in number theory problems.</p>



<a name="303343538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303343538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303343538">(Oct 11 2022 at 00:33)</a>:</h4>
<p>Isn't there a function that returns the set of factors of an integer?</p>



<a name="303344213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303344213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303344213">(Oct 11 2022 at 00:43)</a>:</h4>
<p>There is, but there is no norm_num extension for it like I thought.</p>



<a name="303344802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303344802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303344802">(Oct 11 2022 at 00:51)</a>:</h4>
<p>There's <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.factors">docs#nat.factors</a>, which does have a norm_num extension, while needs <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.divisors">docs#nat.divisors</a> which doesn't</p>



<a name="303344994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303344994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303344994">(Oct 11 2022 at 00:54)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">number_theory.divisors</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">∣</span> <span class="mi">100</span> <span class="bp">↔</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">4</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">5</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">10</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">20</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">25</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">50</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">100</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">nat.divisors</span> <span class="mi">100</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">quot.mk</span> <span class="n">_</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">25</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="mi">100</span><span class="o">],</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">nat.mem_divisors.trans</span> <span class="o">(</span><span class="n">and_iff_left</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span> <span class="o">:</span> <span class="mi">100</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)),</span> <span class="n">this</span><span class="o">],</span>
  <span class="n">change</span> <span class="n">n</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">_</span><span class="o">:</span><span class="n">list</span> <span class="n">_</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>a proper norm_num extension would make this a lot faster</p>



<a name="303345843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303345843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303345843">(Oct 11 2022 at 01:06)</a>:</h4>
<p>Here's a slightly silly but faster proof</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">number_theory.divisors</span>
<span class="kn">import</span> <span class="n">data.finset.pointwise</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="kn">section</span>

<span class="n">open_locale</span> <span class="n">pointwise</span>

<span class="kd">lemma</span> <span class="n">divisors_mul</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>  <span class="o">:</span>
  <span class="o">(</span><span class="n">m</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">divisors</span> <span class="bp">=</span> <span class="n">m.divisors</span> <span class="bp">*</span> <span class="n">n.divisors</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">m.eq_zero_or_pos</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">hm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">n.eq_zero_or_pos</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">hn</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hm.ne'</span><span class="o">,</span> <span class="n">hn.ne'</span><span class="o">,</span> <span class="n">finset.mem_mul</span><span class="o">,</span> <span class="n">mem_divisors</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">nat.mul_eq_zero</span><span class="o">,</span> <span class="n">or_self</span><span class="o">,</span>
    <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">and_true</span><span class="o">,</span> <span class="n">exists_and_distrib_left</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨⟨⟨</span><span class="n">i₁</span><span class="o">,</span> <span class="n">hi₁</span><span class="o">⟩,</span> <span class="n">i₂</span><span class="o">,</span> <span class="n">hi₂</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">prod_dvd_and_dvd_of_dvd_prod</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">i₁</span><span class="o">,</span> <span class="n">hi₁</span><span class="o">,</span> <span class="n">i₂</span><span class="o">,</span> <span class="n">hi₂</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">mul_dvd_mul</span> <span class="n">hy</span> <span class="n">hx</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="kd">lemma</span> <span class="n">insert_mul</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">insert</span> <span class="n">x</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">•</span> <span class="n">t</span> <span class="bp">∪</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finset.mul_def</span><span class="o">,</span> <span class="n">insert_eq</span><span class="o">,</span> <span class="n">union_product</span><span class="o">,</span> <span class="n">image_union</span><span class="o">,</span> <span class="bp">←</span><span class="n">finset.mul_def</span><span class="o">,</span> <span class="bp">←</span><span class="n">finset.mul_def</span><span class="o">,</span>
    <span class="n">singleton_mul</span><span class="o">,</span> <span class="n">smul_finset_def</span><span class="o">],</span>
  <span class="n">refl</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">smul_finset_insert</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">•</span> <span class="n">insert</span> <span class="n">y</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">insert</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="bp">•</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">insert_eq</span><span class="o">,</span> <span class="n">smul_finset_union</span><span class="o">,</span> <span class="n">smul_finset_singleton</span><span class="o">,</span> <span class="n">insert_eq</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">]</span>

<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">n</span> <span class="bp">∣</span> <span class="mi">100</span> <span class="bp">↔</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">4</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">5</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">10</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">20</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">25</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">50</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">100</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">∣</span> <span class="mi">100</span> <span class="bp">↔</span> <span class="n">n</span> <span class="bp">∈</span> <span class="n">divisors</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">*</span> <span class="mi">5</span> <span class="bp">^</span> <span class="mi">2</span><span class="o">),</span> <span class="o">{</span> <span class="n">norm_num</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h₁</span><span class="o">,</span> <span class="n">divisors_mul</span><span class="o">,</span> <span class="n">nat.divisors_prime_pow</span> <span class="n">prime_two</span><span class="o">,</span>
    <span class="n">divisors_prime_pow</span> <span class="o">(</span><span class="k">show</span> <span class="n">nat.prime</span> <span class="mi">5</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">)],</span>
  <span class="n">norm_num</span> <span class="o">[</span><span class="n">finset.range_succ</span><span class="o">,</span> <span class="n">insert_mul</span><span class="o">,</span> <span class="n">smul_finset_insert</span><span class="o">,</span> <span class="n">finset.singleton_mul</span><span class="o">],</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">eq_iff_iff</span><span class="o">,</span>
  <span class="n">ac_refl</span>
<span class="kd">end</span>
</code></pre></div>
<p>the earlier lemmas are certainly gaps in mathlib - the idea is to show divisors of 100 are products of divisors of 4 and 25, which we have explicit expressions for, then norm_num and set calculations to finish</p>



<a name="303346088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303346088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303346088">(Oct 11 2022 at 01:10)</a>:</h4>
<p>I think - by the way - that this approach would be better for norm_num than trying to check divisibility of every number from 1..n, in particular using the existing extension for nat.factors, then my new divisors_mul. And maybe using lists instead of finsets?</p>



<a name="303347137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303347137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303347137">(Oct 11 2022 at 01:27)</a>:</h4>
<p>My thinking for the norm_num extension was to exhaustively list all divisors up to sqrt n and mirror them to get the rest (in order, to boot). This is the same cost as <code>nat.factors</code> since it also does divisibility tests up to sqrt n</p>



<a name="303347380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303347380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303347380">(Oct 11 2022 at 01:31)</a>:</h4>
<p>I thought <code>nat.factors</code> doesn't do divisibility tests up to sqrt n, because once you get the smallest factor you divide by it, so less needs to be checked</p>



<a name="303347447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303347447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303347447">(Oct 11 2022 at 01:32)</a>:</h4>
<p>For instance for <code>nat.factors 1024</code>, we never check if <code>30</code> divides <code>1024</code>, even though <code>30 &lt; sqrt 1024</code> (I think, I might be misunderstanding?)</p>



<a name="303353771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303353771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303353771">(Oct 11 2022 at 03:12)</a>:</h4>
<p>Oh, no you are right. That's only if you get lucky though, if the number is prime then you really do have to go all the way up to sqrt n</p>



<a name="303501928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303501928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303501928">(Oct 11 2022 at 19:06)</a>:</h4>
<p>Agreed. That said, the average number of prime factors of n is log log n, while the average number of divisors is log n, so I think overall (amortized) this saves a log factor? Though it's probably likely there are other factors involved here (no pun intended) and the only real way to compare is benchmarking</p>



<a name="303502949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303502949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303502949">(Oct 11 2022 at 19:12)</a>:</h4>
<p>you still have to sort the factors at the end though</p>



<a name="303502978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303502978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303502978">(Oct 11 2022 at 19:12)</a>:</h4>
<p>true</p>



<a name="303503124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303503124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303503124">(Oct 11 2022 at 19:13)</a>:</h4>
<p>might be able to get away with a clever merge sort though, because each of the lists you get along the way will come sorted - eg above it was {1,2,4} * {1,5,25}</p>



<a name="303503254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303503254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303503254">(Oct 11 2022 at 19:14)</a>:</h4>
<p>sure, I mean any sort is a bunch of merge sorts</p>



<a name="303503345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303503345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303503345">(Oct 11 2022 at 19:15)</a>:</h4>
<p>true but here we can prove that the inputs {1,2,4} and {1,5,25} are sorted by construction</p>



<a name="303503389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303503389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303503389">(Oct 11 2022 at 19:15)</a>:</h4>
<p>but we are essentially linearizing a high-dimensional cube here, so there are still linearly many ordering relations to work out</p>



<a name="303503610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303503610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303503610">(Oct 11 2022 at 19:16)</a>:</h4>
<p>my hope was that this would be less costly than proving the other things between 1 and sqrt n aren't factors, especially because the cube is in log log n dimensions (on average)</p>



<a name="303503817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303503817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303503817">(Oct 11 2022 at 19:17)</a>:</h4>
<p>(by linearly many I mean in the number of points in the cube which is log n, the size of the output here)</p>



<a name="303504092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303504092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303504092">(Oct 11 2022 at 19:19)</a>:</h4>
<p>I think it is likely to be more asymptotically efficient, but also a lot more complicated than just iterating which will result in code similar to the <code>nat.factors</code> implementation</p>



<a name="303504118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303504118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303504118">(Oct 11 2022 at 19:20)</a>:</h4>
<p>I think so too</p>



<a name="303684613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303684613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303684613">(Oct 12 2022 at 17:17)</a>:</h4>
<p>I realised there might be a nicer way to do this - we can compute the list of divisors using the VM, and it's enough to just produce a proof that the list is correct, and for that it suffices to proof we have a sublist of the correct list (ie everything we have is a divisor) and we have the right number of things. The first we can even do in pairs, and one multiplication will deal with two elements of the list; and the number of divisors can already be computed from <code>nat.factors</code></p>



<a name="303685238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303685238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303685238">(Oct 12 2022 at 17:21)</a>:</h4>
<p>I'm assuming you are still looking for a computationally efficient way to find all the divisors, rather than one that is less work to implement?</p>



<a name="303685639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303685639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303685639">(Oct 12 2022 at 17:23)</a>:</h4>
<p>I agree that it is more or less a required bit of work to multiply the divisors in the list in pairs to get the target number. But what of all the other numbers that we haven't multiplied? You still need to eliminate the possibility of a large prime factor of the target number</p>



<a name="303695101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303695101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303695101">(Oct 12 2022 at 18:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat/near/303685238">said</a>:</p>
<blockquote>
<p>I'm assuming you are still looking for a computationally efficient way to find all the divisors, rather than one that is less work to implement?</p>
</blockquote>
<p>I'm not too sure to be honest - but I suspect this idea isn't too much more work to implement than yours, while also being a lot more efficient?</p>



<a name="303695278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/303695278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#303695278">(Oct 12 2022 at 18:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat/near/303685639">said</a>:</p>
<blockquote>
<p>I agree that it is more or less a required bit of work to multiply the divisors in the list in pairs to get the target number. But what of all the other numbers that we haven't multiplied? You still need to eliminate the possibility of a large prime factor of the target number</p>
</blockquote>
<p>I think this is eliminated if we have a proof of the number of divisors (because the given list is a sublist of the list of divisors, and it has the same length, therefore they're equal). And we can calculate the number of divisors relatively easily by using the existing nat.factors extension</p>



<a name="304382907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/304382907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#304382907">(Oct 17 2022 at 05:34)</a>:</h4>
<blockquote>
<p>and the number of divisors can already be computed from <code>nat.factors</code></p>
</blockquote>
<p>Do we have the lemma that says this?</p>



<a name="304383118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/304383118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#304383118">(Oct 17 2022 at 05:36)</a>:</h4>
<p>Relatedly, should we have a <code>norm_num_rhs</code> tactic so that we can write the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="o">:</span> <span class="n">nat.divisors</span> <span class="mi">100</span> <span class="bp">=</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num_rhs</span>
</code></pre></div>



<a name="304383204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/304383204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#304383204">(Oct 17 2022 at 05:37)</a>:</h4>
<p>that looks like the conv mode tactic</p>



<a name="304383381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/304383381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#304383381">(Oct 17 2022 at 05:39)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">nat.factors</span> <span class="mi">100</span> <span class="bp">=</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">conv</span> <span class="o">{</span><span class="n">norm_num</span><span class="o">},</span>
  <span class="c1">-- this: 100.factors = [2, 2, 5, 5]</span>
<span class="kd">end</span>
</code></pre></div>



<a name="304639176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Easiest%20way%20to%20do%20casework%20on%20factors%20of%20%20nat/near/304639176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Easiest.20way.20to.20do.20casework.20on.20factors.20of.20.20nat.html#304639176">(Oct 18 2022 at 09:14)</a>:</h4>
<blockquote>
<p>the earlier lemmas are certainly gaps in mathlib </p>
</blockquote>
<p>I PR'd<code>divisors_mul</code> and a helper lemma in <a href="https://github.com/leanprover-community/mathlib/pull/17041">#17041</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
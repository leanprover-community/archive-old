---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/fin.20hell.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html">fin hell</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271139002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271139002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271139002">(Feb 08 2022 at 14:52)</a>:</h4>
<p>I have a fun little puzzle for people who like that kind of "fun little puzzle":</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.basic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">∨</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">k</span>  <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="271139271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271139271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271139271">(Feb 08 2022 at 14:54)</a>:</h4>
<p>This ought to be <code>cases k, cases j, linarith</code>.</p>



<a name="271139277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271139277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271139277">(Feb 08 2022 at 14:54)</a>:</h4>
<p><code>namespace profinitely_filtered_pseudo_normed_group_with_Tinv</code> will save you this time</p>



<a name="271139290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271139290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271139290">(Feb 08 2022 at 14:55)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/succ_order.lt_succ_iff_lt_or_eq">docs#succ_order.lt_succ_iff_lt_or_eq</a></p>



<a name="271139612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271139612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271139612">(Feb 08 2022 at 14:57)</a>:</h4>
<p><code>s/linarith/omega/</code>?</p>



<a name="271139913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271139913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271139913">(Feb 08 2022 at 14:59)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/succ_order.lt_succ_iff">docs#succ_order.lt_succ_iff</a> along with <a href="https://leanprover-community.github.io/mathlib_docs/find/le_iff_lt_or_eq">docs#le_iff_lt_or_eq</a>?</p>



<a name="271140096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271140096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271140096">(Feb 08 2022 at 15:00)</a>:</h4>
<p>or rather the more general version of <code>lt_succ_iff</code> which takes in a proof that <code>k</code> is not maximal rather than inferring it from <code>no_max_order</code>.</p>



<a name="271142200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271142200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271142200">(Feb 08 2022 at 15:14)</a>:</h4>
<p>I did not know that we had a coercion from <code>fin n</code> to <code>fin (n + 1)</code></p>



<a name="271142537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271142537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271142537">(Feb 08 2022 at 15:16)</a>:</h4>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">∨</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">k</span>  <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">fin.lt_def</span><span class="o">,</span> <span class="n">fin.ext_iff</span><span class="o">]</span> <span class="n">using</span> <span class="n">nat.lt_succ_iff_lt_or_eq</span>
</code></pre></div>
</div></div>



<a name="271142669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271142669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271142669">(Feb 08 2022 at 15:17)</a>:</h4>
<p>My way using <code>succ_order</code> would be much easier if <code>fin</code> addition was absorbent...</p>



<a name="271142758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271142758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271142758">(Feb 08 2022 at 15:17)</a>:</h4>
<p><code>k + 1</code> really shouldn't appear in the statement at all</p>



<a name="271142764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271142764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271142764">(Feb 08 2022 at 15:17)</a>:</h4>
<p>The <code>succ</code> I'm getting is <code>λ a, if a = fin.last n then fin.last n else a + 1</code>, not <code>λ a, a + 1</code> as you would expect.</p>



<a name="271142969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271142969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271142969">(Feb 08 2022 at 15:19)</a>:</h4>
<p>There is already a function for this, namely <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.succ">docs#fin.succ</a>. But then the right hand side is awkward, maybe it should be about <code>fin.cast_succ j</code>.</p>



<a name="271143143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271143143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271143143">(Feb 08 2022 at 15:20)</a>:</h4>
<p><code>simp</code> changes the statement to <code>j &lt; k.succ ↔ j &lt; ⇑fin.cast_succ k ∨ j = ⇑fin.cast_succ k</code></p>



<a name="271143440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271143440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271143440">(Feb 08 2022 at 15:22)</a>:</h4>
<p>There may be a <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> issue here. The full context is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kd">noncomputable theory</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kn">open</span> <span class="n">function</span> <span class="n">set</span> <span class="n">submodule</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">big_operators</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span>
          <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">basis.flag</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="bp">$</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="n">span</span> <span class="n">R</span> <span class="o">(</span><span class="n">b</span> <span class="bp">''</span> <span class="o">{</span><span class="n">j</span> <span class="bp">|</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">k</span><span class="o">})</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">basis.flag_zero</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="bp">$</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">b.flag</span> <span class="mi">0</span> <span class="bp">=</span> <span class="bp">⊥</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">basis.flag_last</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="bp">$</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">b.flag</span> <span class="o">(</span><span class="n">fin.last</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⊤</span>  <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">basis.flag_mono</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="bp">$</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">b.flag</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">pain</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">∨</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">k</span>  <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">basis.flag_span_succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">fin</span> <span class="bp">$</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">b.flag</span> <span class="n">k</span> <span class="bp">⊔</span> <span class="n">span</span> <span class="n">R</span> <span class="o">{</span><span class="n">b</span> <span class="n">k</span><span class="o">}</span> <span class="bp">=</span> <span class="n">b.flag</span> <span class="n">k.succ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">basis.flag</span><span class="o">,</span> <span class="bp">←</span> <span class="n">span_union</span><span class="o">,</span> <span class="bp">←</span> <span class="n">image_singleton</span><span class="o">,</span> <span class="bp">←</span> <span class="n">image_union</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">j</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">k</span> <span class="bp">∨</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">↔</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">pain</span><span class="o">,</span>
  <span class="n">tauto</span>
<span class="kd">end</span>
</code></pre></div>



<a name="271143526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271143526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271143526">(Feb 08 2022 at 15:23)</a>:</h4>
<p>You can see the weird goal is generated by <code>simp</code> in the suffices.</p>



<a name="271143654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271143654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271143654">(Feb 08 2022 at 15:24)</a>:</h4>
<p>Maybe the correct path is to forget about fin and define a function on nat.</p>



<a name="271144145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271144145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271144145">(Feb 08 2022 at 15:27)</a>:</h4>
<p>In <code>basis.flag</code> shouldn't <code>b</code> be a basis of size <code>n</code>?</p>



<a name="271144430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271144430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271144430">(Feb 08 2022 at 15:29)</a>:</h4>
<p>I don't really care. Maybe I was too cautious there.</p>



<a name="271144552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271144552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271144552">(Feb 08 2022 at 15:30)</a>:</h4>
<p>I mean, if <code>M</code> is dimension 3 then a flag has 4 subspaces (of dimensions 0, 1, 2, 3)</p>



<a name="271145001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271145001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271145001">(Feb 08 2022 at 15:32)</a>:</h4>
<p>Oh I see. I got my counting wrong.</p>



<a name="271145450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271145450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271145450">(Feb 08 2022 at 15:35)</a>:</h4>
<p>Now I need to fight casts and inclusion even in the definition of <code>basis.flag</code> <span aria-label="sob" class="emoji emoji-1f62d" role="img" title="sob">:sob:</span></p>



<a name="271146216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271146216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271146216">(Feb 08 2022 at 15:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113488-general/topic/fin.20hell/near/271143654">said</a>:</p>
<blockquote>
<p>Maybe the correct path is to forget about fin and define a function on nat.</p>
</blockquote>
<p>This seems very reasonable. You could even use int if there was some use for it.</p>



<a name="271337134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271337134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bolton Bailey <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271337134">(Feb 09 2022 at 19:49)</a>:</h4>
<p>Just as we have tactics#zify to transition from N to Z, we should have <code>nify</code> to transition from fin to N.</p>



<a name="271344137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/fin%20hell/near/271344137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/fin.20hell.html#271344137">(Feb 09 2022 at 20:40)</a>:</h4>
<p>You can always "cases i" to destruct your fin into the underlying nat value. And then rely on simp lemmas</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html">Reasoning about bitwise xor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="208271213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208271213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208271213">(Aug 27 2020 at 20:24)</a>:</h4>
<p>I'm currently stuck at <a href="https://github.com/leanprover-community/mathlib/blob/a579f8d2b446dbde34420fa79d4e7991404a66ab/src/data/nat/basic.lean#L989">this sorry</a> about <code>nat.lxor</code> and I'd like to ask whether anyone has an idea how to tackle it. The pen-and-paper proof is as follows. By our hypothesis, <code>v</code> is not zero. Let <code>i</code> be the position of the most significant 1-bit of <code>v</code>. Then at least one of <code>a</code>, <code>b</code> or <code>c</code> has a 1 at position <code>i</code>. Wlog, assume this is <code>a</code>. Then <code>a xor v</code> does not have a 1 at position <code>i</code>, but for every <code>j &gt; i</code>, <code>a xor v</code> has a 1 at position <code>j</code> iff <code>a</code> does, so <code>a xor v &lt; a</code>.</p>
<p>Does anyone have an idea how to approach these bitwise arguments? I tried both <code>nat.digits</code> and <code>nat.test_bit</code> and friends, but both seem very painful for this purpose.</p>



<a name="208271390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208271390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208271390">(Aug 27 2020 at 20:25)</a>:</h4>
<p>Is this useful for diagram chasing?!</p>



<a name="208271479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208271479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208271479">(Aug 27 2020 at 20:26)</a>:</h4>
<p>It's useful for <a href="https://github.com/leanprover-community/mathlib/blob/a579f8d2b446dbde34420fa79d4e7991404a66ab/src/set_theory/game/nim.lean#L331">addition of Grundy numbers</a>.</p>



<a name="208271509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208271509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208271509">(Aug 27 2020 at 20:26)</a>:</h4>
<p>And what is a grungy number?</p>



<a name="208271547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208271547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208271547">(Aug 27 2020 at 20:27)</a>:</h4>
<p>See <a href="https://en.wikipedia.org/wiki/Nimber">here</a> for example.</p>



<a name="208274248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208274248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208274248">(Aug 27 2020 at 20:49)</a>:</h4>
<p>Is it true if <code>a = 0</code>, <code>b = 0</code> and <code>c = 0</code>? Then there is no most significant 1-bit for any of the values</p>



<a name="208274353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208274353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208274353">(Aug 27 2020 at 20:50)</a>:</h4>
<p>Ah! The assumption makes that impossible, my mistake</p>



<a name="208274516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208274516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208274516">(Aug 27 2020 at 20:51)</a>:</h4>
<p>I was thinking, maybe you can use a decomposition: <code>0 &lt; a -&gt; exists p k, a = 2^k + p /\ p &lt; 2^k</code>. Then, <code>k</code> gives you a handle on the most significant 1-bit</p>



<a name="208275609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208275609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208275609">(Aug 27 2020 at 21:01)</a>:</h4>
<p>If you have <code>a = 2^ka + pa</code> and <code>b = 2^kb + pb</code>, you have three cases to consider when decomposing the <code>xor</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">xor</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">xor</span> <span class="n">pa</span> <span class="n">pb</span> <span class="k">if</span> <span class="n">ka</span> <span class="bp">=</span> <span class="n">kb</span>
          <span class="mi">2</span><span class="bp">^</span><span class="n">kb</span> <span class="bp">+</span> <span class="n">xor</span> <span class="n">a</span> <span class="n">pb</span> <span class="k">if</span> <span class="n">ka</span> <span class="bp">&lt;</span> <span class="n">kb</span>
          <span class="mi">2</span><span class="bp">^</span><span class="n">ka</span> <span class="bp">+</span> <span class="n">xor</span> <span class="n">pa</span> <span class="n">b</span> <span class="k">if</span> <span class="n">ka</span> <span class="bp">&gt;</span> <span class="n">kb</span>
</code></pre></div>



<a name="208279755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208279755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208279755">(Aug 27 2020 at 21:37)</a>:</h4>
<p>I don't like theorems that have <code>let</code> in their statements. In this case I think it would be best to just inline the let and introduce it in the body if you need it</p>



<a name="208279919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208279919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208279919">(Aug 27 2020 at 21:38)</a>:</h4>
<p>Also, the first disjunct is impossible - once you expand it you get <code>lxor a (lxor a (lxor b c)) = lxor b c</code>, which is greater than <code>a</code> by hypothesis</p>



<a name="208279957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208279957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208279957">(Aug 27 2020 at 21:39)</a>:</h4>
<p>in fact the other two disjuncts also simplify once you expand the let</p>



<a name="208280012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208280012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208280012">(Aug 27 2020 at 21:39)</a>:</h4>
<p>you should prove associativity of <code>lxor</code> for any <code>bitwise</code> so that you can conclude associativity of <code>band</code> and <code>bor</code> too</p>



<a name="208280190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208280190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208280190">(Aug 27 2020 at 21:41)</a>:</h4>
<p>In general, a good strategy for all sorts of bitwise properties is to apply <code>test_bit</code> extensionality, simp with <code>test_bit</code>, then conclude using a boolean theorem</p>



<a name="208280704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208280704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208280704">(Aug 27 2020 at 21:47)</a>:</h4>
<p>I don't know if this is helpful but it might suggest alternative approaches: I developed properties of the colex ordering <a href="https://github.com/leanprover-community/mathlib/pull/2770/files#diff-0e3f030c8979e8f440f1352f14f14ebe">here</a> - if you view naturals as the finite set of positions where the bit is on (ie under the map taking a <code>A : finset ℕ</code> to <code>A.sum (pow 2)</code>) then the ordering on naturals is the same as colex ordering, and lxor corresponds to symmetric difference of sets, so it could be helpful to use some of the ordering properties I put there</p>



<a name="208280711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208280711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208280711">(Aug 27 2020 at 21:47)</a>:</h4>
<p>I would suggest this version of the statement:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">tri&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">lxor</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">lxor</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">lxor</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:=</span>
</code></pre></div>



<a name="208281539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208281539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208281539">(Aug 27 2020 at 21:55)</a>:</h4>
<p>Your wlog in the proof sketch doesn't make any sense because a,b,c are not symmetric in the statement, only b and c</p>



<a name="208307970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208307970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208307970">(Aug 28 2020 at 05:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor/near/208281539">said</a>:</p>
<blockquote>
<p>Your wlog in the proof sketch doesn't make any sense because a,b,c are not symmetric in the statement, only b and c</p>
</blockquote>
<p>The proof sketch only uses the more general assumption <code>nat.lxor a (nat.lxor b c) ≠ 0</code>, which is symmetric.</p>



<a name="208308715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208308715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208308715">(Aug 28 2020 at 06:06)</a>:</h4>
<p>It is possible to formalize your argument directly, but there are some lemmas to prove about bitwise stuff</p>



<a name="208308793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208308793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208308793">(Aug 28 2020 at 06:07)</a>:</h4>
<p>I think it might be easier though to make use of the fact that <code>(\forall i, test_bit i a -&gt; test_bit i b) -&gt; a &lt;= b</code></p>



<a name="208308980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208308980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208308980">(Aug 28 2020 at 06:11)</a>:</h4>
<p>In this case, I think you want to construct the number <code>x</code> which matches <code>a</code> up to position <code>i</code>, and is 1 at position <code>i</code> and 0 at all lower bits. Then <code>a xor v \sub x-1</code> and <code>x &lt;= a</code>, which does the latter part of your proof sketch</p>



<a name="208309172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208309172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208309172">(Aug 28 2020 at 06:14)</a>:</h4>
<p>The lemma for the first part of your sketch is that if <code>v != 0</code> then there exists <code>i</code> such that <code>2^i &lt;= v &lt; 2^(i+1)</code>, which may already exist, plus the proof that <code>test_bit i v = 1</code> for such a number, which should not be hard to prove if you unfold the definition in terms of right shift (which is the same as integer division by 2^i)</p>



<a name="208332234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Reasoning%20about%20bitwise%20xor/near/208332234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Reasoning.20about.20bitwise.20xor.html#208332234">(Aug 28 2020 at 11:47)</a>:</h4>
<p>Thanks, I was able to work it out using your ideas. I PRed the resulting lemmas about <code>test_bit</code>, <code>lxor</code> and friends in <a href="https://github.com/leanprover-community/mathlib/issues/3964">#3964</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
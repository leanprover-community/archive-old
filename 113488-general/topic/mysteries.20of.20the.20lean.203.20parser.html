---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html">mysteries of the lean 3 parser</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="242437989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/242437989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#242437989">(Jun 12 2021 at 08:56)</a>:</h4>
<p>this exists:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#reduce</span> <span class="o">[</span><span class="n">whnf</span><span class="o">]</span> <span class="mi">2</span> <span class="c1">-- (1.add 0).succ</span>
</code></pre></div>



<a name="242704115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/242704115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#242704115">(Jun 15 2021 at 08:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">infix</span> <span class="n">f</span><span class="o">:</span><span class="mi">1</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">=</span><span class="o">)</span> <span class="c1">-- ok</span>
<span class="kd">infix</span> <span class="n">f</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">=</span><span class="o">)</span> <span class="c1">-- ok</span>
<span class="kd">infix</span> <span class="bp">+</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">=</span><span class="o">)</span> <span class="c1">-- ok</span>
<span class="kd">infix</span> <span class="bp">+</span><span class="o">:</span><span class="mi">1</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">=</span><span class="o">)</span> <span class="c1">-- parse fail</span>
</code></pre></div>



<a name="242705363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/242705363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#242705363">(Jun 15 2021 at 09:01)</a>:</h4>
<p>Oh boy, notations have a lot of easter eggs. This exists:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="bp">`</span><span class="n">foo</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="n">x</span><span class="o">:</span><span class="n">prev</span> <span class="o">:=</span> <span class="n">x</span>
<span class="k">#print</span> <span class="kd">notation</span> <span class="n">foo</span>
<span class="c1">-- `foo`:50 _:50 := #0</span>
</code></pre></div>
<p>I guess it's useful?</p>



<a name="242706085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/242706085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#242706085">(Jun 15 2021 at 09:08)</a>:</h4>
<p>Whaaat?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="mi">42</span> <span class="o">:=</span> <span class="n">false</span>
<span class="k">#eval</span> <span class="k">if</span> <span class="mi">42</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div>



<a name="242710576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/242710576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#242710576">(Jun 15 2021 at 09:50)</a>:</h4>
<p>Oh, a segfault. Haven't seen one of those in a while.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">F</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="kd">notation</span> <span class="bp">`</span><span class="n">foo</span><span class="bp">`</span> <span class="n">binders</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">F</span>
<span class="k">#check</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
</code></pre></div>
<p>(note: I have no idea what I'm doing here)</p>



<a name="242819814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/242819814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#242819814">(Jun 16 2021 at 01:20)</a>:</h4>
<p>well this is fun:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">true</span>
<span class="kd">notation</span> <span class="bp">`Λ`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">b</span><span class="o">:</span><span class="n">scoped</span> <span class="bp">`</span> <span class="o">:</span><span class="bp">Λ`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">c</span><span class="o">:</span><span class="n">scoped</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">b</span> <span class="n">c</span>

<span class="k">#check</span> <span class="bp">Λ</span> <span class="n">x</span><span class="o">:</span><span class="n">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="o">:</span><span class="bp">Λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">2</span>
<span class="c1">-- Λ (x y : ℕ), x &lt; 2 :Λ (x y : ℕ), y &lt; 2 : Prop</span>
<span class="k">#check</span> <span class="bp">Λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="o">:</span><span class="bp">Λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">2</span>
<span class="c1">-- Λ (x y x y : ℕ), x &lt; 2 :Λ (x y x y : ℕ), y &lt; 2 : Prop</span>
<span class="k">#check</span> <span class="bp">Λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="o">:</span><span class="bp">Λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">2</span>
<span class="c1">-- Λ (x y x y x y x y : ℕ), x &lt; 2 :Λ (x y x y x y x y : ℕ), y &lt; 2 : Prop</span>
</code></pre></div>



<a name="242823358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/242823358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#242823358">(Jun 16 2021 at 02:27)</a>:</h4>
<p>pretty sure this is a bug:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">unit</span> <span class="o">:=</span> <span class="o">()</span>
<span class="kd">def</span> <span class="n">unit.bla</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:=</span> <span class="o">()</span>

<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="k">#check</span> <span class="n">foo.bla.bla.bla.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span><span class="bp">.</span><span class="o">{</span><span class="mi">42</span><span class="o">}</span>
</code></pre></div>



<a name="242829844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/242829844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#242829844">(Jun 16 2021 at 04:49)</a>:</h4>
<p>I can't make sense of any of this</p>



<a name="242830223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/242830223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#242830223">(Jun 16 2021 at 04:56)</a>:</h4>
<p>This is all white box testing BTW. I've been reading the parser code and every time I see something odd I try to make a test case. In this case, the problem is that lean has a fallback approach to disambiguating a namespaced name like <code>nat.add</code> from a projection on a constant like <code>list.nil.tail</code>, and every time the fallback is called it parses a level list, possibly discarding the one from the previous iteration. As a result, you can get this weird behavior where you can stick multiple level lists on a multi-fallback name expression, and they will be parsed but the level list itself is discarded</p>



<a name="243110356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243110356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243110356">(Jun 18 2021 at 02:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">attribute</span> <span class="o">[</span><span class="n">intro</span><span class="o">]</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="mi">1</span>
</code></pre></div>
<p>Apparently long form attributes accept multiple bracket lists...</p>



<a name="243110403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243110403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243110403">(Jun 18 2021 at 02:34)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">attribute</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="mi">1</span>
</code></pre></div>
<p>...or no bracket lists</p>



<a name="243114493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243114493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243114493">(Jun 18 2021 at 04:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">private</span> <span class="kn">local</span> <span class="kn">attribute</span> <span class="kn">protected</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="mi">1</span>
</code></pre></div>
<p>apparently <code>local attribute</code> can have modifiers, and can also be a modifier on another declaration. So you can use this to make otherwise impossible definitions like a <code>private protected def</code>, which amusingly can't be referred to because it has a crazy namespace and also can't be referenced except through that namespace</p>



<a name="243123024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243123024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243123024">(Jun 18 2021 at 07:01)</a>:</h4>
<p>"i have discovered a truly marvelous proof of this, which, however, is a <code>private local attribute protected theorem</code>"</p>



<a name="243192625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243192625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243192625">(Jun 18 2021 at 18:06)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>
<span class="kd">structure</span> <span class="n">bar</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">foo</span> <span class="kd">extends</span> <span class="kn">private</span> <span class="n">to_bar'</span> <span class="o">:</span> <span class="n">bar</span> <span class="kn">renaming</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
</code></pre></div>
<p>I don't think all of these features are simultaneously useful, but <code>extends</code> has a few seldom used knobs:</p>
<ul>
<li>For a <code>class</code>, the parent coercion will be marked <code>@[instance]</code>, unless <code>private</code> is set</li>
<li><code>to_bar' : bar</code> instead of just <code>bar</code> allows you to change the name of the parent coercion field. It seems to be ignored if <code>old_structure_cmd</code> is set</li>
<li><code>renaming x -&gt; y</code> lets you rename fields that are being splatted into the structure when <code>old_structure_cmd</code> is set</li>
</ul>



<a name="243193756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243193756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243193756">(Jun 18 2021 at 18:18)</a>:</h4>
<p>That <code>private</code> sounds like it might be useful for making the canonical parent projection be <code>coe</code> by hiding the real one completely</p>



<a name="243194244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243194244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243194244">(Jun 18 2021 at 18:24)</a>:</h4>
<p>Despite the name, it doesn't actually make anything <code>private</code> in the sense of a <code>private def</code>. It only removes the <code>@[instance]</code> attribute on the parent projection</p>



<a name="243196476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243196476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243196476">(Jun 18 2021 at 18:50)</a>:</h4>
<p>You might know that <code>structure</code> allows defining local notations as additional fields, which can be used in later fields. But did you know that <code>inductive</code> <em>also</em> supports local notations? Here is the syntax:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">prov</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">infix</span> <span class="bp">`⊢`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">prov</span>
<span class="bp">|</span> <span class="n">le</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">⊢</span> <span class="n">b</span>

<span class="kd">mutual</span> <span class="kd">inductive</span> <span class="n">prov'</span><span class="o">,</span> <span class="n">defeq</span>
<span class="kd">infix</span> <span class="bp">`⊢`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">prov'</span>

<span class="k">with</span> <span class="n">prov'</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">le</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">⊢</span> <span class="n">b</span>

<span class="k">with</span> <span class="n">defeq</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">eq</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">defeq</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>
<p>Unfortunately, it only supports one notation command, so make it count.</p>



<a name="243196800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243196800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243196800">(Jun 18 2021 at 18:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser/near/243196476">said</a>:</p>
<blockquote>
<p>You might know that <code>structure</code> allows defining local notations as additional fields, which can be used in later fields. But did you know that <code>inductive</code> <em>also</em> supports local notations? Here is the syntax:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">prov</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kd">infix</span> <span class="bp">`⊢`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">prov</span>
<span class="bp">|</span> <span class="n">le</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">⊢</span> <span class="n">b</span>

<span class="kd">mutual</span> <span class="kd">inductive</span> <span class="n">prov'</span><span class="o">,</span> <span class="n">defeq</span>
<span class="kd">infix</span> <span class="bp">`⊢`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">prov'</span>

<span class="k">with</span> <span class="n">prov'</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">le</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">⊢</span> <span class="n">b</span>

<span class="k">with</span> <span class="n">defeq</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">eq</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">defeq</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>
<p>Unfortunately, it only supports one notation command, so make it count.</p>
</blockquote>
<p>I used this for my BSc thesis. Very handy when defining large inductives :)</p>



<a name="243197048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243197048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243197048">(Jun 18 2021 at 18:56)</a>:</h4>
<p>Inductive constructors accept doc strings:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- This documents foo -/</span>
<span class="kd">inductive</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="sd">/-- This documents foo.zero -/</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">foo</span> <span class="mi">0</span>
<span class="sd">/-- This documents foo.one -/</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">:</span> <span class="n">foo</span> <span class="mi">1</span>
</code></pre></div>



<a name="243197647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243197647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243197647">(Jun 18 2021 at 19:02)</a>:</h4>
<p>We actually get doc blames in <a href="https://github.com/leanprover-community/mathlib/blob/master/scripts/nolints.txt">nolint.txt</a> for not providing those!</p>



<a name="243197900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243197900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243197900">(Jun 18 2021 at 19:05)</a>:</h4>
<p>Do structure fields accept them?</p>



<a name="243197983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243197983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243197983">(Jun 18 2021 at 19:06)</a>:</h4>
<p>nope</p>



<a name="243263902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243263902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243263902">(Jun 19 2021 at 18:56)</a>:</h4>
<p>I'm not sure if this counts as the same sort of lean 3 parser mystery, but I came across:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">foo.bar</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">[</span><span class="n">X.bar</span><span class="o">]</span> <span class="c1">-- works</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">X.bar</span><span class="o">]</span> <span class="c1">-- fails</span>
</code></pre></div>
<p>which surprised me: it means we can't do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">[</span><span class="n">X.bar</span><span class="o">]</span>
</code></pre></div>
<p>as well</p>



<a name="243264066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243264066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243264066">(Jun 19 2021 at 19:00)</a>:</h4>
<p>oh, good catch, I didn't notice that when looking at the code</p>



<a name="243264075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243264075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243264075">(Jun 19 2021 at 19:00)</a>:</h4>
<p>looking at it now that still seems like it should work</p>



<a name="243264176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243264176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243264176">(Jun 19 2021 at 19:03)</a>:</h4>
<p>Oh, I see, it parses <code>X.bar</code> as a name, sees a <code>]</code> and decides this must be a variable binder update even though it hasn't resolved the variable yet</p>



<a name="243264241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243264241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243264241">(Jun 19 2021 at 19:04)</a>:</h4>
<p>The <code>variable</code> command has an exception for this because it came up in the past wrt <code>variable [io.interface]</code>, but the fix was not propagated to <code>variables</code> as well</p>



<a name="243377776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243377776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243377776">(Jun 21 2021 at 12:59)</a>:</h4>
<p><code>(::)</code> is a token, probably because of the <code>(: ... :)</code> pattern notation, even though it doesn't have any special meaning beyond the usual interpretation as a section of the <code>list.cons</code> function. However the implementation is a bit different, and so adding whitespace to break the token changes the result slightly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">(</span> <span class="bp">&lt;</span> <span class="o">)</span>  <span class="c1">-- has_lt.lt : ?M_1 → ?M_1 → Prop</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span>    <span class="c1">-- has_lt.lt : ?M_1 → ?M_1 → Prop</span>

<span class="k">#check</span> <span class="o">(</span> <span class="o">::</span> <span class="o">)</span> <span class="c1">-- list.cons : ?M_1 → list ?M_1 → list ?M_1</span>
<span class="k">#check</span> <span class="o">(::)</span>   <span class="c1">-- λ (_x : ?M_1) (_y : list ?M_1), _x :: _y : ?M_1 → list ?M_1 → list ?M_1</span>
</code></pre></div>



<a name="243378096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243378096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243378096">(Jun 21 2021 at 13:01)</a>:</h4>
<p>However, because this override is specific to <code>::</code>, other notations beginning with <code>:</code> don't get the same treatment, and the <code>(:</code> can end up breaking them:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="n">nat.lt</span>
<span class="kd">infix</span> <span class="bp">`</span><span class="o">:</span><span class="bp">&gt;`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">foo</span>

<span class="k">#check</span> <span class="o">(</span> <span class="o">:</span><span class="bp">&gt;</span> <span class="o">)</span> <span class="c1">-- foo : ℕ → ℕ → Prop</span>
<span class="k">#check</span> <span class="o">(:</span><span class="bp">&gt;</span><span class="o">)</span> <span class="c1">-- invalid expression</span>
</code></pre></div>



<a name="243400533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243400533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243400533">(Jun 21 2021 at 15:34)</a>:</h4>
<p>Apparently you can write set comprehensions using either <code>∈</code> or <code>in</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="o">{</span><span class="n">x</span> <span class="k">in</span> <span class="o">(</span><span class="bp">∅</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span><span class="o">)</span> <span class="bp">|</span> <span class="n">true</span><span class="o">}</span>
<span class="c1">-- {x ∈ ∅ | true} : set ℕ</span>
</code></pre></div>



<a name="243412338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243412338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243412338">(Jun 21 2021 at 17:04)</a>:</h4>
<p>You might know that you can change tactic classes using <code>begin [class] tacs, ... end</code>. But this also works in the middle of a tactic proof, if you put the class after a <code>{ ... }</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">skip</span><span class="o">,</span> <span class="c1">-- this is a tactic</span>
  <span class="o">{</span> <span class="o">[</span><span class="n">smt</span><span class="o">]</span>
    <span class="n">eblast</span> <span class="o">},</span> <span class="c1">-- this is a smt_tactic</span>
<span class="kd">end</span>
</code></pre></div>



<a name="243448251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243448251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243448251">(Jun 21 2021 at 21:53)</a>:</h4>
<p>It turns out <code>#print</code> is a bit more featureful than you might be aware. Also <code>#help</code> exists</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="s2">"hello world"</span> <span class="c1">-- prints "hello world"; only works with string literals</span>
<span class="k">#print</span> <span class="n">raw</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="kd">by</span> <span class="n">skip</span><span class="o">)</span> <span class="c1">-- prints pexprs without elaboration</span>
<span class="k">#print</span> <span class="n">options</span> <span class="c1">-- print lean command line options</span>
<span class="k">#print</span> <span class="n">trust</span> <span class="c1">-- print trust level (0 = most paranoid)</span>
<span class="c1">-- #print key_equivalences -- crash lean</span>
<span class="k">#print</span> <span class="n">nat.add</span> <span class="c1">-- prints the definition of nat.add</span>
<span class="k">#print</span> <span class="kd">definition</span> <span class="n">nat.add</span> <span class="c1">-- prints nat.add for people who like to spell out "definition"</span>
<span class="k">#print</span> <span class="n">instances</span> <span class="n">inhabited</span> <span class="c1">-- prints all instances of inhabited typeclass</span>
<span class="k">#print</span> <span class="n">classes</span> <span class="c1">-- prints all typeclasses</span>
<span class="k">#print</span> <span class="n">attributes</span> <span class="c1">-- prints all attributes</span>
<span class="k">#print</span> <span class="kd">prefix</span> <span class="n">nat.add</span> <span class="c1">-- prints all definitions starting with nat.add</span>
<span class="k">#print</span> <span class="n">aliases</span> <span class="c1">-- prints all aliases, created by "export" command</span>
<span class="k">#print</span> <span class="kd">axioms</span> <span class="c1">-- prints all axioms in the current environment (there are more than 3 things in this list)</span>
<span class="k">#print</span> <span class="kd">axioms</span> <span class="n">classical.em</span> <span class="c1">-- prints all axioms used by a given theorem</span>
<span class="k">#print</span> <span class="n">fields</span> <span class="n">group</span> <span class="c1">-- prints all fields in a structure</span>
<span class="k">#print</span> <span class="kd">notation</span> <span class="c1">-- prints all notation</span>
<span class="k">#print</span> <span class="kd">notation</span> <span class="o">,</span> <span class="bp">-&gt;</span> <span class="c1">-- prints all notation using the tokens `,` or `-&gt;`</span>
<span class="k">#print</span> <span class="kd">inductive</span> <span class="n">nat</span> <span class="c1">-- same as `#print nat` but only works for inductives</span>
<span class="k">#print</span> <span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="c1">-- print all declarations marked `@[ext]`</span>
<span class="k">#print</span> <span class="o">[</span><span class="n">recursor</span><span class="o">]</span> <span class="n">nat.rec</span> <span class="c1">-- print diagnostics for a recursor</span>
<span class="k">#print</span> <span class="o">[</span><span class="n">unify</span><span class="o">]</span> <span class="c1">-- print all unification hints</span>
<span class="k">#print</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">functor_norm</span> <span class="c1">-- print all simp lemmas in the functor_norm simp set? it doesn't work</span>
<span class="k">#print</span> <span class="o">[</span><span class="n">congr</span><span class="o">]</span> <span class="n">functor_norm</span> <span class="c1">-- congr lemmas are apparently also related to the simp sets; also doesn't work</span>
<span class="k">#print</span> <span class="bp">&lt;</span> <span class="c1">-- Same as `#print notation &lt;`</span>

<span class="k">#help</span> <span class="c1">-- help help</span>
<span class="k">#help</span> <span class="n">options</span> <span class="c1">-- print `set_option` options and descriptions</span>
<span class="k">#help</span> <span class="n">commands</span> <span class="c1">-- print all commands</span>
</code></pre></div>



<a name="243472116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/243472116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#243472116">(Jun 22 2021 at 04:49)</a>:</h4>
<p>I think that long ago, I knew about <code>#help</code>.</p>



<a name="244982361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/244982361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#244982361">(Jul 05 2021 at 23:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="bp">`</span><span class="sd">/--'`x := 55 * x</span>

<span class="sd">example : (110:ℕ) = /--'2 := rfl</span>

<span class="sd">/--' testing -/</span>
</code></pre></div>
<p>so as it turns out you can override comment notation... the <code>example</code> complies, the block comment there doesn't work</p>



<a name="244982552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/244982552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#244982552">(Jul 05 2021 at 23:53)</a>:</h4>
<p>even more amazlingly, you can do it with the close-comment block and seemingly get no issues:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="bp">`-/`</span> <span class="o">:=</span> <span class="mi">55</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">55</span><span class="o">:</span><span class="n">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-/</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"> testing -/</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">trivial</span>
</code></pre></div>
<p>the syntax highlighter even deals with it (!)</p>



<a name="245129773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/245129773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#245129773">(Jul 07 2021 at 05:07)</a>:</h4>
<p>Apparently you can put negative attributes on a definition, although it's hard to come up with an example where this makes a difference.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="n">simp</span><span class="o">]</span> <span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="c1">-- cannot remove attribute [simp]: no prior declaration on foo</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kd">def</span> <span class="n">bar</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="k">#print</span> <span class="n">bar</span> <span class="c1">-- @[_simp_cache, simp] def bar : ℕ := 1</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">,</span> <span class="bp">-</span><span class="n">simp</span><span class="o">]</span> <span class="kd">def</span> <span class="n">baz</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="k">#print</span> <span class="n">baz</span> <span class="c1">-- @[_simp_cache] def baz : ℕ := 1</span>
</code></pre></div>



<a name="245194495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/245194495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#245194495">(Jul 07 2021 at 15:01)</a>:</h4>
<p>So that last example adds <code>baz</code> to the simp cache but doesn't mark it as simp? Does this relate to the C++ implementation of simp?</p>



<a name="245397458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/245397458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#245397458">(Jul 09 2021 at 03:46)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="kd">notation</span> <span class="bp">`</span><span class="n">foo</span><span class="bp">`</span><span class="o">:</span><span class="mi">20</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">)</span> <span class="n">a</span><span class="o">,</span> <span class="n">foo</span> <span class="c1">-- works</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="kd">notation</span> <span class="bp">`</span><span class="n">foo</span><span class="bp">`</span><span class="o">:</span><span class="mi">20</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">foo</span> <span class="c1">-- fails because the first lambda looks 0-ary to lean</span>
</code></pre></div>



<a name="246666158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/246666158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#246666158">(Jul 21 2021 at 00:18)</a>:</h4>
<p>Having observed that the lean grammar can contain commands inside string literals inside expressions inside commands, I had to play with that, and it turns out that things are a little weirder than you might expect:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.interactive.emit_code</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">interactive.parse</span> <span class="o">(</span><span class="k">do</span>
  <span class="n">s</span> <span class="bp">←</span> <span class="n">lean.parser.pexpr</span><span class="o">,</span>
  <span class="n">s</span> <span class="bp">←</span> <span class="n">tactic.to_expr</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">s</span> <span class="bp">←</span> <span class="n">tactic.eval_expr</span> <span class="n">string</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">lean.parser.emit_code_here</span> <span class="n">s</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">tactic.triv</span>

<span class="kn">namespace</span> <span class="n">foo</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">emit_code</span> <span class="s2">"</span>
<span class="s2">  #where -- we are in namespace foo</span>

<span class="s2">  -- example foo : true := trivial  -- fails</span>
<span class="s2">  example := by triv                -- this works though</span>
<span class="s2">  #check true                       -- true : _</span>
<span class="s2">  #check by exact true              -- true : Prop</span>

<span class="s2">  example := by emit_code </span><span class="se">\"</span><span class="s2"></span>
<span class="s2">    #print </span><span class="se">\\\"</span><span class="s2">inception</span><span class="se">\\\"</span><span class="s2"></span>
<span class="s2">    -- end foo -- uncomment this to get a segfault</span>
<span class="s2">  </span><span class="se">\"</span><span class="s2"></span>

<span class="s2">  end foo</span>
<span class="s2">"</span>

<span class="kd">end</span> <span class="n">foo</span> <span class="c1">-- fails, closed namespace foo already</span>
</code></pre></div>



<a name="246670680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/246670680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#246670680">(Jul 21 2021 at 01:40)</a>:</h4>
<p>here's another fun variation, a command parsing quine:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="s2">"example := by emit_code foo"</span>
<span class="kd">example</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">emit_code</span> <span class="n">foo</span>
</code></pre></div>



<a name="247017294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/247017294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#247017294">(Jul 23 2021 at 18:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="o">(</span><span class="kd">notation</span> <span class="bp">`</span><span class="n">foo</span><span class="bp">`</span><span class="o">:</span><span class="mi">20</span> <span class="o">:=</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">foo</span><span class="o">),</span>
  <span class="n">trivial</span>
<span class="kd">end</span>
</code></pre></div>
<p>local notations where you least expect them</p>



<a name="247017710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/247017710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#247017710">(Jul 23 2021 at 18:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">,</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kd">end</span>
</code></pre></div>
<p>This one is probably a bit misleading...</p>



<a name="247656904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/247656904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#247656904">(Jul 30 2021 at 00:04)</a>:</h4>
<p>bound variable capture in binder collections:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">5</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">6</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">6</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">5</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">6</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">6</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">&lt;</span> <span class="mi">5</span><span class="o">,</span> <span class="n">_x</span> <span class="bp">&lt;</span> <span class="mi">6</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">6</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="247679611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/247679611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#247679611">(Jul 30 2021 at 07:54)</a>:</h4>
<p>I'm more surprised that <code>x y &lt; 5</code> bounds <em>both</em> <code>x</code> and <code>y</code>.  Why do we learn about all these cool features only now?</p>



<a name="247708250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/247708250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#247708250">(Jul 30 2021 at 13:34)</a>:</h4>
<p>I thought this was already used in mathlib, especially with set membership (in fact I thought I saw code from you yourself Gabriel using this feature!)</p>



<a name="248210781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/248210781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#248210781">(Aug 03 2021 at 11:54)</a>:</h4>
<p>Notation captures field notation without resolving it to a symbol name until the notation is used:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">a</span> <span class="bp">`+'`</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">a.foo</span> <span class="bp">+</span> <span class="n">b.foo</span>

<span class="kd">def</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">unit</span>
<span class="kd">def</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">unit</span>

<span class="kd">def</span> <span class="n">X.foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="kd">def</span> <span class="n">Y.foo</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span> <span class="o">:=</span> <span class="mi">2</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">x</span> <span class="bp">+'</span> <span class="n">x</span>  <span class="c1">-- int</span>
<span class="k">#check</span> <span class="n">y</span> <span class="bp">+'</span> <span class="n">y</span>  <span class="c1">-- nat</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+'</span> <span class="n">x</span><span class="o">)</span>  <span class="c1">-- cannot evaluate function: 0 arguments given but expected 1</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+'</span> <span class="n">y</span><span class="o">)</span>  <span class="c1">-- cannot evaluate function: 0 arguments given but expected 1</span>
</code></pre></div>



<a name="248210804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mysteries%20of%20the%20lean%203%20parser/near/248210804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/mysteries.20of.20the.20lean.203.20parser.html#248210804">(Aug 03 2021 at 11:54)</a>:</h4>
<p>(the <code>#eval</code> failure is reposted <a href="#narrow/stream/113488-general/topic/.23eval.20gets.20stuck.20on.20dot.20notation">here</a>)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html">Verifying proof of a particular theorem</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="200776106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200776106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Shu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200776106">(Jun 13 2020 at 17:18)</a>:</h4>
<p>Is there a way to verify that a particular lemma has been proven in a particular lean file, in a way that is 'unhackable'? This would have applications, say, if a teacher wanted to have students submit some kind of homework in lean that would be verified automatically.</p>



<a name="200776211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200776211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200776211">(Jun 13 2020 at 17:22)</a>:</h4>
<p>This has been discussed in the context of coding contests, but we don't have a bullet-proof workflow.</p>



<a name="200776263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200776263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200776263">(Jun 13 2020 at 17:22)</a>:</h4>
<p>You can discuss this with <span class="user-mention" data-user-id="264734">@Donald Sebastian Leung</span>. I don't remember what was the other similar thing.</p>



<a name="200776667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200776667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200776667">(Jun 13 2020 at 17:32)</a>:</h4>
<p>The way used in codewars is to have a separate file (which the student cannot edit) which contains the theorem statement, and proof given by referencing the name of the student's proof; then use <code>#print axioms</code> on this</p>



<a name="200776690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200776690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200776690">(Jun 13 2020 at 17:33)</a>:</h4>
<p>This way you can verify that the student has proved what they were meant to prove, and the print axioms list should only contain the valid axioms in lean</p>



<a name="200776696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200776696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200776696">(Jun 13 2020 at 17:33)</a>:</h4>
<p>I don't know of a convincing hack for this</p>



<a name="200796702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200796702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Donald Sebastian Leung <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200796702">(Jun 14 2020 at 02:45)</a>:</h4>
<p>IIRC it was mentioned that the <code>#print axioms</code> method used by Codewars could still be subverted in principle by redefining the <code>#print axioms</code> notation. The other similar thing mentioned by <span class="user-mention" data-user-id="110031">@Patrick Massot</span> is probably <a href="https://competition.isabelle.systems">Proving for Fun</a> where Codewars derived its testing setup from (for Lean). The only difference in the setup between Codewars and Proving for Fun AFAIK is that for the latter, instead of using <code>#print axioms</code>, they inspect the output of running <code>leanchecker</code> on the check file instead which closes off any known loopholes (there was a brief period where they discovered a loophole with <code>leanchecker</code> itself but I believe it has been fixed since).</p>
<p><span class="user-mention" data-user-id="296764">@Kevin Shu</span> You may wish to refer to selected comments on <a href="https://github.com/codewars/codewars-runner-cli/issues/773">Codewars/codewars-runner-cli#773</a> for an extended discussion on automating the process of checking Lean submissions and cheat detection / prevention techniques.</p>



<a name="200820147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200820147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200820147">(Jun 14 2020 at 15:05)</a>:</h4>
<p>Lean can do arbitrary I/O in tactics. It should be easy to use this to subvert any fully automated testing harness. The Proving for Fun method, for example, could be tricked by replacing the <code>leanchecker</code> executable. Further, this is a major security risk -- running arbitrary untrusted code -- which needs to be mitigated by proper sandboxing.</p>
<p>All this could be addressed by adding a flag to Lean which disables I/O in tactics (i.e. makes <code>tactic.unsafe_run_io</code> a noop). This shouldn't break anything; neither the Lean standard library nor mathlib uses this function.</p>



<a name="200821399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200821399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200821399">(Jun 14 2020 at 15:36)</a>:</h4>
<p>Language-based sandboxing is hard to design and almost impossible to make 100% sound - just look at the mess in the JVM. If you want sandboxing, put the entire Lean process in a proper sandbox.</p>



<a name="200822365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200822365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200822365">(Jun 14 2020 at 16:02)</a>:</h4>
<p>At a minimum, you'd have to take away <code>unchecked_cast</code>, but then the hunt is on for exploitable interpreter bugs, and this is not a road worth going down...</p>



<a name="200825077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200825077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200825077">(Jun 14 2020 at 17:16)</a>:</h4>
<p>Yes, language sandboxes in general are hard and I wouldn't rely on a hypothetical "safe Lean" to run untrusted code without any additional measures. But for the purposes of this thread,  I think (without knowing much at all about this part of Lean) you could just disable Lean's I/O functionality entirely, i.e. all IO-related primitives are replaced with runtime errors. That would at least make exploitation much less trivial. Call it defence in depth if you will.</p>



<a name="200839035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verifying%20proof%20of%20a%20particular%20theorem/near/200839035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Verifying.20proof.20of.20a.20particular.20theorem.html#200839035">(Jun 14 2020 at 23:41)</a>:</h4>
<p>I don't know anything about this stuff, but someone recently was talking about overriding existing overrides. Can we "shut down" things like <code>unchecked_cast</code> and <code>unsafe_run_io</code> from Lean?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
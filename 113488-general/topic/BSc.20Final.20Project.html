---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/BSc.20Final.20Project.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html">BSc Final Project</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="220647062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220647062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomaz Gomes Mascarenhas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220647062">(Dec 22 2020 at 00:31)</a>:</h4>
<p>Hi all! I'm close to finish my BSc in Computer Science and, as my final project, I'm planning to formalize some data structure using Lean. If possible, I would like to formalize one that wasn't formalized yet on mathlib and will be of some relevance to it. One possibility is to choose one from Benjamin's Pierce course on formalization of Algorithms (<a href="https://softwarefoundations.cis.upenn.edu/vfa-current/toc.html">https://softwarefoundations.cis.upenn.edu/vfa-current/toc.html</a>) and adapt it to Lean. What do you think? Any suggestions?</p>



<a name="220648611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220648611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220648611">(Dec 22 2020 at 00:57)</a>:</h4>
<p>I suggest you start with the easiest ones to see what tools Lean might be missing. You may have to write programming-specific tactics to help yourself complete your tasks. Having a slow buildup in difficulty should also help you choose the problem to focus on.</p>



<a name="220709271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220709271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220709271">(Dec 22 2020 at 16:41)</a>:</h4>
<p>there's some stuff for insertion sort and merge sort in <code>data/list/sort.lean</code>, so that seems like a good place to look</p>



<a name="220709297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220709297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220709297">(Dec 22 2020 at 16:41)</a>:</h4>
<p>it doesn't seem very fleshed out, in the sense that there are many other ways to sort arrays that are not mentioned</p>



<a name="220709372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220709372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220709372">(Dec 22 2020 at 16:42)</a>:</h4>
<p>also, there are kind of two main facts about sorting arrays - the fact that algorithms actually do sort arrays, and the asymptotic analysis of how much time it takes</p>



<a name="220709394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220709394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220709394">(Dec 22 2020 at 16:42)</a>:</h4>
<p>nothing currently in the sort logic mentions the time complexity</p>



<a name="220709439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220709439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220709439">(Dec 22 2020 at 16:42)</a>:</h4>
<p>I'm not sure if anything anywhere in Lean is mentioning the time complexity of algorithms? but I think something along these lines would be interesting</p>



<a name="220709557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220709557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220709557">(Dec 22 2020 at 16:43)</a>:</h4>
<p>my instinct would be to focus on sorting rather than red-black trees and priority queues, because sorting is clearly incomplete and it'll be easier to do than the more complex data structures</p>



<a name="220723855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220723855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220723855">(Dec 22 2020 at 19:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238605">Kevin Lacker</span> <a href="#narrow/stream/113488-general/topic/BSc.20Final.20Project/near/220709297">said</a>:</p>
<blockquote>
<p>it doesn't seem very fleshed out, in the sense that there are many other ways to sort arrays that are not mentioned</p>
</blockquote>
<p>I don't think the current implementations are intended to show off all possible sort algorithms; there is just one simple one to show that it is possible, and one efficient one in case you just need to sort stuff</p>



<a name="220723949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220723949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220723949">(Dec 22 2020 at 19:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238605">Kevin Lacker</span> <a href="#narrow/stream/113488-general/topic/BSc.20Final.20Project/near/220709394">said</a>:</p>
<blockquote>
<p>nothing currently in the sort logic mentions the time complexity</p>
</blockquote>
<p>It's not really possible to formalize time complexity of (shallowly embedded) lean algorithms. You need an actual theory of computation for that, e.g. <code>computability/</code> and even then you probably won't get something practically usable</p>



<a name="220727797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220727797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220727797">(Dec 22 2020 at 19:54)</a>:</h4>
<p>for sorts specifically I was thinking you could implement them in terms of a thing that counts the number of comparisons? i dunno if it would be practically usable, but maybe within scope for an undergrad project</p>



<a name="220727848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220727848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220727848">(Dec 22 2020 at 19:54)</a>:</h4>
<p>I only refer to this as "not fleshed out" in the sense of "still some stuff an undergrad could do" rather than "this library is insufficient for some practical reason"</p>



<a name="220728045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220728045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220728045">(Dec 22 2020 at 19:56)</a>:</h4>
<p>It's certainly possible to have a lightweight formalization of time or comparison complexity enough to prove the asymptotic orders of some sorting algorithms, and that could indeed be an undergrad project</p>



<a name="220729130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220729130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220729130">(Dec 22 2020 at 20:07)</a>:</h4>
<p>I'm not sure how you'd go about counting comparisons or similar in a lean function without adding substantial bookkeeping</p>



<a name="220729715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220729715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Lacker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220729715">(Dec 22 2020 at 20:14)</a>:</h4>
<p>the sort algorithms are just so simple, I figure you would be able to add the substantial bookkeeping</p>



<a name="220730402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220730402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220730402">(Dec 22 2020 at 20:22)</a>:</h4>
<p>The usual approach is to use a state monad that counts whatever you want to count</p>



<a name="220734547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/220734547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#220734547">(Dec 22 2020 at 21:09)</a>:</h4>
<p>You can also consider formalizing the operational semantics of a small programming language with <code>if</code>, <code>rec</code>, <code>compare</code> <code>let</code> and array operations and counting the number of evaluation steps for arbitrary inputs</p>



<a name="223069426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/223069426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomaz Gomes Mascarenhas <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#223069426">(Jan 17 2021 at 23:28)</a>:</h4>
<p>Thank you all! I decided to make a lightweight formalization of the time complexity of the sorting algorithms from mathlib. I just have one doubt, is it possible to add this bookkeeping to the existing insertion sort and merge sort, or the idea is to write new functions that use the state monad to count comparisons?</p>



<a name="223081301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/223081301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#223081301">(Jan 18 2021 at 05:02)</a>:</h4>
<p><span class="user-mention" data-user-id="360938">@Tomaz Gomes Mascarenhas</span> I don't think you can add it to the existing functions, because you would need to change their type to somehow make room for the bookkeeping... but we don't want their types to change.</p>



<a name="223082037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/223082037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#223082037">(Jan 18 2021 at 05:20)</a>:</h4>
<p>I wondered before if using typeclasses one could do this, if you have an algorithm for rings that you want to measure in terms of ring operations for instance, you can make a dummy type with has_add, has_neg, has_mul, has_one etc that are defined to count the number of basic operations needed to form that expression.<br>
Then calling the same function for these dummy types would count the total number of operations.<br>
 But I couldn't get it to work satisfactorily.</p>



<a name="223082108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/223082108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#223082108">(Jan 18 2021 at 05:22)</a>:</h4>
<p>The example I tried to do was karatsuba matrix multiplication but somehow getting the right number of operations out of the final matrix was hard. The nature of my setup double counted terms appearing twice, where as an actual implementation wouldn't recompute the term <span aria-label="confused" class="emoji emoji-1f615" role="img" title="confused">:confused:</span></p>



<a name="223082458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/223082458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#223082458">(Jan 18 2021 at 05:31)</a>:</h4>
<p>otherwise it sounds like a nifty trick (-;</p>



<a name="223094513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/223094513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#223094513">(Jan 18 2021 at 09:00)</a>:</h4>
<p>Presumably you can count ring operations by quotienting <code>R \times count</code> by just the first variable, then use <code>quotient.out</code> to get the count?</p>



<a name="223094571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/223094571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#223094571">(Jan 18 2021 at 09:01)</a>:</h4>
<p>That doesn't work for counting operations that don't directly map into the result though, as your example of a sort needs</p>



<a name="223149231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/BSc%20Final%20Project/near/223149231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Hendrix <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/BSc.20Final.20Project.html#223149231">(Jan 18 2021 at 17:52)</a>:</h4>
<p>I think for a thesis on this, I'd just define a simple imperative language in Lean with arrays, write the operational semantics, define a cost model, and then start proving properties about it. <br>
For properly proving properties about the operational semantics of a Lean program, you need an interpreter or compiler, and that's a lot of work to sign up for up front.  Once you have the basic imperative language, you instead have a library you could extend in a bunch of directions (e.g., get closer to a real machine semantics, more accurate cost models, automation).<br>
This assumes you are interested primarily in the complexity analysis.  If you are more interested in the foundations of Lean, this would take you afield from that.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
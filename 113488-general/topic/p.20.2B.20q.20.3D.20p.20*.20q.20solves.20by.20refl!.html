---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html">p + q = p * q solves by refl!</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="212218929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212218929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212218929">(Oct 04 2020 at 11:27)</a>:</h4>
<p>Something seems wrong either with the pretty-printer or with type-class resolution here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">multiplicative</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_semigroup.to_has_add</span> <span class="n">G</span> <span class="o">(</span><span class="n">add_monoid.to_add_semigroup</span> <span class="n">G</span><span class="o">))</span>
             <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c">/-</span><span class="cm"></span>
<span class="cm">  p q : multiplicative G</span>
<span class="cm">  ⊢ p * q = p + q</span>
<span class="cm">  -/</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>

<p>Obviously the RHS of my lemma is contrived, but it's what <code>extract_goal</code> produced mid-proof</p>



<a name="212220403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220403">(Oct 04 2020 at 12:08)</a>:</h4>
<p>This lets me make a rather strange <code>(multiplicative G) ≃+ G</code> object</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.basic</span>

<span class="kd">def</span> <span class="n">bad_add</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">@</span><span class="n">add_semigroup.to_has_add</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">add_monoid.to_add_semigroup</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">G</span><span class="o">)</span> <span class="n">_inst_1</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">bad_map_add</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">multiplicative</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="kd">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">bad_add</span> <span class="n">G</span><span class="bp">;</span> <span class="n">exact</span>
    <span class="n">multiplicative.to_add</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">multiplicative.to_add</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">multiplicative.to_add</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">def</span> <span class="n">bad_to_add</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span>
  <span class="kd">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">bad_add</span><span class="bp">;</span> <span class="n">exact</span>
    <span class="o">(</span><span class="n">multiplicative</span> <span class="n">G</span><span class="o">)</span> <span class="bp">≃+</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">add_equiv.</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">equiv.to_fun_as_coe</span><span class="o">,</span> <span class="n">bad_map_add</span> <span class="n">x</span> <span class="n">y</span><span class="o">]},</span>
  <span class="bp">..@</span><span class="n">multiplicative.to_add</span> <span class="n">G</span>
<span class="o">}</span>

<span class="k">#check</span> <span class="n">bad_to_add</span>
</code></pre></div>



<a name="212220420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220420">(Oct 04 2020 at 12:09)</a>:</h4>
<p>This is expected behavior</p>



<a name="212220473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220473">(Oct 04 2020 at 12:10)</a>:</h4>
<p>Would <code>bad_to_add</code> make sense in mathlib then?</p>



<a name="212220476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220476">(Oct 04 2020 at 12:10)</a>:</h4>
<p>With a better name, obviously</p>



<a name="212220477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220477">(Oct 04 2020 at 12:10)</a>:</h4>
<p>absolutely not</p>



<a name="212220484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220484">(Oct 04 2020 at 12:10)</a>:</h4>
<p>Perhaps some more context - I'm trying to implement <code>add_monoid_algebra k G ≃+* monoid_algebra k (multiplicative G)</code></p>



<a name="212220486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220486">(Oct 04 2020 at 12:10)</a>:</h4>
<p>it is pretty obviously not a desirable instance</p>



<a name="212220495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220495">(Oct 04 2020 at 12:11)</a>:</h4>
<p>You can locally override instances, as you are doing in these examples</p>



<a name="212220498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220498">(Oct 04 2020 at 12:11)</a>:</h4>
<p>but they cause problems down the line so you should keep it to a minimum</p>



<a name="212220501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220501">(Oct 04 2020 at 12:11)</a>:</h4>
<p>Sorry, I'm not suggesting <code>bad_add</code> should be a global instance</p>



<a name="212220504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220504">(Oct 04 2020 at 12:11)</a>:</h4>
<p>I don't see how that equiv makes sense</p>



<a name="212220543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220543">(Oct 04 2020 at 12:12)</a>:</h4>
<p>are those both rings?</p>



<a name="212220551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220551">(Oct 04 2020 at 12:12)</a>:</h4>
<p>Perhaps I need to show a longer example</p>



<a name="212220563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220563">(Oct 04 2020 at 12:12)</a>:</h4>
<p>I'm pretty sure <code>≃+*</code> works on rings and ringish things</p>



<a name="212220572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220572">(Oct 04 2020 at 12:13)</a>:</h4>
<p>Both <code>add_monoid_algebra k G</code> and <code>monoid_algebra k (multiplicative G)</code> are semirings, yes</p>



<a name="212220659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220659">(Oct 04 2020 at 12:15)</a>:</h4>
<p>I was able to prove this lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">add_monoid_algebra.map_domain_mul</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">α₂</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">add_monoid_algebra</span> <span class="n">β</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α₂</span><span class="o">}</span> <span class="o">(</span><span class="n">f_map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)):</span>
  <span class="o">(</span><span class="n">map_domain</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="n">add_monoid_algebra</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_monoid_algebra</span> <span class="n">β</span> <span class="n">α₂</span><span class="o">)</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">map_domain</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">map_domain</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:</span> <span class="n">add_monoid_algebra</span> <span class="n">β</span> <span class="n">α₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>

<p>and I can then use it to construct the ring isomorphism as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">add_monoid_algebra.to_multiplicative</span> <span class="o">:</span>
  <span class="n">add_monoid_algebra</span> <span class="n">k</span> <span class="n">G</span> <span class="bp">≃+*</span> <span class="n">monoid_algebra</span> <span class="n">k</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">unfold</span> <span class="n">finsupp.dom_congr</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">map_domain_mul</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">extract_goal</span><span class="o">,</span> <span class="c1">-- this is where the weird goal appears</span>
    <span class="n">intros</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">to_add_mul</span><span class="o">],</span>
    <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">finsupp.dom_congr</span><span class="o">,</span> <span class="n">map_domain_add</span><span class="o">],</span>
  <span class="o">},</span>
  <span class="bp">..</span><span class="n">finsupp.dom_congr</span> <span class="n">multiplicative.to_add</span> <span class="o">}</span>
</code></pre></div>

<p>What I'd like to do is bundle <code>f</code>and <code>f_map_mul</code> into a <code>α →+ α₂</code>. The <code>→+</code> object I need is exactly <code>bad_to_add</code>.</p>



<a name="212220768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220768">(Oct 04 2020 at 12:18)</a>:</h4>
<p>I'm asking a more basic question, I think. What kind of object is <code>monoid_algebra k (multiplicative G)</code>? What operations does it support?</p>



<a name="212220774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220774">(Oct 04 2020 at 12:18)</a>:</h4>
<p>Does it have an addition and multiplication, and do they make sense</p>



<a name="212220790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220790">(Oct 04 2020 at 12:19)</a>:</h4>
<p>Perhaps it helps to note that the implementation notes for <code>add_monoid_algebra</code> say</p>
<blockquote>
<p>Similarly, I attempted to just define <code>add_monoid_algebra k G := monoid_algebra k (multiplicative G)</code>,<br>
but the definitional equality <code>multiplicative G = G</code> leaks through everywhere, and<br>
seems impossible to use.</p>
</blockquote>



<a name="212220841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220841">(Oct 04 2020 at 12:20)</a>:</h4>
<p>well there you have it</p>



<a name="212220847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220847">(Oct 04 2020 at 12:21)</a>:</h4>
<p>Right - and IMO the thing that makes it impossible to use is the absence of <code>add_monoid_algebra.to_multiplicative</code> above</p>



<a name="212220852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220852">(Oct 04 2020 at 12:21)</a>:</h4>
<p>With that in place I can (hopefully) replace all the <code>add_monoid_algebra</code> theorems with</p>
<ol>
<li>Apply the iso</li>
<li>use the proof for <code>monoid_algebra</code></li>
</ol>



<a name="212220860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220860">(Oct 04 2020 at 12:21)</a>:</h4>
<p>the problem is the defeqs are wrong</p>



<a name="212220869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220869">(Oct 04 2020 at 12:22)</a>:</h4>
<p>The problem with what and which defeqs?</p>



<a name="212220907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220907">(Oct 04 2020 at 12:22)</a>:</h4>
<p>The iso is trivial, I guess, because they are equal objects</p>



<a name="212220959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212220959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212220959">(Oct 04 2020 at 12:23)</a>:</h4>
<p>To fix the defeqs, the definition should be changed to something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">add_monoid_algebra</span> <span class="n">k</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="n">something</span> <span class="n">reasonable</span><span class="o">,</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="n">something</span> <span class="n">reasonable</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">monoid_algebra</span> <span class="n">k</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">G</span><span class="o">)</span> <span class="o">}</span> <span class="c1">-- use the unreasonable equalities to do the proof obligations</span>
</code></pre></div>



<a name="212221010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221010">(Oct 04 2020 at 12:24)</a>:</h4>
<p>I don't quite get that example - today it's defined as <code>def add_monoid_algebra := G →₀ k</code></p>



<a name="212221030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221030">(Oct 04 2020 at 12:25)</a>:</h4>
<p>oh I see, it is not the definition</p>



<a name="212221034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221034">(Oct 04 2020 at 12:25)</a>:</h4>
<p>and you want to recover that representation</p>



<a name="212221080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221080">(Oct 04 2020 at 12:26)</a>:</h4>
<p>The idiomatic way to use <code>multiplicatuve</code> is to use the <code>to_add</code> function, and others like it.</p>



<a name="212221097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221097">(Oct 04 2020 at 12:26)</a>:</h4>
<p>@Chris, which message is that in response to?</p>



<a name="212221112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221112">(Oct 04 2020 at 12:27)</a>:</h4>
<p>somewhere in your definition is an "illegal" unfolding of <code>multiplicative</code></p>



<a name="212221131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221131">(Oct 04 2020 at 12:28)</a>:</h4>
<p>you could try making <code>multiplicative</code> irreducible to see if that pinpoints the issue, but I don't have your code to test</p>



<a name="212221155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221155">(Oct 04 2020 at 12:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, I think what you're recommending is already what I'm planning to do:</p>
<ul>
<li>Keep the definition of <code>add_monoid_algebra</code></li>
<li>Keep the definition of <code>add_monoid_algebra.has_add</code></li>
<li>Keep the definition of <code>add_monoid_algebra.has_mul</code></li>
<li>Transfer the ring structure of <code>add_monoid_algebra</code> over the isomorphism</li>
</ul>



<a name="212221180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221180">(Oct 04 2020 at 12:28)</a>:</h4>
<p>the question is whether the isomorphism itself is well typed</p>



<a name="212221192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221192">(Oct 04 2020 at 12:28)</a>:</h4>
<p>There are two isomorphism here - <code>bad_add_to_add</code> and <code>monoid_algebra.to_additive</code></p>



<a name="212221198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221198">(Oct 04 2020 at 12:29)</a>:</h4>
<p>The former is obviously badly typed, IMO the latter is totally safe</p>



<a name="212221201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221201">(Oct 04 2020 at 12:29)</a>:</h4>
<p>But the former is a valuable tool for building the latter</p>



<a name="212221202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221202">(Oct 04 2020 at 12:29)</a>:</h4>
<p>A <code>~=+*</code> isomorphism comes with the assumption that both sides have reasonable addition/multiplication structures</p>



<a name="212221247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221247">(Oct 04 2020 at 12:30)</a>:</h4>
<p>Any <code>to_additive</code> def will inevitably perform an <code>illegal</code> unfolding of <code>multiplicative</code></p>



<a name="212221256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221256">(Oct 04 2020 at 12:30)</a>:</h4>
<p>yes, but you aren't doing such a def</p>



<a name="212221264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221264">(Oct 04 2020 at 12:30)</a>:</h4>
<p>actually I take that back, <code>to_additive</code> does no unfolding</p>



<a name="212221269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221269">(Oct 04 2020 at 12:31)</a>:</h4>
<p><code>to_additive</code> does a copy paste job</p>



<a name="212221276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221276">(Oct 04 2020 at 12:31)</a>:</h4>
<p>so there is no leakage</p>



<a name="212221278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221278">(Oct 04 2020 at 12:31)</a>:</h4>
<p>My claim is <code>bad_add_to_add</code> is a utility function to perform that unfolding / copy paste</p>



<a name="212221300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221300">(Oct 04 2020 at 12:31)</a>:</h4>
<p><code>bad_add</code> is aptly named, because <code>multiplicative G</code> isn't supposed to have an add</p>



<a name="212221350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221350">(Oct 04 2020 at 12:32)</a>:</h4>
<p>and anything that contains <code>bad_add</code> in its statement is also bad</p>



<a name="212221365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221365">(Oct 04 2020 at 12:33)</a>:</h4>
<p>I had problems with leakage when using with_zero and I fixed it by making with_zero irreducible and approaching everything in a principled way, never using definitional equality apart from when I was setting up the API</p>



<a name="212221366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221366">(Oct 04 2020 at 12:33)</a>:</h4>
<p>The statement of <code>bad_add_to_add</code> is exactly an intermediate goal state in <code>add_monoid_algebra.to_multiplicative</code> (edited)</p>



<a name="212221367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221367">(Oct 04 2020 at 12:33)</a>:</h4>
<p>which includes <code>bad_add_to_add</code></p>



<a name="212221376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221376">(Oct 04 2020 at 12:33)</a>:</h4>
<p>what <code>to_additive</code> are you talking about?</p>



<a name="212221379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221379">(Oct 04 2020 at 12:33)</a>:</h4>
<p>Ah, sorry - <code>add_monoid_algebra.to_multiplicative</code></p>



<a name="212221419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221419">(Oct 04 2020 at 12:34)</a>:</h4>
<p>I meant that throughout</p>



<a name="212221430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221430">(Oct 04 2020 at 12:34)</a>:</h4>
<p>I don't know what the statement of <code>add_monoid_algebra.to_multiplicative</code> is but it seems highly likely that some bad_add stuff is in there</p>



<a name="212221434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221434">(Oct 04 2020 at 12:34)</a>:</h4>
<p>I pasted it above</p>



<a name="212221436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221436">(Oct 04 2020 at 12:35)</a>:</h4>
<p>It's my proposed isomorphism</p>



<a name="212221440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221440">(Oct 04 2020 at 12:35)</a>:</h4>
<p>I mean the full statement</p>



<a name="212221452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221452">(Oct 04 2020 at 12:35)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!/near/212220659">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!/near/212220659</a> is the full statement?</p>



<a name="212221456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221456">(Oct 04 2020 at 12:36)</a>:</h4>
<p>I just don't understand how you can have a <code>add_monoid_algebra</code> on one side and a <code>monoid_algebra </code> on the other and they are the same type of object</p>



<a name="212221493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221493">(Oct 04 2020 at 12:36)</a>:</h4>
<p>There are maps from G to multiplicative G which could be used at all times. Does this solve the problems you have Eric? In my mind the fix for the leakage mentioned in the docs is to make <code>multiplicative</code> irreducible after the API has been set up</p>



<a name="212221494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221494">(Oct 04 2020 at 12:36)</a>:</h4>
<p>There are implicit arguments</p>



<a name="212221500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221500">(Oct 04 2020 at 12:36)</a>:</h4>
<p>and all the interesting stuff in this discussion is only visible if you look at the implicit arguments</p>



<a name="212221503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221503">(Oct 04 2020 at 12:36)</a>:</h4>
<p>An add_monoid_algebra and a monoid_algebra are just both semirings, they can be isomorphic</p>



<a name="212221509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221509">(Oct 04 2020 at 12:37)</a>:</h4>
<p>aha</p>



<a name="212221514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221514">(Oct 04 2020 at 12:37)</a>:</h4>
<p>so is it the <code>finsupp</code> lemmas then that are exposing the defeqs?</p>



<a name="212221561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221561">(Oct 04 2020 at 12:38)</a>:</h4>
<p>Perhaps the easiest way to see is:</p>
<ul>
<li><code>add_monoid_algebra</code>: <code>single a1 b1 * single a2 b2 = single (a1 + a2) (b2 * b2)</code></li>
<li><code>monoid_algebra</code>: <code>single a1 b1 * single a2 b2 = single (a1 * a2) (b2 * b2)</code></li>
</ul>



<a name="212221571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221571">(Oct 04 2020 at 12:38)</a>:</h4>
<p>So this is an obvious candidate for the type of map that Kevin is talking about - all I want to do is extend the existing maps to preserve additional structure</p>



<a name="212221727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221727">(Oct 04 2020 at 12:42)</a>:</h4>
<p>Aha:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">add_monoid_algebra.map_domain_mul</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">α₂</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">add_monoid_algebra</span> <span class="n">β</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α₂</span><span class="o">}</span> <span class="o">(</span><span class="n">f_map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)):</span>
  <span class="o">(</span><span class="n">map_domain</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="n">add_monoid_algebra</span> <span class="n">β</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_monoid_algebra</span> <span class="n">β</span> <span class="n">α₂</span><span class="o">)</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">map_domain</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">map_domain</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:</span> <span class="n">add_monoid_algebra</span> <span class="n">β</span> <span class="n">α₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>

<p>In your definition, the function <code>f</code> is <code>multiplicative.to_add</code>, so it should not be type correct for <code>f_map_mul</code></p>



<a name="212221740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221740">(Oct 04 2020 at 12:43)</a>:</h4>
<p>I think that if you want to relate the two structures you could go further and define a group homomorphism between an add_group and a group, give it a nice notation, prove that this induces a morphism of semirings from add_monoid_alg and monoid_alg, do things the other way, prove that isomorphisms get sent to isomorphisms etc</p>



<a name="212221888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221888">(Oct 04 2020 at 12:46)</a>:</h4>
<p>We have spent two years running from the fact that we have two kinds of groups; usually it works fine because mathematicians use multiplication and addition in quite different ways, but with valuations I ran into problems because we didn't have eg any API for an infinite cyclic group. Valuations are both additive and multiplicative in the literature and lean's eccentric approach to keeping them separate has had advantages (eg the crystallisation of the monoid with 0 idea) but it also has disadvantages, and one we're seeing now is that it's difficult to pass from one world to the other.</p>



<a name="212221899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221899">(Oct 04 2020 at 12:47)</a>:</h4>
<p>But I think that one reason it's difficult is that nobody cared enough to write the API yet</p>



<a name="212221956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212221956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212221956">(Oct 04 2020 at 12:48)</a>:</h4>
<p>I need an additive valuation on a multiplicative object to continue with discrete valuation rings and it's not there. Maybe it's time to put these things there? We've as yet seen no issues with people wanting to use ten different notations for groups and this idea not scaling.</p>



<a name="212222027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212222027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212222027">(Oct 04 2020 at 12:50)</a>:</h4>
<p>I think that defining the structure which is a group hom from an additive to a multiplicative object and making a proper API would be the correct way to get the morphisms you want. Or are there other problems I've not foreseen?</p>



<a name="212222337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212222337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212222337">(Oct 04 2020 at 12:59)</a>:</h4>
<p>We already have the group homs between additive and multiplicative objects - the case in question is dependent types <code>D X</code> and <code>D (multiplicative Y)</code>, where the <code>monoid</code> on X is used internally by <code>D X</code></p>



<a name="212222707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212222707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212222707">(Oct 04 2020 at 13:10)</a>:</h4>
<p>Anyway, I've put the first lemma I need (<code>finsupp.dom_add_congr</code>) up as <a href="https://github.com/leanprover-community/mathlib/issues/4398">#4398</a>.</p>
<p><del>I think that alone is enough to demonstrate the issue, without complicating things with monoid_algebra.</del></p>
<p><del>The simplified question is, given <code>monoid α</code> how do I construct the canonical isomorphism <code>finsupp α β ≃+ finsupp (additive α) β</code>? I can construct <code>finsupp α β ≃ finsupp (additive α) β</code> easily with <code>finsupp.dom_congr</code>, but I can't use <code>finsupp.dom_add_congr</code> without  the "illegal" <code>α ≃+ additive α</code>object discussed above.</del></p>



<a name="212223390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212223390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212223390">(Oct 04 2020 at 13:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!/near/212221727">said</a>:</p>
<blockquote>
<p>Aha: &lt;snip&gt;<br>
In your definition, the function <code>f</code> is <code>multiplicative.to_add</code>, so it should not be type correct for <code>f_map_mul</code></p>
</blockquote>
<p>Right, so I just called <code>rw</code> on that definition, and lean created the nonsense goal for me automatically</p>



<a name="212225089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212225089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212225089">(Oct 04 2020 at 14:15)</a>:</h4>
<p>The moral is with these different instances on plain <code>def B := A</code> definitions, you really should avoid doing anything that would be ill-typed if <code>B</code> wasn't defeq to <code>A</code>. At some point, it becomes easier to just not have them be defeq in the first place.</p>



<a name="212226938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212226938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212226938">(Oct 04 2020 at 15:06)</a>:</h4>
<p>I ended up not using <code>bad_add_to_add</code>, as I forgot that I did not need that <code>f 0 = 0</code>. <a href="https://github.com/leanprover-community/mathlib/issues/4402">#4402</a> still has the nonsense intermediate goal state that started this thread.</p>



<a name="212229849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212229849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212229849">(Oct 04 2020 at 16:23)</a>:</h4>
<p>Does mathlib have something like a monoid morphism from a multiplicative monoid to an additive monoid (or vice versa)? If not, should we add it? We can call one a <code>logarithm</code>and the other an <code>exponential</code>.</p>



<a name="212229963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212229963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212229963">(Oct 04 2020 at 16:26)</a>:</h4>
<p>(Oh, I now see Kevin's comments about this.)</p>



<a name="212230672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212230672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212230672">(Oct 04 2020 at 16:46)</a>:</h4>
<p>The combinatorial explosion of lemmas in all the variants sounds a bit scary, but maybe this is the logical conclusion of having <code>add_monoid</code> and <code>monoid</code> in the first place?</p>



<a name="212230679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212230679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212230679">(Oct 04 2020 at 16:47)</a>:</h4>
<p>Also, we can call <code>to_add</code> the "universal logarithm" on <code>multiplicative α</code>, which sounds very sophisticated.</p>



<a name="212230756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212230756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212230756">(Oct 04 2020 at 16:49)</a>:</h4>
<p>For notation: <code>+→*</code> for exponentials and <code>*→+</code> for logarithms?</p>



<a name="212232281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212232281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212232281">(Oct 04 2020 at 17:28)</a>:</h4>
<p>What about this approach:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra</span>

<span class="kd">class</span> <span class="n">has_binop</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_const</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">const</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">widget</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_binop</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_binop</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_const</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_const</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_const</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="n">has_const.const</span> <span class="bp">=</span> <span class="n">has_const.const</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_binop</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">has_binop.op</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">has_binop.op</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">y</span><span class="o">))</span>

<span class="kd">instance</span> <span class="n">add_to_op</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_binop</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="bp">+</span><span class="o">)⟩</span>
<span class="kd">instance</span> <span class="n">zero_to_const</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_const</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">mul_to_op</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_binop</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨(</span><span class="bp">*</span><span class="o">)⟩</span>
<span class="kd">instance</span> <span class="n">one_to_const</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_const</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">N</span><span class="o">]</span>
<span class="k">#check</span> <span class="n">widget</span> <span class="n">M</span> <span class="n">N</span>
<span class="k">#check</span> <span class="n">widget</span> <span class="n">N</span> <span class="n">M</span>
</code></pre></div>



<a name="212232287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212232287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212232287">(Oct 04 2020 at 17:28)</a>:</h4>
<p>I guess this is a problem if <code>M</code> is a ring.</p>



<a name="212232940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212232940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212232940">(Oct 04 2020 at 17:42)</a>:</h4>
<p>I was also wondering about the similar:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">base_monoid</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">identity</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span><span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span><span class="o">)</span>
<span class="o">:=</span>
<span class="o">(</span><span class="n">op_identity</span> <span class="o">:</span> <span class="bp">...</span><span class="o">)</span> <span class="c1">-- etc</span>

<span class="n">abbreviation</span> <span class="n">add_monoid</span> <span class="bp">=</span> <span class="n">base_monoid</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span>

<span class="n">abbreviation</span> <span class="n">monoid</span> <span class="bp">=</span> <span class="n">base_monoid</span> <span class="mi">1</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span>
</code></pre></div>



<a name="212233154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212233154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212233154">(Oct 04 2020 at 17:47)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> check out how these things work in Agda. It's similar to what you suggest.</p>



<a name="212246817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212246817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212246817">(Oct 04 2020 at 23:32)</a>:</h4>
<p>In the interest of avoiding combinatorial explosions, to what extent can we get away with using <code>G -&gt;* multiplicative H</code> for "logarithmic homs"?</p>



<a name="212248851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212248851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212248851">(Oct 05 2020 at 00:33)</a>:</h4>
<p>I guess most things should work out if we define the the <code>has_coe_to_fun</code> correctly, no?</p>



<a name="212250144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212250144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212250144">(Oct 05 2020 at 01:06)</a>:</h4>
<p>I think that we can't redefine <code>has_coe_to_fun</code> for this subcase.</p>



<a name="212250228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212250228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212250228">(Oct 05 2020 at 01:09)</a>:</h4>
<p>You use a type alias</p>



<a name="212250558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212250558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212250558">(Oct 05 2020 at 01:19)</a>:</h4>
<p>And loose lots of lemmas.</p>



<a name="212250562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212250562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212250562">(Oct 05 2020 at 01:19)</a>:</h4>
<p>This is not better than adding a new type.</p>



<a name="212250623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212250623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212250623">(Oct 05 2020 at 01:20)</a>:</h4>
<p>Yeah, you're right.</p>



<a name="212250628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212250628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212250628">(Oct 05 2020 at 01:20)</a>:</h4>
<p>Is there some @[derive] magic that can be used?</p>



<a name="212250691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212250691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212250691">(Oct 05 2020 at 01:22)</a>:</h4>
<p>My suggestion is <em>not</em> to create a new type at all, just live with the fact that the codomain of the hom is <code>multiplicative H</code> and use <code>multiplicative</code> lemmas to convert the statements to things about addition in <code>H</code></p>



<a name="212261750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212261750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212261750">(Oct 05 2020 at 06:09)</a>:</h4>
<p>How about a new type for<code>multiplicative int</code>?</p>



<a name="212263593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212263593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212263593">(Oct 05 2020 at 06:41)</a>:</h4>
<p>I've been using <code>multiplicative int</code> a lot lately. I just made notation for it. <code>C∞</code> for the infinite cyclic group.</p>



<a name="212314099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/p%20%2B%20q%20%3D%20p%20%2A%20q%20solves%20by%20refl%21/near/212314099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!.html#212314099">(Oct 05 2020 at 15:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/p.20.2B.20q.20.3D.20p.20*.20q.20solves.20by.20refl!/near/212232940">said</a>:</p>
<blockquote>
<p>I was also wondering about the similar: &lt;snip&gt;</p>
</blockquote>
<p>Turns out this is already discussed here: <a href="https://github.com/leanprover/lean/wiki/Refactoring-structures#encoding-the-algebraic-hierarchy-1">https://github.com/leanprover/lean/wiki/Refactoring-structures#encoding-the-algebraic-hierarchy-1</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Lean.20vs.20other.20systems.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html">Lean vs other systems</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="179166943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179166943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179166943">(Oct 27 2019 at 11:24)</a>:</h4>
<p>There are many systems that allow you to write and check proofs written in a formal language. Lean, Metamath, Isabelle HOL, Coq, ACL2, Agda, Albatross, F*, HOL Light, HOL4, LEGO, Mizar, NuPRL, PVS, Twelf</p>
<p>I'm just wondering if we are better or worse off having all these different systems. Should we all just stick to one and build a good library in it, or is there some fundamental reasons why one is better than another. Yes, Lean has a computational component that Metamath doesn't, but nothing is stopping you from writing a model of a real computer in Metamath. Yes, Lean has proof automation that Metamath doesn't have, but aren't big general  theorems exactly the same as proof automation? I'd personally be especially interested in hearing <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> s thoughts on this. Pondering this I'm reminded of  a song called "One Vision" by Queen..</p>



<a name="179167011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167011">(Oct 27 2019 at 11:27)</a>:</h4>
<p>I am largely agnostic as to foundations. But I do think that we should make every effort to connect all the proof systems together, because how else can we make proofs "stick"? It would be quite the nightmare if we can never get off the ground because we reinvent natural number addition every five years in a new system</p>



<a name="179167069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167069">(Oct 27 2019 at 11:29)</a>:</h4>
<p>Actually, I prefer simple foundations to complex ones because the complex foundations fool you into thinking that you have something that is easier than it is; as soon as you stray from what the axioms give you things become hard again</p>



<a name="179167129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167129">(Oct 27 2019 at 11:30)</a>:</h4>
<p>Are things easier in Lean though, than in Metamath, after having actually tried to do complicated things in Metamath?</p>



<a name="179167145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167145">(Oct 27 2019 at 11:31)</a>:</h4>
<p>The most important feature a foundation has is <em>expressivity</em>, the ability to define the things people care about, with proportional overhead (not exponential overhead!). If you can't write X in the system, then you are doomed, although you can delay the inevitable for a while</p>



<a name="179167190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167190">(Oct 27 2019 at 11:32)</a>:</h4>
<p>The problem with questions like that is it presupposes that Metamath and Lean are trying to solve the same problems, and they aren't</p>



<a name="179167198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167198">(Oct 27 2019 at 11:32)</a>:</h4>
<p>Metamath is a logical foundation and a verification system. It has a "build your own" user experience</p>



<a name="179167208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167208">(Oct 27 2019 at 11:33)</a>:</h4>
<p>so asking if Metamath has tactics is beside the point; it's not supposed to have tactics, it's a foundational system</p>



<a name="179167268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167268">(Oct 27 2019 at 11:34)</a>:</h4>
<p>Of course you want tactics and a nice user experience, but I think metamath is one of the few systems that conciously separates this from the verification aspect</p>



<a name="179167276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167276">(Oct 27 2019 at 11:35)</a>:</h4>
<p>I'm just wondering whether there is any fundamental reason why writing general theorems in metamath in order to help proving things is any different from writing tactics in Lean?</p>



<a name="179167290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167290">(Oct 27 2019 at 11:35)</a>:</h4>
<p>Theorems and tactics are different. A tactic is more like a metatheorem, a family of related theorems that are all provable</p>



<a name="179167340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Kappelmann <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167340">(Oct 27 2019 at 11:36)</a>:</h4>
<p>btw. there are efforts to connect theorem provers, e.g. <a href="http://logipedia.inria.fr/about/about.php" target="_blank" title="http://logipedia.inria.fr/about/about.php">Logipedia/Dedukti</a></p>



<a name="179167341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167341">(Oct 27 2019 at 11:36)</a>:</h4>
<p>the downside of a tactic is that you have to run it every time you want a new proof, whereas you can check a theorem once and use it as many times as you like</p>



<a name="179167349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167349">(Oct 27 2019 at 11:36)</a>:</h4>
<p>I'm not an expert on this so please correct me if I'm completely wrong, but doesn't expressive foundations allow you to write category theory kinds of general theorems that are basically the same thing as tactics? I'm just guessing.</p>



<a name="179167367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167367">(Oct 27 2019 at 11:37)</a>:</h4>
<p>An example of something that can't be proven by a single theorem is <code>norm_num</code></p>



<a name="179167373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167373">(Oct 27 2019 at 11:37)</a>:</h4>
<p>that is, evaluating arbitrary arithmetic expressions</p>



<a name="179167424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167424">(Oct 27 2019 at 11:38)</a>:</h4>
<p>So the problem is that you can't make the metamath proof checker do complex calculations? You have to spell out the calculations in the proof? and then you need to have a metasystem that writes those long calculations?</p>



<a name="179167425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167425">(Oct 27 2019 at 11:38)</a>:</h4>
<p>yes</p>



<a name="179167427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167427">(Oct 27 2019 at 11:38)</a>:</h4>
<p>But is this actually true?</p>



<a name="179167433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167433">(Oct 27 2019 at 11:39)</a>:</h4>
<p>This is a benefit</p>



<a name="179167437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167437">(Oct 27 2019 at 11:39)</a>:</h4>
<p>By an appropriate sequence of lemmas, you can make the metamath proof checker perform any computation in NP</p>



<a name="179167480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167480">(Oct 27 2019 at 11:40)</a>:</h4>
<p>the same holds true for lean btw</p>



<a name="179167496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167496">(Oct 27 2019 at 11:41)</a>:</h4>
<p>So there is no way to make metamath proof checker perform an arbitrary calculation by writing down the definition of the calculation as a turing machine and proving that the calculation terminates? Because if you could, couldn't you somehow transfer the calculation work on to the proof checker side? that is make a tactic that's written inside the system?</p>



<a name="179167538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167538">(Oct 27 2019 at 11:42)</a>:</h4>
<p>As in you can't say, this theorem holds because this tactic proof searching algorithm is proven to terminate, and the proof is simply to run the program?</p>



<a name="179167539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167539">(Oct 27 2019 at 11:42)</a>:</h4>
<p>You have to provide a proof that the TM evaluates to some particular value, and that means roughly one proof step per TM step</p>



<a name="179167546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167546">(Oct 27 2019 at 11:43)</a>:</h4>
<p>so the longer the program runs, the longer the proof gets</p>



<a name="179167551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167551">(Oct 27 2019 at 11:43)</a>:</h4>
<p>metamath doesn't support extending the kernel by a verified computation. I hope to add this capability to MM0 after the bootstrap</p>



<a name="179167593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167593">(Oct 27 2019 at 11:44)</a>:</h4>
<p>It's still pretty darn fast without it</p>



<a name="179167611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167611">(Oct 27 2019 at 11:45)</a>:</h4>
<p>So, the point is that tactics may not terminate, and you can't make a proof checker run something that may not terminate. and metamath is only a proof checker.</p>



<a name="179167654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167654">(Oct 27 2019 at 11:46)</a>:</h4>
<blockquote>
<p>this theorem holds because this tactic proof searching algorithm is proven to terminate</p>
</blockquote>
<p>It would be a very strange theorem that would not be provable outright if you had this property</p>



<a name="179167660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167660">(Oct 27 2019 at 11:46)</a>:</h4>
<p>the only reason it doesn't work for things like <code>norm_num</code> is because the theorems are not uniformly describable</p>



<a name="179167708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167708">(Oct 27 2019 at 11:48)</a>:</h4>
<p>termination or lack thereof is not a problem. Metamath simply doesn't know how computers work so it can't extend itself with a computer program given by the user</p>



<a name="179167721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167721">(Oct 27 2019 at 11:48)</a>:</h4>
<p>If we're running the program, then there is no problem with termination - we continue verification only after it returns, so if it never returns then we never finish the proof</p>



<a name="179167731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167731">(Oct 27 2019 at 11:49)</a>:</h4>
<p>If we are not running the program, and are simply using the existence of the program to prove the theorem, then we may as well chuck the program and prove the theorem directly</p>



<a name="179167780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167780">(Oct 27 2019 at 11:50)</a>:</h4>
<p>I'm just guessing again but isn't the point of all these new type theory systems to kind of make a unification algorithm that can be easily used as a general purpose computer?</p>



<a name="179167782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167782">(Oct 27 2019 at 11:50)</a>:</h4>
<p>that's the theory...</p>



<a name="179167791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167791">(Oct 27 2019 at 11:51)</a>:</h4>
<p>turns out computers are better at being computers than unification algorithms are at being computers</p>



<a name="179167798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167798">(Oct 27 2019 at 11:51)</a>:</h4>
<p>theory and practice are the same in theory but not in practice</p>



<a name="179167863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167863">(Oct 27 2019 at 11:53)</a>:</h4>
<p>I like how metamath is such a simple system and then you just have a list of axioms. Could we do kind of a similar thing where we could extend the unification algorithm by just adding an extra axiom?</p>



<a name="179167910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167910">(Oct 27 2019 at 11:54)</a>:</h4>
<p>Lean is actually extensible in this way, but it's a "big boy" feature and was not entrusted to us. Currently the only extensions to the normalization algorithm are quotients and inductive types</p>



<a name="179167920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167920">(Oct 27 2019 at 11:54)</a>:</h4>
<p>If you add your own rules it becomes very easy to loop or lose some metatheoretic property</p>



<a name="179167928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167928">(Oct 27 2019 at 11:55)</a>:</h4>
<p>and you will almost certainly make defeq undecidable</p>



<a name="179167978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167978">(Oct 27 2019 at 11:56)</a>:</h4>
<p>Basically, in DTT defeq is "second class" equality - it's never strong enough, but you can't just ignore it. I like that in metamath there is only one equality</p>



<a name="179167983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167983">(Oct 27 2019 at 11:56)</a>:</h4>
<p>But couldn't you just add a feature that allows you to prove things by saying that the proof exist because a computation terminates, and then you can just add a "proof by termination" and the checker runs the computation. Of course you may not actually have the proof.</p>



<a name="179167986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167986">(Oct 27 2019 at 11:56)</a>:</h4>
<p>But thats basically what a tactic is.</p>



<a name="179167988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167988">(Oct 27 2019 at 11:56)</a>:</h4>
<p>right, that's what I mean by extending the kernel with a verified computation</p>



<a name="179167994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167994">(Oct 27 2019 at 11:57)</a>:</h4>
<p>that's not the same as a tactic, which is a <em>proof-producing program</em></p>



<a name="179167999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179167999">(Oct 27 2019 at 11:57)</a>:</h4>
<p>metamath prefers to deal with tactics in that sense, because the checker doesn't have to know anything about the tactic for the system to work</p>



<a name="179168000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168000">(Oct 27 2019 at 11:57)</a>:</h4>
<p>Well, basically the same, as the program may not actually terminate when you write "proof by termination" and run the checker?</p>



<a name="179168042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168042">(Oct 27 2019 at 11:58)</a>:</h4>
<p>The checker is given the output of the tactic as its input. It is never given the opportunity to run the tactic itself</p>



<a name="179168057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168057">(Oct 27 2019 at 11:59)</a>:</h4>
<p>so when you start the checker you already have the proof of termination in hand</p>



<a name="179168058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168058">(Oct 27 2019 at 11:59)</a>:</h4>
<p>Ah, right. A tactic would be adding that the program terminates as an axiom.</p>



<a name="179168060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168060">(Oct 27 2019 at 11:59)</a>:</h4>
<p>And seeing what happens.</p>



<a name="179168064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168064">(Oct 27 2019 at 11:59)</a>:</h4>
<p>Lean doesn't have trusted computations either btw</p>



<a name="179168096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168096">(Oct 27 2019 at 12:00)</a>:</h4>
<p>It very nearly does, but you can't use <code>#eval</code> to prove a reflexivity</p>



<a name="179168142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168142">(Oct 27 2019 at 12:01)</a>:</h4>
<p>I want to build my own proof system. Maybe we should collaborate on extending metamath? Personally, I'd like to build a system where you can solve real world problems by checking proofs in order of length.</p>



<a name="179168186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168186">(Oct 27 2019 at 12:02)</a>:</h4>
<p>that will never scale unfortunately</p>



<a name="179168188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168188">(Oct 27 2019 at 12:02)</a>:</h4>
<p>the number of proofs grows exponentially</p>



<a name="179168203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168203">(Oct 27 2019 at 12:03)</a>:</h4>
<p>Well, it of course depends on the language. There's always some weird language where it works, of course. Because you can always put the computation on the checker side.</p>



<a name="179168206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168206">(Oct 27 2019 at 12:03)</a>:</h4>
<p>There actually was a competition of sorts to find the shortest proofs of a bunch of basic propositional logic problems, and many of them were found by exhaustive search, but you hit a wall at about 18 steps</p>



<a name="179168260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168260">(Oct 27 2019 at 12:05)</a>:</h4>
<p>I think a big problem in computer systems is fragility, that is, systems work great, until they don't.</p>



<a name="179168307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168307">(Oct 27 2019 at 12:06)</a>:</h4>
<p>Like, some tactic might work great, until it doesn't. And then the next best thing is basically to go through proofs in order of length.</p>



<a name="179168308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168308">(Oct 27 2019 at 12:06)</a>:</h4>
<p>Whenever you are solving an exponential problem it always looks like that. You might push the wall back a few steps with a different formalism, but you can't eliminate it unless your language is trivial</p>



<a name="179168311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168311">(Oct 27 2019 at 12:06)</a>:</h4>
<p>Having reasonable solutions there in between is where the improvements in systems happen.</p>



<a name="179168330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168330">(Oct 27 2019 at 12:07)</a>:</h4>
<p>machine learning is all about trying to solve these problems by finding structure in the search (something better than "shorter is better")</p>



<a name="179168331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168331">(Oct 27 2019 at 12:07)</a>:</h4>
<p>I mean reasonable solutions for practical problems, you obviously can't have reasonable solutions for all problems.</p>



<a name="179168417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168417">(Oct 27 2019 at 12:09)</a>:</h4>
<p>I think trying to build something between the two ends of search proofs by length and a few tactics that solve simple problems would be to work on trying to "dig a tunnel" from both ends, trying to make searching proofs in order of length better while making tactics better.</p>



<a name="179168476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168476">(Oct 27 2019 at 12:10)</a>:</h4>
<p>that at most doubles the distance to the wall</p>



<a name="179168532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168532">(Oct 27 2019 at 12:12)</a>:</h4>
<p>I mean I just think it could provide ideas to look at things from many angles.</p>



<a name="179168537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168537">(Oct 27 2019 at 12:12)</a>:</h4>
<blockquote>
<p>I'm just wondering if we are better or worse off having all these different systems. Should we all just stick to one and build a good library in it</p>
</blockquote>
<p>Of course the problem with this is that everyone thinks that everybody else should be using their system. It also all depends on what your goals are.</p>
<p>The work of Rob Lewis and his collaborators, and the perfectoid project, are attempts to prove that Lean is capable of doing modern mathematics which "proper mathematicians" are interested in (this is a tongue-in-cheek phrase referring to people doing stuff like number theory/algebra/analysis/geometry etc in maths departments, as opposed to all the category theory / type theory people working on foundations). Sebastian Gouezel has produced work in Isabelle/HOL which is also mainstream mathematics done in a theorem prover. But we are in the minority here -- most work done in these systems is not an attempt to do modern mathematics on a computer. For example my impression is that Agda is a fascinating experiment to see what kinds of fancy inductive-recursive-inductive types one can get away with whilst preserving soundness. That's great, but guess what? The perfectoid project <em>does not contain one single instance of the <code>inductive</code> command</em>. Us "proper mathematicians" just need structures. </p>
<blockquote>
<p>or is there some fundamental reasons why one is better than another.</p>
</blockquote>
<p>People can certainly argue about this point all day. I think that dependent type theory is currently our best option for "all of pure mathematics" and I think that Lean is currently our best option for dependent type theory, but plenty of people have plenty of other opinions. The reason I like my opinion best is that I am one of few "proper mathematicians" who is even in a position to have an opinion, and when I hear other people talking about what they think mathematics is and how it fits best into their systems, I often find that the underlying disagreement is actually the question of what mathematics <em>is</em>. I am attempting to represent the generic pure mathematician who works in a generic mathematics department. </p>
<p>As is the case for programming languages in general, the best tool for the job depends very heavily on what the job is. An analogue of your question might be "I'm just wondering if we are better of worse off having all these different programming languages -- C, Rust, Java, Python, x86 assembly. Should we all just stick to one?"</p>



<a name="179168864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Juho Kupiainen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168864">(Oct 27 2019 at 12:23)</a>:</h4>
<p>To me, as someone who isn't that knowledgeable of foundational systems, it seems like a pretty practical way to describe a foundational system would be a list of axtioms that state that a computer program terminates. The lengths of various proofs and relative (between theorems) performance of the checker would be determined by which axioms you add. You could make a checker that both runs a computation to check for the proof and at the same time searches for proofs that the computation terminates so as to not have to do the computation. And I guess you can also describe the axiomatic content this way as well.</p>



<a name="179168990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179168990">(Oct 27 2019 at 12:27)</a>:</h4>
<blockquote>
<p>To me, as someone who isn't that knowledgeable of foundational systems, it seems like a pretty practical way to describe a foundational system would be a list of axtioms that state that a computer program terminates. The lengths of various proofs and relative (between theorems) performance of the checker would be determined by which axioms you add. And of course you can describe the axiomatic content this way as well.</p>
</blockquote>
<p>I guess this list of axioms are more or less the rules for recursors of inductive types.</p>



<a name="179170648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179170648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179170648">(Oct 27 2019 at 13:14)</a>:</h4>
<p>I have a related question about foundations and how they play with different proof systems.</p>
<p>I've been reading about topos theory lately, which I understand in some ways is an alternative foundations for mathematics, where there's a clearer distinction between the types of foundational assumptions we make.</p>
<p>This may sound hilarious to the mathematicians, but as a programmer I think of it as being a foundation with built-in axiomatic/foundational polymorphism, in the sense that I can define mathematical objects like the real numbers that are independent of the topos I work in, so by delaying the choice of topos that restricts the type of things I can say, I get a nicer organization of theorems based on the types of assumptions that have been made.</p>
<p>So to my naive understanding, it feels like doing math in topos theory is analogous to following good software engineering practices in maintaining a large code base. Is this a valid comparison?</p>
<p>If so, does the choice of foundations between something like Metamath/STT/DTT make a difference in working towards a goal like this?</p>



<a name="179170880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179170880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179170880">(Oct 27 2019 at 13:20)</a>:</h4>
<blockquote>
<p>relative (between theorems) performance of the checker would be determined by which axioms you add.</p>
</blockquote>
<p>If you need to add axioms to make a proof check faster (by more than a constant additive factor), then the prover is not expressive enough</p>



<a name="179171075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171075">(Oct 27 2019 at 13:26)</a>:</h4>
<blockquote>
<p>If so, does the choice of foundations between something like Metamath/STT/DTT make a difference in working towards a goal like this?</p>
</blockquote>
<p>Note that Metamath does not belong on that list - it is not a mathematical foundation, it is an environment that lets you define your mathematical foundation. Isabelle has a similar distinction, if you are familiar with the difference between Isabelle/Pure vs Isabelle/HOL.</p>
<p>Most formal systems let you pick your axioms, although lean doesn't really let you turn off a great deal of axioms that you might not want (like universes or proof irrelevance). To me, your topos theory example is similar to proving theorems with attention paid to the axioms you use. In metamath this is easy because the axioms are quite fine grained - there are 30 or so of them, leading to 2^30 different subsystems of ZFC you could study; or just forget ZFC and add your own axioms if you prefer something else. Lean has only 3 axioms, and the only really useful one to avoid is <code>choice</code>, so reverse mathematics is a non-starter.</p>



<a name="179171226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171226">(Oct 27 2019 at 13:31)</a>:</h4>
<p>Could you define CoIC inside Metamath and then work using that?</p>



<a name="179171359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171359">(Oct 27 2019 at 13:35)</a>:</h4>
<p>Yes</p>



<a name="179171375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171375">(Oct 27 2019 at 13:36)</a>:</h4>
<p>I got most of the way to doing that with lean, but that was before my masters thesis so I wasn't really sure what the axioms for inductives were</p>



<a name="179171415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171415">(Oct 27 2019 at 13:36)</a>:</h4>
<p>MLTT is not difficult</p>



<a name="179171429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171429">(Oct 27 2019 at 13:37)</a>:</h4>
<p>There is a HOL library for metamath available at <a href="http://us.metamath.org/holuni/mmhol.html" target="_blank" title="http://us.metamath.org/holuni/mmhol.html">http://us.metamath.org/holuni/mmhol.html</a></p>



<a name="179171478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171478">(Oct 27 2019 at 13:38)</a>:</h4>
<p>the real bottleneck is usually getting an exact statement of the axiomatic system</p>



<a name="179171494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171494">(Oct 27 2019 at 13:39)</a>:</h4>
<p>Ok, yeah I can see the analogy with it being the assembly language for proofs.</p>



<a name="179171625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171625">(Oct 27 2019 at 13:43)</a>:</h4>
<p>For my example with topos theory, let's say I make a definition that works in any elementary topos, and then I define a new topos, I can do this in independent order, and as soon as I'm done I should get a bunch of free theorems. If one was working in Metamath, then it feels like you'd have to be working one level higher, where the free theorems get automatically generated, does this sound correct?</p>



<a name="179171682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171682">(Oct 27 2019 at 13:44)</a>:</h4>
<p>If you prove a theorem using axioms A, B and apply it in a context where you are also assuming C, you don't need to do anything special</p>



<a name="179171755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171755">(Oct 27 2019 at 13:46)</a>:</h4>
<p>What you don't get with this kind of embedding is the ability to reinterpret symbols. For example, if I prove a fact like <code>foo = foo</code> where <code>foo</code> is a "fixed constant" about which I know nothing, I cannot apply it with <code>foo := 2</code>. I can add an axiom saying <code>foo = 2</code>, and then <code>foo</code> acts like a definition, but I can't also add a definition <code>foo = 3</code> because that would be inconsistent</p>



<a name="179171769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171769">(Oct 27 2019 at 13:47)</a>:</h4>
<p>In order to really do the topos theory approach justice, you have to deep embed it, getting something more like the category theory library</p>



<a name="179171818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171818">(Oct 27 2019 at 13:48)</a>:</h4>
<p>this comes with some notational overhead unless you design the tool to deal with terms of this form</p>



<a name="179171823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171823">(Oct 27 2019 at 13:48)</a>:</h4>
<p>right, the reason we have higher level programming languages is not just to avoid typing less, but because our intended meaning of the program is better captured at a higher level, because the lower level aspects are deemed implementation details.</p>



<a name="179171837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171837">(Oct 27 2019 at 13:49)</a>:</h4>
<p>MM1 is higher level than MM0 is higher level than Metamath if I've understood things correctly</p>



<a name="179171900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171900">(Oct 27 2019 at 13:51)</a>:</h4>
<p>MM0 is more complex than metamath but they are equally expressive. MM1 is sugar over MM0</p>



<a name="179171902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171902">(Oct 27 2019 at 13:51)</a>:</h4>
<p>ah right</p>



<a name="179171910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179171910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179171910">(Oct 27 2019 at 13:51)</a>:</h4>
<p>"higher level" is perhaps not the right characterization. All of them are capable of speaking at quite high levels mathematically</p>



<a name="179172023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179172023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179172023">(Oct 27 2019 at 13:53)</a>:</h4>
<p>the thing that is low level is the actual mechanics of proving theorems. It's not like with computer languages where the low level languages are concerned with completely different things, different levels of abstraction</p>



<a name="179172307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179172307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179172307">(Oct 27 2019 at 14:01)</a>:</h4>
<p>Hmm yeah it is possible that I fail to notice my own bias with thinking about software/programming languages.</p>
<p>When I say higher level proof language, I mean a language that generates proofs that have a lot of repetition. The way Metamath allows you to inspect proofs down to very low level of detail is very nice, but the issue I have in mind is that if I write a definition in this higher level language, then the best way to understand its meaning is by reading it at this level, because we want to hide the repetition to increase the signal/noise ratio. Do you see this not being an issue?</p>



<a name="179172633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179172633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179172633">(Oct 27 2019 at 14:10)</a>:</h4>
<p>I can give an example I have in mind: Take Lawvere's Fixpoint Theorem, that generalizes many other fixpoint theorems. I would like to see not just the proof of the LFT itself, but also how other theorems are instances of it. To me it feels like you would need to work on a higher semantic level than MM0 in order to do this, but maybe I'm mistaken?</p>



<a name="179173747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179173747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179173747">(Oct 27 2019 at 14:44)</a>:</h4>
<blockquote>
<p>When I say higher level proof language, I mean a language that generates proofs that have a lot of repetition. The way Metamath allows you to inspect proofs down to very low level of detail is very nice, but the issue I have in mind is that if I write a definition in this higher level language, then the best way to understand its meaning is by reading it at this level, because we want to hide the repetition to increase the signal/noise ratio. Do you see this not being an issue?</p>
</blockquote>
<p>Metamath is actually very non-repetitive, MM0 even more so. It would be nice to have some theorems about this, but they are pretty close to optimal. The repetition you see in the web page presentation is because each line is independent of the others, and common subterms are expanded during printing. In the actual proof it's totally deduplicated</p>



<a name="179173825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179173825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179173825">(Oct 27 2019 at 14:47)</a>:</h4>
<blockquote>
<p>I can give an example I have in mind: Take Lawvere's Fixpoint Theorem, that generalizes many other fixpoint theorems. I would like to see not just the proof of the LFT itself, but also how other theorems are instances of it. To me it feels like you would need to work on a higher semantic level than MM0 in order to do this, but maybe I'm mistaken?</p>
</blockquote>
<p>I don't know what Lawvere's Fixpoint Theorem is, but I'm 100% confident you can state it as a single theorem of MM/MM0. If you want to apply it in a particular circumstance, you prove that your category instantiates the assumptions, unfold the meaning of the symbols (i.e. maybe you want to replace "generic morphism" with "function") in the statement, and that's it.</p>



<a name="179173890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179173890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179173890">(Oct 27 2019 at 14:49)</a>:</h4>
<p>the considerations are roughly the same if you wanted to do the same thing in lean. Declare the general concept of a category, do your work there, then instantiate the theory in the concrete case</p>



<a name="179174088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179174088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179174088">(Oct 27 2019 at 14:54)</a>:</h4>
<p>Lean is actually far more repetitive than Metamath. This is the result of things like tactics that don't clean up after themselves in the output proof, <code>congr</code> generating congr lemmas from scratch every time it's called, typeclass inference not saving and reusing typeclass lookups, and kernel <code>rfl</code> proofs, which have to unfold huge equation compiler terms</p>



<a name="179174155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179174155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179174155">(Oct 27 2019 at 14:56)</a>:</h4>
<p>Metamath looks more repetitive because of its print settings, but exactly because of that people have a much greater incentive to minimize repetition. In other theorem provers all the junk is hidden under the rug</p>



<a name="179175045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179175045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179175045">(Oct 27 2019 at 15:25)</a>:</h4>
<p>to clarify, Lean is far more repetitive than Metamath during compilation/tactic execution; this is the cost of automation which allows the user to work at a higher level when writing Lean source code</p>



<a name="179175293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179175293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179175293">(Oct 27 2019 at 15:32)</a>:</h4>
<p>of course, your Lean server recompiles every time more than 200ms elapses between keystrokes, and while ideally you don't notice this because of caching, it's not hard for users to get to a place where they experience significant lag waiting on elaboration, typeclass resolution, and tactic execution</p>



<a name="179177310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177310">(Oct 27 2019 at 16:28)</a>:</h4>
<p><span class="user-mention" data-user-id="126113">@Olli</span> note that Lean's implementation of DTT naturally has semantics in locally cartesian closed categories, so it's easy to shallowly replay the proof of the LFPT in <code>Type</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="c1">-- https://ncatlab.org/nlab/show/Lawvere%27s+fixed+point+theorem</span>

<span class="n">def</span> <span class="n">δ</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">X</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="kn">eval</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="bp">×</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">pr</span><span class="o">,</span> <span class="n">pr</span><span class="bp">.</span><span class="mi">1</span> <span class="n">pr</span><span class="bp">.</span><span class="mi">2</span>

<span class="kn">lemma</span> <span class="n">lfpt</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">ϕ</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">Hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">ϕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">B</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">B</span><span class="o">,</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">f</span><span class="o">,</span> <span class="n">cases</span> <span class="n">Hf</span> <span class="o">(</span><span class="n">f</span> <span class="err">∘</span> <span class="kn">eval</span> <span class="err">∘</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">map</span> <span class="n">ϕ</span> <span class="n">id</span><span class="o">)</span> <span class="err">∘</span> <span class="n">δ</span><span class="o">)</span> <span class="k">with</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">,</span> <span class="n">use</span> <span class="n">ϕ</span> <span class="n">p</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">conv_rhs</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">Hp</span> <span class="o">},</span> <span class="n">refl</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">cantor</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">ϕ</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">ϕ</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">H</span><span class="o">,</span> <span class="n">cases</span> <span class="n">lfpt</span> <span class="n">ϕ</span> <span class="n">H</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span> <span class="k">with</span> <span class="n">p</span> <span class="n">Hp</span><span class="o">,</span> <span class="n">ifinish</span>
<span class="kn">end</span>
</pre></div>



<a name="179177389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177389">(Oct 27 2019 at 16:31)</a>:</h4>
<p><span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> thanks, I was going to attempt this on my own but it's good to have something to look at if I get stuck :)</p>



<a name="179177441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177441">(Oct 27 2019 at 16:32)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> if I were to prove LFPT in Metamath and then show that Cantor's Theorem follows from it, would I be assuming <code>lfpt</code> and deriving <code>canth</code>, or would I have to make a new statement different from <code>canth</code> that I know means the same thing?</p>



<a name="179177506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177506">(Oct 27 2019 at 16:34)</a>:</h4>
<p>I think the larger issue I am trying to understand is if there is a way for me to see what are some examples of theorems/definitions that have very high generality (such as LFPT) simply by looking at the shape of the set of proof derivations in the database of theorems I'm working in (so probably <code>set.mm</code> in Metamath)</p>



<a name="179177511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177511">(Oct 27 2019 at 16:35)</a>:</h4>
<p>You would apply <code>lfpt</code> to get something that is not exactly <code>canth</code> but is equivalent to it (defeq in lean terminology)</p>



<a name="179177522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177522">(Oct 27 2019 at 16:35)</a>:</h4>
<p>you would have to postprocess the statement to get rid of the category theory notations</p>



<a name="179177563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177563">(Oct 27 2019 at 16:36)</a>:</h4>
<p>There isn't that much category theory, but here's the yoneda lemma: <a href="http://us.metamath.org/mpeuni/yoneda.html" target="_blank" title="http://us.metamath.org/mpeuni/yoneda.html">http://us.metamath.org/mpeuni/yoneda.html</a></p>



<a name="179177674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177674">(Oct 27 2019 at 16:40)</a>:</h4>
<p>To continue with the analogy of maintaining software at large, I am wondering if we have the same conflict between adding new features (theorems) vs. abstracting/decoupling them from each other, and how much does the foundation we choose have to do with the ease of organizing things nicely</p>



<a name="179177802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177802">(Oct 27 2019 at 16:44)</a>:</h4>
<p>I think that the cost of abstraction is higher in (formal) math than it is in software, because you have to filter everything through an extra definitional layer</p>



<a name="179177820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177820">(Oct 27 2019 at 16:45)</a>:</h4>
<p>the foundation doesn't matter at all. The only thing a foundation can do for you is make certain things impossible and other things difficult</p>



<a name="179177865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177865">(Oct 27 2019 at 16:46)</a>:</h4>
<p>the job of making things easy is left to the user interface</p>



<a name="179177881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177881">(Oct 27 2019 at 16:47)</a>:</h4>
<p>it's interesting to think about especially when it comes to the prospects of having some kind of an AI helping us do mathematics. The first thing that comes to mind is a superhuman tactic to solve a goal, but wouldn't it be even more valuable having suggestions on how to organize the material we already have in a way that makes expanding it easier?</p>



<a name="179177936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179177936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179177936">(Oct 27 2019 at 16:48)</a>:</h4>
<p>yes? What does that have to do with foundations?</p>



<a name="179178023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178023">(Oct 27 2019 at 16:51)</a>:</h4>
<p>To give a simple example of why foundations don't matter, suppose I rewrote the lean kernel to produce typechecking proofs that it fed to metamath / ZFC as an oracle, and reports success if the backend prover accepts the proof. The front end wouldn't change at all, mathlib would still compile, you wouldn't even notice the difference - yet now the foundation is fundamentally different</p>



<a name="179178069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178069">(Oct 27 2019 at 16:52)</a>:</h4>
<p>this is why I see a type system as a front end feature</p>



<a name="179178088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178088">(Oct 27 2019 at 16:53)</a>:</h4>
<p>if we think of the set of theorems we have as a data structure, then I think a highly general theorem such as LFPT should be a densely connected node, or there should be some metric for valuing these types of theorems over ones that are less general. I mean I am not a mathematician so this might be very naive, but if we were to throw process cycles at a database of theorems in the hopes of making breakthroughs that connect areas of mathematics we had not realized were related, then this type of activity would be essential</p>



<a name="179178142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178142">(Oct 27 2019 at 16:54)</a>:</h4>
<p>densely connected node is probably an incorrect description, but I hope you understand what I mean by valuing generality</p>



<a name="179178159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178159">(Oct 27 2019 at 16:55)</a>:</h4>
<p>Honestly, given Jesse's demonstration of the proof, I don't value it very highly. The proof is apparently only two lines, which means that if you try to apply this theorem in a particular category the unpacking overhead will be more than the proof itself</p>



<a name="179178167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178167">(Oct 27 2019 at 16:55)</a>:</h4>
<p>I always tend to get this impression from category theory proofs</p>



<a name="179178271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178271">(Oct 27 2019 at 16:58)</a>:</h4>
<p>the savings from extracting a theorem is (number of uses - 1) * (size of proof) - definitions needed to state the theorem - (number of uses) * (unpacking overhead)</p>



<a name="179178343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178343">(Oct 27 2019 at 17:00)</a>:</h4>
<p>if unpacking overhead is small and no new definitions are needed, then it's a pretty low bar to meet, but definitions and unpacking overhead often go together, and category theory is full of small abstract theorems</p>



<a name="179178532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178532">(Oct 27 2019 at 17:04)</a>:</h4>
<p>the unpacking overhead is high because it is applicable in a wider set of contexts, right? i.e. we are talking about breadth vs. depth</p>



<a name="179178741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178741">(Oct 27 2019 at 17:11)</a>:</h4>
<p>Unpacking overhead depends on a few things. Roughly, it depends on the difference between the putative generalization and the concrete instance that it's supposed to be generalizing. Oftentimes it's a literal generalization, as in you have just universally quantified some variable that was already there. Rather than prove 2 + 3 = 3 + 2 we prove a + b = b + a. This kind of generalization has almost no overhead.</p>
<p>A bigger overhead comes from unpacking structures; for example we want that to follow from an abelian group axiom, so we have some <code>&lt;G, +&gt; \in AbGroup</code> and have a theorem <code>&lt;G, +&gt; \in AbGroup -&gt; a \in G -&gt; b \in G -&gt; a + b = b + a</code>. This is still not so bad, because I've unfolded the structure. If it shows up bundled, it might instead be <code>S \in AbGroup -&gt; a \in carrier G -&gt; b \in carrier G -&gt; add G a b = add G b a</code> and now we have to instantiate this with <code>&lt;G, +&gt;</code>, and then replace <code>add &lt;G, +&gt;</code> with <code>+</code> and <code>carrier &lt;G, +&gt;</code> with <code>G</code> everywhere they appear</p>



<a name="179178795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178795">(Oct 27 2019 at 17:13)</a>:</h4>
<p>If, as in lean, we didn't bother to remember that e.g. <code>int</code> is an abelian group, but instead have to traverse the algebraic hierarchy to find the proof, then the overhead is a bit more.</p>



<a name="179178869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179178869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179178869">(Oct 27 2019 at 17:15)</a>:</h4>
<p>right, so you are saying that you don't value this theorem as much because its abstractness makes it less useful in digging deeper faster, meaning it would not be a useful piece of a superhuman tactic, as it would slow it down.</p>
<p>What I am getting at is that this type of theorem is useful not as a building block, but as a goal in itself, i.e. I care less about theorems that go very deep, and more about the ones that bridge a lot of gaps.</p>



<a name="179179433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179179433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Olli <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Lean.20vs.20other.20systems.html#179179433">(Oct 27 2019 at 17:33)</a>:</h4>
<p>I concede that what I initially wrote is what your point refutes, but it made me realize that an actually useful AI for doing mathematics probably should wrestle with these two conflicting goals of digging deep into a search tree, and the conflicting objective of organizing theorems in such a way that makes them slow to use (but insightful to read)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
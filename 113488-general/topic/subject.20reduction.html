---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/subject.20reduction.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html">subject reduction</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="312137803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312137803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312137803">(Nov 25 2022 at 08:40)</a>:</h4>
<p>Jon Sterling (who is no mug) says <a href="https://twitter.com/jonmsterling/status/1595558964472717313?s=20&amp;t=rXSABLrOmWPlrldPonfdJw">on Twitter</a>: "It’s funny how much is made of how Lean’s typechecking is undecidable, definitional equality intransitive, subject reduction failure… To those of us who know WHY these things fail in Lean it is quite clear that these things could be fixed in a semester’s internship project, without fundamentally changing the user experience of Lean (except, of course, to improve it)." He then goes on to sketch how to do this.</p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/jonmsterling/status/1595558964472717313?s=20&amp;t=rXSABLrOmWPlrldPonfdJw"><img class="twitter-avatar" src="https://uploads.zulipusercontent.net/7c775d208f56f858a9e3c6bde2c9b0262307ea9e/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313339373632343831313532323836333130362f5552516a556f66305f6e6f726d616c2e6a7067"></a><p>It’s funny how much is made of how Lean’s typechecking is undecidable, definitional equality intransitive, subject reduction failure… To those of us who know WHY these things fail in Lean it is quite clear that these things could be fixed in a semester’s internship project,</p><span>- Jon Sterling (@jonmsterling)</span></div></div><p>My experience is that when people who haven't written proof assistants start talking about how to "fix" a proof assistant, there is often some argument from the other side of the form "the problem with your "fix" is that actually it breaks X, Y and Z". But this is a long way from my area of expertise so I thought I may as well ask here, hoping that people who understand the subtleties might chime in. I have never had any interest in this subject reduction conversation because it seems that we have ample evidence that Lean is capable of doing proofs in hard modern mathematics (with classical axioms of course, as mainstream mathematicians believe that constructivism died 100 years ago) and thus any claim that it is "broken" in some way cannot be relevant to what I want to use Lean for. However perhaps it is relevant to others, especially if Lean 4 is wanting to broaden its remit beyond mathematics (and my understanding is that this is the case).</p>



<a name="312138301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312138301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312138301">(Nov 25 2022 at 08:44)</a>:</h4>
<p><span class="user-mention" data-user-id="261512">@Jonathan Sterling</span> hopefully pinging the right person...(just occurred to me that you might be here)</p>



<a name="312178943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312178943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312178943">(Nov 25 2022 at 12:43)</a>:</h4>
<p>The fact that definitional equality is intransitive has nothing to do with equality being transitive in Lean, right?</p>



<a name="312193986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312193986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312193986">(Nov 25 2022 at 14:01)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> equality is provably transitive even if definitional equality is sometimes (in rare cases) not transitive.</p>



<a name="312194882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312194882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312194882">(Nov 25 2022 at 14:05)</a>:</h4>
<p>I’d definitely love <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>’s feedback on Jon’s proposal.  I’d also love to know how easy it would be to add Jon’s proposal to one of the external type checkers and just see how much of the current mathlib and core Lean 3 term proofs (if any) wouldn’t go through in his revised type system.</p>



<a name="312200400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312200400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312200400">(Nov 25 2022 at 14:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312137803">said</a>:</p>
<blockquote>
<p>Jon Sterling (who is no mug) says <a href="https://twitter.com/jonmsterling/status/1595558964472717313?s=20&amp;t=rXSABLrOmWPlrldPonfdJw">on Twitter</a>: "It’s funny how much is made of how Lean’s typechecking is undecidable, definitional equality intransitive, subject reduction failure… To those of us who know WHY these things fail in Lean it is quite clear that these things could be fixed in a semester’s internship project, without fundamentally changing the user experience of Lean (except, of course, to improve it)." He then goes on to sketch how to do this.</p>
<p>My experience is that when people who haven't written proof assistants start talking about how to "fix" a proof assistant, there is often some argument from the other side of the form "the problem with your "fix" is that actually it breaks X, Y and Z". But this is a long way from my area of expertise so I thought I may as well ask here, hoping that people who understand the subtleties might chime in. I have never had any interest in this subject reduction conversation because it seems that we have ample evidence that Lean is capable of doing proofs in hard modern mathematics (with classical axioms of course, as mainstream mathematicians believe that constructivism died 100 years ago) and thus any claim that it is "broken" in some way cannot be relevant to what I want to use Lean for. However perhaps it is relevant to others, especially if Lean 4 is wanting to broaden its remit beyond mathematics (and my understanding is that this is the case).</p>
</blockquote>
<p>Hi Kevin, thanks for the ping! I generally agree about your experience with people who have some "great idea" but no experience, but in case it helps clarify things, <strong>I have <em>extensive</em> experience building proof assistants</strong>: I have been doing so for seven years and have built three of them. So while my familiarity with the Lean codebase itself is limited, my understanding of the subtlety of integrating various ideas in real code is deep and based on a lot of experience.</p>
<p>The proposal for fixing the quotients that I mentioned is not due to me, but rather to Mario Carneiro; as Mario pointed out years ago, this one thing could be fixed easily without anyone noticing. The proposal about fixing accessibility predicates is more invasive but likewise not due to me, but rather to Gilbert, Cockx, Sozeau, and Tabareau --- all of whom are proof assistant engineers extraordinaire with <em>even more</em> experience than me. Sozeau and Tabareau have been hardcore proof assistant builders for longer than Lean has even existed...  It is perhaps worthwhile to listen to what they have to say.</p>



<a name="312200761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312200761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312200761">(Nov 25 2022 at 14:34)</a>:</h4>
<p>My feeling about these things has always been (1) the problems are not so bad, so I don't know why people complain about them so much, and (2) the problems can be fixed and are <strong>not</strong> (contrary to what some people seem to like to say) part of a Great Tradeoff between Theory and Practice, or a tradeoff between the Goals of Lean and the Goals of Pointy-Headed Type Theorists. </p>
<p>My personal interest in this is not to gesticulate and demand that energy be devoted to work that will likely have a limited practical impact on Lean's users (as you say, people have been successfully working around conversion being broken for years without too much frustration). I am more reacting to some people (including but certainly not only <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>) positioning what are some minor technical <strong>bugs</strong> that we know how to fix as if they are a political position, like "Maybe the type theorists need conversion to be transitive, but if we did that, we wouldn't be able to have X, Y, Z" — what I have been trying to explain for a while now is that there is no such tradeoff in play, so the only question is whether you want to devote time to fixing these bugs using the well-known solutions (which are completely compatible with Lean's goals and design to be an efficient proof assistant for classical mathematics with heavy use of proof-irrelevance).</p>
<p>I think it is very reasonable if nobody here wants to devote time to that, and all I would appreciate is if people stop positioning these (relatively minor) design mistakes as if they are trade-offs between theory and practice, which they are not.</p>



<a name="312203531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312203531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312203531">(Nov 25 2022 at 14:49)</a>:</h4>
<p>Nice to have you here, and thanks for your comments. Maybe you can enlighten me on one of your sentences:<br>
<span class="user-mention silent" data-user-id="261512">Jonathan Sterling</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312200761">said</a>:</p>
<blockquote>
<p>people have been successfully working around conversion being broken for years without too much frustration</p>
</blockquote>
<p>In fact, people working with mathlib have never needed to work around conversion being broken for years, because there has never been any issue related to that, as far as I can tell, so no need to work anything around. Could you explain in laymen terms what conversion being broken means (by layman, I mean for someone understanding a lot of mathematics in the traditional sense and a very basic background in logic), and how it could manifest itself? Maybe in fact it already happened but we couldn't recognize it for what it was.</p>



<a name="312210539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312210539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312210539">(Nov 25 2022 at 15:24)</a>:</h4>
<p>Good question, it is often hard to pinpoint the cause of some issue if you don't have some experience with it, and in a setting where there is heavy use of sophisticated automation like in Lean, it can be hard to tell whether some issue is caused by a bug or if it is a non-bug caused by some subtlety of the automation...</p>
<p>The usual thing that happens when conversion fails to be transitive is that you will have some equation that should hold by <code>reflexivity</code> according to the type theory of Lean, but Lean itself rejects <code>reflexivity</code> here --- so to prove your goal you instead break it up into several equational reasoning steps that are each solved by <code>reflexivity</code> and then composed by transitivity of (propositional) equality. This can also arise in cases that do not involve a goal of the form <code>u = v</code>, for instance when you have a predicate of the form <code>P(u)</code> and you want to solve it using a proof of <code>P(v)</code> where <code>u</code> and <code>v</code> are (should be) definitionally equal, but conversion fails to see this. </p>
<p>Last time I discussed this with Kevin he mentioned to me that he has seen things like this happen, and indeed, you just work around it by rephrasing (sometimes in an artificial way) the thing you were trying to write until the typechecker accepts it.</p>



<a name="312211083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312211083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312211083">(Nov 25 2022 at 15:27)</a>:</h4>
<p>ok, so conversion failure is when terms should be definitionally equal but the kernel fails to see that. Yes, that might have happened -- although the issues I remember were more mistakes on my side than on the kernel's :-)</p>



<a name="312211683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312211683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312211683">(Nov 25 2022 at 15:30)</a>:</h4>
<p>Yeah... It is often really hard to figure out whether it is my own fault or the system's fault :)  This is basically why type theorists have always had the design goals of conversion to be <strong>sound</strong> (never accepts something wrong), <strong>complete</strong> (always accepts something right), and <strong>efficient</strong> (doesn't take too long); I would personally like to add <strong>predictable</strong> to this list. The reason these things are important is that it is necessary, in my world, for users to be able to reliably determine whether they are the one who made a mistake, or the kernel is the one who made the mistake. If conversion does not claim to reliably implement definitional equality, there is no "ground source of truth" and no one component can be assigned blame for a failure.</p>
<p>I often hear "Well, we don't use <code>reflexivity</code> very often, since we try not to depend too much on definitional equality; so why does it matter if some random thing an be proved using <code>reflexivity</code> or if it requires a more complex argument that we can automate?" This is all true (and good proof engineering practice too!), but I think what is at stake is not so much the degree of power that we endow <code>reflexivity</code> with (e.g. what kinds of non-trivial things can it prove) but rather, no matter how weak or strong it is, how reliable and predictable it is.</p>



<a name="312212167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312212167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312212167">(Nov 25 2022 at 15:33)</a>:</h4>
<p>Things that clearly happen sometimes is cases where you build a proof using tactics, the proof is really quick, but then the proof checking by the kernel is really slow (but terminates eventually). Say 0.5s for proof building, 10s for proof checking. This is not a theoretical failure of whatever, because in the end the kernel works it out, but more of an engineering problem with different heuristics used on one side and the other. These ones are really frustrating from a practical point of view!</p>



<a name="312212412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312212412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312212412">(Nov 25 2022 at 15:34)</a>:</h4>
<p>Yeah!! These are the kinds of questions that I am increasingly interested in, because it really gets right to the point... And I think that there is a lot of room to investigate the way that various theoretical concepts (e.g. completeness) influence the pragmatic aspects of the user experience.</p>



<a name="312212535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312212535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312212535">(Nov 25 2022 at 15:35)</a>:</h4>
<p>And often you can work them around by changing randomly your proof until the kernel is also quick.</p>



<a name="312212622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312212622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312212622">(Nov 25 2022 at 15:36)</a>:</h4>
<p>That's true... I've experienced that problem a LOT when using Coq — you do this great proof, and then hit <code>Qed.</code> and the whole computer grinds to a halt <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="312212802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312212802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312212802">(Nov 25 2022 at 15:36)</a>:</h4>
<p>(By randomly, I mean, change a rewrite to a simplifier invocation or vice-versa).</p>



<a name="312216549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312216549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312216549">(Nov 25 2022 at 15:56)</a>:</h4>
<p>I'm not sure whether this sort of issue falls under the "subject reduction" style stuff, but there is often cases where a proof term doesn't work, but writing <code>by exact _</code> for the exact same proof term does. I'm told that this is to do with metavariables, but I don't fully understand it.</p>



<a name="312219858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312219858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312219858">(Nov 25 2022 at 16:15)</a>:</h4>
<p>Yeah, I think these issues that we are now discussing a more subtle than the subject reduction stuff, and do not necessarily reflect a bug but just some engineering tradeoffs that are very hard to negotiate :)</p>



<a name="312220939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312220939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312220939">(Nov 25 2022 at 16:21)</a>:</h4>
<p><span class="user-mention" data-user-id="261512">@Jonathan Sterling</span> Could you please explain what you have in mind by adding <em>predictable</em> to {<em>sound</em>, <em>complete</em>, <em>efficient</em>}? Naively, it sounds to me that <em>predictable</em> would be a consequence of the other three.</p>



<a name="312221432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312221432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312221432">(Nov 25 2022 at 16:23)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Good point, I think that what you say is true in a certain sense: if conversion correctly (soundly, completely) implements definitional equality, it is of course predictable if you understand definitional equality. So maybe it would have been better for me to say that predictability more pertains to the design of definitional equality than to the implementation of conversion.</p>



<a name="312221701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312221701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312221701">(Nov 25 2022 at 16:25)</a>:</h4>
<p><span class="user-mention" data-user-id="261512">@Jonathan Sterling</span>  How much work work do you think this is, and would it be easier to implement a proof of concept in one of the external checkers?</p>



<a name="312222235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312222235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312222235">(Nov 25 2022 at 16:28)</a>:</h4>
<p>Good question; the first part (fixing quotients) is almost certainly very easy (but we should check with Mario), but the broader issue is quite involved (but still doable if someone actually wanted to do it). The bigger issue is that singleton elimination (not sure what people call it in Lean world) for inductively defined propositions is not really compatible with having a working conversion algorithm, and the way to work around this is that the these inductively defined propositions can be replaced with <em>recursively</em> defined propositions in practice, and then the need for singleton elimination disappears. The main place where these inductively defined propositions occur today is in accessibility predicates, which are part of Lean's elaboration of well-founded recursive pattern-matching definitions.</p>



<a name="312222399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312222399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312222399">(Nov 25 2022 at 16:29)</a>:</h4>
<p>The translation of these accessibility predicates to recursively defined predicates with their associated induction principles is quite complicated, to my recollection, and this is the place where most of the work would happen. There was a partially implemented prototype of this in Coq I think by Sozeau (because the Coq people experimenting with Lean's proof-irrelevant Prop universe), but I do not think it was ever really completed.</p>



<a name="312222685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312222685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312222685">(Nov 25 2022 at 16:30)</a>:</h4>
<p>The idea that I am describing comes from this paper IIRC, which I found really impressive: <a href="https://dl.acm.org/doi/10.1145/3290316">https://dl.acm.org/doi/10.1145/3290316</a>.  Although the goals of the paper pertained to integrating proof irrelevance into a type theory that does not have UIP, the ideas of this paper also apply to systems like Lean where we take UIP for granted.</p>



<a name="312224138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312224138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312224138">(Nov 25 2022 at 16:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312216549">said</a>:</p>
<blockquote>
<p>I'm not sure whether this sort of issue falls under the "subject reduction" style stuff, but there is often cases where a proof term doesn't work, but writing <code>by exact _</code> for the exact same proof term does. I'm told that this is to do with metavariables, but I don't fully understand it.</p>
</blockquote>
<p>If I may come back to this slightly off topic point, replacing <code>t</code> with <code>by exact t</code> should result in the exact same term being sent to the kernel. In particular, the kernel should not be sent any metavariables at all to check. Rather, (my entirely phenomenological understanding not tested against the actual source code is that) the <code>by exact</code> trick tells the elaborator to postpone its work on some parts of the expression that might get stuck, and first process some other subexpressions that cause the <code>by exact</code>ed expression to become unstuck.</p>



<a name="312225336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312225336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312225336">(Nov 25 2022 at 16:48)</a>:</h4>
<p>Lean 4's generalized elaboration ordering should hopefully make that particular workaround obsolete</p>



<a name="312225552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312225552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312225552">(Nov 25 2022 at 16:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312225336">said</a>:</p>
<blockquote>
<p>Lean 4's generalized elaboration ordering should hopefully make that particular workaround obsolete</p>
</blockquote>
<p>Sounds cooll!! Where can I learn more about the generalized elaboration ordering? (It's ok if nothing's written, I can also look at code :) )</p>



<a name="312226009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312226009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312226009">(Nov 25 2022 at 16:52)</a>:</h4>
<p><a href="https://davidchristiansen.dk/pubs/tyde2020-predictable-macros-abstract.pdf">https://davidchristiansen.dk/pubs/tyde2020-predictable-macros-abstract.pdf</a> describes a similar but more elegant design, and how Lean simplifies the implementation in exchange for a bit of redundant computation :)</p>



<a name="312226389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312226389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312226389">(Nov 25 2022 at 16:54)</a>:</h4>
<p>This might be dumb for some reason I am missing, but it seems to me that definitions by well-founded recursion already do not compute and we are basically okay with that (for closed terms we have other methods to propositionally "compute" the value, and for open terms computation isn't likely to be useful).<br>
In that case, how bad would it be to just discard the computation rule for <code>acc.rec</code>? That would fix the associated subject reduction issue right?</p>



<a name="312226738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312226738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312226738">(Nov 25 2022 at 16:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312225336">said</a>:</p>
<blockquote>
<p>Lean 4's generalized elaboration ordering should hopefully make that particular workaround obsolete</p>
</blockquote>
<p>it's not perfect: <a href="#narrow/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631/near/311869098">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/logic.2Eequiv.2Ebasic.20mathlib4.23631/near/311869098</a></p>



<a name="312227265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312227265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312227265">(Nov 25 2022 at 17:00)</a>:</h4>
<p>In my experience, acc.rec not computing has been really annoying when it actually matters; this is rarely though.</p>



<a name="312227755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312227755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312227755">(Nov 25 2022 at 17:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312226389">said</a>:</p>
<blockquote>
<p>This might be dumb for some reason I am missing, but it seems to me that definitions by well-founded recursion already do not compute and we are basically okay with that (for closed terms we have other methods to propositionally "compute" the value, and for open terms computation isn't likely to be useful).<br>
In that case, how bad would it be to just discard the computation rule for <code>acc.rec</code>? That would fix the associated subject reduction issue right?</p>
</blockquote>
<p>Oh, very interesting --- I didn't realize these things don't compute on their own. I'd have to think about it a little more, but your idea sounds potentially workable and nicely non-invasive. Maybe we can try it on a branch and see what happens?</p>



<a name="312227854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312227854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312227854">(Nov 25 2022 at 17:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312226009">said</a>:</p>
<blockquote>
<p><a href="https://davidchristiansen.dk/pubs/tyde2020-predictable-macros-abstract.pdf">https://davidchristiansen.dk/pubs/tyde2020-predictable-macros-abstract.pdf</a> describes a similar but more elegant design, and how Lean simplifies the implementation in exchange for a bit of redundant computation :)</p>
</blockquote>
<p>Oh OK thanks! I was recently hanging out with David and he explained this idea to me. It sounds amazing.</p>



<a name="312227875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312227875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312227875">(Nov 25 2022 at 17:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> This is basically <a href="https://github.com/leanprover/lean/pull/1803">https://github.com/leanprover/lean/pull/1803</a></p>



<a name="312228103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312228103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312228103">(Nov 25 2022 at 17:05)</a>:</h4>
<p>There is also <a href="https://github.com/leanprover-community/lean/pull/562">https://github.com/leanprover-community/lean/pull/562</a></p>



<a name="312228134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312228134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312228134">(Nov 25 2022 at 17:05)</a>:</h4>
<p>I may have accidentally done some testing on a lean version which is older than that.</p>



<a name="312228751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312228751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312228751">(Nov 25 2022 at 17:09)</a>:</h4>
<p>OK I tested on lean-3.48.0, and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="k">#reduce</span> <span class="bp">@</span><span class="n">acc.rec</span> <span class="n">ℕ</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">IH</span> <span class="n">IH'</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span> <span class="o">(</span><span class="n">well_founded.apply</span> <span class="n">has_well_founded.wf</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>prints <code>nat.zero</code> (so the computation rule is still around in some form).</p>



<a name="312228763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312228763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312228763">(Nov 25 2022 at 17:09)</a>:</h4>
<p>Yes, since that change <code>acc.rec</code> computes only when applied to a <em>syntactic</em> <code>acc.intro</code> (which is how <code>well_founded.fix_eq</code> is derived). So if you work with well-founded recursion where well-foundedness comes from an external proof as usual, it should be basically impossible to observe this failure of transitivity unless you or a tactic explicitly unfold the major premise.</p>



<a name="312228817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312228817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312228817">(Nov 25 2022 at 17:09)</a>:</h4>
<p>And also the subject reduction failure from the paper Jon linked to still "works" (i.e., fails in the same way).</p>



<a name="312228902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312228902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312228902">(Nov 25 2022 at 17:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312228763">said</a>:</p>
<blockquote>
<p>Yes, since that change <code>acc.rec</code> computes only when applied to a <em>syntactic</em> <code>acc.intro</code> (which is how <code>well_founded.fix_eq</code> is derived). So if you work with well-founded recursion where well-foundedness comes from an external proof as usual, it should be basically impossible to observe this failure of transitivity unless you or a tactic explicitly unfold the major premise.</p>
</blockquote>
<p>So I think this is not a good idea... haha.</p>



<a name="312228927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312228927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312228927">(Nov 25 2022 at 17:10)</a>:</h4>
<p>This sounds like "how to create subject reduction failure 101"</p>



<a name="312228967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312228967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312228967">(Nov 25 2022 at 17:10)</a>:</h4>
<p>Precisely. It is absolutely a non-starter to have rules that distinguish between syntactic forms that are definitionally equivalent. Why bother putting in such a rule in the first place? It would be better to remove the computation entirely and generate unfolding axioms.</p>



<a name="312229549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312229549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312229549">(Nov 25 2022 at 17:14)</a>:</h4>
<p>I would have to check the code carefully, but I believe this is the natural emergent behavior from iota reduction + "do not reduce proofs". The rule specific to <code>acc</code> was <em>removed</em>.</p>



<a name="312229726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312229726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312229726">(Nov 25 2022 at 17:15)</a>:</h4>
<p>It certainly means that completely blocking computation like in the PR should not affect most code</p>



<a name="312229962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312229962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312229962">(Nov 25 2022 at 17:17)</a>:</h4>
<p>I see, so now that there is no longer special logic to reduce proofs that appear as arguments to <code>acc.rec</code>, it would make sense to consider that PR (or equivalent) again.</p>



<a name="312230112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312230112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312230112">(Nov 25 2022 at 17:18)</a>:</h4>
<p>Oh, I think now I am starting to partly understanding what you folks are saying...</p>



<a name="312247794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312247794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312247794">(Nov 25 2022 at 19:32)</a>:</h4>
<p>If we give up the computation rule for <code>acc</code>, then I think one can argue (at least informally) that the type checker can operate without ever reducing a proof. In other words, proofs become "typechecker irrelevant" in the sense that once the type checker builds one, it never has to inspect it again. Here is the rough argument I have in mind:</p>
<ul>
<li>
<p>One reason we might need to reduce a proof is to check whether a reduction rule applies to an expression that contains it.</p>
<ul>
<li>
<p>For the beta rule, if we are reducing <code>h x</code> and <code>h</code> is a proof, then the term <code>h x</code> we are reducing must also be a proof. In that case, we could not get into this situation in the first place (by assumption).</p>
</li>
<li>
<p>For the inductive proposition computation rules, if we are reducing <code>T.rec ... h</code> with <code>h</code> a proof, first note that there is again no problem if the elimination results in another proposition.</p>
</li>
</ul>
<p>So, we only need to consider propositions <code>h : p</code> where <code>p</code> supports large elimination. I will consider a few specific examples, and assume that all inductive propositions can be treated similarly. In case of doubt, one can always decline to support a computation rule (as in the case of <code>acc</code>).</p>
<ul>
<li>
<p>If <code>p</code> is <code>false</code> then it has no constructors, so there are no computation rules to worry about.</p>
</li>
<li>
<p>If <code>p</code> is <code>and q r</code> then we should reduce <code>and.rec f (and.mk hq hr)</code> to <code>f hq hr</code>. Instead, we reduce <code>and.rec f h</code> to <code>f h.fst h.snd</code> (effectively eta-expanding <code>h</code>).</p>
</li>
<li>
<p>If <code>p</code> is <code>x = y</code> then <code>eq.rec a h</code> can only reduce when <code>h</code> reduces to <code>rfl</code>. In that case, <code>x</code> and <code>y</code> would be defeq. So instead, check whether <code>x</code> and <code>y</code> are defeq and if so reduce <code>eq.rec a h</code> to <code>a</code>. (This relies on UIP of course.)</p>
</li>
<li>
<p>If <code>p</code> is some other weird inductive proposition like <code>acc</code> then we declare that we're not going to have a computation rule for it, so there is nothing to do.</p>
</li>
</ul>
</li>
<li>
<p>The other situation in which we might need to reduce a proof <code>h</code> is to check whether it is defeq to something else. By definitional proof irrelevance, we can answer "yes" without inspecting <code>h</code>.</p>
</li>
<li>
<p>Any other cases I forgot?</p>
</li>
</ul>



<a name="312262631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312262631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312262631">(Nov 25 2022 at 22:05)</a>:</h4>
<p>Just to be super clear on what you mean, when you say a <code>proof</code> you mean an element <code>u:P</code> where <code>P:Prop</code>?</p>



<a name="312262922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312262922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312262922">(Nov 25 2022 at 22:07)</a>:</h4>
<p>Yes, exactly</p>



<a name="312269808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312269808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312269808">(Nov 25 2022 at 23:37)</a>:</h4>
<p>Cool! It would be a really fantastic step to get Lean to the point where it does not compute these proofs. If that invariant can be imposed, it will make a lot of other things easier to do :)</p>



<a name="312277145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312277145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312277145">(Nov 26 2022 at 00:20)</a>:</h4>
<p>It was definitely my understanding that this was the intent behind <a href="https://github.com/leanprover-community/lean/pull/568">lean#568</a>.</p>



<a name="312277280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312277280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312277280">(Nov 26 2022 at 00:24)</a>:</h4>
<p>Incidentally, this discussion came up in this week's lean 4 dev meeting (maybe <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> was reading your tweets?) and while there are a few hurdles to getting these issues fixed, I don't think we're really against it. The change to <code>quot</code> seems like the easy part, it would need to be tested / backported on mathlib3 first (that is, changing the type of <code>quot</code> from <code>Sort u -&gt; Sort u</code> to <code>Sort u -&gt; Sort (max 1 u)</code>) but I anticipate ~no breakage.</p>



<a name="312277995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312277995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312277995">(Nov 26 2022 at 00:34)</a>:</h4>
<p>The change to <code>acc</code> is quite a bit more invasive and it's not clear what approach would be best:</p>
<ol>
<li>Make <code>acc</code> live in <code>Type u</code>; then <code>well_founded</code> is also a <code>Type u</code> and we would often want to use noncomputable stuff to prove it. This would still result in unpredictable computation of well-founded definitions.</li>
<li>Make <code>acc</code> not do reduction of proofs, as in <a href="https://github.com/leanprover-community/lean/pull/568">lean#568</a>. This makes well-founded definitions <em>almost</em> never compute, and this is what is currently used by mathlib3. It's still not quite as strong as <span class="user-mention" data-user-id="110032">@Reid Barton</span> 's plan, since it would still reduce <code>acc.rec_on ... (acc.intro ..)</code>.</li>
<li>Make <code>acc</code> never reduce. This would make well-founded definitions never compute, and matches Reid's plan.</li>
</ol>
<p>I think that no matter what, we would want some tactic or mechanism for evaluating well founded definitions. I think that this is a major missing piece in lean's tactic story.</p>



<a name="312278008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312278008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312278008">(Nov 26 2022 at 00:35)</a>:</h4>
<p><span class="user-mention" data-user-id="261512">@Jonathan Sterling</span></p>



<a name="312281321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312281321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312281321">(Nov 26 2022 at 01:29)</a>:</h4>
<p>I'm really excited to here there is interest and internal discussion!! I agree with you that figuring out the right thing to do with <code>acc</code> is a bit tricky. Just to clarify, the three options you describe are OK, but the option I suggested is different — my proposal will allow wf-definitions to compute definitionally, without having any of the downsides. But my proposal is much harder to implement than any of your three, so I think it would be a good idea to start where you're at and see if one of those can work out well for Lean and its existing codebase.</p>



<a name="312281382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312281382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312281382">(Nov 26 2022 at 01:30)</a>:</h4>
<p>I agree that having some kind of tactic mechanism to evaluate wf definitions should be a priority :)</p>



<a name="312283657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312283657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312283657">(Nov 26 2022 at 02:07)</a>:</h4>
<p>I'm not an expert in type theory, but I did once investigate into some issues around <a href="https://leanprover-community.github.io/mathlib_docs/find/acc">docs#acc</a> and dig up some <a href="#narrow/stream/113489-new-members/topic/Computation.20with.20dfinsupp.20and.20multisets/near/298049059">old PR/issues</a> from the early days of Lean 3.</p>



<a name="312283872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312283872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312283872">(Nov 26 2022 at 02:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312212167">said</a>:</p>
<blockquote>
<p>Things that clearly happen sometimes is cases where you build a proof using tactics, the proof is really quick, but then the proof checking by the kernel is really slow (but terminates eventually). Say 0.5s for proof building, 10s for proof checking.</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312224138">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312216549">said</a>:</p>
<blockquote>
<p>I'm not sure whether this sort of issue falls under the "subject reduction" style stuff, but there is often cases where a proof term doesn't work, but writing <code>by exact _</code> for the exact same proof term does.</p>
</blockquote>
<p>... the <code>by exact</code> trick tells the elaborator to postpone its work on some parts of the expression that might get stuck, and first process some other subexpressions that cause the <code>by exact</code>ed expression to become unstuck.</p>
</blockquote>
<p>I've also once observed that adding <code>by apply</code> could sometimes speed up elaboration (not kernel checking) significantly in <a href="https://github.com/leanprover-community/mathlib/pull/14967">#14967</a></p>



<a name="312286132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312286132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312286132">(Nov 26 2022 at 02:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="261512">Jonathan Sterling</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312281321">said</a>:</p>
<blockquote>
<p>I'm really excited to here there is interest and internal discussion!! I agree with you that figuring out the right thing to do with <code>acc</code> is a bit tricky. Just to clarify, the three options you describe are OK, but the option I suggested is different — my proposal will allow wf-definitions to compute definitionally, without having any of the downsides afaict (though personally I am not so sure that definitional computation with well-founded definitions is always desirable — it can sometimes be a bit hard to control). But my proposal is much harder to implement than any of your three, so I think it would be a good idea to start where you're at and see if one of those can work out well for Lean and its existing codebase.</p>
</blockquote>
<p>To be clear, I don't actually know what you specifically have in mind here. You have only hinted that there is a better way here and in your twitter thread, and without the details it is hard to assess what the fallout is.</p>
<p>But more importantly, this issue is decidedly low priority, and people making noise about it can actually be harmful especially considering how much it is a non-issue in practice. I think it is great if people investigate potential solutions, if you would like to work on it or find someone else to work on it, but this is definitely a "merely theoretical" problem for we have long since come up with good enough workarounds so that we can move on to more pressing things.</p>



<a name="312286617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312286617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312286617">(Nov 26 2022 at 02:56)</a>:</h4>
<blockquote>
<p>my proposal will allow wf-definitions to compute definitionally, without having any of the downsides afaict</p>
</blockquote>
<p>By the way, this already sounds impossible given the results of my thesis. Because you can construct a wf-definition whose definitional computation simulates a turing machine. You have to break at least the type of <code>acc.rec</code> or proof irrelevance or the iota rule for some inductives and all of those options would have some real-world consequences</p>



<a name="312297893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312297893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312297893">(Nov 26 2022 at 06:16)</a>:</h4>
<p>I also didn't understand from the paper what the plan would be to replace definitions by wf recursion with.</p>



<a name="312467858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312467858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312467858">(Nov 27 2022 at 13:13)</a>:</h4>
<p>I do find it annoying in Lean4 when a definition using pattern matching that is compiled to something with <code>well_founded</code> doesn't reduce. I think it would make sense for these automatically generated well founded proofs to use a <code>Type</code> version of <code>Acc</code> so that they do unfold. I don't think these automatically generated proofs use any axioms.</p>



<a name="312473555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312473555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312473555">(Nov 27 2022 at 13:59)</a>:</h4>
<p>No axioms probably, but they do case on predicates such as <code>prod.lex</code> that do not eliminate into <code>Type</code>. So either you need to lift them into <code>Type</code> as well or add some other sufficient side condition such as decidable equality on the type of the first element in order to fix <code>acc</code> instances.</p>



<a name="312477057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312477057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312477057">(Nov 27 2022 at 14:27)</a>:</h4>
<p>They also use a lot of arithmetic theorems on nat, because of <code>simp_arith</code> or its lean 3 approximation for reasoning about <code>SizeOf</code> expressions. IIRC these theorems do use <code>propext</code> in lean 3</p>



<a name="312478318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312478318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312478318">(Nov 27 2022 at 14:38)</a>:</h4>
<p>Will using <code>propext</code> be a problem? The natural number lemmas will mainly be used for proving inequalities, not accessibility of a relation right? So it should be okay?</p>



<a name="312478648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312478648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312478648">(Nov 27 2022 at 14:40)</a>:</h4>
<p>Yes, <code>propext</code> will block computation if you require that the proof be reducible to an <code>acc.intro</code> constructor application</p>



<a name="312478910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312478910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312478910">(Nov 27 2022 at 14:43)</a>:</h4>
<p>and <code>propext</code> gets pulled in to all sorts of theorems because of <code>simp</code> and <code>rw</code></p>



<a name="312478985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312478985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312478985">(Nov 27 2022 at 14:43)</a>:</h4>
<p>I don't think it would be a good thing for the library if we have to work under the constraint of no <code>propext</code></p>



<a name="312479077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312479077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312479077">(Nov 27 2022 at 14:44)</a>:</h4>
<p>I would much rather set things up so that <em>all</em> well founded functions can compute in some sense, even if not by defeq</p>



<a name="312493389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312493389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312493389">(Nov 27 2022 at 16:46)</a>:</h4>
<p>I definitely agree we need well-founded stuff to compute somehow. There're two separate problems here, closed terms and non-closed terms. </p>
<p>I'd like closed terms to compute regardless of axioms in the proof</p>
<p>For non-closed terms there is always going to be a problem about how far to unfold, so we can't have nice behaviour on non-closed terms except in certain cases, and I think a reasonable expectation is that things defined using pattern matching should unfold in the expected way</p>



<a name="312613791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312613791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312613791">(Nov 28 2022 at 12:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312479077">said</a>:</p>
<blockquote>
<p>I would much rather set things up so that <em>all</em> well founded functions can compute in some sense, even if not by defeq</p>
</blockquote>
<p>I think I might come in and defend def-eq here. def-eq has the advantage that you don't need to use casts. I think that this is not a major difference for the sorts of things that we do in mathlib, but we really don't use any inductive types more complicated than a <code>list</code>. I'm surrounded by people trying to do compiler related things in Lean, and Lean has some shortcomings here compared with Coq, and I wouldn't be at all surprised if well-founded definitions not unfolding by def-eq caused someone a major headache somewhere.</p>



<a name="312616095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312616095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312616095">(Nov 28 2022 at 12:26)</a>:</h4>
<p><code>acc</code>-in-<code>Type</code> doesn't require any special support does it? Aside from in the equation compiler I suppose.</p>



<a name="312616729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312616729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312616729">(Nov 28 2022 at 12:30)</a>:</h4>
<p>I guess I'm not really sure what path you're advocating for here</p>



<a name="312620135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312620135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312620135">(Nov 28 2022 at 12:49)</a>:</h4>
<p>I'm advocating for using <code>acc</code> in <code>Type</code> for automatically generated well foundedness proofs that could presumably be done quite easily without axioms. Stuff like this is compiled to <code>WellFounded.fix</code> in Lean4 currently, and presumably it doesn't need axioms to prove this even if it does use them. Hopefully both the theorems below should be provable with <code>rfl</code> at some point, but not currently.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">T</span>

<span class="kn">open</span> <span class="n">T</span>

<span class="kd">def</span> <span class="n">thing</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">T</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">_</span> <span class="o">::</span> <span class="n">ns</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">thing</span> <span class="o">(</span><span class="n">mk</span> <span class="n">ns</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">ns</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">thing</span> <span class="o">(</span><span class="n">mk</span> <span class="o">(</span><span class="n">n</span> <span class="o">::</span> <span class="n">ns</span><span class="o">))</span> <span class="bp">=</span> <span class="n">thing</span> <span class="o">(</span><span class="n">mk</span> <span class="n">ns</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--fails</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">thing</span> <span class="o">(</span><span class="n">mk</span> <span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="bp">=</span> <span class="n">mk</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--fails</span>
</code></pre></div>



<a name="312634966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312634966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312634966">(Nov 28 2022 at 14:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312286132">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="261512">Jonathan Sterling</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312281321">said</a>:</p>
<blockquote>
<p>I'm really excited to here there is interest and internal discussion!! I agree with you that figuring out the right thing to do with <code>acc</code> is a bit tricky. Just to clarify, the three options you describe are OK, but the option I suggested is different — my proposal will allow wf-definitions to compute definitionally, without having any of the downsides afaict (though personally I am not so sure that definitional computation with well-founded definitions is always desirable — it can sometimes be a bit hard to control). But my proposal is much harder to implement than any of your three, so I think it would be a good idea to start where you're at and see if one of those can work out well for Lean and its existing codebase.</p>
</blockquote>
<p>To be clear, I don't actually know what you specifically have in mind here. You have only hinted that there is a better way here and in your twitter thread, and without the details it is hard to assess what the fallout is.</p>
<p>But more importantly, this issue is decidedly low priority, and people making noise about it can actually be harmful especially considering how much it is a non-issue in practice. I think it is great if people investigate potential solutions, if you would like to work on it or find someone else to work on it, but this is definitely a "merely theoretical" problem for we have long since come up with good enough workarounds so that we can move on to more pressing things.</p>
</blockquote>
<p>Re: "people making noise about it can actually be harmful ", to be very clear, I would have been totally silent about it if I had not seen several unprovoked rants about it by Kevin Buzzard in the past year pushing disinformation about the issue. So if you are looking to keep the issue quiet, I would certainly recommend that you look to your camp first before coming after outsiders who are trying to correct the record. As I've said many times, we don't have any problem with you choosing that this is not a priority. We do have problems with repeated statements that spread disinformation on a subtle topic that concerns us. It is telling that people in this thread are saying things like "it's a non-issue, I've never encountered it" or whatever, but then admit that they actually have no idea what the consequences of it are, and admitting "oh yeah, that's probably happened" when I explain what the consequences are.</p>
<p>Regarding your thesis, the thing I describe is NOT impossible and it is not contradicted by your thesis. What is true is that you cannot use inductively defined accessibility predicates anymore; these can be replaced, however, with recursively defined ones. This is detailed in the paper I linked earlier in the thread. It is still unclear what the fallout is, which is why I did not advocate you to just blindly jump into it, and favored the more conservative ideas expressed in this thread by others (like Reid's comments on deleting some problematic rules, at the expense of some computation --- which sounded reasonable to me).</p>



<a name="312635083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312635083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312635083">(Nov 28 2022 at 14:05)</a>:</h4>
<p>So my first suggestion would be to (1) stop spreading disinformation, and/or (2) start communicating with the team who wrote that paper. It's ok if this isn't a priority, but you must silence those who are spreading disinformation if you don't want it to come back to you.</p>



<a name="312636751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312636751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312636751">(Nov 28 2022 at 14:12)</a>:</h4>
<p>Well, that escalated quickly.</p>



<a name="312637054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312637054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312637054">(Nov 28 2022 at 14:13)</a>:</h4>
<p>I apologize if I have ruined this thread, I felt that there was a lot of very productive discourse in it so far. I was reacting to Mario characterizing my intervention as "harmful", when I feel the harm began when disinformation was allowed to go out unchallenged. I have always felt that Mario's interventions in the past were of a very positive nature, as his writings clarified many of the underlying issues; my own comments were essentially based on Mario's.</p>
<p>I hope we can work collaboratively to a better mutual understanding of these issues, informed by the goals of the Lean project (which I certainly am not in a place to dictate, nor would I even advise paying too much attention to these metatheoretic issues when you've got more fun stuff to do).</p>



<a name="312638650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312638650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312638650">(Nov 28 2022 at 14:21)</a>:</h4>
<p>As for disinformation, which I may have spread, I’m not clear on the very simple question: does the current breakage of subject reduction effect Lean users?  I’ve heard two conflicting things: (1) the only way to encounter this issue is to come up with a contrived example using something like <code>acc</code> and this just doesn’t occur in practice.   (2) That it does occur in practice occasionally and when it does, people find workarounds, possibly painfully.</p>
<p>I think it is clear that not everything that should be defeq the kernel can compute in a reasonable time, but it is hard to know if it is because of SR/transitivity or just a slow kernel.  (Mario also points out that if a=b and b=c are defeq and fast to compute, it may be that a=c maybe be really slow to compute and will timeout.  I assume fixing transitivity and SR won’t fix this, right?)</p>



<a name="312639649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312639649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312639649">(Nov 28 2022 at 14:25)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="115715">@Jason Rute</span> for bringing us back onto track :)  I think (2) is probably the case (based on the conversations I've had with Lean users both here and elsewhere), but I would guess that the workaround are not too painful in most cases --- if they were very painful (rather than more like a little ant-bite, which is what I think they are like), we would probably be hearing more about it. So based on this, my estimation is that it might not be worthwhile to try and fix this, but it also would not be the hardest thing in the world to fix it. It is certainly not the case, as I have demonstrated, that fixing it would contradict the goals of Lean to have quotient types and proof irrelevance. It might contradict the goals of "not wasting time on stuff that doesn't matter too much", which I totally respect ;-)</p>
<p>Regarding your second paragraph, that is an excellent point, and it is indeed the case that whether "fast conversions" are closed under composition is orthogonal to the question of whether conversions in general are closed under composition. If the issues under discussion were fixed, it would still be the case that there are some things that fast when broken up into steps, but slow when composed --- and I think it is unclear whether that could ever be fixed, but it would certainly be a very deep and hard research question for someone to investigate.</p>



<a name="312640006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312640006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312640006">(Nov 28 2022 at 14:27)</a>:</h4>
<p>By the way, here is the previous discussion on subject reduction: <a class="stream-topic" data-stream-id="113488" href="/#narrow/stream/113488-general/topic/What.20is.20the.20subject.20reduction.20debate.3F">#general &gt; What is the subject reduction debate?</a></p>



<a name="312640571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312640571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312640571">(Nov 28 2022 at 14:29)</a>:</h4>
<p>Also, here is a stack exchange question on the matter.  I tried to give what I felt at the time was my best answer given what I knew.  Anyone is free to correct the record by adding their own answer, commenting on mine, or persuading me to edit (or delete) my answer: <a href="https://proofassistants.stackexchange.com/a/1194/122">https://proofassistants.stackexchange.com/a/1194/122</a></p>



<a name="312641459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312641459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312641459">(Nov 28 2022 at 14:33)</a>:</h4>
<p>I thought your PA.SE answer was mostly fine (for instance, your operative comment about syntactic subsingleton elimination for <code>acc</code> is correct!), with the caveat that the failure of a particular normalization algorithm does not imply that you cannot have a computational model --- as you know, your VM provides a computational model of some sort, and we can also do similar things on the mathematical side.</p>



<a name="312642165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312642165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312642165">(Nov 28 2022 at 14:36)</a>:</h4>
<p>P.S. In case it did not come out in this thread, I want to say that I have so much admiration for Lean and especially the very innovative things happening in Lean 4. I can't believe my eyes when I see the macro tooling, custom elaboration, and editor integration, just to give a couple examples...</p>
<p>I have long felt that there was so much amazing and exciting work happening in Lean that there was no need for boosters of Lean to try and argue "against" other tools, or (much more bafflingly), "against" the idea of informing implementation through type theory (which I observed in the discussion of subject reduction, rhetorically transforming trade-offs that are really about time/effort into (non-)trade-offs that purport to be about theory/practice). The work speaks for itself, and it's amazing.</p>



<a name="312664066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312664066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312664066">(Nov 28 2022 at 16:14)</a>:</h4>
<p><span class="user-mention" data-user-id="261512">@Jonathan Sterling</span> I understand how you can translate some inductive predicates into recursive ones, but to do this for <code>acc</code> itself seems to invoke a regress because the recursion needs to be well founded somehow. Can you give a concrete example?</p>



<a name="312669607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312669607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312669607">(Nov 28 2022 at 16:39)</a>:</h4>
<p>Thanks for your question, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>. I will think about it, and also double-check that I have not made a mistake. I believe the general form of <code>acc</code> is not translatable in this sense, but that many common instances well-founded recursion (that would arise from defining recursive functions in practice) would be — of which the account of <code>le (S m) n</code> is the prototype. I'm sorry for adding to the confusion by making it sound like you could do this in general as opposed to case-by-case.</p>



<a name="312671421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312671421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312671421">(Nov 28 2022 at 16:48)</a>:</h4>
<p>So part of the 'fallout' that would have  to be investigated is to see how such a constraint really affects the existing library code.</p>



<a name="312672992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312672992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312672992">(Nov 28 2022 at 16:55)</a>:</h4>
<p>I think that ultimately the idea of <span class="user-mention" data-user-id="110044">@Chris Hughes</span> in this thread is probably the most broadly applicable and practical one.</p>



<a name="312674807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312674807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312674807">(Nov 28 2022 at 17:02)</a>:</h4>
<p>Zooming out, if the general accessibility predicate is <code>Type</code>-valued, we still do not lose too much. There will be many cases (especially in the case of lexicographic induction) where a <code>Prop</code>-valued one can be defined, and you will obtain some additional definitional equalities in that case, but I am very doubtful that a <code>Type</code>-valued <code>acc R</code> predicate would be worse to use in practice than what is currently there. The VM can still be instrumented to erase it, if you want — there is a lot of literature on analyses that can automatically erase such things that I could suggest, but it is reasonable to just special-case it at first.</p>



<a name="312685291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312685291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312685291">(Nov 28 2022 at 17:47)</a>:</h4>
<p>Erasure at least is not a problem because we send the version of the definition <em>before</em> eliminating syntactic recursion to the code generator</p>



<a name="312686050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312686050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jonathan Sterling <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312686050">(Nov 28 2022 at 17:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110024">Sebastian Ullrich</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312685291">said</a>:</p>
<blockquote>
<p>Erasure at least is not a problem because we send the version of the definition <em>before</em> eliminating syntactic recursion to the code generator</p>
</blockquote>
<p>very smart idea!</p>



<a name="312860556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312860556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312860556">(Nov 29 2022 at 14:54)</a>:</h4>
<p>I am sorry to have arrived late to this party. I have been trying to catch up on the discussion and read enough of the Gilbert et al. paper to at least have a general sense of what is being proposed. That paper describes an extension to MLTT (as well as an impredicative version thereof), and then proofs of consistency relative to ETT (resp. Voevodsky's resizing axioms). How does this translate to Lean?</p>
<p>My understanding is that the idea is to eliminate some of the problematic features of Lean's foundation (an elimination principle from Prop to type or definitional proof irrelevance or maybe both?), and then do something to patch the places in the library where these are currently used. What's not clear to me is whether this involves adding something new. In other words, it is not clear to me whether the proposal is to weaken Lean's type theory (by ruling out things that were allowed before) or modify it (by also allowing other things that were not allowed before or not there before). <span class="user-mention" data-user-id="261512">@Jonathan Sterling</span> I'd be curious to see a sketch of the proposal, even if the details aren't fully worked out.</p>
<p>By the way, long ago, when Leo was first working out the mechanisms for handling well-founded recursion in Lean, he also experimented with putting <code>acc R</code> in Type. He characterized this as providing the recursive function with "fuel" to carry out the computation. My vague memory is that there were problems with that beyond merely adding irrelevant data to a computation, but I don't remember the details and I may be misremembering entirely. I'd be happy to see a solution like that if it could be made to work, if there are clear principles that dictate what is really computationally relevant and what can be erased in code extraction.</p>



<a name="312892904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312892904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312892904">(Nov 29 2022 at 17:20)</a>:</h4>
<p>I did a bit of an experiment with the <code>Acc</code> in type idea. The code is <a href="https://gist.github.com/ChrisHughes24/eb4689e7cdda8f1f58e9968438597452">here</a>. It's not as good as it seems. The expected equalities are not definitional. Maybe by very carefully defining the proof that <code>lt</code> is well_founded on the natural numbers they could be made to be definitional. Probably it would require a carefully defined <code>lt</code> in Type with carefully written proofs of <code>n &lt; n + 1</code> etc to get the desired definitional equalities.</p>



<a name="312893041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312893041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312893041">(Nov 29 2022 at 17:21)</a>:</h4>
<p>To be clear, the equality <code>fib (n+2) = fin n + fib (n+1)</code> is not definitional in my code.</p>



<a name="312893150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312893150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312893150">(Nov 29 2022 at 17:21)</a>:</h4>
<p>Of course, this will still all compute on closed terms.</p>



<a name="312897641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312897641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312897641">(Nov 29 2022 at 17:42)</a>:</h4>
<p>I feel like it's unreasonable to expect that definitional equality but I don't know exactly why. Does it work in Coq?</p>



<a name="312912714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312912714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312912714">(Nov 29 2022 at 18:57)</a>:</h4>
<p>Chris, thanks for working that out!</p>
<p>Isn't this whole discussion about definitional equality? If we don't care about that, we can use any definitions that work, even nonconstructive ones, and we can tune code extraction to do whatever we want it to do. That is Isabelle's approach:<br>
<a href="https://isabelle.in.tum.de/dist/Isabelle2022/doc/functions.pdf">https://isabelle.in.tum.de/dist/Isabelle2022/doc/functions.pdf</a><br>
<a href="https://isabelle.in.tum.de/dist/Isabelle2022/doc/corec.pdf">https://isabelle.in.tum.de/dist/Isabelle2022/doc/corec.pdf</a><br>
The underlying definitions of the functions are arbitrary (as long as they satisfy the defining equations), and there is no concern with matching them up with any built-in notion of computation in the type theory.</p>



<a name="312914144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312914144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312914144">(Nov 29 2022 at 19:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312897641">said</a>:</p>
<blockquote>
<p>I feel like it's unreasonable to expect that definitional equality but I don't know exactly why. Does it work in Coq?</p>
</blockquote>
<p>I think it gets stuck on a <code>if n + 0 = n + 1 then _ else _</code></p>



<a name="312916342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/312916342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312916342">(Nov 29 2022 at 19:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110865">Jeremy Avigad</span> <a href="#narrow/stream/113488-general/topic/subject.20reduction/near/312912714">said</a>:</p>
<blockquote>
<p>Chris, thanks for working that out!</p>
<p>Isn't this whole discussion about definitional equality? If we don't care about that, we can use any definitions that work, even nonconstructive ones, and we can tune code extraction to do whatever we want it to do. That is Isabelle's approach:<br>
<a href="https://isabelle.in.tum.de/dist/Isabelle2022/doc/functions.pdf">https://isabelle.in.tum.de/dist/Isabelle2022/doc/functions.pdf</a><br>
<a href="https://isabelle.in.tum.de/dist/Isabelle2022/doc/corec.pdf">https://isabelle.in.tum.de/dist/Isabelle2022/doc/corec.pdf</a><br>
The underlying definitions of the functions are arbitrary (as long as they satisfy the defining equations), and there is no concern with matching them up with any built-in notion of computation in the type theory.</p>
</blockquote>
<p>I think some people do care about definitional equality, even if those people aren't mathlib contributors. It came up in a toy project. I had where I wanted these things to be definitional equalities because I was using dependent types and didn't want to use casts.</p>



<a name="316196662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/subject%20reduction/near/316196662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#316196662">(Dec 16 2022 at 06:38)</a>:</h4>
<p>This paper seems to be related: <a href="https://hal.archives-ouvertes.fr/hal-03857705v2">https://hal.archives-ouvertes.fr/hal-03857705v2</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
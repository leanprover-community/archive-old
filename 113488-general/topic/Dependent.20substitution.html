---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Dependent.20substitution.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html">Dependent substitution</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="277405391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277405391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277405391">(Apr 01 2022 at 11:56)</a>:</h4>
<p>How to deal with this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">constant</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span>
<span class="kd">constant</span> <span class="n">init</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="kd">constant</span> <span class="n">V</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">V</span> <span class="n">n</span>
<span class="kd">constant</span> <span class="n">ma</span> <span class="o">:</span> <span class="n">V</span> <span class="o">(</span><span class="n">init</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">example</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">V</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">init</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">init</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ma</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp_rw</span> <span class="n">H</span><span class="o">,</span> <span class="c1">-- fails</span>
  <span class="n">subst</span> <span class="n">H</span><span class="o">,</span>   <span class="c1">-- fails</span>
  <span class="n">cases</span> <span class="n">H</span><span class="o">,</span>   <span class="c1">-- fails</span>
<span class="kd">end</span>
</code></pre></div>



<a name="277405749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277405749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277405749">(Apr 01 2022 at 11:59)</a>:</h4>
<p>the theorem isn't provable?</p>



<a name="277405755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277405755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277405755">(Apr 01 2022 at 11:59)</a>:</h4>
<p>What do you want your goal to be after any of these tactics?</p>



<a name="277406440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277406440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277406440">(Apr 01 2022 at 12:05)</a>:</h4>
<p>Here is to prove it. You want to generalize one of the sides of the equality <code>H</code> to be a fresh variable, so you can substitute/case it away.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">V</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="n">init</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">init</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ma</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n'</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">V</span> <span class="n">n'</span><span class="o">),</span> <span class="n">f</span> <span class="n">n'</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="n">init</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n'</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">init</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ma</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n'</span> <span class="n">h'</span> <span class="n">H'</span><span class="o">,</span> <span class="n">subst</span> <span class="n">H'</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h'</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">this</span> <span class="n">h</span> <span class="n">H</span>
<span class="kd">end</span>
</code></pre></div>



<a name="277407966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277407966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277407966">(Apr 01 2022 at 12:18)</a>:</h4>
<p>Thanks, it works. But I'm wondering can simp_rw be improved to handle such situations?<br>
I was expecting to have goal <code>f n = H.rec ma</code> after simp_rw.</p>



<a name="277419636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277419636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277419636">(Apr 01 2022 at 13:43)</a>:</h4>
<p>I ran into something similar with <code>cons_induction_cons</code> <a href="https://github.com/leanprover-community/mathlib/pull/13027">#13027</a>. It would be nice if <code>generalize</code> could help</p>



<a name="277424480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277424480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277424480">(Apr 01 2022 at 14:15)</a>:</h4>
<p>here's a proof that doesn't require stating the induction hypothesis:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">V</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">init</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">init</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ma</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">generalize</span> <span class="o">:</span> <span class="n">ma</span> <span class="bp">=</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span>
<span class="kd">end</span>
</code></pre></div>



<a name="277445276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277445276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277445276">(Apr 01 2022 at 16:37)</a>:</h4>
<p>Does something similar work for my cons proof?</p>



<a name="277459639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277459639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277459639">(Apr 01 2022 at 18:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> That works only in this contrived example, because <code>h</code> is universally quantified over <code>V n</code> and doesn't need any properties of <code>ma</code>. In my actual context, it cannot be applied. Floris van Doorn's solution cannot be applied either. Here is a very simplified and minimized example obtained from my actual lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic.induction</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">constant</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">constant</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">structure</span> <span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">list</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">A</span>
<span class="kd">def</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">option</span> <span class="n">A</span>
<span class="kd">def</span> <span class="n">f₁</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">true</span>
<span class="kd">structure</span> <span class="n">F</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">true</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">G</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">true</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">f₂</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="k">with</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">s.b</span> <span class="bp">++</span> <span class="o">[</span><span class="n">s.a</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">constant</span> <span class="n">H</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">B</span>
<span class="kd">def</span> <span class="n">f₃</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">f₂</span> <span class="n">s</span> <span class="o">(</span><span class="n">H</span> <span class="n">s</span> <span class="n">m</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">I</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="n">s.c</span> <span class="bp">→</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">y</span> <span class="n">s.a</span><span class="o">)</span>
<span class="kd">structure</span> <span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="n">s.c</span> <span class="bp">→</span> <span class="n">G</span> <span class="n">s.a</span><span class="o">)</span>
<span class="kd">constant</span> <span class="n">I.x</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">I</span> <span class="n">y</span>
<span class="kd">constant</span> <span class="n">I.f₄</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">I</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">ma</span> <span class="o">:</span> <span class="n">F</span> <span class="n">y</span> <span class="n">s.a</span><span class="o">)</span> <span class="o">:</span> <span class="n">I</span> <span class="n">y</span>
<span class="kd">@[ext]</span> <span class="kd">structure</span> <span class="n">K</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">I</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">m</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">K.mk</span>
<span class="kd">def</span> <span class="n">K.f₅</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">K</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">s₁</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">K</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">{</span><span class="n">g</span> <span class="k">with</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">s₁</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">f₆</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">K</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">g.f₅</span> <span class="o">(</span><span class="n">f₃</span> <span class="n">g.s</span> <span class="o">(</span><span class="n">g.d.f</span> <span class="n">g.s</span> <span class="n">hs</span><span class="o">)</span><span class="bp">.</span><span class="n">m</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">s'</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">{</span><span class="n">md</span> <span class="o">:</span> <span class="n">G</span> <span class="n">s.a</span><span class="o">}</span> <span class="o">{</span><span class="n">ma</span> <span class="o">:</span> <span class="n">F</span> <span class="n">y</span> <span class="n">s'.a</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.c</span><span class="o">)</span> <span class="o">(</span><span class="n">hs₁</span> <span class="o">:</span> <span class="n">s'.c</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">J</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">f₁</span> <span class="n">y</span> <span class="n">s'.a</span><span class="o">)</span> <span class="o">:</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">:</span> <span class="n">I</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">I.x</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">f₄</span> <span class="n">s'</span> <span class="n">ma</span>
  <span class="k">in</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">f₁</span> <span class="n">y</span> <span class="o">(</span><span class="n">f₆</span> <span class="o">(</span><span class="n">m</span> <span class="n">a</span> <span class="n">d</span> <span class="n">s</span><span class="o">)</span> <span class="n">hs</span><span class="o">)</span><span class="bp">.</span><span class="n">s.a</span><span class="o">),</span> <span class="o">(</span><span class="n">f₆</span> <span class="o">(</span><span class="n">m</span> <span class="n">a</span> <span class="n">d</span> <span class="n">s</span><span class="o">)</span> <span class="n">hs</span><span class="o">)</span><span class="bp">.</span><span class="n">s</span> <span class="bp">=</span> <span class="n">s'</span> <span class="bp">→</span>
  <span class="o">(</span><span class="n">a.f</span> <span class="o">(</span><span class="n">f₆</span> <span class="o">(</span><span class="n">m</span> <span class="n">a</span> <span class="n">d</span> <span class="n">s</span><span class="o">)</span> <span class="n">hs</span><span class="o">)</span><span class="bp">.</span><span class="n">s</span> <span class="n">hs</span> <span class="n">h₂</span><span class="o">)</span><span class="bp">.</span><span class="n">m</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a.f</span> <span class="n">s'</span> <span class="n">hs₁</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">m</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">a</span> <span class="n">h₂</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="n">h₁</span><span class="o">,</span> <span class="c1">-- fails</span>
<span class="kd">end</span>
</code></pre></div>
<p>We don't need to look at all those definitions. All we can observe is that we have hypothesis <code>h₁</code> and the goal would be refl after rewriting <code>h₁</code>. I don't really see what to generalize in order to close this goal...?</p>



<a name="277461017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277461017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277461017">(Apr 01 2022 at 18:30)</a>:</h4>
<p>kind of messy, but <code>congr, exact h₁, exact h₁, apply proof_irrel_heq,</code> works</p>



<a name="277461096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277461096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277461096">(Apr 01 2022 at 18:31)</a>:</h4>
<p>or just <code>congr'</code></p>



<a name="277519000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277519000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277519000">(Apr 02 2022 at 09:43)</a>:</h4>
<p>This is the shortest proof I can get (for the first example). We don't need to generalize anything.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">V</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">init</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">init</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ma</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">heq_of_eq_rec_left</span> <span class="n">H</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="277544446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277544446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277544446">(Apr 02 2022 at 18:34)</a>:</h4>
<p><span class="user-mention" data-user-id="456794">@Patrick Johnson</span> Here's another proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">V</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">init</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">init</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ma</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">H</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="n">ma</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="277702073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277702073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277702073">(Apr 04 2022 at 09:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Dependent.20substitution/near/277419636">said</a>:</p>
<blockquote>
<p>I ran into something similar with <code>cons_induction_cons</code> <a href="https://github.com/leanprover-community/mathlib/pull/13027">#13027</a>. It would be nice if <code>generalize</code> could help</p>
</blockquote>
<p>Here's a mwe of this proof, in case anyone feels like being sniped by it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fin.tuple</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kn">open</span> <span class="n">fin</span>

<span class="sd">/-- Recurse on an `n+1`-tuple by splitting it into a single element and an `n`-tuple. -/</span>
<span class="kd">@[elab_as_eliminator]</span>
<span class="kd">def</span> <span class="n">cons_induction</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x₀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">fin.cons</span> <span class="n">x₀</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">_root_.cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">cons_self_tail</span><span class="o">)</span> <span class="bp">$</span> <span class="n">h</span> <span class="o">(</span><span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">tail</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">cons_induction_cons</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x₀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">fin.cons</span> <span class="n">x₀</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">x₀</span> <span class="o">:</span> <span class="n">α</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">α</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">cons_induction</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x₀</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h</span> <span class="n">x₀</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">x₀</span> <span class="n">x</span><span class="o">),</span> <span class="n">_root_.cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">hy</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">cons_induction</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h</span> <span class="n">x₀</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">convert</span> <span class="n">this</span> <span class="n">_</span> <span class="n">rfl</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="n">y</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">dunfold</span> <span class="n">cons_induction</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="n">cast_cast</span><span class="o">,</span> <span class="n">cast_eq</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">tail_cons</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="277769441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277769441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277769441">(Apr 04 2022 at 17:50)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">cons_induction_cons</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n.succ</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x₀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="o">(</span><span class="n">fin.cons</span> <span class="n">x₀</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">x₀</span> <span class="o">:</span> <span class="n">α</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">α</span> <span class="n">i.succ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">cons_induction</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x₀</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">h</span> <span class="n">x₀</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">cons_induction</span><span class="o">,</span> <span class="n">cast_eq</span><span class="o">],</span>
  <span class="n">congr'</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">tail_cons</span> <span class="n">_</span> <span class="n">_</span>
<span class="kd">end</span>
</code></pre></div>



<a name="277769883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277769883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277769883">(Apr 04 2022 at 17:53)</a>:</h4>
<p>do we have a dependent <code>congr_arg(₂)</code>? I think this is the correct glue, this <code>congr</code> does some crazy <code>eq.rec</code>s that I don't understand</p>



<a name="277770010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277770010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277770010">(Apr 04 2022 at 17:54)</a>:</h4>
<p>which makes sense, I guess, as that is what congr_arg basically is</p>



<a name="277770634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277770634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277770634">(Apr 04 2022 at 17:58)</a>:</h4>
<p>I feel like I'm understanding this a bit better; in some ways you want to <code>rw (h)eq.rec (h x_0 x) (tail_cons _ _)</code> but the elaborator is not going to be happy matching that</p>



<a name="277773318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277773318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277773318">(Apr 04 2022 at 18:16)</a>:</h4>
<p>I've been wanting <code>congr_arg₂</code>, <code>congr_fun₂</code> and <code>funext₂</code> recently. I was about to add them. What do people think?</p>



<a name="277773371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277773371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277773371">(Apr 04 2022 at 18:17)</a>:</h4>
<p>seems like a good idea to me!</p>



<a name="277775507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Dependent%20substitution/near/277775507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Dependent.20substitution.html#277775507">(Apr 04 2022 at 18:34)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="284160">@Eric Rodriguez</span>, I have no idea how I didn't find that; edited the PR to use your proof</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/another.20decidable_eq.20problem.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html">another decidable_eq problem</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222522835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222522835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222522835">(Jan 13 2021 at 01:58)</a>:</h4>
<p>Something is wrong with my definition of <code>orthonormal</code> here:  as evidence, note that if <code>orthonormal</code> is changed to <code>linear_independent</code> throughout, then there are no errors.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.inner_product</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="kn">open</span> <span class="n">finite_dimensional</span>

<span class="kd">variables</span> <span class="o">(</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">is_R_or_C</span> <span class="bp">𝕜</span><span class="o">]</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`⟪`</span><span class="n">x</span><span class="bp">`</span><span class="o">,</span> <span class="bp">`</span><span class="n">y</span><span class="bp">`⟫`</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">inner</span> <span class="bp">𝕜</span> <span class="n">_</span> <span class="n">_</span> <span class="n">x</span> <span class="n">y</span>

<span class="kd">def</span> <span class="n">orthonormal</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="bp">⟪</span><span class="n">v</span> <span class="n">i</span><span class="o">,</span> <span class="n">v</span> <span class="n">j</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="bp">𝕜</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="bp">𝕜</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">basis_constructor</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">ι</span><span class="o">]</span>
  <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">E</span><span class="o">}</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="n">orthonormal</span> <span class="bp">𝕜</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">card_eq</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">ι</span> <span class="bp">=</span> <span class="n">findim</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_basis</span> <span class="bp">𝕜</span> <span class="n">v</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">my_set</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">findim</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="bp">→</span> <span class="n">E</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">my_set_spec</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="n">orthonormal</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">my_set</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">findim</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">))</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">my_set</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">basis_constructor</span> <span class="bp">𝕜</span> <span class="o">(</span><span class="n">my_set_spec</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simp</span><span class="o">)</span> <span class="c1">-- error is here!</span>
</code></pre></div>



<a name="222522961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222522961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222522961">(Jan 13 2021 at 02:00)</a>:</h4>
<p>The error message is a beauty!</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>type mismatch at application
  basis_constructor 𝕜 (my_set_spec 𝕜 E)
term
  my_set_spec 𝕜 E
has type
 @orthonormal 𝕜 E _inst_1 _inst_2
    (fin
       (@findim 𝕜 E
          (@normed_field.to_field 𝕜 ... ***etc etc***
but is expected to have type ***etc etc***
 ```
</code></pre></div>



<a name="222523022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222523022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222523022">(Jan 13 2021 at 02:01)</a>:</h4>
<p>But run through diff-checker, the difference in terms is</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>classical.prop_decidable (a = b))
</code></pre></div>
<p>vs</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>@subtype.decidable_eq ℕ
  (λ (x : ℕ),
    x &lt;
      @findim 𝕜 E
        (@normed_field.to_field 𝕜
            (@nondiscrete_normed_field.to_normed_field 𝕜
              (@is_R_or_C.to_nondiscrete_normed_field 𝕜 _inst_1)))
        (@normed_group.to_add_comm_group E (@inner_product_space.to_normed_group 𝕜 E _inst_1 _inst_2))
        (@normed_space.to_semimodule 𝕜 E
            (@nondiscrete_normed_field.to_normed_field 𝕜
              (@is_R_or_C.to_nondiscrete_normed_field 𝕜 _inst_1))
            (@inner_product_space.to_normed_group 𝕜 E _inst_1 _inst_2)
            (@inner_product_space.to_normed_space 𝕜 E _inst_1 _inst_2)))
  (λ (a b : ℕ), nat.decidable_eq a b)
  a
  b)
</code></pre></div>



<a name="222526908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222526908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222526908">(Jan 13 2021 at 03:02)</a>:</h4>
<p>Maybe adding a <code>decidable_eq iota </code> argument to <code>basis_constructor</code> might help?</p>



<a name="222530112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222530112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222530112">(Jan 13 2021 at 03:57)</a>:</h4>
<p>I think I would have just given up with this <code>decidable_eq</code> stuff and gone with something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">orthonormal</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∥</span><span class="n">v</span> <span class="n">i</span><span class="bp">∥</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span> <span class="bp">≠</span> <span class="n">j</span> <span class="bp">→</span> <span class="bp">⟪</span><span class="n">v</span> <span class="n">i</span><span class="o">,</span> <span class="n">v</span> <span class="n">j</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>



<a name="222530950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222530950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222530950">(Jan 13 2021 at 04:10)</a>:</h4>
<p>Thanks both!  I really would like to get it working the "if then else" way.  It feels like whack-a-mole:  Chris' idea solves my toy example (posted here) but creates new problems in my real use case.  I have tried twice to get a useful <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>, without success, so let me just link the branch:<br>
<a href="https://github.com/leanprover-community/mathlib/compare/exists-orthonormal-basis">https://github.com/leanprover-community/mathlib/compare/exists-orthonormal-basis</a><br>
it would be great if someone has the energy to track down the issue.</p>



<a name="222531355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222531355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222531355">(Jan 13 2021 at 04:17)</a>:</h4>
<p>Is there any particular reason to use if-then-else if it creates this mess?</p>



<a name="222531439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222531439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222531439">(Jan 13 2021 at 04:18)</a>:</h4>
<p>Good question! ... it's just a hunch, but I suspect that arguments like the following will be cleaner:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- An orthonormal set is linearly independent. -/</span>
<span class="kd">lemma</span> <span class="n">linear_independent_of_orthonormal</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="n">orthonormal</span> <span class="bp">𝕜</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">linear_independent</span> <span class="bp">𝕜</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">linear_independent_iff</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">l</span> <span class="n">hl</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h_fun</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">j</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="bp">⟪</span><span class="n">v</span> <span class="n">i</span><span class="o">,</span> <span class="n">v</span> <span class="n">j</span><span class="bp">⟫</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">j</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="bp">𝕜</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="bp">𝕜</span><span class="o">)),</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">he</span> <span class="n">i</span> <span class="n">j</span><span class="o">]</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="bp">⟪</span><span class="n">v</span> <span class="n">i</span><span class="o">,</span> <span class="n">finsupp.total</span> <span class="n">ι</span> <span class="n">E</span> <span class="bp">𝕜</span> <span class="n">v</span> <span class="n">l</span><span class="bp">⟫</span> <span class="bp">=</span> <span class="bp">⟪</span><span class="n">v</span> <span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="bp">⟫</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">hl</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">finsupp.total_apply</span><span class="o">,</span> <span class="n">finsupp.inner_sum</span><span class="o">,</span> <span class="n">h_fun</span><span class="o">]</span> <span class="n">using</span> <span class="n">key</span>
<span class="kd">end</span>
</code></pre></div>



<a name="222531467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222531467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222531467">(Jan 13 2021 at 04:19)</a>:</h4>
<p>anything with summing, anything where one would write it on paper using <a href="https://en.wikipedia.org/wiki/Kronecker_delta">https://en.wikipedia.org/wiki/Kronecker_delta</a></p>



<a name="222531656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222531656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222531656">(Jan 13 2021 at 04:22)</a>:</h4>
<p>I haven't tried it, but it feels like one would have to break into cases to prove the above lemma using the other definition?</p>



<a name="222532911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222532911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222532911">(Jan 13 2021 at 04:41)</a>:</h4>
<p>I see. Yeah, maybe I just don't have enough patience for this sort of typeclass mess :-)</p>



<a name="222532979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222532979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222532979">(Jan 13 2021 at 04:42)</a>:</h4>
<p>Though for a case like this we would probably anyway want a lemma stating <code>l.sum (λ j a, a * ⟪v i, v j⟫) = l i</code>.</p>



<a name="222546789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222546789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222546789">(Jan 13 2021 at 08:07)</a>:</h4>
<p>I'd go for Frédéric's solution, which avoids all the mess (but you would still prove the lemmas that <code>⟪v i, v i⟫ = 1</code> and <code>⟪v i, v j⟫ = 0</code> for <code>i</code> different from <code>j</code>, which is what you really need). If you really want to go for the <code>ite</code> definition, a way to fix things is probably to remove <code>open_locale classical</code>, and add <code>decidable_eq</code> assumptions in all the statements where Lean complains. But IMHO having less typeclasses in definitions is good; because it means Lean will have to work less whenever it encounters the definition.</p>



<a name="222599297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222599297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222599297">(Jan 13 2021 at 15:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113488-general/topic/another.20decidable_eq.20problem/near/222546789">said</a>:</p>
<blockquote>
<p>If you really want to go for the <code>ite</code> definition, a way to fix things is probably to remove <code>open_locale classical</code>, and add <code>decidable_eq</code> assumptions in all the statements where Lean complains.</p>
</blockquote>
<p>I got it working with this suggestion.  Now that my pride has been satisfied with this small victory over Lean, perhaps I can switch to Frédéric's method :)</p>



<a name="222664906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222664906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222664906">(Jan 14 2021 at 00:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/113488-general/topic/another.20decidable_eq.20problem/near/222531439">said</a>:</p>
<blockquote>
<p>Good question! ... it's just a hunch, but I suspect that arguments like the following will be cleaner:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- An orthonormal set is linearly independent. -/</span>
<span class="kd">lemma</span> <span class="n">linear_independent_of_orthonormal</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="n">orthonormal</span> <span class="bp">𝕜</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">linear_independent</span> <span class="bp">𝕜</span> <span class="n">v</span> <span class="o">:=</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Frédéric's definition looks like it should be convenient for deducing that from <code>linear_independent_of_ne_zero_of_inner_eq_zero</code>.</p>



<a name="222666360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/another%20decidable_eq%20problem/near/222666360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/another.20decidable_eq.20problem.html#222666360">(Jan 14 2021 at 00:21)</a>:</h4>
<p>Ah, thanks for the pointer, I didn't know we had this already!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
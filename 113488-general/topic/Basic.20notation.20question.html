---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Basic.20notation.20question.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html">Basic notation question</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="245497562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245497562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gihan Marasingha <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245497562">(Jul 09 2021 at 21:01)</a>:</h4>
<p>The proof of <a href="https://leanprover-community.github.io/mathlib_docs/find/summable_zero">docs#summable_zero</a> is <code>has_sum_zero.summable</code>. I'm unfamiliar with this use of the <code>.</code> notation. What does it mean? Is it discussed in TPIL?</p>



<a name="245497945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245497945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245497945">(Jul 09 2021 at 21:03)</a>:</h4>
<p>The simple version is that <code>f.bar</code> when <code>f : foo</code> means <code>foo.bar f</code>.</p>



<a name="245498155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245498155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245498155">(Jul 09 2021 at 21:04)</a>:</h4>
<p>The slightly more complex version is that <code>f</code> doesn't even need to be the first argument.</p>



<a name="245498425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245498425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245498425">(Jul 09 2021 at 21:05)</a>:</h4>
<p>I think the range of things it supports has increased since TPIL was written</p>



<a name="245498635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245498635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245498635">(Jul 09 2021 at 21:06)</a>:</h4>
<p>Generally, we refer to this as "dot notation"; you might find some more discussions in Zulip using that term.</p>
<p>Here's a hopefully helpful repost:<br>
<span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/smallest.20element.20of.20a.20set.3F/near/212325387">said</a>:</p>
<blockquote>
<p>For more on dot notation see the end of <a href="https://leanprover.github.io/theorem_proving_in_lean/propositions_and_proofs.html#conjunction">3.3.1</a> and <a href="https://leanprover.github.io/theorem_proving_in_lean/structures_and_records.html">9.1</a> in TPiL. I think it finally clicked for me though after I read <a href="#narrow/stream/113488-general/topic/dot.20notation.20confusion/near/157341136">this thread</a>.</p>
</blockquote>



<a name="245498914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245498914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gihan Marasingha <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245498914">(Jul 09 2021 at 21:07)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="310045">@Eric Wieser</span> and <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> !</p>



<a name="245499684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245499684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245499684">(Jul 09 2021 at 21:11)</a>:</h4>
<p>By the way, a lot of the library is written to exploit this notation.  For example, we have <a href="https://leanprover-community.github.io/mathlib_docs/find/differentiable.continuous">docs#differentiable.continuous</a>, so that if you ever know <code>(hf : differentiable ℝ f)</code>, then you can write <code>hf.continuous</code> for the fact that <code>f</code> is continuous.</p>



<a name="245499924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245499924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245499924">(Jul 09 2021 at 21:12)</a>:</h4>
<p>And we have <a href="https://leanprover-community.github.io/mathlib_docs/find/is_compact.bounded">docs#is_compact.bounded</a>, so that if you ever know <code>(hs : is_compact s)</code>, then you can write <code>hs.bounded</code> for the fact that <code>s</code> is bounded.</p>



<a name="245499952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245499952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245499952">(Jul 09 2021 at 21:12)</a>:</h4>
<p>And many many more :)</p>



<a name="245500831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245500831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245500831">(Jul 09 2021 at 21:16)</a>:</h4>
<p>I even recently defined <code>has_subset.subset.finpartition_on</code> to be able to write <code>h.finpartition_on</code> when <code>h : A ⊆ B</code>.</p>



<a name="245500984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245500984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gihan Marasingha <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245500984">(Jul 09 2021 at 21:16)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="260507">@Heather Macbeth</span>!</p>



<a name="245501066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245501066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245501066">(Jul 09 2021 at 21:17)</a>:</h4>
<p>Very useful examples that I wish I knew before are <code>le.trans</code>, <code>le.trans_lt</code>, <code>lt.trans</code>, <code>lt.trans_le</code></p>



<a name="245501389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245501389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245501389">(Jul 09 2021 at 21:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/Basic.20notation.20question/near/245501066">said</a>:</p>
<blockquote>
<p>Very useful examples that I wish I knew before are <code>le.trans</code>, <code>le.trans_lt</code>, <code>lt.trans</code>, <code>lt.trans_le</code></p>
</blockquote>
<p>Yes, and <a href="https://leanprover-community.github.io/mathlib_docs/find/has_lt.lt.ne">docs#has_lt.lt.ne</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/has_lt.lt.ne'">docs#has_lt.lt.ne'</a>.</p>



<a name="245501482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245501482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245501482">(Jul 09 2021 at 21:19)</a>:</h4>
<p>So instead of <code>le_of_le_lt hle hlt</code>, you can seamlessly write <code>hle.trans_lt hlt</code> and get a <code>&lt;</code> result in the end. You also have the handy <code>lt.le</code> instead of <code>le_of_lt</code> and <code>.antisymm</code> which works at least for <code>≤</code> and <code>⊆</code>.</p>



<a name="245501862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245501862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245501862">(Jul 09 2021 at 21:21)</a>:</h4>
<p>The biggest drawback in my opinion is that typeclass inference basically stops at the dot notation so, because many projections are overloaded (<code>.antisymm</code>, <code>.trans</code>, ...),  the type of what you dot notate on has to be pretty clear for the notation to work.</p>



<a name="245515539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245515539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gihan Marasingha <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245515539">(Jul 09 2021 at 23:05)</a>:</h4>
<p>OK, I think I get it now. Thanks for the explanations! I see that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">pp.generalized_field_notation</span> <span class="n">false</span>
</code></pre></div>
<p>desugars (is that a word?) this notation. So in the example <span class="user-mention" data-user-id="387244">@Yaël Dillies</span>  mentioned, we can do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.ordered</span>

<span class="kd">set_option</span> <span class="n">pp.generalized_field_notation</span> <span class="n">false</span>

<span class="kd">lemma</span> <span class="n">bar</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hle</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hlt</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">hle.trans_lt</span> <span class="n">hlt</span>

<span class="k">#print</span> <span class="n">bar</span>
</code></pre></div>
<p>and find that the proof of <code>bar</code> is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hle</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">hlt</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">),</span> <span class="n">has_le.le.trans_lt</span> <span class="n">hle</span> <span class="n">hlt</span>
</code></pre></div>
<p>The reason the dot notation works here is that <code>hle : has_le.le a b</code> and, coincidentally (not), there's a function called <code>has_le.le.trans_lt</code> which takes, as its first parameter, a term of type <code>has_le.le x y</code>. So <code>hle.trans_lt</code> is just applying the <code>has_le.le.trans_lt</code> function, but with <code>hle</code> as the first argument.</p>
<p>Rephrasing, this works because:</p>
<ol>
<li>The <em>name</em> of the <em>type</em> of <code>hle</code> matches the first part of the <em>name</em> of a dotted-function (here <code>has_le.le.trans_lt</code>) and</li>
<li>The  <em>type</em> of the first parameter of the function <code>has_le.le.trans_lt</code> matches the <em>type</em> of <code>hle</code>.</li>
</ol>
<p>I hope that's correct!</p>



<a name="245535271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245535271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245535271">(Jul 10 2021 at 07:23)</a>:</h4>
<p>It's correct except that it works even slightly more generally! <code>hle</code> doen't have to be the first explicit parameter of the function. It has to be the first explicit parameter <strong>of type <code>has_le.le</code></strong> of the function. So for example this would work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.convex.topology</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">ℝ</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>

<span class="c1">-- mathematically stupid</span>
<span class="kd">def</span> <span class="n">convex.foo</span> <span class="o">(</span><span class="n">hAcomp</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hAconv</span> <span class="o">:</span> <span class="n">convex</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">hAcomp.is_closed</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">hAconv</span> <span class="o">:</span> <span class="n">convex</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">hAcomp</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">A</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">hAconv.foo</span> <span class="n">hAcomp</span> <span class="c1">-- convex.foo hAcomp hAconv : is_closed A</span>
<span class="k">#check</span> <span class="n">hAconv.foo</span> <span class="c1">-- I would have expected this to work</span>
<span class="c">/-</span><span class="cm"> type mismatch at application</span>
<span class="cm">  convex.foo hAconv</span>
<span class="cm">term</span>
<span class="cm">  hAconv</span>
<span class="cm">has type</span>
<span class="cm">  convex A</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  is_compact ?m_3-/</span>
</code></pre></div>
<p>but surprisingly (to me) it doesn't like partial application.</p>



<a name="245535433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245535433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245535433">(Jul 10 2021 at 07:27)</a>:</h4>
<p>I think dot notation will also unfold definitions sometimes too; if you have <code>def my_nat := nat</code>, then dot notation on terms of type <code>mynat</code> will first try the mynat namespace then the nat namespace. I can't check that right now though.</p>



<a name="245535435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Basic%20notation%20question/near/245535435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Basic.20notation.20question.html#245535435">(Jul 10 2021 at 07:27)</a>:</h4>
<p>Maybe it has to be reducible</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
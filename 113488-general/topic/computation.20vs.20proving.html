---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/computation.20vs.20proving.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html">computation vs proving</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204457511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204457511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204457511">(Jul 20 2020 at 18:24)</a>:</h4>
<p>In order to avoid continued hijacking <a href="#narrow/stream/144837-PR-reviews/topic/.233403">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.233403</a> (sorry <span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>), I'm starting this thread.</p>



<a name="204457530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204457530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204457530">(Jul 20 2020 at 18:25)</a>:</h4>
<p>Probably lots of people have thought about this before.</p>



<a name="204457574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204457574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204457574">(Jul 20 2020 at 18:25)</a>:</h4>
<p>How hard would it be to have a more formal approach to "specification" and "implementation"?</p>



<a name="204457762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204457762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204457762">(Jul 20 2020 at 18:27)</a>:</h4>
<p>If I could write:</p>
<div class="codehilite"><pre><span></span><code><span class="n">specification</span> <span class="n">natural_number_object</span> <span class="o">:=</span> <span class="n">initial</span> <span class="n">semiring</span> <span class="n">blabla</span>

<span class="c1">-- and then</span>

<span class="n">implementation</span> <span class="n">natural_number_object</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">some</span> <span class="k">proof</span>

<span class="n">implementation</span> <span class="n">natural_number_object</span> <span class="n">num</span> <span class="o">:=</span> <span class="n">some</span> <span class="k">proof</span>
</code></pre></div>


<p>would that help?</p>



<a name="204457788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204457788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204457788">(Jul 20 2020 at 18:27)</a>:</h4>
<p>Of course we <em>can</em> do that with typeclasses.</p>



<a name="204457832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204457832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204457832">(Jul 20 2020 at 18:27)</a>:</h4>
<p>But maybe that abusing a system for something it isn't <em>really</em> designed for/ meant to be used for.</p>



<a name="204458003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458003">(Jul 20 2020 at 18:28)</a>:</h4>
<p>I'm not sure if we want to prove lemmas about polynomials by starting</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">RX</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">RX</span><span class="o">]</span> <span class="o">[</span><span class="n">polynomial_like_type</span> <span class="n">R</span> <span class="n">RX</span><span class="o">]</span>
</code></pre></div>



<a name="204458343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458343">(Jul 20 2020 at 18:31)</a>:</h4>
<p>In particular, what typeclasses currently don't allow, but what I <em>would want</em> to have from this "spec/impl" business, is that if I need to prove that some polynomial of degree 3 is irreducible over <code>zmod 5</code>, then I can just say <code>exact dec_trivial</code> and Lean should automatically figure out that it can translate the question to one of the computational implementations, and run the computation itself.</p>



<a name="204458461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458461">(Jul 20 2020 at 18:32)</a>:</h4>
<p>But then, nevertheless, the theorem should be a theorem about <em>all</em> implementations, in other words a theorem that follows from the "spec".</p>



<a name="204458470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458470">(Jul 20 2020 at 18:32)</a>:</h4>
<p>Does that even make sense?</p>



<a name="204458545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458545">(Jul 20 2020 at 18:33)</a>:</h4>
<p>this is the <code>equiv_rw</code> problem, right?</p>



<a name="204458566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458566">(Jul 20 2020 at 18:33)</a>:</h4>
<p>you have two types and you know they satisfy the same sentences in the theory of rings</p>



<a name="204458671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458671">(Jul 20 2020 at 18:34)</a>:</h4>
<p>in order to prove some particular thing about theorem-rings, you equiv to a theorem about compute-rings, run the computation, and then come back</p>



<a name="204458689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458689">(Jul 20 2020 at 18:34)</a>:</h4>
<p>but we already don't have great machinery for doing this between two proof-y types</p>



<a name="204458759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458759">(Jul 20 2020 at 18:36)</a>:</h4>
<p>I guess we need automation for proving that a particular lemma is part of the theory of rings</p>



<a name="204458841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458841">(Jul 20 2020 at 18:36)</a>:</h4>
<p>In the special case of computations, maybe it's not so much of an issue</p>



<a name="204458872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458872">(Jul 20 2020 at 18:37)</a>:</h4>
<p>why? is it because you want the theory of the computational type to be exactly the theory of the proving type?</p>



<a name="204458875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458875">(Jul 20 2020 at 18:37)</a>:</h4>
<p>You could just apply <code>computational_polynomial_equiv.injective</code>, and then simp the equiv through the expression.</p>



<a name="204458908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458908">(Jul 20 2020 at 18:37)</a>:</h4>
<p>Whereas for a generic lemma, it is not obvious that you are only multiplying and adding some variables.</p>



<a name="204458995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204458995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204458995">(Jul 20 2020 at 18:38)</a>:</h4>
<p>Otoh, I guess if there is an <code>ite</code> in there, then we might already need some specialized simp-lemmas. And maybe there is a <code>polynomial.map</code>, etc...</p>



<a name="204459010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204459010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204459010">(Jul 20 2020 at 18:38)</a>:</h4>
<p>So already, there will be quite some headache.</p>



<a name="204508131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204508131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204508131">(Jul 21 2020 at 02:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/computation.20vs.20proving/near/204458343">said</a>:</p>
<blockquote>
<p>In particular, what typeclasses currently don't allow, but what I <em>would want</em> to have from this "spec/impl" business, is that if I need to prove that some polynomial of degree 3 is irreducible over <code>zmod 5</code>, then I can just say <code>exact dec_trivial</code> and Lean should automatically figure out that it can translate the question to one of the computational implementations, and run the computation itself.</p>
</blockquote>
<p>But this <em>is</em> exactly what <code>dec_trivial</code> does</p>



<a name="204508149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204508149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204508149">(Jul 21 2020 at 02:53)</a>:</h4>
<p>(The point being you just need to provide the <code>decidable</code> instances that show how to do the translation.)</p>



<a name="204508153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204508153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204508153">(Jul 21 2020 at 02:53)</a>:</h4>
<p>The main issue is that we usually use "least common denominator" algorithms with relatively poor asymptotic complexity because we don't assume any extra structure on the classes</p>



<a name="204508199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204508199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204508199">(Jul 21 2020 at 02:54)</a>:</h4>
<p>but you could easily have multiple <code>decidable</code> instances for the same predicate with different priorities and additional typeclass assumptions for specialized procedures that aren't always applicable</p>



<a name="204508267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204508267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204508267">(Jul 21 2020 at 02:56)</a>:</h4>
<p>A nice warmup problem for this is to implement a decidable instance for <code>a &lt; b</code> on <code>nat</code> that is O(log n)</p>



<a name="204511473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204511473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204511473">(Jul 21 2020 at 04:27)</a>:</h4>
<p>Somehow, it's not good enough... because the <code>decidable_*</code> instances <em>infect</em> our definitions, and make it hard to prove generic stuff about the definitions.</p>



<a name="204511530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204511530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204511530">(Jul 21 2020 at 04:28)</a>:</h4>
<p>Why are polynomials currently noncomputable? We didn't change any definitions, apart from ripping out <code>decidable_*</code> assumptions. But that's complete nonsense. If <code>decidable_eq R</code> is present, it should manage to compute even though that wasn't an assumption on the definition.</p>



<a name="204512199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204512199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204512199">(Jul 21 2020 at 04:48)</a>:</h4>
<p>I think using typeclasses for this is perfectly fine. To me it seems  analogous to <code>decidable</code>:</p>
<ul>
<li>With a proposition, we cannot construct data depending on whether it is true or false (without choice), so we tag it with a class <code>decidable</code> for the propositions for which we can</li>
<li>With a noncomputable def, I cannot compute. So I tag it with a class <code>computable</code> which contains an implementation and a proof that the implementation is equal to the noncomputable def. Now I can compute with the implementation.</li>
</ul>
<p>I think you can do something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">computes</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">certificate</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">val</span><span class="o">)</span>

<span class="n">def</span> <span class="n">compute</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">computes</span> <span class="n">x</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="err">‹</span><span class="n">computes</span> <span class="n">x</span><span class="err">›</span><span class="bp">.</span><span class="n">val</span>

<span class="n">def</span> <span class="n">computable_fun</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">β</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">computes</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="204602102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204602102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204602102">(Jul 21 2020 at 20:58)</a>:</h4>
<p>This only supports "heavy <code>rfl</code>"-style computation though, right?</p>



<a name="204602839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204602839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204602839">(Jul 21 2020 at 21:05)</a>:</h4>
<p>For me <code>norm_num</code> is the model here--<code>norm_str</code> was a joke but there's no reason not to have a <code>norm_poly</code> that can compute things like degrees and whether polynomials are irreducible, regardless of whether <code>polynomial</code> is itself computable or not.</p>



<a name="204603128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204603128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204603128">(Jul 21 2020 at 21:08)</a>:</h4>
<p>The question in my mind is how to design this in a coherent way where <code>norm_poly</code> knows to invoke <code>norm_num</code> to decide whether a coefficient is zero if that makes sense, but maybe to invoke <code>norm_poly</code> if the coefficient is actually another polynomial, etc.</p>



<a name="204603295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204603295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204603295">(Jul 21 2020 at 21:10)</a>:</h4>
<p>This is not the same as <code>decidable_eq</code>--that one is an internal notion of decidability (which is classically trivial) but here we want an algorithm to (attempt to) decide whether two <em>terms</em> are provably equal.</p>



<a name="204643256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204643256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204643256">(Jul 22 2020 at 08:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/computation.20vs.20proving/near/204603128">said</a>:</p>
<blockquote>
<p>The question in my mind is how to design this in a coherent way where <code>norm_poly</code> knows to invoke <code>norm_num</code> to decide whether a coefficient is zero if that makes sense, but maybe to invoke <code>norm_poly</code> if the coefficient is actually another polynomial, etc.</p>
</blockquote>
<p>The way I would like this to be implemented is as plugins for <code>norm_num</code>, so that it can handle things other than simple numeric computations but can also do basic beta reduction and definition expansion for unknown functions, as well as decision procedures for things like matrix and polynomial computation. At that point it becomes more of a general purpose evaluator so the name <code>norm_num</code> will not fit anymore, but that's how I imagine it evolving.</p>



<a name="204643386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204643386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204643386">(Jul 22 2020 at 08:56)</a>:</h4>
<p>By the way, I sort of hinted at this above but it's actually possible to compute on <em>terms</em> using well crafted typeclass instances</p>



<a name="204643859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204643859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204643859">(Jul 22 2020 at 09:02)</a>:</h4>
<p>Since no one solved the puzzle, here's the solution:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">num</span><span class="bp">.</span><span class="n">lemmas</span>

<span class="n">class</span> <span class="n">to_num</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">num</span><span class="o">)</span> <span class="o">(</span><span class="n">eq</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">to_num</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:</span> <span class="n">to_num</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="n">to_num</span><span class="bp">.</span><span class="n">one</span> <span class="o">:</span> <span class="n">to_num</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="n">to_num</span><span class="bp">.</span><span class="n">bit0</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="o">[</span><span class="n">to_num</span> <span class="n">a</span><span class="o">]</span> <span class="o">:</span> <span class="n">to_num</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">bit0</span> <span class="o">(</span><span class="n">to_num</span><span class="bp">.</span><span class="n">x</span> <span class="n">a</span><span class="o">),</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">to_num</span><span class="bp">.</span><span class="n">eq</span><span class="o">]</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="n">to_num</span><span class="bp">.</span><span class="n">bit1</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="o">[</span><span class="n">to_num</span> <span class="n">a</span><span class="o">]</span> <span class="o">:</span> <span class="n">to_num</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">bit1</span> <span class="o">(</span><span class="n">to_num</span><span class="bp">.</span><span class="n">x</span> <span class="n">a</span><span class="o">),</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">to_num</span><span class="bp">.</span><span class="n">eq</span><span class="o">]</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="n">decidable_lt</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">to_num</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">to_num</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">decidable_of_iff</span> <span class="o">(</span><span class="n">to_num</span><span class="bp">.</span><span class="n">x</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">to_num</span><span class="bp">.</span><span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="err">$</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">to_num</span><span class="bp">.</span><span class="n">eq</span><span class="o">]</span>

<span class="kn">set_option</span> <span class="n">class</span><span class="bp">.</span><span class="n">instance_max_depth</span> <span class="mi">1000</span>
<span class="kn">example</span> <span class="o">:</span> <span class="mi">345813045810345183</span> <span class="bp">&lt;</span> <span class="mi">2351384051340513405</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>


<p>This is pretty fast even though it does only kernel computation</p>



<a name="204643914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204643914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204643914">(Jul 22 2020 at 09:03)</a>:</h4>
<p>The instance max depth only needs to be raised because the depth is proportional to the size of the numbers, and those numbers are not 32 bit</p>



<a name="204644249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204644249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204644249">(Jul 22 2020 at 09:07)</a>:</h4>
<p>With a simple extension we can get fast kernel addition and multiplication on <code>nat</code> as well:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">to_num</span><span class="bp">.</span><span class="n">add</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">to_num</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">to_num</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="n">to_num</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">to_num</span><span class="bp">.</span><span class="n">x</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">to_num</span><span class="bp">.</span><span class="n">x</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">to_num</span><span class="bp">.</span><span class="n">eq</span><span class="o">]</span><span class="bp">⟩</span>
<span class="kn">instance</span> <span class="n">to_num</span><span class="bp">.</span><span class="n">mul</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">to_num</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">to_num</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="n">to_num</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">to_num</span><span class="bp">.</span><span class="n">x</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">to_num</span><span class="bp">.</span><span class="n">x</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">to_num</span><span class="bp">.</span><span class="n">eq</span><span class="o">]</span><span class="bp">⟩</span>

<span class="kn">set_option</span> <span class="n">class</span><span class="bp">.</span><span class="n">instance_max_depth</span> <span class="mi">1000</span>
<span class="kn">example</span> <span class="o">:</span> <span class="mi">500</span> <span class="bp">*</span> <span class="mi">500</span> <span class="bp">*</span> <span class="mi">500</span> <span class="bp">*</span> <span class="mi">39</span> <span class="bp">&lt;</span> <span class="mi">235138405</span> <span class="bp">*</span> <span class="mi">134051340</span> <span class="bp">+</span> <span class="mi">12</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>



<a name="204644813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204644813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204644813">(Jul 22 2020 at 09:15)</a>:</h4>
<p>Also notice that this can also easily be adapted to prove things like <code>(3 * 4 : real) &lt; 17</code></p>



<a name="204648134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204648134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204648134">(Jul 22 2020 at 10:00)</a>:</h4>
<p>Mario that is_really_ cool :D</p>



<a name="204648160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204648160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204648160">(Jul 22 2020 at 10:00)</a>:</h4>
<p>Can it prove 617 is prime?</p>



<a name="204753914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204753914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204753914">(Jul 23 2020 at 02:03)</a>:</h4>
<p>The limitation of this technique is that it can't do "nondeterministic" computation like tactics can, so you don't get short certificate proofs (for example to prove non-primality). Also the best environment for this uses the <code>semidecidable</code> class instead of <code>decidable</code> (which I think still has yet to be defined because of bikeshedding over the name, but is basically <code>option p</code>), because many kinds of proof methods aren't actually decision procedures, for example proving that numerals are equal in a possibly nonzero characteristic ring</p>



<a name="204753978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204753978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204753978">(Jul 23 2020 at 02:04)</a>:</h4>
<p>But for proving primality, you aren't really doing any short circuiting anyway for a proof by trial division, so you could do something similar there. I would have to write the <code>num.prime</code> decision procedure first though</p>



<a name="204761241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204761241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204761241">(Jul 23 2020 at 05:11)</a>:</h4>
<p>Using <a href="https://github.com/leanprover-community/mathlib/issues/3525">#3525</a>, this method also extends to primality proofs:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">num</span><span class="bp">.</span><span class="n">prime</span>

<span class="kn">instance</span> <span class="n">decidable_prime</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">[</span><span class="n">to_num</span> <span class="n">a</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">decidable_of_iff</span> <span class="o">(</span><span class="n">num</span><span class="bp">.</span><span class="n">prime</span> <span class="o">(</span><span class="n">to_num</span><span class="bp">.</span><span class="n">x</span> <span class="n">a</span><span class="o">))</span> <span class="err">$</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">to_num</span><span class="bp">.</span><span class="n">eq</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="mi">617</span> <span class="o">:=</span> <span class="n">dec_trivial</span> <span class="c1">-- takes about 200 ms</span>
</code></pre></div>



<a name="204765429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204765429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204765429">(Jul 23 2020 at 06:55)</a>:</h4>
<p>Everything is trivial</p>



<a name="204775372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computation%20vs%20proving/near/204775372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/computation.20vs.20proving.html#204775372">(Jul 23 2020 at 09:15)</a>:</h4>
<p>Relevant link: <a href="https://aphyr.com/posts/342-typing-the-technical-interview">https://aphyr.com/posts/342-typing-the-technical-interview</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
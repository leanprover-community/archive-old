---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html">Proving that a variable is of a given type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="215558499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215558499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215558499">(Nov 04 2020 at 09:36)</a>:</h4>
<p>Given some <code>a: α</code>, some set <code>s: set α</code>, and a definition <code>β: {x // x ∈ s}</code>, how might I go about proving that <code>a: ↥β</code>, given that a is in fact ∈ s?</p>



<a name="215558730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215558730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215558730">(Nov 04 2020 at 09:38)</a>:</h4>
<p>Are you looking for <code>β.2</code>?</p>



<a name="215558911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215558911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215558911">(Nov 04 2020 at 09:40)</a>:</h4>
<p><span class="user-mention" data-user-id="359992">@Robert Maxton</span> You can not prove that a term <code>t</code> has type <code>T</code>. That's only something that the type checker can check for you.</p>



<a name="215559035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215559035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215559035">(Nov 04 2020 at 09:41)</a>:</h4>
<p>Also, if you have <code>β: {x // x ∈ s}</code>, then typically <code>a: ↥β</code> doesn't make sense. Did you mean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">β</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="c1">-- with the `=` sign</span>
</code></pre></div>



<a name="215559175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215559175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215559175">(Nov 04 2020 at 09:42)</a>:</h4>
<p>In that case, I think your question is how to <em>construct</em> a term of type <code>↥β</code> starting from <code>a</code> and a proof <code>ha :  a ∈ s</code> .</p>



<a name="215559227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215559227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215559227">(Nov 04 2020 at 09:42)</a>:</h4>
<p>yes, I did. And... uh, if the type checker gets it wrong? For example, in my case I have a proof already in my context that <code>a ∈ s</code>, and a proposition that begins <code>∀ (a : ↥s)</code> that I'd like to use it with; but the 'native type' of <code>a</code> is some underlying set.</p>



<a name="215559396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215559396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215559396">(Nov 04 2020 at 09:44)</a>:</h4>
<p>The answer is that <code>↥β</code> is a structure, so you can build it in 3 ways:</p>
<ol>
<li>Using the constructor function: <code>subtype.mk a ha</code></li>
<li>Using record syntax:</li>
</ol>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">property</span> <span class="o">:=</span> <span class="n">ha</span> <span class="o">}</span>
</code></pre></div>
<ol start="3">
<li>Using the anonymous constructor: <code>\&lt;a, ha\&gt;</code>. (If you type <code>\&lt;</code> in VScode, then it will automatically replace it by the correct fancy unicode bracket).</li>
</ol>



<a name="215559601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215559601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215559601">(Nov 04 2020 at 09:46)</a>:</h4>
<p>Version 3 is what most people use, but it is good to realise that it is just a fancy short-hand for the other 2 options.</p>



<a name="215559860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215559860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215559860">(Nov 04 2020 at 09:49)</a>:</h4>
<p><code>invalid constructor ⟨...⟩, 'has_lift_t.lift' is not an inductive type</code></p>



<a name="215559903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215559903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215559903">(Nov 04 2020 at 09:49)</a>:</h4>
<p>Could you please paste more code?</p>



<a name="215559982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215559982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215559982">(Nov 04 2020 at 09:50)</a>:</h4>
<p>bleh, making an mwe of this is a bit of a mess. let's see what I can do...</p>



<a name="215560002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215560002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215560002">(Nov 04 2020 at 09:50)</a>:</h4>
<p>Maybe paste the output of <code>extract_goal</code></p>



<a name="215560682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215560682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215560682">(Nov 04 2020 at 09:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">import</span> <span class="n">algebra.ring_quot</span>
<span class="kn">import</span> <span class="n">ring_theory.ideal.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="n">open_locale</span> <span class="n">classical</span>


<span class="kd">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">R</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">I</span><span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">I</span><span class="o">),</span> <span class="bp">@</span><span class="n">is_unit</span> <span class="n">R</span> <span class="o">(</span><span class="n">ring.to_monoid</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">a</span><span class="o">))</span>
    <span class="bp">→</span> <span class="n">true</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hdefI</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="k">have</span><span class="o">:</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span> <span class="kd">by</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span><span class="o">:</span> <span class="n">is_unit</span><span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">x</span><span class="o">),</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">one_add_one_eq_two</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">add_assoc</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="215560762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215560762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215560762">(Nov 04 2020 at 09:59)</a>:</h4>
<p>At this point I'd like to say <code>apply hdefI</code> or <code>apply (hdefI (1 + x))</code>, but I can't because <code>1+x</code> is of type <code>R</code>, not <code>↥I</code></p>



<a name="215561111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215561111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215561111">(Nov 04 2020 at 10:03)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">apply</span> <span class="n">hdefI</span> <span class="o">⟨</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">x</span><span class="o">,</span> <span class="n">this</span><span class="o">⟩,</span>
</code></pre></div>



<a name="215561253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215561253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215561253">(Nov 04 2020 at 10:04)</a>:</h4>
<p>You're making your life complicated by using the subtype associated to <code>I</code> too much. Can't you write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">R</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">I</span><span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">is_unit</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">a</span><span class="o">))</span>
    <span class="bp">→</span> <span class="n">true</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hdefI</span><span class="o">,</span> <span class="kd">begin</span>
  <span class="k">have</span><span class="o">:</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span> <span class="kd">by</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span><span class="o">:</span> <span class="n">is_unit</span><span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">x</span><span class="o">),</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">one_add_one_eq_two</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">add_assoc</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hdefI</span> <span class="n">_</span> <span class="n">this</span><span class="o">,</span>
  <span class="o">},</span>

<span class="kd">end</span>
</code></pre></div>
<p>(it's hard to tell without seeing more context).</p>



<a name="215561523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215561523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215561523">(Nov 04 2020 at 10:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> ... I probably could have, but at this point I'd have to rewrite much of my proof, so I'd rather not. Something to think about in the future, then. <br>
<span class="user-mention" data-user-id="112680">@Johan Commelin</span>  Huh. Thanks, that does work. How is that different from <code>apply hdefI (1+x)</code>, though? Or like, the latter complains that I haven't proved that <code>I</code> has <code>has_one</code>, but the constructor doesn't seem to care?</p>



<a name="215561714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215561714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215561714">(Nov 04 2020 at 10:09)</a>:</h4>
<p><code>x</code> has type <code>R</code>, and so <code>1 + x</code> also has type <code>R</code>.</p>



<a name="215561746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215561746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215561746">(Nov 04 2020 at 10:09)</a>:</h4>
<p>But you want something that lives in the ideal. How should lean know that <code>1 + x</code> is in the ideal?</p>



<a name="215561756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215561756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215561756">(Nov 04 2020 at 10:09)</a>:</h4>
<p>You have to tell it <code>this</code></p>



<a name="215561837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215561837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215561837">(Nov 04 2020 at 10:10)</a>:</h4>
<p>In other words, you have to package together the element <code>1 + x</code> and a proof that it is in the ideal <code>I</code>.</p>



<a name="215561859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215561859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215561859">(Nov 04 2020 at 10:10)</a>:</h4>
<p>That's exactly what those weird brackets do for you.</p>



<a name="215561862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215561862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215561862">(Nov 04 2020 at 10:10)</a>:</h4>
<p>If you really want to keep it this way then you can at least replace <code> (∀ (a:I), @is_unit R (ring.to_monoid R) (1 + a))</code> by <code> (∀ (a:I), is_unit (1 + a : R))</code></p>



<a name="215561971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215561971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215561971">(Nov 04 2020 at 10:12)</a>:</h4>
<p>... Ah. I had the same problem when I was setting up this proof in the first place, so I expanded out <code>is_unit</code> for lack of any better way to tell Lean that the sum was valid.</p>



<a name="215562041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215562041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215562041">(Nov 04 2020 at 10:12)</a>:</h4>
<p>What's the precedence of <code>:</code> over <code>+</code>? Is that "1 + (a of type R)", or "(1+a) which is of type R"?</p>



<a name="215562102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215562102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215562102">(Nov 04 2020 at 10:13)</a>:</h4>
<p>and to be honest, I was kind of expecting unification to handle that; or like, it honestly confuses me that unification <em>doesn't</em> automatically fill in constructions of that form, given how implicit type conversion usually works in languages with type classes</p>



<a name="215562112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215562112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215562112">(Nov 04 2020 at 10:13)</a>:</h4>
<p>then again, I probably shouldn't be applying Scala instincts to Lean too much lol</p>



<a name="215562374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215562374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215562374">(Nov 04 2020 at 10:16)</a>:</h4>
<p>It is <code>(1 + a) : R</code>.</p>



<a name="215562410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215562410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215562410">(Nov 04 2020 at 10:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="359992">Robert Maxton</span> <a href="#narrow/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type/near/215562102">said</a>:</p>
<blockquote>
<p>and to be honest, I was kind of expecting unification to handle that; or like, it honestly confuses me that unification <em>doesn't</em> automatically fill in constructions of that form, given how implicit type conversion usually works in languages with type classes</p>
</blockquote>
<p>I'm still not sure what you would like Lean to do. Should it look into the context of your tactic state and see if you already have a proof of <code>1 + x</code> at hand?</p>



<a name="215562420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215562420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215562420">(Nov 04 2020 at 10:17)</a>:</h4>
<p>What should it do if you don't have such a proof ready?</p>



<a name="215562544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215562544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215562544">(Nov 04 2020 at 10:18)</a>:</h4>
<p>Note that the syntax is not <code>_ : _</code> but <code>(_ : _)</code>, which should implicitly answer the precedence question</p>



<a name="215563160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215563160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215563160">(Nov 04 2020 at 10:25)</a>:</h4>
<blockquote>
<p>I'm still not sure what you would like Lean to do. Should it look into the context of your tactic state and see if you already have a proof of 1 + x at hand?</p>
</blockquote>
<p>Well, yes, essentially. That's the whole point of the proofs-as-types system, no? Since a proof would be of type <code>1+x ∈ I</code>, all it would have to do is check if there's any variables of that type in the context. If there isn't, <em>then</em> it can complain that it failed to unify; but it seems weird that it can find 'an instance of a typeclass' but not 'an proof-instance of this Prop'.</p>



<a name="215563348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215563348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215563348">(Nov 04 2020 at 10:27)</a>:</h4>
<p>Because typeclass search and unification are two different things.</p>



<a name="215563357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215563357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215563357">(Nov 04 2020 at 10:27)</a>:</h4>
<p>Also note that the tactic state widget is very helpful to answer your precedence questions quickly and exactly in the case you care about. Simply move your mouse cursor above various symbols in the tactic state to see how they are grouped.</p>



<a name="215563400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215563400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215563400">(Nov 04 2020 at 10:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="359992">Robert Maxton</span> <a href="#narrow/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type/near/215563160">said</a>:</p>
<blockquote>
<p>but it seems weird that it can find 'an instance of a typeclass' but not 'an proof-instance of this Prop'.</p>
</blockquote>
<p>well, typeclass inference and unification are two very different things.</p>



<a name="215563422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215563422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215563422">(Nov 04 2020 at 10:28)</a>:</h4>
<p>And you always have to balance speed vs automation</p>



<a name="215563463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215563463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215563463">(Nov 04 2020 at 10:28)</a>:</h4>
<p>It's a trade-off</p>



<a name="215563513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215563513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215563513">(Nov 04 2020 at 10:28)</a>:</h4>
<p>In this case, the idea is that writing <code>\&lt;a, ha\&gt;</code> is worth the hassle, compared to making lean try to figure things out itself.</p>



<a name="215563882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215563882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215563882">(Nov 04 2020 at 10:32)</a>:</h4>
<p>Sure, in this case it needs to check <code>x \mem I</code>. But in general it could be any proposition that you are using to build a subtype.</p>



<a name="215564159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564159">(Nov 04 2020 at 10:35)</a>:</h4>
<p>Robert, in principle you could imagine a different elaborator which tries to do what you want. But as Johan wrote, it would make things more complicated for very few use cases. You would much more often need to switch to the explicit thing we have now.</p>



<a name="215564196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564196">(Nov 04 2020 at 10:35)</a>:</h4>
<p>Right, but no matter what proposition <code>p</code> it is, the subtype would be defined as <code>{x \\ p x}</code>, so it could always attempt to find a variable of type <code>p x</code>. And yeah, I guess mentally I conflate the two because I usually think of 'the algorithm that fills underscores' as 'unification'.</p>



<a name="215564363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564363">(Nov 04 2020 at 10:37)</a>:</h4>
<p>And I guess. Mostly my issue is that it's not very discoverable/the error isn't very legible, and AFAIK there isn't much about subtypes in any of the existing tutorials/documentation &gt;.&gt;</p>



<a name="215564377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564377">(Nov 04 2020 at 10:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="359992">Robert Maxton</span> <a href="#narrow/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type/near/215564196">said</a>:</p>
<blockquote>
<p>so it could always attempt to find a variable of type <code>p x</code>.</p>
</blockquote>
<p>My claim is that this could potentially be pretty expensive.</p>



<a name="215564426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564426">(Nov 04 2020 at 10:38)</a>:</h4>
<p>That + 'other languages already do the automatic casting' is my motive here lol</p>



<a name="215564452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564452">(Nov 04 2020 at 10:38)</a>:</h4>
<p>We do automatic casting <em>from</em> the subtype <code>{x // p x}</code> to <code>X</code>. But not the other way round.</p>



<a name="215564464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564464">(Nov 04 2020 at 10:38)</a>:</h4>
<p>Fair. I haven't actually looked at lean's code/similar inference engine code myself, so I wouldn't know.</p>



<a name="215564472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564472">(Nov 04 2020 at 10:39)</a>:</h4>
<p>One direction doesn't need Lean to search for proofs, the other does.</p>



<a name="215564499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564499">(Nov 04 2020 at 10:39)</a>:</h4>
<p>We have automatic casting from <code>nat</code> to <code>int</code> to <code>rat</code> to <code>real</code> to <code>complex</code>, etc...</p>



<a name="215564522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564522">(Nov 04 2020 at 10:40)</a>:</h4>
<p>But you wouldn't want to have an automatic cast from <code>int</code> to <code>nat</code> that starts search for <code>0 \le n</code> proofs</p>



<a name="215564615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564615">(Nov 04 2020 at 10:40)</a>:</h4>
<p>Though actually, how could it get expensive? After all, the number of variables in the context is presumably a fairly small number, and the types all have to be pre-computed for the interactive help function to work anyway</p>



<a name="215564644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564644">(Nov 04 2020 at 10:41)</a>:</h4>
<p>I'm not expecting it to automatically compose proofs together to try and build the right term, just to see if any of the existing variables already have the right type</p>



<a name="215564703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564703">(Nov 04 2020 at 10:41)</a>:</h4>
<p>or like, this seems solvable by <code>grep</code>ing on the existing interactive context output lol</p>



<a name="215564722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564722">(Nov 04 2020 at 10:42)</a>:</h4>
<p>It would be nice if we can make</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">lift</span> <span class="n">x</span> <span class="n">to</span> <span class="n">s</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>work</p>



<a name="215564819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564819">(Nov 04 2020 at 10:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="359992">Robert Maxton</span> <a href="#narrow/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type/near/215564615">said</a>:</p>
<blockquote>
<p>Though actually, how could it get expensive? After all, the number of variables in the context is presumably a fairly small number, and the types all have to be pre-computed for the interactive help function to work anyway</p>
</blockquote>
<p>Because checking that two types are definitionally equal can get expensive.</p>



<a name="215564889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564889">(Nov 04 2020 at 10:43)</a>:</h4>
<p>Ah. Thus the use of the constructor so that you only have to do it for a single variable.</p>



<a name="215564917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215564917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215564917">(Nov 04 2020 at 10:44)</a>:</h4>
<p>I suppose that makes some sense, though I'm still confused about what the interactive context is doing different...</p>



<a name="215565362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565362">(Nov 04 2020 at 10:49)</a>:</h4>
<p>What do you think of something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">foobar</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">can_lift</span> <span class="n">R</span> <span class="n">I</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">coe</span><span class="o">,</span>
  <span class="n">cond</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">I</span><span class="o">,</span>
  <span class="n">prf</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">}</span>

<span class="kd">theorem</span> <span class="n">mwe</span> <span class="o">{</span><span class="n">R</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">I</span><span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">R</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">I</span><span class="o">),</span> <span class="n">is_unit</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">))</span> <span class="bp">→</span> <span class="n">true</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hdefI</span><span class="o">,</span>
<span class="kd">begin</span>
  <span class="n">lift</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">x</span> <span class="n">to</span> <span class="bp">↥</span><span class="n">I</span> <span class="k">with</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span><span class="o">:</span> <span class="n">is_unit</span><span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">x</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">one_add_one_eq_two</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="bp">←</span> <span class="n">h</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">hdefI</span> <span class="n">y</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="215565512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565512">(Nov 04 2020 at 10:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="359992">Robert Maxton</span> <a href="#narrow/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type/near/215564917">said</a>:</p>
<blockquote>
<p>I suppose that makes some sense, though I'm still confused about what the interactive context is doing different...</p>
</blockquote>
<p>The interactive context will show you <code>hx : p x</code>. If you have a goal <code>q x</code>, and you run <code>assumption</code>, then lean will try to see if <code>hx</code> has type <code>q x</code>. It will <em>not</em> syntactically compare <code>p x</code> and <code>q x</code> and stop if they differ.</p>



<a name="215565559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565559">(Nov 04 2020 at 10:51)</a>:</h4>
<p>In stead, it will try to see whether <code>p x</code> and <code>q x</code> are definitionally equal. This is a process that usually is very fast, but it can be quite expensive.</p>



<a name="215565663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565663">(Nov 04 2020 at 10:52)</a>:</h4>
<p>Actually, defining a <code>has_lift</code> like that would be valuable, yeah. Among other reasons it'd be entirely reasonable to include that in <code>ring_theory.ideal.basic</code> as a utility helper function, so it'd achieve the same effect of basically not having to worry about it anymore.</p>



<a name="215565729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565729">(Nov 04 2020 at 10:53)</a>:</h4>
<p>Yup, but <code>can_lift</code> is a relative "newcomer". So there are still a lot of gaps in the library where we should add instances.</p>



<a name="215565730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565730">(Nov 04 2020 at 10:53)</a>:</h4>
<p>and I see. So it's a sort of precedent problem, where we generally say that we operate up to definitional equality, but sometimes we have to revert to literal syntactic equality instead.</p>



<a name="215565749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565749">(Nov 04 2020 at 10:53)</a>:</h4>
<p>what's the distinction between <code>can_lift</code> and <code>has_lift</code>? I think I've seen the latter in the libraries already</p>



<a name="215565775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565775">(Nov 04 2020 at 10:54)</a>:</h4>
<p>Also, it doesn't work without the crazy up-arrow before the <code>I</code>, in <code>lift 1 + x to ↥I with y</code>. That's bad, I think. So we should fix that first.</p>



<a name="215565815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565815">(Nov 04 2020 at 10:54)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> Any idea on how to do that <span aria-label="point up" class="emoji emoji-1f446" role="img" title="point up">:point_up:</span></p>



<a name="215565941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565941">(Nov 04 2020 at 10:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="359992">Robert Maxton</span> <a href="#narrow/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type/near/215565749">said</a>:</p>
<blockquote>
<p>what's the distinction between <code>can_lift</code> and <code>has_lift</code>? I think I've seen the latter in the libraries already</p>
</blockquote>
<p><code>has_lift</code> is about automatic coercions. Those will always be functions defined on all terms. <code>can_lift</code> is trying to help with the opposite battle. When you have a function <code>X -&gt; Y</code> and a term <code>y : Y</code>, you can lift it to <code>X</code> if a certain predicate is full-filled.</p>



<a name="215565990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215565990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215565990">(Nov 04 2020 at 10:56)</a>:</h4>
<p>E.g., you can lift a <code>n : int</code> to <code>nat</code> if you know <code>0 \le n</code>.</p>



<a name="215566045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215566045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215566045">(Nov 04 2020 at 10:56)</a>:</h4>
<p>In my opinion <code>has_lift</code> is bad terminology from the point of view of what's common terminology in maths. But is was there from the start, and it seems to be a common name in computer science.</p>



<a name="215566078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215566078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215566078">(Nov 04 2020 at 10:57)</a>:</h4>
<p>So now we have a lot of things that are called <code>lift</code>, and sometimes they do opposite things <span aria-label="head bandage" class="emoji emoji-1f915" role="img" title="head bandage">:head_bandage:</span></p>



<a name="215566534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215566534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215566534">(Nov 04 2020 at 11:02)</a>:</h4>
<p>ah, I see. Yes, that is exactly the sort of thing I'm looking for</p>



<a name="215566548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215566548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robert Maxton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215566548">(Nov 04 2020 at 11:02)</a>:</h4>
<p>and pft. Yeah, I actually usually see that as coercion or casting rather than lifting (unless it's strictly a supertype, which I think <em>would</em> roughly map to the usual math terminology), but I'm hardly a CS specialist.</p>



<a name="215567076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215567076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215567076">(Nov 04 2020 at 11:08)</a>:</h4>
<p>I don't know about supertypes. But in maths, lifting is usually something that takes some effort.<br>
E.g., you have</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>      Y
      |
   f  v
X --&gt; Z
</code></pre></div>
<p>then you can ask whether the function <code>f</code> lifts to a function from <code>X</code> to <code>Y</code>.</p>



<a name="215568635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215568635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215568635">(Nov 04 2020 at 11:28)</a>:</h4>
<p>I wonder whether the possibility of fixing this in Lean4 is still open.</p>



<a name="215572959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215572959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215572959">(Nov 04 2020 at 12:22)</a>:</h4>
<p>Which part, the naming?</p>



<a name="215573130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215573130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215573130">(Nov 04 2020 at 12:24)</a>:</h4>
<p>Note that there is no <code>has_lift</code> equivalent in the Lean 4 stdlib at all right now; after all, there is nothing special about it in contrast to <code>has_coe</code> (now <code>Coe</code>).</p>



<a name="215573200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215573200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215573200">(Nov 04 2020 at 12:25)</a>:</h4>
<p>What was the original intent behind the separation of <code>has_lift</code> and <code>has_coe</code>?</p>



<a name="215583327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215583327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215583327">(Nov 04 2020 at 13:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> is there still <code>quotient.lift</code>? This is usually called <code>quotient.descent</code> in maths I guess. The quotient is smaller than the big set so lives under it.</p>



<a name="215585125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215585125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215585125">(Nov 04 2020 at 14:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> It is still there as <code>Quot.lift</code>. Interesting point of view; from a CS standpoint one would say that the quotient type is "structurally bigger", i.e. has one more type constructor, I'd guess. Like lifting monadic values into bigger monads (where no-one wants to think about cardinality).</p>



<a name="215585200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215585200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215585200">(Nov 04 2020 at 14:12)</a>:</h4>
<p>My impression was that we had lost this argument some time ago wrt quotients.</p>



<a name="215585238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215585238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215585238">(Nov 04 2020 at 14:12)</a>:</h4>
<p>It's the way we draw things on the blackboard</p>



<a name="215585277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215585277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215585277">(Nov 04 2020 at 14:13)</a>:</h4>
<p>I wasn't even aware there was an argument</p>



<a name="215585390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215585390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215585390">(Nov 04 2020 at 14:13)</a>:</h4>
<p>All the mathematical language -- the bigger set "covers" the smaller one, points in the quotient "lift" to points in the bigger set etc -- are set up this way.</p>



<a name="215587840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215587840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215587840">(Nov 04 2020 at 14:30)</a>:</h4>
<p>Kevin, <code>quotient.lift</code> is just a lift in the opposite category of types and functions, what's the problem? <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="215587939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215587939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215587939">(Nov 04 2020 at 14:31)</a>:</h4>
<p>Maybe we should call it <code>oplift</code> then?</p>



<a name="215588441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/215588441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#215588441">(Nov 04 2020 at 14:34)</a>:</h4>
<p>In the category theory library I think we already use <code>lift</code>/<code>desc</code> as an <code>opposite</code> pair, so... yeah</p>



<a name="238576997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/238576997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#238576997">(May 13 2021 at 03:42)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type/near/215565775">said</a>:</p>
<blockquote>
<p>Also, it doesn't work without the crazy up-arrow before the <code>I</code>, in <code>lift 1 + x to ↥I with y</code>. That's bad, I think. So we should fix that first.</p>
</blockquote>
<p>I just saw this again when going through my starred messages. It is fixed in <a href="https://github.com/leanprover-community/mathlib/issues/7598">#7598</a></p>



<a name="238581080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proving%20that%20a%20variable%20is%20of%20a%20given%20type/near/238581080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Proving.20that.20a.20variable.20is.20of.20a.20given.20type.html#238581080">(May 13 2021 at 04:49)</a>:</h4>
<p>Thanks a lot Floris!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
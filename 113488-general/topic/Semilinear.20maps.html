---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Semilinear.20maps.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html">Semilinear maps</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="250028000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250028000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250028000">(Aug 19 2021 at 18:33)</a>:</h4>
<p>For a while now, the fact that mathlib doesn't have conjugate linear maps has been blocking progress. For example, the map that takes an operator to its adjoint on a complex Hilbert space is a conjugate linear map, and so is the Riesz representation. This also prevents us from developing the orthogonal group, the unitary group, etc, properly. (See <a href="#narrow/stream/116395-maths/topic/Conjugate-linear">here</a> for a discussion of this issue.)</p>
<p><a href="#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class/near/214442983">Last October</a>,  <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span>  proposed a solution involving redefining linear maps to be semilinear maps. A semilinear map <code>f</code> is a map from an <code>R</code>-module to an <code>S</code>-module with a ring equivalence <code>σ</code>between <code>R</code> and <code>S</code>, such that <code>f (c • x) = (σ c) • (f x)</code>. If we plug in the identity into <code>σ</code>, we get regular linear maps, and if we plug in the complex conjugate, we get conjugate linear maps. There are also other examples (e.g. Frobenius-linear maps) where this is useful which are covered by this general formulation.</p>
<p>Now, together with <span class="user-mention" data-user-id="260507">@Heather Macbeth</span>  and <span class="user-mention" data-user-id="110596">@Rob Lewis</span> , we have implemented this idea on a ~1-month old version of mathlib! The result can be found on branch <code>semilinear-option2</code>. The main issue that we had to overcome involved composition of such maps, and <code>symm</code> for linear equivalences: having things like <code>σ₁₂.trans σ₂₃</code> or <code>σ.symm</code> in the types of semilinear maps creates major problems. For example, we want the composition of two conjugate-linear maps to be a regular linear map, not<br>
a <code>conj.trans conj</code>-linear map. To solve this issue, following a discussion from back in January, we created two typeclasses to make Lean infer the right ring equivalence. The first one is <code>[ring_equiv_comp_triple σ₁₂ σ₂₃ σ₁₃]</code> which expresses the fact that <code>σ₁₂.trans σ₂₃ = σ₁₃</code>, and the second one is <code>[ring_equiv_inv_pair σ₁₂ σ₂₁]</code> which states that <code>σ₁₂</code> and <code>σ₂₁</code> are inverses of each other. Note that (again following <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> 's idea) we have introduced notation to ensure that regular linear maps can still be used as before, i.e. <code>M →ₗ[R] N</code> still works as before to mean a regular linear map.</p>
<p>This mostly works well (maybe even surprisingly so!). Regular linear maps work essentially the same as<br>
before, and we have a proof-of-concept file that shows how it handles conjugate-linear maps (<code>linear_algebra/conjugate_linear.lean</code>).</p>
<p>Now, even though overall it works quite well, there is still a small cost to be paid:</p>
<ol>
<li>We have phased out the notation <code>M →ₗ N</code> (where the ring is not specified). </li>
<li>When defining a regular linear map directly using the structure (i.e. when specifying <code>to_fun</code>, <code>map_smul'</code> and so on), there is a <code>ring_equiv.refl</code> that shows up in <code>map_smul'</code>. This can mostly be dsimp'ed away, but is mildly annoying.</li>
<li>Elaboration seems slightly more brittle, and it fails a little bit more often than before. For example, when <code>f</code> is a linear map and <code>g</code> is something that can be coerced to a linear map (say a linear equiv), one has to write <code>↑g</code> to make it work, or sometimes even to add a type annotation. This also occurs when using <code>trans</code> twice (i.e. <code>e₁.trans (e₂.trans e₃)</code>). To mitigate this problem, we have added new notation for composition of regular linear maps (<code>∘ₗ</code> for <code>comp</code> and <code>≫ₗ</code> for <code>trans</code>). (Note that this is only provided to fix occasional elaboration issues and we don't necessarily expect this to replace <code>comp</code> and <code>trans</code>.)</li>
<li>It seems to exacerbate the bug discussed <a href="#narrow/stream/113488-general/topic/odd.20repeated.20type.20class.20search">here</a> for reasons that we don't understand all that well right now. It manifests itself in very slow calls to the tactic <code>ext</code>, and the quick fix is to manually use the right ext lemma.</li>
<li>A few random other issues that didn't arise often enough to see a pattern.</li>
</ol>
<p>We would of course be very interested in PRing this to mathlib, and since this is such a big change we would like to solicit discussion here before actually going through with this.</p>
<p>Any thoughts?</p>



<a name="250030002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250030002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250030002">(Aug 19 2021 at 18:48)</a>:</h4>
<p>Point 1 is no issue at all. I didn't even remember that notation existed. Point 2 seems very minor. Points 3 to 5 are extremely hard to evaluate without using the new setup.</p>



<a name="250030163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250030163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250030163">(Aug 19 2021 at 18:49)</a>:</h4>
<p>Note also that the elaboration issue may change in Lean 4. I have no idea whether it would become better or worse.</p>



<a name="250030284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250030284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250030284">(Aug 19 2021 at 18:50)</a>:</h4>
<p>Is there a particular reason why you want to use a ring equivalence as opposed to just a ring hom?</p>



<a name="250030458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250030458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250030458">(Aug 19 2021 at 18:51)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> Semilinear maps over a ring hom behave badly for certain constructions, in particular <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.map">docs#submodule.map</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.range">docs#linear_map.range</a>.  It's not impossible to do the generalization to ring homs, but it's a lot less lightweight.</p>



<a name="250030579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250030579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250030579">(Aug 19 2021 at 18:52)</a>:</h4>
<p>I'm mostly thinking of some examples from number theory... for example you might want to consider Frobenius semilinear maps over a non-perfect field.</p>



<a name="250030697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250030697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250030697">(Aug 19 2021 at 18:53)</a>:</h4>
<p>It would be a shame to do such a massive refactor only to find out that it's not general enough to cover natural examples</p>



<a name="250030811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250030811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250030811">(Aug 19 2021 at 18:54)</a>:</h4>
<p>In particular, whenever <code>map</code> or <code>range</code> appear in a proof, you have to bump up your assumptions to the ring hom being a ring equiv (well, a one-sided equiv is enough ...). So you get <code>include ...</code> and <code>omit ...</code> everywhere.</p>



<a name="250030852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250030852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250030852">(Aug 19 2021 at 18:54)</a>:</h4>
<p>I tried it at <a href="https://github.com/leanprover-community/mathlib/tree/semilinear5">branch#semilinear5</a> if you're curious. (see this commit<br>
<a href="https://github.com/leanprover-community/mathlib/commit/a3a1cfc7accf602f92cd5e0e52a72bfce4735072">https://github.com/leanprover-community/mathlib/commit/a3a1cfc7accf602f92cd5e0e52a72bfce4735072</a> ) ... but got bored halfway through <code>linear_algebra.basic</code></p>



<a name="250031908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250031908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250031908">(Aug 19 2021 at 19:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/Semilinear.20maps/near/250030697">said</a>:</p>
<blockquote>
<p>It would be a shame to do such a massive refactor only to find out that it's not general enough to cover natural examples</p>
</blockquote>
<p>I don't think the current version would preclude generalizing further to ring homs someday; the two tasks are basically independent.  One mathlib has the ring equiv generalization, if you want to further generalize to ring homs, find-and-replacing most of the <code>R ≃+* R₂</code> in the library to  <code>R →+* R₂</code> is the easy part, the hard part is fixing every proof involving <code>map</code>.</p>



<a name="250032866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250032866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250032866">(Aug 19 2021 at 19:04)</a>:</h4>
<p>Why would you need <code>include</code> / <code>omit</code> vs just a cast from a <code>ring_equiv</code> to a <code>ring_hom</code>?</p>



<a name="250033230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250033230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250033230">(Aug 19 2021 at 19:06)</a>:</h4>
<p>Yes that's what I was about to say. How hard would it be to setup the def to use <code>ring_hom</code> and then for the annoying lemmas you assume it's the coercion of some <code>ring_equiv</code> ?</p>



<a name="250033396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250033396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250033396">(Aug 19 2021 at 19:07)</a>:</h4>
<p>You still have to fix every annoying lemma separately, and that's the big task.  Because in some sections of the library the needs-fixing lemmas are closely interspersed with the don't-need-fixing lemmas.</p>



<a name="250033483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250033483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250033483">(Aug 19 2021 at 19:07)</a>:</h4>
<p>I have a hunch it might be best to setup the def to take just a plain function, for unification reasons</p>



<a name="250033599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250033599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250033599">(Aug 19 2021 at 19:08)</a>:</h4>
<p>Oh okay I see the issue with include and omit now</p>



<a name="250033649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250033649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250033649">(Aug 19 2021 at 19:08)</a>:</h4>
<p>You would also have to be very careful to ensure that regular linear maps are defined with <code>σ</code> being the coercion from a <code>ring_equiv.refl</code> to a <code>ring_hom</code> and not a <code>ring_hom.id</code>. I'm not sure how annoying this would get.</p>



<a name="250034347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250034347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250034347">(Aug 19 2021 at 19:12)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.map">docs#submodule.map</a> should work whenever you're semilinear over a surjective ring hom. So again even for map using an equivalence is possibly not the right generalization (in my opinion)</p>



<a name="250034549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250034549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250034549">(Aug 19 2021 at 19:13)</a>:</h4>
<p>Right, this is what I was getting at with "one-sided equiv"</p>



<a name="250035550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250035550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250035550">(Aug 19 2021 at 19:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/Semilinear.20maps/near/250030579">said</a>:</p>
<blockquote>
<p>I'm mostly thinking of some examples from number theory... for example you might want to consider Frobenius semilinear maps over a non-perfect field.</p>
</blockquote>
<p>In this example, are the ring homs surjective?</p>



<a name="250035602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250035602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250035602">(Aug 19 2021 at 19:19)</a>:</h4>
<p>No.</p>



<a name="250036012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250036012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250036012">(Aug 19 2021 at 19:22)</a>:</h4>
<p>So presumably one never uses the <code>map</code> construction for them anyway (i.e., we don't know a use case where we'd want <code>map</code> for semilinear maps over a surjective, non-bijective ring hom).</p>



<a name="250037628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250037628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250037628">(Aug 19 2021 at 19:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/113488-general/topic/Semilinear.20maps/near/250033649">said</a>:</p>
<blockquote>
<p>You would also have to be very careful to ensure that regular linear maps are defined with <code>σ</code> being the coercion from a <code>ring_equiv.refl</code> to a <code>ring_hom</code> and not a <code>ring_hom.id</code>. I'm not sure how annoying this would get.</p>
</blockquote>
<p>This is what I was referring to when I said<br>
<span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Semilinear.20maps/near/250033483">said</a>:</p>
<blockquote>
<p>I have a hunch it might be best to setup the def to take just a plain function, for unification reasons</p>
</blockquote>
<p>You're correct that <code>↑ring_equiv.refl = ring_hom.id</code> is problematic as it is not true by <code>rfl</code>, but <code>⇑ring_equiv.refl = ⇑ring_hom.id</code> does not suffer from the same problem.</p>



<a name="250037715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250037715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250037715">(Aug 19 2021 at 19:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/113488-general/topic/Semilinear.20maps/near/250033396">said</a>:</p>
<blockquote>
<p>You still have to fix every annoying lemma separately, and that's the big task.  Because in some sections of the library the needs-fixing lemmas are closely interspersed with the don't-need-fixing lemmas.</p>
</blockquote>
<p>If we get the generality of the definition right we can always relax the lemmas about it later</p>



<a name="250037949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250037949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250037949">(Aug 19 2021 at 19:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/Semilinear.20maps/near/250037628">said</a>:</p>
<blockquote>
<p>You're correct that <code>↑ring_equiv.refl = ring_hom.id</code> is problematic as it is not true by <code>rfl</code>, but <code>⇑ring_equiv.refl = ⇑ring_hom.id</code> does not suffer from the same problem.</p>
</blockquote>
<p>Frederic was responding to Anatole's comment.  The natural way in our formalism would be neither, but instead to use two ring homs together with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">ring_equiv_inv_pair</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_inv_pair₁</span> <span class="o">:</span> <span class="n">σ'.comp</span> <span class="n">σ</span> <span class="bp">=</span> <span class="n">ring_hom.id</span> <span class="n">R₁</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_inv_pair₂</span> <span class="o">:</span> <span class="n">σ.comp</span> <span class="n">σ'</span> <span class="bp">=</span> <span class="n">ring_hom.id</span> <span class="n">R₂</span><span class="o">)</span>
</code></pre></div>



<a name="250038586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250038586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250038586">(Aug 19 2021 at 19:41)</a>:</h4>
<p>I guess the idea for writing lemmas that match <code>A →ₗ[⇑σ] B</code> or <code>A →ₗ[↑σ] B</code> would work for the <code>σ : R ≃+* R'</code> case but not for the surjective case <span class="user-mention" data-user-id="243562">@Adam Topaz</span>  was thinking about, since we don't have bundled surjective maps.</p>



<a name="250039262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250039262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250039262">(Aug 19 2021 at 19:45)</a>:</h4>
<p>Eric, what problem are you trying to address exactly?  The experiment I tried at<br>
<a href="https://github.com/leanprover-community/mathlib/commit/a3a1cfc7accf602f92cd5e0e52a72bfce4735072">https://github.com/leanprover-community/mathlib/commit/a3a1cfc7accf602f92cd5e0e52a72bfce4735072</a><br>
failed for lack of energy, not because there was any technical problem.</p>



<a name="250039454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250039454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250039454">(Aug 19 2021 at 19:47)</a>:</h4>
<p>If we really want to allow for surjective rather than bijective ring homs in <code>submodule.map</code>, then split my typeclass above as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">ring_equiv_inv_pair_left</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_inv_pair₁</span> <span class="o">:</span> <span class="n">σ'.comp</span> <span class="n">σ</span> <span class="bp">=</span> <span class="n">ring_hom.id</span> <span class="n">R₁</span><span class="o">)</span> <span class="c1">-- `σ` has a left inverse</span>

<span class="kd">class</span> <span class="n">ring_equiv_inv_pair_right</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_inv_pair₂</span> <span class="o">:</span> <span class="n">σ.comp</span> <span class="n">σ'</span> <span class="bp">=</span> <span class="n">ring_hom.id</span> <span class="n">R₂</span><span class="o">)</span> <span class="c1">-- `σ` has a right inverse</span>
</code></pre></div>
<p>and use only the appropriate one.</p>



<a name="250040017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250040017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250040017">(Aug 19 2021 at 19:51)</a>:</h4>
<p>I'm just exploring the consequences of Adam's suggestion to use <code>ring_hom</code>s, because it was my first thought too. I haven't made any attempt at actually trying to do it or thought of a particularly compelling reason to do so.</p>



<a name="250040063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250040063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250040063">(Aug 19 2021 at 19:51)</a>:</h4>
<p>But at that commit I am using ring homs ...?</p>



<a name="250040151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250040151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250040151">(Aug 19 2021 at 19:52)</a>:</h4>
<p>I think I somehow missed the message where you posted that <code>5</code> branch the first time; apologies!</p>



<a name="250041432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250041432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250041432">(Aug 19 2021 at 20:00)</a>:</h4>
<p>I think if we really want to have <code>ring_hom</code>s instead of <code>ring_equiv</code>s, we'll need to have a few more of these typeclasses to express the fact that they are surjective/bijective/whatever. Having to pass these facts as parameters to every lemma sounds untenable.</p>



<a name="250042451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250042451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250042451">(Aug 19 2021 at 20:08)</a>:</h4>
<p><span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> If we only need bijective, then nothing needs to change; we can get by with the same two typeclasses <code>ring_equiv_comp_triple</code> and  <code>ring_equiv_inv_pair</code> as before, right?</p>



<a name="250042513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250042513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250042513">(Aug 19 2021 at 20:08)</a>:</h4>
<p>With <code>ring_equiv_inv_pair</code> expressing bijectivity.</p>



<a name="250044285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250044285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250044285">(Aug 19 2021 at 20:23)</a>:</h4>
<p>Well, the case where we only need bijective is basically what we've done. If we want to be able to define linear maps over any <code>ring_hom</code>, with lemmas that only work in specific cases (i.e. when <code>σ</code> is surjective bijective), then I think we need some more typeclasses.</p>



<a name="250047871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250047871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250047871">(Aug 19 2021 at 20:56)</a>:</h4>
<p>Suppose that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\sigma : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is a morphism of rings and let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">B_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> denote the image of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>.<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">f : M \to N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> be a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>-semilinear map.<br>
Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> be an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>-submodule of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>. The image <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(H)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span> is a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">B_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-submodule of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>. Consider the base-change <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><msub><mi>B</mi><mn>0</mn></msub></msub><mi>f</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B \otimes_{B_0} f(H)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93343em;vertical-align:-0.2501em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.05017em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span> of this <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">B_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-submodule. This is now a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-module, and it comes equipped with a natural morphism of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-modules to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>. We can then take the image of this map. In explicit terms, this is going to be the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-submodule of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> generated by the image of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> as a function. I think this deserves to be the correct generalization of <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.map">docs#submodule.map</a> for a semilinear map, and it doesn't require any further assumptions on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>.</p>



<a name="250047963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250047963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250047963">(Aug 19 2021 at 20:56)</a>:</h4>
<p>The carrier set will not be defeq to the image of <code>f</code> as a function, of course, but it will be propeq in the case where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> is surjective.</p>



<a name="250048419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250048419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250048419">(Aug 19 2021 at 21:00)</a>:</h4>
<p>I see, so define <code>submodule.map</code> to have carrier <code>span (f '' H)</code> rather than just <code>f '' H</code>.</p>



<a name="250912255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250912255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250912255">(Aug 27 2021 at 10:36)</a>:</h4>
<blockquote>
<p>feat(linear_algebra): introduce notation for linear_map.comp and linear_equiv.trans <a href="https://github.com/leanprover-community/mathlib/issues/8857">#8857</a></p>
</blockquote>
<p>is a PR by <span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span>  that prepares the notation changes.</p>



<a name="250912334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250912334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250912334">(Aug 27 2021 at 10:37)</a>:</h4>
<p>I'm in favour of making this change, but it would be good to try to align the notation as much as possible with the notation used in the category theory library.</p>



<a name="250912447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250912447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250912447">(Aug 27 2021 at 10:38)</a>:</h4>
<p>What part of semilinear maps motivated the new notation?</p>



<a name="250933134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250933134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250933134">(Aug 27 2021 at 13:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/113488-general/topic/Semilinear.20maps/near/250028000">said</a>:</p>
<blockquote>
<ol start="3">
<li>Elaboration seems slightly more brittle, and it fails a little bit more often than before. For example, when <code>f</code> is a linear map and <code>g</code> is something that can be coerced to a linear map (say a linear equiv), one has to write <code>↑g</code> to make <code>f.comp ↑g</code> work, or sometimes even to add a type annotation. This also occurs when using <code>trans</code> twice (i.e. <code>e₁.trans (e₂.trans e₃)</code>). To mitigate this problem, we have added new notation for composition of regular linear maps (<code>∘ₗ</code> for <code>comp</code> and <code>≫ₗ</code> for <code>trans</code>). (Note that this is only provided to fix occasional elaboration issues and we don't necessarily expect this to replace <code>comp</code> and <code>trans</code>.)</li>
</ol>
</blockquote>



<a name="250950479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250950479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250950479">(Aug 27 2021 at 15:40)</a>:</h4>
<p>I guess the notation hack </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">f</span> <span class="bp">`∘'`</span> <span class="o">:=</span> <span class="n">f.comp</span>
</code></pre></div>
<p>will not help at all with this elaboration issue...</p>



<a name="250959686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250959686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250959686">(Aug 27 2021 at 16:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/Semilinear.20maps/near/250912334">said</a>:</p>
<blockquote>
<p>I'm in favour of making this change, but it would be good to try to align the notation as much as possible with the notation used in the category theory library.</p>
</blockquote>
<p>Did you have any specific suggestion in mind? In any case I agree; in fact I picked <code> ≫ₗ </code> for <code>trans</code> precisely to look like the category theory notation.</p>



<a name="250959943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250959943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250959943">(Aug 27 2021 at 16:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/Semilinear.20maps/near/250950479">said</a>:</p>
<blockquote>
<p>I guess the notation hack </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">f</span> <span class="bp">`∘'`</span> <span class="o">:=</span> <span class="n">f.comp</span>
</code></pre></div>
<p>will not help at all with this elaboration issue...</p>
</blockquote>
<p>Not yet :-) But in the upcoming main PR, it will be changed to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">infixr</span> <span class="bp">`</span> <span class="bp">∘ₗ</span> <span class="bp">`</span><span class="o">:</span><span class="mi">80</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">linear_map.comp</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span>
  <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">_</span><span class="o">)</span> <span class="n">ring_hom_comp_triple.ids</span>
</code></pre></div>
<p>to hardcode the fact that both maps involved are plain linear maps.</p>



<a name="250967236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250967236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250967236">(Aug 27 2021 at 17:41)</a>:</h4>
<p>Doesn't category theory use something like <code>&lt;&lt;&gt;&gt;</code> (but then the fancy unicode variant)?</p>



<a name="250967317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250967317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250967317">(Aug 27 2021 at 17:41)</a>:</h4>
<p>See right after <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.iso.trans/src">src#category_theory.iso.trans</a></p>



<a name="250971172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/250971172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#250971172">(Aug 27 2021 at 18:08)</a>:</h4>
<p>I see! I took my inspiration from <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.category_struct/src">src#category_theory.category_struct</a>. Maybe the other one would be better.</p>



<a name="251221712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/251221712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#251221712">(Aug 30 2021 at 12:28)</a>:</h4>
<p>I have now changed the notation for <code>trans</code> to <code>≪≫ₗ</code>.</p>



<a name="252170559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/252170559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#252170559">(Sep 06 2021 at 12:48)</a>:</h4>
<p>People have had a week to complain, so now the notation is consistent, I'm going ahead and merging the PR.</p>



<a name="252287109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/252287109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#252287109">(Sep 07 2021 at 11:10)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> I'm doing some preliminary experiments with a <code>is_tensor_product</code> class. So far I'm mostly amazed by how often tensor products have already been used/imported in mathlib.</p>



<a name="253906363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Semilinear%20maps/near/253906363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Semilinear.20maps.html#253906363">(Sep 19 2021 at 01:12)</a>:</h4>
<p>I have now created the main PR for this: <a href="https://github.com/leanprover-community/mathlib/issues/9272">#9272</a>. The main change since the discussion here is that we made it work with <code>ring_hom</code>s instead of <code>ring_equiv</code>s. The diff looks huge but it's not as bad as it looks: almost all of the meat is in <code>algebra/module/basic</code> and <code>linear_algebra/basic</code>, and the rest is small routine fixes.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
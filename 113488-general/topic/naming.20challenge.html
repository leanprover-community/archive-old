---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/naming.20challenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html">naming challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="247862123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/247862123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#247862123">(Aug 01 2021 at 14:43)</a>:</h4>
<p>How should I (re)name this concept?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/--</span>
<span class="sd">An element `a : Î±` is `regular` (name subject to change) if `x â†¦ a + x` is order-reflecting.</span>
<span class="sd">We will make a separate version of lemmas that require `[contravariant_class Î± Î± (+) (â‰¤)]` with</span>
<span class="sd">`regular` assumptions instead. These can then be easily instantiated to specific types, like</span>
<span class="sd">`ennreal`, where we can replace the assumption `regular x` by `x â‰  âˆ`.</span>
<span class="sd">-/</span>
<span class="kd">def</span> <span class="n">regular</span> <span class="o">{</span><span class="n">Î±</span><span class="o">}</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">Î±</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">âˆ€</span> <span class="o">â¦ƒ</span><span class="n">x</span> <span class="n">y</span><span class="o">â¦„,</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">â‰¤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">â†’</span> <span class="n">x</span> <span class="bp">â‰¤</span> <span class="n">y</span>
</code></pre></div>



<a name="247864120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/247864120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#247864120">(Aug 01 2021 at 15:37)</a>:</h4>
<p>How about <code>cancellable</code>? Or <code>add_le_cancellable</code> (if the relation is <code>â‰¤</code> and operation is <code>+</code>)? Or <code>rel_cancellable</code> (if the same name is to be used for many relations)?</p>
<p>I am not very familiar yet with the naming conventions, but I thought having various suggestions to consider can hardly hurt <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span>.</p>



<a name="247864409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/247864409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kalle KytÃ¶lÃ¤ <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#247864409">(Aug 01 2021 at 15:45)</a>:</h4>
<p>The term "regular" would of course be following a time-honored tradition in math naming conventions for just about anything... By which I mean: I hope mathlib will <em>not</em> adopt it in this case! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="247883438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/247883438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#247883438">(Aug 02 2021 at 00:00)</a>:</h4>
<p>I think I'll go for <code>add_le_cancellable</code>. Thanks for the suggestions.</p>



<a name="247937646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/247937646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#247937646">(Aug 02 2021 at 16:15)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> pointed out in <a href="https://github.com/leanprover-community/mathlib/issues/8503">#8503</a> that lean actually already has a notion of <a href="https://leanprover-community.github.io/mathlib_docs/find/is_left_regular">docs#is_left_regular</a> (added by <span class="user-mention" data-user-id="321459">@Damiano Testa</span>). Interestingly, that definition doesn't have<code>@[to_additive]</code>. We could try to make these definitions more closely connected, for example by calling the both <code>is_[left|right]_[mul|add]_[le_]_cancellable</code> or both <code>is_[left|right]_[mul|add]_[le_]_regular</code></p>



<a name="248179498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/248179498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#248179498">(Aug 03 2021 at 03:49)</a>:</h4>
<p>(deleted)</p>



<a name="248179603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/248179603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#248179603">(Aug 03 2021 at 03:51)</a>:</h4>
<p>I like the idea of connecting the two notions: it is a common trick to prove injectivity by showing strict monotonicity!</p>
<p>As for the name, I chose <code>regular</code> because I was thinking of using this for regular elements and regular sequences in commutative algebra.  For this same reason, it had not occurred to me to do the same for additive.  Also, at the time of the PR I was less "Lean-mature" and was not aware of the <code>to_additive</code> attribute.</p>
<p>In fact, following up on a comment by Eric, it seems to make sense to define <code>co(ntra)variant</code> as <code>âˆ€ (m), analogue_of_mul_le_cancellable_with_explicit_m_input</code>.</p>



<a name="249584866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/249584866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#249584866">(Aug 16 2021 at 12:58)</a>:</h4>
<p>Anyone have a nice idea how to give these two definitions distinct, but not too long, names in <a href="https://github.com/leanprover-community/mathlib/issues/8514">#8514</a>? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Given `P 0`, `P 1`, and `P (p ^ k)` for positive prime powers, and a way to extend `P a` and</span>
<span class="sd">`P b` to `P (a * b)` when `a, b` are coprime, you can define `P` for all natural numbers. -/</span>
<span class="kd">@[elab_as_eliminator]</span>
<span class="kd">def</span> <span class="n">rec_on_coprime'</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">â„•</span> <span class="bp">â†’</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">p</span> <span class="n">n</span> <span class="o">:</span> <span class="n">â„•</span><span class="o">,</span> <span class="n">prime</span> <span class="n">p</span> <span class="bp">â†’</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">â†’</span> <span class="n">P</span> <span class="o">(</span><span class="n">p</span> <span class="bp">^</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">coprime</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">â†’</span> <span class="n">P</span> <span class="n">a</span> <span class="bp">â†’</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">â†’</span> <span class="n">P</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">a</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">rec_on_prime_pow</span> <span class="n">h0</span> <span class="n">h1</span> <span class="bp">$</span> <span class="bp">Î»</span> <span class="n">a</span> <span class="n">p</span> <span class="n">n</span> <span class="n">hp'</span> <span class="n">hpa</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">h</span> <span class="o">(</span><span class="n">p</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="o">((</span><span class="n">prime.coprime_pow_of_not_dvd</span> <span class="n">hp'</span> <span class="n">hpa</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span>
  <span class="o">(</span><span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">eq.rec</span> <span class="n">h1</span> <span class="n">h.symm</span> <span class="k">else</span> <span class="n">hp</span> <span class="n">p</span> <span class="n">n</span> <span class="n">hp'</span> <span class="bp">$</span> <span class="n">nat.pos_of_ne_zero</span> <span class="n">h</span><span class="o">)</span> <span class="n">ha</span>

<span class="sd">/-- Given `P 0`, `P (p ^ k)` for all prime powers, and a way to extend `P a` and `P b` to</span>
<span class="sd">`P (a * b)` when `a, b` are coprime, you can define `P` for all natural numbers. -/</span>
<span class="kd">@[elab_as_eliminator]</span>
<span class="kd">def</span> <span class="n">rec_on_coprime</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">â„•</span> <span class="bp">â†’</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">p</span> <span class="n">n</span> <span class="o">:</span> <span class="n">â„•</span><span class="o">,</span> <span class="n">prime</span> <span class="n">p</span> <span class="bp">â†’</span> <span class="n">P</span> <span class="o">(</span><span class="n">p</span> <span class="bp">^</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">coprime</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">â†’</span> <span class="n">P</span> <span class="n">a</span> <span class="bp">â†’</span> <span class="n">P</span> <span class="n">b</span> <span class="bp">â†’</span> <span class="n">P</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="bp">âˆ€</span> <span class="n">a</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">rec_on_coprime'</span> <span class="o">(</span><span class="bp">Î»</span> <span class="n">p</span> <span class="n">n</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span> <span class="n">hp</span> <span class="n">p</span> <span class="n">n</span> <span class="n">h</span><span class="o">)</span> <span class="n">h0</span> <span class="o">(</span><span class="n">hp</span> <span class="mi">2</span> <span class="mi">0</span> <span class="n">prime_two</span><span class="o">)</span> <span class="n">h</span>
</code></pre></div>



<a name="249591383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/249591383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#249591383">(Aug 16 2021 at 13:54)</a>:</h4>
<p>Swapping the order of the arguments in the first one so that <code>hp</code> comes after <code>h1</code> would make it easier to tell what the difference is!</p>



<a name="249591407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/249591407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#249591407">(Aug 16 2021 at 13:55)</a>:</h4>
<p><code>rec_on_prime_coprime</code> and <code>rec_on_pos_prime_coprime</code>?</p>



<a name="273630949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273630949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273630949">(Mar 01 2022 at 12:15)</a>:</h4>
<p>Anyone have any ideas to name the following linear maps?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">name_me1</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">E'</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="o">(</span><span class="n">E''</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">E'</span><span class="o">)</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="o">(</span><span class="n">E''</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">continuous_linear_map.compL</span> <span class="bp">ğ•œ</span> <span class="n">E''</span> <span class="n">E'</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">L</span>

<span class="kd">def</span> <span class="n">name_me2</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">E'</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">E''</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">E</span><span class="o">)</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">E'</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="o">(</span><span class="n">E''</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">precompR</span> <span class="n">E''</span> <span class="o">(</span><span class="n">flip</span> <span class="n">L</span><span class="o">))</span><span class="bp">.</span><span class="n">flip</span>
</code></pre></div>



<a name="273633684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273633684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273633684">(Mar 01 2022 at 12:39)</a>:</h4>
<p>Can you include the <code>simps</code> lemma they generate too?</p>



<a name="273635676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273635676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273635676">(Mar 01 2022 at 12:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">á¾°</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="bp">â‡‘</span><span class="o">(</span><span class="n">name_me1</span> <span class="n">E''</span> <span class="n">L</span><span class="o">)</span> <span class="n">á¾°</span> <span class="bp">=</span> <span class="bp">â‡‘</span><span class="o">(</span><span class="n">compL</span> <span class="bp">ğ•œ</span> <span class="n">E''</span> <span class="n">E'</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="bp">â‡‘</span><span class="n">L</span> <span class="n">á¾°</span><span class="o">)</span>
<span class="o">(</span><span class="n">á¾°</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">E''</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">E'</span><span class="o">)</span> <span class="o">:</span> <span class="bp">â‡‘</span><span class="o">(</span><span class="bp">â‡‘</span><span class="o">(</span><span class="n">name_me1</span> <span class="n">E''</span> <span class="n">L</span><span class="o">)</span> <span class="n">á¾°</span><span class="o">)</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">â‡‘</span><span class="n">L</span> <span class="n">á¾°</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">f</span>
<span class="o">(</span><span class="n">á¾°</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">E''</span> <span class="bp">â†’</span><span class="n">L</span><span class="o">[</span><span class="bp">ğ•œ</span><span class="o">]</span> <span class="n">E'</span><span class="o">)</span> <span class="o">(</span><span class="n">á¾°_1</span> <span class="o">:</span> <span class="n">E''</span><span class="o">)</span> <span class="o">:</span> <span class="bp">â‡‘</span><span class="o">(</span><span class="bp">â‡‘</span><span class="o">(</span><span class="bp">â‡‘</span><span class="o">(</span><span class="n">name_me1</span> <span class="n">E''</span> <span class="n">L</span><span class="o">)</span> <span class="n">á¾°</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="n">á¾°_1</span> <span class="bp">=</span> <span class="bp">â‡‘</span><span class="o">(</span><span class="bp">â‡‘</span><span class="n">L</span> <span class="n">á¾°</span><span class="o">)</span> <span class="o">(</span><span class="bp">â‡‘</span><span class="n">f</span> <span class="n">á¾°_1</span><span class="o">)</span>
</code></pre></div>



<a name="273636613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273636613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273636613">(Mar 01 2022 at 13:03)</a>:</h4>
<p>I'm thinking of something like <code>precompose_right</code> / <code>precompose_left</code>, since we're precomposing the function <code>E'' â†’L[ğ•œ] E'</code> on the right/left argument.</p>



<a name="273637914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273637914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273637914">(Mar 01 2022 at 13:15)</a>:</h4>
<p>Maybe <code>compLâ‚‚</code> for the first one to be consistent with <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map">docs#linear_map</a>.complâ‚‚ ? your second map should correspond to <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map">docs#linear_map</a>.comprâ‚‚</p>



<a name="273646267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273646267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273646267">(Mar 01 2022 at 14:11)</a>:</h4>
<p>Those are indeed very close, my maps have the second linear map bundled. <br>
<code>flip (name_me1 L) f</code> is basically the same as <code>linear_map.complâ‚‚ L f</code> (up to continuity and semilinearity).</p>



<a name="273649276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273649276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273649276">(Mar 01 2022 at 14:32)</a>:</h4>
<p>I think it would be a good idea if the API of bilinear maps and continuous bilinear maps would be as close as possible, but I also think that the bundled definitions are better then <code>linear_map.complâ‚‚ L f</code> (btw please change your linear map from L to B, it is really confusing with the L from the clm notation).</p>



<a name="273649355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273649355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273649355">(Mar 01 2022 at 14:33)</a>:</h4>
<p>but there is already diverging notation with <code>continuous_linear_map.compL</code> and <code>linear_map.lcomp</code>.</p>



<a name="273649429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273649429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273649429">(Mar 01 2022 at 14:33)</a>:</h4>
<p>(deleted)</p>



<a name="273659071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273659071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273659071">(Mar 01 2022 at 15:37)</a>:</h4>
<p>Sometimes I wonder if we're shooting ourselves in the foot with this heavy point-free approach, and would do better to just write <code>\lam a f x, L a (f x)</code> and use some <code>linearity</code> tactic to find the linearity proof automatically.</p>



<a name="273708901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273708901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273708901">(Mar 01 2022 at 20:57)</a>:</h4>
<p>Indeed all this doesn't exist on paper, and we certainly want to keep it that way on paper.</p>



<a name="273787581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/273787581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#273787581">(Mar 02 2022 at 10:52)</a>:</h4>
<p>This sounds like some abstract nonsense that does exist in cartesian closed categories (possibly with some extra structure).</p>



<a name="282267098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/282267098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#282267098">(May 13 2022 at 15:54)</a>:</h4>
<p>/poll What statement would people expect for the name <code>equiv.subtype_congr</code>?<br>
<code>{Î±} {p q : Î± â†’ Prop} (e : {x // p x} â‰ƒ {x // q x}) (f : {x // Â¬p x} â‰ƒ {x // Â¬q x}) : perm Î±</code><br>
<code>(e : Î±â‚ â‰ƒ Î±â‚‚) (p : Î±â‚‚ â†’ Prop) : {aâ‚ // (p âˆ˜ e) aâ‚} â‰ƒ {aâ‚‚ // p aâ‚‚}</code></p>



<a name="282267196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/282267196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#282267196">(May 13 2022 at 15:55)</a>:</h4>
<p>answer: <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_congr">docs#equiv.subtype_congr</a><br>
bonus: what would you call the other? (I'm making the one of these that isn't in mathlib already and not sure what name to give it if not that)</p>



<a name="282269632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/282269632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#282269632">(May 13 2022 at 16:11)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_equiv">docs#equiv.subtype_equiv</a> is one of the other ones</p>



<a name="282269883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/282269883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#282269883">(May 13 2022 at 16:13)</a>:</h4>
<p>I think the current <code>equiv.subtype_congr</code> should be called <code>equiv.subtype_piecewise</code>?</p>



<a name="282269934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/282269934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#282269934">(May 13 2022 at 16:13)</a>:</h4>
<p>I was rewriting option 3 as I didn't think of it, d'ah!</p>



<a name="282270068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/282270068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#282270068">(May 13 2022 at 16:14)</a>:</h4>
<p>Or maybe even just <code>equiv.piecewise</code></p>



<a name="282270107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/282270107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#282270107">(May 13 2022 at 16:15)</a>:</h4>
<p>oh, I think my proof is nicer so I'll PR that (no non-terminal simps :]) I currently don't have a good computer though, so I will refactor the names when I get to a good computer</p>



<a name="282270791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/282270791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#282270791">(May 13 2022 at 16:20)</a>:</h4>
<p>Option 1 looks like a <code>perm.subtype_piecewise</code> to me.  I would expect <code>equiv.subtype_piecewise</code> to be <code>{Î± Î²} {p : Î± â†’ Prop} {q : Î² â†’ Prop} (e : { a // p a } â‰ƒ { b // q b }) (f : { a // Â¬ p a } â‰ƒ { b // Â¬ q b }) : Î± â‰ƒ Î²</code>.</p>



<a name="282271227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/282271227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#282271227">(May 13 2022 at 16:23)</a>:</h4>
<p>oh, and option 2 is <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_equiv_of_subtype">docs#equiv.subtype_equiv_of_subtype</a></p>



<a name="282271609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/282271609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#282271609">(May 13 2022 at 16:26)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/14125">#14125</a></p>



<a name="283177882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283177882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283177882">(May 21 2022 at 15:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> <a href="#narrow/stream/113488-general/topic/naming.20challenge/near/282271227">said</a>:</p>
<blockquote>
<p>oh, and option 2 is <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_equiv_of_subtype">docs#equiv.subtype_equiv_of_subtype</a></p>
</blockquote>
<p>what should this be called? I don't like this name but not sure what a better one would be</p>



<a name="283179182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283179182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> YaÃ«l Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283179182">(May 21 2022 at 15:31)</a>:</h4>
<p>I rarely see stuff in the <code>equiv.subty</code> namespace <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span></p>



<a name="283319064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283319064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283319064">(May 23 2022 at 13:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/naming.20challenge/near/273659071">said</a>:</p>
<blockquote>
<p>Sometimes I wonder if we're shooting ourselves in the foot with this heavy point-free approach, and would do better to just write <code>\lam a f x, L a (f x)</code> and use some <code>linearity</code> tactic to find the linearity proof automatically.</p>
</blockquote>
<p>I worked on this a little bit recently. If you use every bound variable exactly once then the map will be linear. I have some very untidy code taking lambda terms and turning them into terms using linear composition and swap, which swaps the arguments of a bilinear map.</p>



<a name="283319634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283319634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> YaÃ«l Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283319634">(May 23 2022 at 13:36)</a>:</h4>
<p><del>You can replace "exactly once", by "at most once", right?</del> not for linearity, but for affine maps yes</p>



<a name="283320357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283320357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283320357">(May 23 2022 at 13:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110044">Chris Hughes</span> <a href="#narrow/stream/113488-general/topic/naming.20challenge/near/283319064">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/naming.20challenge/near/273659071">said</a>:</p>
<blockquote>
<p>Sometimes I wonder if we're shooting ourselves in the foot with this heavy point-free approach, and would do better to just write <code>\lam a f x, L a (f x)</code> and use some <code>linearity</code> tactic to find the linearity proof automatically.</p>
</blockquote>
<p>I worked on this a little bit recently. If you use every bound variable exactly once then the map will be linear. I have some very untidy code taking lambda terms and turning them into terms using linear composition and swap.</p>
</blockquote>
<p>I wonder how much Lean 4 will help us with this. I also want to be able to write down functors with lambda calculus, but making sure I end up with a term I can actually use.</p>



<a name="283337336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283337336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283337336">(May 23 2022 at 15:41)</a>:</h4>
<p>I would have thought we could just copy the design of <code>continuity</code></p>



<a name="283337386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283337386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283337386">(May 23 2022 at 15:41)</a>:</h4>
<p>Which would mean using <a href="https://leanprover-community.github.io/mathlib_docs/find/is_linear_map">docs#is_linear_map</a> a lot more</p>



<a name="283341678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283341678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283341678">(May 23 2022 at 16:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/naming.20challenge/near/283337336">said</a>:</p>
<blockquote>
<p>I would have thought we could just copy the design of <code>continuity</code></p>
</blockquote>
<p>I'm not at all sure that this is the same problem. You don't need to have a library of tagged lemmas, the condition is that every bound variable is used exactly once; this never changes. The linearity of the functions is part of the type, there's no need for a search for lemmas. And I don't think it can be solved just by applying lemmas. I'm not sure what lemma you would apply first to prove linearity of something like <code>\la f g x y, g y (f x)</code>.</p>



<a name="283341888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283341888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283341888">(May 23 2022 at 16:15)</a>:</h4>
<p>I'm thinking of a more general case like showing <code>\la p, matrix.trace (f p.1 + g p.2)</code> is linear</p>



<a name="283343834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283343834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283343834">(May 23 2022 at 16:30)</a>:</h4>
<p>Okay. I think that you need a combination of both. The method I had in mind would prove that <code>\la p1 p2, trace (add (f p1) (g p2)) </code> is linear if trace, add, f and g were all bundled linear maps. But you need something else to figure out addition is bilinear and to case split on p.</p>



<a name="283344130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283344130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283344130">(May 23 2022 at 16:32)</a>:</h4>
<p>So I guess you need something like continuity, but because the category of modules is monoidal closed you can add more things that continuity won't do currently like proving linearity of <code>\la f g x y g y (f x)</code></p>



<a name="283345153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283345153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283345153">(May 23 2022 at 16:39)</a>:</h4>
<p>Not really a case split on p, just noting that <code>prod.fst</code> is a linear map</p>



<a name="283702870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283702870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283702870">(May 24 2022 at 06:38)</a>:</h4>
<p>It's a bit more complicated than that because <code>p</code> appears twice in the term which usually means the map isn't linear but somehow this one works and to be honest I'm not sure exactly what the general rule is that this is a special case of that means it's linear despite <code>p</code> appearing twice.</p>



<a name="283708371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283708371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283708371">(May 24 2022 at 07:50)</a>:</h4>
<p>Isn't it just the rule that <code>f x + g x</code> is linear in x if both f and g are?</p>



<a name="283710820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283710820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> YaÃ«l Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283710820">(May 24 2022 at 08:15)</a>:</h4>
<p>Isn't the rule "appears exactly once per summand"?</p>



<a name="283711157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283711157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283711157">(May 24 2022 at 08:18)</a>:</h4>
<p>My thinking was that the above would be found in the same way that <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous.add">docs#continuous.add</a> is found today</p>



<a name="283711189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283711189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283711189">(May 24 2022 at 08:19)</a>:</h4>
<p>There's no need for a notion of summands</p>



<a name="283720316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283720316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283720316">(May 24 2022 at 09:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">YaÃ«l Dillies</span> <a href="#narrow/stream/113488-general/topic/naming.20challenge/near/283710820">said</a>:</p>
<blockquote>
<p>Isn't the rule "appears exactly once per summand"?</p>
</blockquote>
<p>It works I guess because addition is actually linear rather than bilinear. There's a map of type <code>(A â†’â‚—[R] B) â†’ (A â†’â‚—[R] C) â†’ (A â†’â‚—[R] B Ã— C)</code>, called <code>linear_map.prod</code>. So if there was a version of <code>add</code> with type <code>A Ã— A â†’â‚—[R] A</code>, you could rewrite <code>\la p, trace (f p.1 + g p.2)</code> as <code>\la p, trace (add (linear_map.prod (f.comp prod.fst) (g.comp prod.snd) p))</code> and that can be proven linear using the rule about using every bound variable exactly once.</p>



<a name="283721177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/naming%20challenge/near/283721177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/naming.20challenge.html#283721177">(May 24 2022 at 09:54)</a>:</h4>
<p>So I would prefer to use a rewrite rule instead of something similar to <code>continuous_add</code> to rewrite addition in terms of bundled linear maps, because this allows the more powerful automation to be used afterwards. The earlier example of <code>\lam a f x, L a (f x)</code> probably can't be proven linear using the same approach as the continuity tactic, linearity is really a harder problem than continuity because the space of linear maps is a vector space.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
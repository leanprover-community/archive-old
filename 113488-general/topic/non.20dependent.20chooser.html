---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/non.20dependent.20chooser.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html">non dependent chooser</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206680732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206680732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206680732">(Aug 12 2020 at 10:57)</a>:</h4>
<p>Dear expert tactic writers, a couple of years ago, I wrote the first version of the <code>choose</code> tactic. It was a very simple wrapper around <code>classical.some</code> and <code>classical.some_spec</code>, but already very useful for mathematicians. Very quickly, Johannes made it much more general so that it's more useful but I probably lost hope to understand the code. Now I would need a new version and I don't know what to do (I could build an independent stupid version but it would probably be better to integrate it as an option to <code>choose</code>). The situation that came up several times recently is this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">Q</span> <span class="o">:</span><span class="n">Y</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="n">def</span> <span class="n">bad_chooser</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">Q</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">h</span> <span class="n">x</span> <span class="n">hx</span>

<span class="kn">lemma</span> <span class="n">choose_aux</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">Q</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">h</span> <span class="n">x</span> <span class="n">hx</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">y</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">hy</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">inhabit</span> <span class="n">Y</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">default</span> <span class="n">Y</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">chooser</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">Q</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">choose_aux</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">chooser_spec</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">Q</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Q</span> <span class="o">(</span><span class="n">chooser</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">choose_aux</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>


<p>The issue with <code>bad_chooser</code> is that the dependent function type is often less convenient to use as the version offered by the last two declarations. And <code>choose f hf using h</code> currently gives the bad version.</p>



<a name="206680821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206680821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206680821">(Aug 12 2020 at 10:58)</a>:</h4>
<p>Let me ping <span class="user-mention" data-user-id="268315">@Anatole Dedecker</span> since he is the latest one to have stumbled on this.</p>



<a name="206682970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206682970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206682970">(Aug 12 2020 at 11:29)</a>:</h4>
<p>Actually the above version is already not general enough, I should have written:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">Q</span> <span class="o">:</span><span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">classical</span><span class="bp">.</span><span class="n">choose_aux</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">h</span> <span class="n">x</span> <span class="n">hx</span> <span class="k">with</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">y</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">hy</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">inhabit</span> <span class="n">Y</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">default</span> <span class="n">Y</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="n">noncomputable</span>
<span class="n">def</span> <span class="n">classical</span><span class="bp">.</span><span class="n">chooser</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">choose_aux</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">classical</span><span class="bp">.</span><span class="n">chooser_spec</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">x</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">chooser</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">choose_aux</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="206683100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206683100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206683100">(Aug 12 2020 at 11:30)</a>:</h4>
<p>Anatole, while waiting for a potential improved version of <code>choose</code>, you can put those functions and lemmas somewhere and then in your proof, use:</p>
<div class="codehilite"><pre><span></span><code>  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">Ioo</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">c</span> <span class="err">∈</span> <span class="n">Ioo</span> <span class="n">a</span> <span class="n">x</span><span class="o">,</span>  <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">g&#39;</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="n">c</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">sub_zero</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">),</span> <span class="err">←</span> <span class="n">sub_zero</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)],</span>
    <span class="n">exact</span> <span class="n">exists_ratio_has_deriv_at_eq_ratio_slope&#39;</span> <span class="n">g</span> <span class="n">g&#39;</span> <span class="n">hx</span><span class="bp">.</span><span class="mi">1</span> <span class="n">f</span> <span class="n">f&#39;</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hgg&#39;</span> <span class="n">y</span> <span class="err">$</span> <span class="n">sub</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hff&#39;</span> <span class="n">y</span> <span class="err">$</span> <span class="n">sub</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">)</span> <span class="n">hga</span> <span class="n">hfa</span>
      <span class="o">(</span><span class="n">tendsto_nhds_within_of_tendsto_nhds</span> <span class="o">(</span><span class="n">hgg&#39;</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">continuous_at</span><span class="bp">.</span><span class="n">tendsto</span><span class="o">)</span>
      <span class="o">(</span><span class="n">tendsto_nhds_within_of_tendsto_nhds</span> <span class="o">(</span><span class="n">hff&#39;</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span><span class="bp">.</span><span class="n">continuous_at</span><span class="bp">.</span><span class="n">tendsto</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">simp_rw</span> <span class="n">exists_prop</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">chooser</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hc</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">chooser_spec</span> <span class="n">this</span><span class="o">,</span>
</code></pre></div>



<a name="206683255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206683255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206683255">(Aug 12 2020 at 11:33)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> proposed another feature for <code>choose</code> in <a href="https://github.com/leanprover-community/mathlib/issues/3699">#3699</a>, if he does that then maybe this could happen at the same time.</p>



<a name="206683585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206683585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206683585">(Aug 12 2020 at 11:39)</a>:</h4>
<p>Maybe it would be better to treat this as two operations, <code>choose</code> with the current behavior followed by <code>extend</code> which extends a partial function to a total one</p>



<a name="206685191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206685191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206685191">(Aug 12 2020 at 12:03)</a>:</h4>
<p>I agree with both Rob and Reid. I'll experiment with Reid's version, but I need to disappear for one day and a half.</p>



<a name="206688439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206688439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206688439">(Aug 12 2020 at 12:43)</a>:</h4>
<p>Reid, did you mean some version of:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">extend</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">P</span> <span class="n">x</span> <span class="k">then</span> <span class="n">f</span> <span class="n">x</span> <span class="n">hx</span> <span class="k">else</span> <span class="n">default</span> <span class="n">Y</span>

<span class="n">def</span> <span class="n">chooser&#39;</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">Q</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="n">extend</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">h</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">chooser_spec&#39;</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">Q</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">Q</span> <span class="o">(</span><span class="n">chooser&#39;</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">chooser&#39;</span><span class="o">,</span> <span class="n">extend</span><span class="o">,</span> <span class="n">hx</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span>
<span class="kn">end</span>
</code></pre></div>


<p>and now I really leave (I'll read Zulip but won't have Lean for one day and a half).</p>



<a name="206688764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206688764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206688764">(Aug 12 2020 at 12:47)</a>:</h4>
<p>any ideas on syntax? I think I know how this can be implemented, but the new strategy requires <code>Y</code> to be inhabited/has_zero/nonempty</p>



<a name="206689081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206689081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206689081">(Aug 12 2020 at 12:51)</a>:</h4>
<p>For example <code>choose! f hf using h</code> will do the same thing as <code>choose</code> but it will remove all propositional arguments from <code>f</code> using a default value that it magics up somehow</p>



<a name="206689231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206689231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206689231">(Aug 12 2020 at 12:52)</a>:</h4>
<p>the under the hood implementation can be as reid says, but I think it would be nicer from the user point of view to be able to do both parts in one tactic call</p>



<a name="206690493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206690493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206690493">(Aug 12 2020 at 13:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I'm imagining something along the following lines--not sure how feasible this is to implement:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- α β : Type</span>
<span class="c1">-- y : β</span>
<span class="c1">-- P : α → Prop</span>
<span class="c1">-- Q : β → Prop</span>
<span class="c1">-- f : Π (x : α), P x → β</span>
<span class="c1">-- hf : ∀ (x : α) (H : P x), Q (f x H)</span>

<span class="n">extend</span> <span class="n">f</span> <span class="o">[</span><span class="kn">using</span> <span class="n">y</span><span class="o">]</span> <span class="o">[</span><span class="k">with</span> <span class="n">hf&#39;</span><span class="o">],</span>

<span class="c1">-- f : α → β</span>
<span class="c1">-- hf : ∀ (x : α), P x → Q (f x)</span>
<span class="c1">-- hf&#39; : ∀ (x : α), (¬ P x) → f x = y</span>
</code></pre></div>



<a name="206690762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206690762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206690762">(Aug 12 2020 at 13:06)</a>:</h4>
<p>how would you present the negative case if <code>f</code> had several propositional arguments (which I assume are all getting deleted)?</p>



<a name="206690833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206690833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206690833">(Aug 12 2020 at 13:07)</a>:</h4>
<p>also, <code>y</code> could be a function</p>



<a name="206693044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206693044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206693044">(Aug 12 2020 at 13:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113488-general/topic/non.20dependent.20chooser/near/206683100">said</a>:</p>
<blockquote>
<p>Anatole, while waiting for a potential improved version of <code>choose</code>, you can put those functions and lemmas somewhere and then in your proof, use [...]</p>
</blockquote>
<p>I know Patrick can't answer now, but what would be a good place to put this into the library ?</p>



<a name="206869273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206869273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206869273">(Aug 13 2020 at 20:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/non.20dependent.20chooser/near/206689081">said</a>:</p>
<blockquote>
<p>For example <code>choose! f hf using h</code> will do the same thing as <code>choose</code> but it will remove all propositional arguments from <code>f</code> using a default value that it magics up somehow. the under the hood implementation can be as reid says, but I think it would be nicer from the user point of view to be able to do both parts in one tactic call</p>
</blockquote>
<p>This all sounds perfect to me. My initial reaction to <code>choose!</code> was: no the exclamation mark means "try harder", but I managed to convinced myself that eliminating propositional arguments was trying harder to make a (non-dependent) function.</p>



<a name="206869660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/206869660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#206869660">(Aug 13 2020 at 20:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="268315">Anatole Dedecker</span> <a href="#narrow/stream/113488-general/topic/non.20dependent.20chooser/near/206693044">said</a>:</p>
<blockquote>
<blockquote>
<p>Anatole, while waiting for a potential improved version of <code>choose</code>, you can put those functions and lemmas somewhere and then in your proof, use [...]</p>
</blockquote>
<p>I know Patrick can't answer now, but what would be a good place to put this into the library ?</p>
</blockquote>
<p>It could be in <code>logic.function.basic</code> but if Mario says he can merge it into the <code>choose</code> tactic soon then he will handle that. In any case I think we need the definition and lemma outside of the tactic, since we can want to use it in term mode definitions.</p>



<a name="207028251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/207028251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#207028251">(Aug 15 2020 at 16:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> could you tell whether you intend to work on this improvement to <code>choose</code> in the near future? We need to decide whether <a href="https://github.com/leanprover-community/mathlib/issues/3740">#3740</a> is waiting for this.</p>



<a name="207028317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/207028317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#207028317">(Aug 15 2020 at 16:22)</a>:</h4>
<p>Sure, I will look into it</p>



<a name="207028328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/207028328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#207028328">(Aug 15 2020 at 16:22)</a>:</h4>
<p>Oh yeah I completely forgot to make a PR for Patrick's lemmas, sorry :(</p>



<a name="207028378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/207028378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#207028378">(Aug 15 2020 at 16:24)</a>:</h4>
<p>Mario doesn't need us to prove those lemmas, this is negligible compared to the tactic side.</p>



<a name="207037903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/207037903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#207037903">(Aug 15 2020 at 20:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span> <a href="https://github.com/leanprover-community/mathlib/issues/3806">#3806</a></p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">∃</span><span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">i</span> <span class="bp">∨</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">j</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">choose</span><span class="bp">!</span> <span class="n">i</span> <span class="n">j</span> <span class="n">h</span> <span class="kn">using</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">guard_hyp</span> <span class="n">i</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span>
  <span class="n">guard_hyp</span> <span class="n">j</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span>
  <span class="n">guard_hyp</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">i</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">∨</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">j</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kn">end</span>
</code></pre></div>



<a name="207126587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/207126587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#207126587">(Aug 17 2020 at 10:16)</a>:</h4>
<p>I tried to use the new choose to streamline the proof of Baire theorem, and it seems to me that this use case is not covered by the new version. The issue is that the type might be empty, but in the choosing process there is a universal quantification over this type, so if the type is empty everything becomes trivial. Here is a mwe:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">normed_space</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">lemma</span> <span class="n">zou</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">F</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span> <span class="o">(</span><span class="n">F</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">q</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">hx</span><span class="o">]</span> <span class="kn">using</span> <span class="n">h</span> <span class="n">x</span> <span class="n">hx</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">x</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">choose</span> <span class="n">F</span> <span class="n">hF</span> <span class="kn">using</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="bp">⟨</span><span class="n">F</span><span class="o">,</span> <span class="n">hF</span><span class="bp">⟩</span>
<span class="kn">end</span>
</code></pre></div>


<p>I would like to be able to <code>choose! F hF using h</code>, but <code>α</code> might be empty.</p>



<a name="207128842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/207128842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#207128842">(Aug 17 2020 at 10:48)</a>:</h4>
<p>Do you mean you want a special case where the target type appears in the variables as well?</p>



<a name="207134279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/207134279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#207134279">(Aug 17 2020 at 11:59)</a>:</h4>
<p>Yes, when a target type appears in a forall, then the forall variable could be used as a default value (or to inhabit the type). In my mwe, I would like the proof to be</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">choose</span><span class="bp">!</span> <span class="n">F</span> <span class="n">hF</span> <span class="kn">using</span> <span class="n">h</span>
  <span class="n">exact</span> <span class="bp">⟨</span><span class="n">F</span><span class="o">,</span> <span class="n">hF</span><span class="bp">⟩</span>
</code></pre></div>



<a name="207154525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/207154525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#207154525">(Aug 17 2020 at 15:03)</a>:</h4>
<p>coming right up</p>



<a name="207178565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/non%20dependent%20chooser/near/207178565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/non.20dependent.20chooser.html#207178565">(Aug 17 2020 at 18:19)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/3842">#3842</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
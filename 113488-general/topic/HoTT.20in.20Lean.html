---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/HoTT.20in.20Lean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20in.20Lean.html">HoTT in Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="185441871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20in%20Lean/near/185441871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20in.20Lean.html#185441871">(Jan 12 2020 at 17:14)</a>:</h4>
<p><span class="user-mention" data-user-id="233147">@Ulrik Buchholtz</span> I was wondering if you could elaborate a bit on the project you suggested during one of the Lean Together discussions. I didn't quite follow the kind of setup you have in mind.</p>



<a name="185451039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20in%20Lean/near/185451039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20in.20Lean.html#185451039">(Jan 12 2020 at 21:33)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="233147">Ulrik Buchholtz</span> I was wondering if you could elaborate a bit on the project you suggested during one of the Lean Together discussions. I didn't quite follow the kind of setup you have in mind.</p>
</blockquote>
<p>It's not a fully elaborated idea yet, but very roughly, the idea is to work in simplicial sets (or perhaps cubical sets) as a 1-topos model of extensional type theory. There we have meta-propositions and meta-type universes that we can compute with. Then we axiomatize the homotopical structure: the univalent universes of fibrant types closed under homotopy pushouts. This idea has traces to Voevodsky's <a href="https://ncatlab.org/homotopytypetheory/show/Homotopy+Type+System" target="_blank" title="https://ncatlab.org/homotopytypetheory/show/Homotopy+Type+System">HTS</a>, but the new developments in <a href="https://arxiv.org/abs/1705.03307" target="_blank" title="https://arxiv.org/abs/1705.03307">Two-Level Type Theory and Applications</a>, Coquand's <a href="http://www.cse.chalmers.se/~coquand/bishop.pdf" target="_blank" title="http://www.cse.chalmers.se/~coquand/bishop.pdf">Universe of Bishop Sets</a>, as well as <a href="https://hal.inria.fr/hal-01859964" target="_blank" title="https://hal.inria.fr/hal-01859964">Definitional Proof-Irrelevance without K</a> make me hopeful that we can devise rules for specialized univeses of strict propositions (inside the meta-propositions) and strict or Bishop sets mapping to the meta-sets such that these are equivalent to the homotopy propositions and sets, respectively, and with rules for inductive types in these universes with appropriate eliminators, and that all this can be made seamless with metaprogramming. For any type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex"> A </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> with points <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex"> a, b : A </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, we have both an identity type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><msub><mo>=</mo><mi>A</mi></msub><mi>b</mi></mrow><annotation encoding="application/x-tex"> a =_A b </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> (representing identifications/paths) as well as a meta-equality type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><msubsup><mo>=</mo><mi>A</mi><mi>m</mi></msubsup><mi>b</mi></mrow><annotation encoding="application/x-tex"> a=_A^m b </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.939723em;vertical-align:-0.275331em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.424669em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> that is a meta-prop representing equality of cells. There are many possible variations (e.g., using <a href="https://arxiv.org/abs/1712.04864" target="_blank" title="https://arxiv.org/abs/1712.04864">Orton-Pitts</a> style definitions of fibrancy structures in cubical sets), but I was thinking that if we don't care about constructivity, then a relatively simple setup would suffice.</p>



<a name="185516148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20in%20Lean/near/185516148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20in.20Lean.html#185516148">(Jan 13 2020 at 17:38)</a>:</h4>
<p>So is this similar to the setup used in <a href="https://github.com/annenkov/two-level" target="_blank" title="https://github.com/annenkov/two-level">https://github.com/annenkov/two-level</a>?<br>
In particular the intended interpretation of the outer <code>Type</code> is supposed to be a simplicial set, so we cannot use classical reasoning in the outer level, right?<br>
One thing I could not work out is whether we ever add any constants which reinforce the interpretation of <code>Type</code> as specifically simplicial sets, as opposed to any model topos (say) with the expected conditions of fibrancy of sums, fibrant universes, univalent universes etc.</p>



<a name="185517055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20in%20Lean/near/185517055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20in.20Lean.html#185517055">(Jan 13 2020 at 17:48)</a>:</h4>
<p>How would this approach compare to working in the "standard" model where a <code>Type</code> is a set, and defining the internal version of <code>Type</code> to be a simplicial set in the classical sense, and simply proving (okay, it is not so easy, but I also think it's not out of reach) theorems about fibrancy of sums and universes and so on?<br>
Basically my question is: if we had all the model category-theoretic prerequisites for the "model theory" of HoTT in place, how easy would it be to build an "internal HoTT system" that is usable in practice? Would it differ substantially from the approach you are suggesting?</p>



<a name="185590874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20in%20Lean/near/185590874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20in.20Lean.html#185590874">(Jan 14 2020 at 12:30)</a>:</h4>
<blockquote>
<p>So is this similar to the setup used in <a href="https://github.com/annenkov/two-level" target="_blank" title="https://github.com/annenkov/two-level">https://github.com/annenkov/two-level</a>?</p>
</blockquote>
<p>Yes, Danil Annenkov is a co-author of the two-level type theory paper. </p>
<blockquote>
<p>So we cannot use classical reasoning in the outer level, right?</p>
</blockquote>
<p>Not directly, no, but the way I was thinking about it, the outer (meta) level is an “implementation detail” and shouldn't be used for reasoning. So you add axioms about the (univalent, inner) types, but not about the meta-types. That said, with a 1-cohesive modality, you could capture the outermost 1-topos Set that simplicial sets sits 1-cohesively over, and add axioms for that, but that seems unnecessary.</p>
<blockquote>
<p>One thing I could not work out is whether we ever add any constants which reinforce the interpretation of Type as specifically simplicial sets, as opposed to any model topos (say) with the expected conditions of fibrancy of sums, fibrant universes, univalent universes etc.</p>
</blockquote>
<p>Well, we'd add axioms that the inner higher topos has choice, Reedy-limits, Whitehead's principle and sets cover. That should narrow down the Grothendieck <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (\infty,1) </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos models considerably. We could then further add that geometric realization of simplicial sets is surjective.</p>



<a name="185591352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20in%20Lean/near/185591352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ulrik Buchholtz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20in.20Lean.html#185591352">(Jan 14 2020 at 12:36)</a>:</h4>
<blockquote>
<p>How would this approach compare to working in the "standard" model where a <code>Type</code> is a set, and defining the internal version of <code>Type</code> to be a simplicial set in the classical sense, and simply proving (okay, it is not so easy, but I also think it's not out of reach) theorems about fibrancy of sums and universes and so on?<br>
Basically my question is: if we had all the model category-theoretic prerequisites for the "model theory" of HoTT in place, how easy would it be to build an "internal HoTT system" that is usable in practice? Would it differ substantially from the approach you are suggesting?</p>
</blockquote>
<p>My guess is that with current technology, it would be much more cumbersome. My hope was that with a little macroprogramming in Lean4, you could reuse most of mathlib as is, but in the univalent layer. A slight price to pay is that there are two (mathematical) prop universes, one strict, and one homotopical, but they would be equivalent (and both equivalent to bool). I fear that the (shallow/deep?) embedding approach would not be nearly as transparent in practice.<br>
But (as I mentioned last week), I would actually love to be wrong, because I'd like to see many applications of internal languages (for different kinds of categories or first-order models or …) be transparent and easy to use.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
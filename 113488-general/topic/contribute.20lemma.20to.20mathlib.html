---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html">contribute lemma to mathlib</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="267841933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267841933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267841933">(Jan 13 2022 at 09:17)</a>:</h4>
<p>Here is the lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ultrafilter_comap_set</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="bp">𝒱</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">𝒱</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∃</span> <span class="bp">𝒰</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">X</span><span class="o">,</span> <span class="bp">𝒰.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">𝒱</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">𝒰</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="c1">-- 𝒰 will be the ultrafilter generated by the filter base { (f ⁻¹' V ∩ A) | V ∈ 𝒱 }</span>
  <span class="k">let</span> <span class="n">B₀</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">f</span><span class="bp">⁻¹'</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">A</span><span class="o">)</span> <span class="bp">∩</span> <span class="n">A</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ℬ</span> <span class="o">:</span> <span class="n">filter_basis</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">sets</span> <span class="o">:=</span> <span class="o">{</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V</span> <span class="bp">∩</span> <span class="n">A</span><span class="o">)</span> <span class="bp">|</span> <span class="n">V</span> <span class="bp">∈</span> <span class="bp">𝒱</span> <span class="o">},</span>
    <span class="n">nonempty</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">B₀</span><span class="o">,</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">inter_sets</span> <span class="o">:=</span> <span class="kd">begin</span>
      <span class="k">assume</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span>
      <span class="k">assume</span> <span class="n">B'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="o">⟨</span><span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">,</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">∈</span> <span class="bp">𝒱</span><span class="o">,</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V</span> <span class="bp">∩</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">⟩,</span>
      <span class="n">rintro</span> <span class="o">⟨</span><span class="n">V'</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">,</span> <span class="n">h₁'</span> <span class="o">:</span> <span class="n">V'</span> <span class="bp">∈</span> <span class="bp">𝒱</span><span class="o">,</span> <span class="n">h₂'</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V'</span> <span class="bp">∩</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B'</span><span class="o">⟩,</span>
      <span class="k">let</span> <span class="n">B''</span> <span class="o">:=</span> <span class="n">B</span> <span class="bp">∩</span> <span class="n">B'</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">B''</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">h'</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="o">(</span><span class="n">V</span> <span class="bp">∩</span> <span class="n">V'</span><span class="o">)</span> <span class="bp">∩</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B''</span><span class="o">,</span> <span class="k">from</span> <span class="k">calc</span>
        <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="o">(</span><span class="n">V</span> <span class="bp">∩</span> <span class="n">V'</span><span class="o">)</span> <span class="bp">∩</span> <span class="n">A</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V</span> <span class="bp">∩</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V'</span><span class="o">)</span> <span class="bp">∩</span> <span class="n">A</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">set.preimage_inter</span>
        <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V</span> <span class="bp">∩</span> <span class="n">A</span><span class="o">)</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V'</span> <span class="bp">∩</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span><span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">tauto</span><span class="o">}</span>
        <span class="bp">...</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">∩</span> <span class="n">B'</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h₂</span><span class="o">,</span> <span class="n">h₂'</span><span class="o">],</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="n">V</span> <span class="bp">∩</span> <span class="n">V'</span><span class="o">,</span> <span class="bp">𝒱.</span><span class="n">inter_sets</span> <span class="n">h₁</span> <span class="n">h₁'</span><span class="o">,</span> <span class="n">h'</span><span class="o">⟩,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">set.subset.rfl</span><span class="o">],</span>
    <span class="kd">end</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="k">let</span> <span class="n">ℱ</span> <span class="o">:=</span> <span class="n">ℬ.filter</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℱ</span> <span class="o">:=</span> <span class="n">ℬ.mem_filter_iff.mpr</span> <span class="o">⟨</span><span class="n">B₀</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f</span> <span class="bp">''</span> <span class="n">A</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">set.inter_subset_right</span> <span class="o">(</span><span class="n">f</span><span class="bp">⁻¹'</span> <span class="o">(</span><span class="n">f</span> <span class="bp">''</span> <span class="n">A</span><span class="o">))</span> <span class="n">A</span><span class="o">⟩,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">ℱ.ne_bot</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rw</span> <span class="n">ℬ.has_basis.ne_bot_iff</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">,</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">∈</span> <span class="bp">𝒱</span><span class="o">,</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V</span> <span class="bp">∩</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="o">(</span><span class="n">set.inter_comm</span> <span class="o">(</span><span class="n">f</span><span class="bp">⁻¹'</span> <span class="n">V</span><span class="o">)</span> <span class="n">A</span><span class="o">)</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">h₂</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">id</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">set.image_inter_nonempty_iff</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span> <span class="bp">∩</span> <span class="n">V</span> <span class="bp">∈</span> <span class="bp">𝒱</span><span class="o">,</span> <span class="k">from</span> <span class="bp">𝒱.</span><span class="n">inter_sets</span> <span class="n">h</span> <span class="n">h₁</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">ultrafilter.nonempty_of_mem</span> <span class="n">this</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="k">let</span> <span class="bp">𝒰</span> <span class="o">:=</span> <span class="n">ultrafilter.of</span> <span class="n">ℱ</span><span class="o">,</span>
  <span class="n">use</span> <span class="bp">𝒰</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>

  <span class="k">show</span> <span class="bp">𝒰.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">𝒱</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">),</span> <span class="n">V</span> <span class="bp">∈</span> <span class="bp">𝒱</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">ℱ</span><span class="o">,</span> <span class="kd">begin</span>
      <span class="k">assume</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Y</span><span class="o">,</span>
      <span class="k">assume</span> <span class="n">hV</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">∈</span> <span class="bp">𝒱</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">filter_basis.mem_filter_iff</span> <span class="n">ℬ</span><span class="o">,</span>
      <span class="k">let</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V</span> <span class="bp">∩</span> <span class="n">A</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">B</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="k">show</span> <span class="n">B</span> <span class="bp">∈</span> <span class="n">ℬ</span><span class="o">,</span> <span class="k">from</span> <span class="o">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hV</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
      <span class="k">show</span> <span class="n">B</span> <span class="bp">⊆</span> <span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V</span><span class="o">,</span> <span class="k">from</span> <span class="n">set.inter_subset_left</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">V</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="bp">𝒰</span> <span class="bp">≤</span> <span class="bp">𝒱</span><span class="o">,</span> <span class="k">from</span> <span class="k">calc</span>
      <span class="n">map</span> <span class="n">f</span> <span class="bp">𝒰</span> <span class="bp">≤</span> <span class="n">map</span> <span class="n">f</span> <span class="n">ℱ</span> <span class="o">:</span> <span class="n">filter.map_mono</span> <span class="o">(</span><span class="n">ultrafilter.of_le</span> <span class="n">ℱ</span><span class="o">)</span>
      <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">𝒱</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">exact</span> <span class="o">(</span><span class="n">filter.tendsto_def.mpr</span> <span class="n">this</span><span class="o">),</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="bp">𝒰</span> <span class="bp">=</span> <span class="bp">𝒱</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="bp">𝒱.</span><span class="n">unique</span> <span class="n">this</span><span class="o">),</span>
    <span class="n">exact_mod_cast</span> <span class="n">this</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>

  <span class="k">show</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">𝒰</span><span class="o">,</span> <span class="k">from</span> <span class="n">filter.le_def.mp</span> <span class="o">(</span><span class="n">ultrafilter.of_le</span> <span class="n">ℱ</span><span class="o">)</span> <span class="n">A</span> <span class="o">(</span><span class="kd">by</span> <span class="n">assumption</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">ℱ</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>
<p>I couldn't find anything like this in mathlib. I thought proving it would be simple, but it turned out not to be the case. I was thinking about contributing this since it is a non-trivial result. Any thoughts? Should I just open a PR?</p>



<a name="267842494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267842494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267842494">(Jan 13 2022 at 09:22)</a>:</h4>
<p>Can you promote that from an existential to a construction?</p>



<a name="267842876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267842876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267842876">(Jan 13 2022 at 09:25)</a>:</h4>
<p>That is, something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ultrafilter_comap_set</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="bp">𝒱</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">𝒱</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ultrafilter</span> <span class="n">X</span>

<span class="kd">lemma</span> <span class="n">map_ultrafilter_comap_set</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="bp">𝒱</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">𝒱</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">ultrafilter_comap_set</span> <span class="n">f</span> <span class="n">A</span><span class="bp">𝒱</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">𝒱</span>

<span class="kd">lemma</span> <span class="n">mem_ultrafilter_comap_set</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="bp">𝒱</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">𝒱</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">A</span> <span class="bp">∈</span> <span class="n">ultrafilter_comap_set</span> <span class="n">f</span> <span class="n">A</span><span class="bp">𝒱</span> <span class="n">h</span>
</code></pre></div>



<a name="267844805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267844805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267844805">(Jan 13 2022 at 09:42)</a>:</h4>
<p>Yes I can.</p>



<a name="267844862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267844862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267844862">(Jan 13 2022 at 09:43)</a>:</h4>
<p>I know I will also need to change the variable names to fit the style of order.filter.ultrafilter. Also, I'm not sure about the name of this thing.</p>



<a name="267847177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267847177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267847177">(Jan 13 2022 at 10:05)</a>:</h4>
<p>I think this proof is needlessly complicated, I'll try to find time to write a shorter proof.</p>



<a name="267847715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267847715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267847715">(Jan 13 2022 at 10:11)</a>:</h4>
<p>Yeah, my tactic skills (or lack thereof) shows.</p>



<a name="267863332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267863332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267863332">(Jan 13 2022 at 12:45)</a>:</h4>
<p>This is not a question of tactic skills. You need to get used to how much structure we use on filters, especially push-forward, pull-back, inf and sup. And of course you need to know the library.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.bases</span> <span class="n">order.filter.ultrafilter</span>

<span class="kn">open</span> <span class="n">filter</span> <span class="n">set</span>
<span class="n">open_locale</span> <span class="n">filter</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">ultrafilter.eq_of_le</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">ultrafilter.coe_injective</span> <span class="o">(</span><span class="n">b.unique</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">ultrafilter</span>

<span class="kd">lemma</span> <span class="n">ultrafilter_comap_set</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="bp">𝒰</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">X</span><span class="o">,</span> <span class="bp">𝒰.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">V</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">𝒰</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="o">(</span><span class="n">comap</span> <span class="n">f</span> <span class="n">V</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span> <span class="n">comap_inf_principal_ne_bot_of_image_mem</span> <span class="n">V.ne_bot</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">of</span> <span class="o">(</span><span class="n">comap</span> <span class="n">f</span> <span class="n">V</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">A</span><span class="o">),</span> <span class="n">_</span><span class="o">,</span> <span class="n">of_le</span> <span class="n">_</span> <span class="o">(</span><span class="n">mem_inf_of_right</span> <span class="bp">$</span> <span class="n">mem_principal_self</span> <span class="n">A</span><span class="o">)⟩,</span>
  <span class="n">apply</span> <span class="n">eq_of_le</span><span class="o">,</span>
  <span class="k">calc</span> <span class="n">filter.map</span> <span class="n">f</span> <span class="o">(</span><span class="n">of</span> <span class="o">(</span><span class="n">comap</span> <span class="n">f</span> <span class="n">V</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">A</span><span class="o">))</span>
      <span class="bp">≤</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">comap</span> <span class="n">f</span> <span class="n">V</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">map_mono</span> <span class="o">(</span><span class="n">of_le</span> <span class="n">_</span><span class="o">)</span>
  <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="bp">$</span> <span class="n">comap</span> <span class="n">f</span> <span class="n">V</span><span class="o">)</span> <span class="bp">⊓</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">map_inf_le</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="bp">$</span> <span class="n">comap</span> <span class="n">f</span> <span class="n">V</span><span class="o">)</span> <span class="bp">⊓</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="bp">$</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">map_principal</span>
  <span class="bp">...</span> <span class="bp">≤</span> <span class="n">V</span> <span class="bp">⊓</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="bp">$</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">inf_le_inf_right</span> <span class="n">_</span> <span class="n">map_comap_le</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">V</span> <span class="o">:</span> <span class="n">inf_of_le_left</span> <span class="o">(</span><span class="n">le_principal_iff.mpr</span> <span class="n">h</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="267863475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267863475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267863475">(Jan 13 2022 at 12:46)</a>:</h4>
<p>As you can see, the core of the proof is a <em>computation</em> using all the structure I mentioned. As far as I know, this doesn't exist anywhere else (it certainly doesn't exist in Bourbaki).</p>



<a name="267898144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267898144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267898144">(Jan 13 2022 at 17:00)</a>:</h4>
<p>I did try to make it work with <code>comap f V ⊓ 𝓟 A</code>, but I ran into problems when I wanted to show the equality <code>𝒰.map f = V</code>, so I tried a different approach.<br>
I have not used the <code>refine</code> tactic yet, so I'm not sure what magic it does.</p>



<a name="267898722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267898722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267898722">(Jan 13 2022 at 17:03)</a>:</h4>
<blockquote>
<p>And of course you need to know the library.</p>
</blockquote>
<p>Yeah, this is a major issue I have.</p>



<a name="267899260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267899260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267899260">(Jan 13 2022 at 17:06)</a>:</h4>
<p><span class="user-mention" data-user-id="416322">@Bernd Losert</span> <code>refine</code> is like <code>exact</code> but any holes you leave (the underscores) become new goals if Lean doesn't otherwise figure them out for you.</p>



<a name="267899459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267899459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267899459">(Jan 13 2022 at 17:08)</a>:</h4>
<p>For example, say <code>f</code> has two arguments, then <code>apply f</code> and <code>refine f _ _</code> have a similar effect.</p>



<a name="267899504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267899504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267899504">(Jan 13 2022 at 17:08)</a>:</h4>
<p>Ah, that's interesting.</p>



<a name="267900193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267900193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267900193">(Jan 13 2022 at 17:12)</a>:</h4>
<p>It's also useful for using custom induction lemmas since it gives you more control (and also the <code>induction</code> tactic seems to have some longstanding bugs...). Setting up strong induction, for example: <code>refine nat.strong_induction_on n (λ n' ih, _)</code></p>



<a name="267908078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267908078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267908078">(Jan 13 2022 at 18:08)</a>:</h4>
<p><code>refine</code> isn't doing anything fancy here. You could write the exact same proof as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ultrafilter_comap_set</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span> <span class="bp">∈</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="bp">𝒰</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">X</span><span class="o">,</span> <span class="bp">𝒰.</span><span class="n">map</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">V</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">𝒰</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="o">(</span><span class="n">comap</span> <span class="n">f</span> <span class="n">V</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span> <span class="n">comap_inf_principal_ne_bot_of_image_mem</span> <span class="n">V.ne_bot</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">of</span> <span class="o">(</span><span class="n">comap</span> <span class="n">f</span> <span class="n">V</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">A</span><span class="o">),</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">eq_of_le</span><span class="o">,</span>
    <span class="k">calc</span> <span class="n">filter.map</span> <span class="n">f</span> <span class="o">(</span><span class="n">of</span> <span class="o">(</span><span class="n">comap</span> <span class="n">f</span> <span class="n">V</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">A</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="n">comap</span> <span class="n">f</span> <span class="n">V</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">map_mono</span> <span class="o">(</span><span class="n">of_le</span> <span class="n">_</span><span class="o">)</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="bp">$</span> <span class="n">comap</span> <span class="n">f</span> <span class="n">V</span><span class="o">)</span> <span class="bp">⊓</span> <span class="n">map</span> <span class="n">f</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">map_inf_le</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="bp">$</span> <span class="n">comap</span> <span class="n">f</span> <span class="n">V</span><span class="o">)</span> <span class="bp">⊓</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="bp">$</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">map_principal</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">V</span> <span class="bp">⊓</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="bp">$</span> <span class="n">f</span> <span class="bp">''</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">inf_le_inf_right</span> <span class="n">_</span> <span class="n">map_comap_le</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">V</span> <span class="o">:</span> <span class="n">inf_of_le_left</span> <span class="o">(</span><span class="n">le_principal_iff.mpr</span> <span class="n">h</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">of_le</span> <span class="n">_</span> <span class="o">(</span><span class="n">mem_inf_of_right</span> <span class="bp">$</span> <span class="n">mem_principal_self</span> <span class="n">A</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="267908181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267908181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267908181">(Jan 13 2022 at 18:09)</a>:</h4>
<p>If anything is fancy here then it's the anonymous constructor notation (the angle brackets) and its convenient "associativity".</p>



<a name="267908365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267908365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267908365">(Jan 13 2022 at 18:11)</a>:</h4>
<p><code>refine</code> is a really fundamental tactic. In a very real sense, every tactic is a special case of <code>refine</code>.</p>



<a name="267908759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267908759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267908759">(Jan 13 2022 at 18:14)</a>:</h4>
<p>I don't remember seeing <code>refine</code> in "Theorem proving with Lean". Most of my tactic knowledge comes from there.</p>



<a name="267908777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267908777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267908777">(Jan 13 2022 at 18:14)</a>:</h4>
<p>Isn't <code>refine</code> the only tactic that exists in agda? (This is only partially a joke)</p>



<a name="267908844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267908844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267908844">(Jan 13 2022 at 18:15)</a>:</h4>
<p>The only tactic I know of in Agda is <code>rewrite</code>.</p>



<a name="267908994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267908994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267908994">(Jan 13 2022 at 18:16)</a>:</h4>
<p>I'm not aware of how updated this list is, but <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html">https://leanprover-community.github.io/mathlib_docs/tactics.html</a> contains a more complete set of possibilities available in mathlib</p>
<p>(tip: it's a bit overwhelming, so don't worry too much)</p>



<a name="267909135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267909135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267909135">(Jan 13 2022 at 18:17)</a>:</h4>
<p><span class="user-mention" data-user-id="416322">@Bernd Losert</span> <code>refine</code> is the analogue of agda's <code>C-c C-r</code> (in emacs)</p>



<a name="267909311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267909311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267909311">(Jan 13 2022 at 18:19)</a>:</h4>
<p>Ah, I don't use emacs with Agda, so no clue.</p>



<a name="267909388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267909388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267909388">(Jan 13 2022 at 18:19)</a>:</h4>
<p>Is it possible to write agda without emacs?</p>



<a name="267909501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267909501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267909501">(Jan 13 2022 at 18:20)</a>:</h4>
<p>Of course. I'm also writing Lean without emacs or vscode.</p>



<a name="267909549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267909549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267909549">(Jan 13 2022 at 18:20)</a>:</h4>
<p>I use vim.</p>



<a name="267909631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267909631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267909631">(Jan 13 2022 at 18:21)</a>:</h4>
<div class="codehilite" data-code-language="VimL"><pre><span></span><code><span class="c">" C-c C-r -&gt; \r</span>
<span class="nb">nnoremap</span> <span class="p">&lt;</span>buffer<span class="p">&gt;</span> <span class="p">&lt;</span>LocalLeader<span class="p">&gt;</span><span class="k">r</span> :<span class="k">call</span> AgdaRefine<span class="p">(</span><span class="s2">"False"</span><span class="p">)&lt;</span>CR<span class="p">&gt;</span>
<span class="nb">nnoremap</span> <span class="p">&lt;</span>buffer<span class="p">&gt;</span> <span class="p">&lt;</span>LocalLeader<span class="p">&gt;</span>R :<span class="k">call</span> AgdaRefine<span class="p">(</span><span class="s2">"True"</span><span class="p">)&lt;</span>CR<span class="p">&gt;</span>
</code></pre></div>



<a name="267909859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267909859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267909859">(Jan 13 2022 at 18:23)</a>:</h4>
<p>:)<br>
My vim setup is very plain. I just run <code>agda</code> on the files, so no hole-driven development for me.</p>



<a name="267910086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267910086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267910086">(Jan 13 2022 at 18:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="416322">Bernd Losert</span> <a href="#narrow/stream/113488-general/topic/contribute.20lemma.20to.20mathlib/near/267909549">said</a>:</p>
<blockquote>
<p>I use vim.</p>
</blockquote>
<p>Are you using lean.nvim or doing something similarly barebones for lean</p>



<a name="267933314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267933314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267933314">(Jan 13 2022 at 21:26)</a>:</h4>
<p>Barebones. I basically run <code>!lean %</code> to type check the file I'm working on.</p>



<a name="267933733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267933733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267933733">(Jan 13 2022 at 21:30)</a>:</h4>
<p>Brave.</p>



<a name="267933913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267933913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267933913">(Jan 13 2022 at 21:32)</a>:</h4>
<p>By doing so, you've really decreased the "interactive" in interactive theorem prober</p>



<a name="267933944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267933944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267933944">(Jan 13 2022 at 21:32)</a>:</h4>
<p>Because you've lost the ability to see the goal automatically at different places in your tactic proofs</p>



<a name="267934029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267934029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267934029">(Jan 13 2022 at 21:33)</a>:</h4>
<p>So you're basically limited to constructing proofs that are basically the equivalent of term mods proofs with holes.</p>



<a name="267934110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267934110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267934110">(Jan 13 2022 at 21:34)</a>:</h4>
<p>Which is now explains why your proof at the beginning of the thread is the way it is</p>



<a name="267934353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267934353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267934353">(Jan 13 2022 at 21:37)</a>:</h4>
<p>Yes. I tried using vscode (again). The feedback in goals is super fast. Unfortunately, vscode has the bad habit of dying on me and sending all my cpus to 100%.</p>



<a name="267934382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267934382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267934382">(Jan 13 2022 at 21:37)</a>:</h4>
<p>It's also a giant time sink to be honest.</p>



<a name="267934535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267934535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267934535">(Jan 13 2022 at 21:38)</a>:</h4>
<p>I used to use emacs before too. But after I while I also realized it was a giant time sink.</p>



<a name="267934567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267934567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267934567">(Jan 13 2022 at 21:39)</a>:</h4>
<p>Have you tried doom emacs? It works pretty much right out of the box.</p>



<a name="267934606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267934606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267934606">(Jan 13 2022 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="416322">Bernd Losert</span> <a href="#narrow/stream/113488-general/topic/contribute.20lemma.20to.20mathlib/near/267933314">said</a>:</p>
<blockquote>
<p>Barebones. I basically run <code>!lean %</code> to type check the file I'm working on.</p>
</blockquote>
<p>This is definitely not recommended.</p>



<a name="267935018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267935018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267935018">(Jan 13 2022 at 21:43)</a>:</h4>
<p>Never tried doom emacs. Maybe I'll give it a try again at some point. I'm doing fine with vim at the moment.</p>



<a name="267938348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267938348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267938348">(Jan 13 2022 at 22:12)</a>:</h4>
<p>Any reason you're <em>not</em> using lean.nvim I suppose I should ask (even just for feedback)?</p>



<a name="267938362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267938362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267938362">(Jan 13 2022 at 22:13)</a>:</h4>
<p>Is it because you're using vanilla vim?</p>



<a name="267939219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267939219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267939219">(Jan 13 2022 at 22:17)</a>:</h4>
<p>Correct.</p>



<a name="267939811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267939811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267939811">(Jan 13 2022 at 22:22)</a>:</h4>
<p>Seems like switching to neovim should be easier than switching to emacs :) -- but even if you stick with your current thing, even just using <code>coc</code> is going to be lots more fun than <code>!lean %</code>, but it's your party.</p>



<a name="267939921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267939921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267939921">(Jan 13 2022 at 22:23)</a>:</h4>
<p>What's coc?</p>



<a name="267940014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267940014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267940014">(Jan 13 2022 at 22:24)</a>:</h4>
<p>An LSP client (one that works for vanilla vim).</p>



<a name="267940410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267940410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267940410">(Jan 13 2022 at 22:28)</a>:</h4>
<p>Ah, OK. There was a time when I used neovim with LSP and all sorts of customizations. But at some point I realized that the benefit I got from it was marginal and started reverting to a more simpler setup. I work as developer, so I've gone through a couple of IDEs. And I've always abandoned them for vim in the end.</p>



<a name="267940722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267940722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267940722">(Jan 13 2022 at 22:30)</a>:</h4>
<p>Sure, I understand, I hate IDEs and don't use anything but (neo)vim :), but I've never done so quite as barebones as you're doing now, I think it'd get quite annoying to me not seeing the goal state.Do what makes you happy (says the guy who ignored people who said lean doesn't support vim and did it anyway :P) but you may try something else for a bit just to see what you're missing from Lean, and then if you're really happy the way you were you go back. And in a biased way I'd try lean.nvim as the closest to what you're doing now :P.</p>



<a name="267940769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267940769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267940769">(Jan 13 2022 at 22:31)</a>:</h4>
<p>Or watch the demo at least maybe -- <a href="https://github.com/Julian/lean.nvim/">https://github.com/Julian/lean.nvim/</a> it's out of date, things look nicer now, but it's close to what my setup looks like.</p>



<a name="267945032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267945032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267945032">(Jan 13 2022 at 23:10)</a>:</h4>
<p>Looks pretty good. Thanks for suggesting it. The only thing that would annoy me is the pop-ups. I've grown to dislike pop-ups.</p>



<a name="267945357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267945357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267945357">(Jan 13 2022 at 23:13)</a>:</h4>
<p>None of that is required (and in my own setup, no popups at this point happen automatically, they're all key driven).</p>



<a name="267962245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267962245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267962245">(Jan 14 2022 at 03:02)</a>:</h4>
<p>The discussion has turned into a talk about text editors (someone might split this thread). So I am going to say something: learning vim/neovim is an old dream of mine and I'd love to learn how to use it with Lean <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="267996755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267996755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267996755">(Jan 14 2022 at 10:40)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> : I have broken-up the proof by <span class="user-mention" data-user-id="110031">@Patrick Massot</span> like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">ultrafilter</span>

<span class="kd">lemma</span> <span class="n">eq_of_le</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">coe_injective</span> <span class="o">(</span><span class="n">g.unique</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">comap_inf_principal_ne_bot_of_image_mem</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">''</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span>
<span class="n">filter.comap_inf_principal_ne_bot_of_image_mem</span> <span class="n">g.ne_bot</span> <span class="n">h</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">of_comap_inf_principal</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">''</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="o">(</span><span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span> <span class="n">comap_inf_principal_ne_bot_of_image_mem</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">of</span> <span class="o">(</span><span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">of_comap_inf_principal_ultrafilter_mem</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">''</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">of_comap_inf_principal</span> <span class="n">h</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="o">(</span><span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span> <span class="n">comap_inf_principal_ne_bot_of_image_mem</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">mem_inf_of_right</span> <span class="o">(</span><span class="n">mem_principal_self</span> <span class="n">s</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">filter.le_def.mp</span> <span class="o">(</span><span class="n">of_le</span> <span class="n">_</span><span class="o">)</span> <span class="n">s</span> <span class="n">this</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">of_comap_inf_principal_ultrafilter_eq_of_map</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">''</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">of_comap_inf_principal</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="o">(</span><span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot</span> <span class="o">:=</span> <span class="n">comap_inf_principal_ne_bot_of_image_mem</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq_of_le</span><span class="o">,</span>
  <span class="k">calc</span> <span class="n">filter.map</span> <span class="n">m</span> <span class="o">(</span><span class="n">of</span> <span class="o">(</span><span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">))</span> <span class="bp">≤</span> <span class="n">filter.map</span> <span class="n">m</span> <span class="o">(</span><span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter.map_mono</span> <span class="o">(</span><span class="n">of_le</span> <span class="n">_</span><span class="o">)</span>
  <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">filter.map</span> <span class="n">m</span> <span class="bp">$</span> <span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span><span class="o">)</span> <span class="bp">⊓</span> <span class="n">filter.map</span> <span class="n">m</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter.map_inf_le</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">filter.map</span> <span class="n">m</span> <span class="bp">$</span> <span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span><span class="o">)</span> <span class="bp">⊓</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="bp">$</span> <span class="n">m</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">filter.map_principal</span>
  <span class="bp">...</span> <span class="bp">≤</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="o">(</span><span class="bp">𝓟</span> <span class="bp">$</span> <span class="n">m</span> <span class="bp">''</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">inf_le_inf_right</span> <span class="n">_</span> <span class="n">filter.map_comap_le</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:</span> <span class="n">inf_of_le_left</span> <span class="o">(</span><span class="n">le_principal_iff.mpr</span> <span class="n">h</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">ultrafilter</span>
</code></pre></div>
<p>One thing that bugs me is that I have to keep repeating the <code>haveI</code>part. Is there a way to prevent this?</p>
<p>If anyone has any other feedback about this code, please let me know.</p>



<a name="267998804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267998804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267998804">(Jan 14 2022 at 11:00)</a>:</h4>
<p>Most of those <code>def</code>s should be lemmas, only the actual construction (<code>of_comap_inf_principal</code>) should be a <code>def</code>. I'm not familiar with this part of mathlib so can't really advise much beyond that.</p>



<a name="267999158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267999158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267999158">(Jan 14 2022 at 11:04)</a>:</h4>
<p>Ah, good point.</p>



<a name="267999824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/267999824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#267999824">(Jan 14 2022 at 11:11)</a>:</h4>
<p>Any thoughts on the <code>haveI</code> issue?</p>



<a name="268000030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/268000030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#268000030">(Jan 14 2022 at 11:13)</a>:</h4>
<p>There might be a trick - this works, but is uglier than what you have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">of_comap_inf_principal_ultrafilter_mem</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">ultrafilter</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">''</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">of_comap_inf_principal</span> <span class="n">h</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">filter.comap</span> <span class="n">m</span> <span class="n">g</span> <span class="bp">⊓</span> <span class="bp">𝓟</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">mem_inf_of_right</span> <span class="o">(</span><span class="n">mem_principal_self</span> <span class="n">s</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">filter.le_def.mp</span> <span class="o">(</span><span class="bp">@</span><span class="n">of_le</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">id</span> <span class="n">_</span><span class="o">))</span> <span class="n">s</span> <span class="n">this</span><span class="o">,</span>  <span class="c1">-- find the instance by unification rather than typeclass search</span>
<span class="kd">end</span>
</code></pre></div>
<p>There might be a nicer way to spell that.</p>



<a name="268004172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/contribute%20lemma%20to%20mathlib/near/268004172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/contribute.20lemma.20to.20mathlib.html#268004172">(Jan 14 2022 at 11:57)</a>:</h4>
<p>I made a PR: <a href="https://github.com/leanprover-community/mathlib/pull/11445">https://github.com/leanprover-community/mathlib/pull/11445</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
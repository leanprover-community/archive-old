---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/calculate.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html">calculate</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="196974760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196974760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196974760">(May 09 2020 at 05:27)</a>:</h4>
<p>I've been playing a bit with how to state exercises in Lean. This may also be related to the IMO grand challenge. This is what I've come up with so far.</p>



<a name="196974797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196974797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196974797">(May 09 2020 at 05:28)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">irreducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">calculate</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span>

<span class="kn">section</span> <span class="n">bit</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">calculate</span>

<span class="kn">lemma</span> <span class="n">calculate_zero</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">calculate</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">calculate_one</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">calculate</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">calculate_bit0</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">calculate</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">calculate</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">bit0</span> <span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">calculate_bit1</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">calculate</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">calculate</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">bit1</span> <span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">bit</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">calculate</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">-</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">calculate_bit0</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">calculate_one</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="196974805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196974805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196974805">(May 09 2020 at 05:29)</a>:</h4>
<p>My question is: can you modify reducibility settings of definitions while you're inside a tactic proof?</p>



<a name="196974868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196974868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196974868">(May 09 2020 at 05:31)</a>:</h4>
<p>Because inside a game / competition / homework setting I guess you can reasonably enforce that participants / students are only allowed to "hand in" a <code>begin ... end</code>-block. But if they can make <code>calculate</code> reducible inside that tactic block, of course this is all doomed.</p>



<a name="196974914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196974914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196974914">(May 09 2020 at 05:33)</a>:</h4>
<p>I've also been thinking that one might want to add some typeclass that adds some "allowed expressions", for example <code>calculate pi</code> would be an "axiom" for the reals, that could be added by the instructor / kata designer</p>



<a name="196974967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196974967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196974967">(May 09 2020 at 05:35)</a>:</h4>
<p>Maybe in codewars you actually hand in more than just a <code>begin ... end</code> block. So then that's not the intended audience <span aria-label="smile" class="emoji emoji-263a" role="img" title="smile">:smile:</span> <br>
But for homework, you could make it a rule.</p>



<a name="196975010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975010">(May 09 2020 at 05:36)</a>:</h4>
<p>This should come with a tactic (or custom <code>begin ... end</code> environment, like <code>calculate_done</code>, that will check that the final expression can be "calculated"</p>



<a name="196975071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975071">(May 09 2020 at 05:38)</a>:</h4>
<p>You can unfold irreducible in a tactic proof (indeed you can even just remove the attribute)</p>



<a name="196975121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975121">(May 09 2020 at 05:41)</a>:</h4>
<p>So then we would need to do something quite a bit more clever.</p>



<a name="196975122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975122">(May 09 2020 at 05:41)</a>:</h4>
<p>In this case, using only the provided lemmas, you are asking to prove that <code>4 - 2</code> is a natural number, but this doesn't require computing the number</p>



<a name="196975127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975127">(May 09 2020 at 05:41)</a>:</h4>
<p>If you really wanted to lock it down to the provided lemmas, you could just have an inductive predicate to that effect</p>



<a name="196975212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975212">(May 09 2020 at 05:44)</a>:</h4>
<p>But you can't prove <code>calculate n</code> for <code>(n : nat)</code>, right? Unless you remove the irreducibility.</p>



<a name="196975216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975216">(May 09 2020 at 05:44)</a>:</h4>
<p>You have to turn it into something sufficiently close to a numeral</p>



<a name="196975219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975219">(May 09 2020 at 05:44)</a>:</h4>
<p>(E.g. <code>2 + 2</code> is fine.)</p>



<a name="196975225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975225">(May 09 2020 at 05:45)</a>:</h4>
<p>Maybe I should cook up an example involving determinants, to make this slightly less trivial.</p>



<a name="196975439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975439">(May 09 2020 at 05:52)</a>:</h4>
<p>Indeed I can, using the Power of Induction:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">calculate</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">nat</span><span class="bp">.</span><span class="n">binary_rec</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">calculate_zero</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">(</span><span class="bp">_|_</span><span class="o">)</span> <span class="n">n</span> <span class="n">h</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">bit</span><span class="o">,</span> <span class="n">calculate_bit0</span><span class="o">,</span> <span class="n">calculate_bit1</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="196975575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975575">(May 09 2020 at 05:57)</a>:</h4>
<p>/me clearly doesn't know enough about bits</p>



<a name="196975581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975581">(May 09 2020 at 05:57)</a>:</h4>
<p>But this means that whatever definition of <code>calculate</code> you come up with, you can always prove <code>calculate n</code>, I guess.</p>



<a name="196975621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975621">(May 09 2020 at 05:58)</a>:</h4>
<p>I mean you could simplify this by saying that you only provide <code>calculate (nat.succ n)</code> when <code>calculate n</code>, and then it would more clearly be an instance of induction</p>



<a name="196975627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975627">(May 09 2020 at 05:58)</a>:</h4>
<p>but if you couldn't do this kind of thing it would defeat the purpose of lean as a proof assistant. We <em>want</em> to be able to prove properties by induction</p>



<a name="196975632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975632">(May 09 2020 at 05:59)</a>:</h4>
<p>Sure</p>



<a name="196975638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975638">(May 09 2020 at 05:59)</a>:</h4>
<p>But I thought maybe we can single out certain properties and make them irreducible and yadda yadda...</p>



<a name="196975686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975686">(May 09 2020 at 06:00)</a>:</h4>
<p>Another way to get what you want is to say that you have an infinite number of axioms, <code>calculate 0</code>, <code>calculate 1</code>, <code>calculate 2</code>, ... without using lean quantifiers to get it</p>



<a name="196975701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975701">(May 09 2020 at 06:01)</a>:</h4>
<p>Maybe another option would be to have a tactic <code>check_answer</code> that must be the last line of the tactic block?</p>



<a name="196975708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975708">(May 09 2020 at 06:01)</a>:</h4>
<p>And the tactic fails if it doesn't like the <code>(p)expr</code> that has been constructed so far.</p>



<a name="196975752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975752">(May 09 2020 at 06:02)</a>:</h4>
<p>Or would you still be able to cheat using induction?</p>



<a name="196975805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975805">(May 09 2020 at 06:04)</a>:</h4>
<p>Hmm... I'm afraid this won't be foolproof either...</p>



<a name="196975817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975817">(May 09 2020 at 06:05)</a>:</h4>
<p>You can probably do something like</p>
<div class="codehilite"><pre><span></span><code>  <span class="n">tactic1</span><span class="o">,</span>
  <span class="n">tactic2</span><span class="o">,</span>
  <span class="n">close_goal_by_induction</span><span class="o">,</span> <span class="c1">-- proof accomplished!</span>
  <span class="k">show</span> <span class="n">calculate</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">check_answer</span>
</code></pre></div>



<a name="196975822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975822">(May 09 2020 at 06:05)</a>:</h4>
<p>And just fool it into checking a trivial exercise</p>



<a name="196975939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975939">(May 09 2020 at 06:08)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">core</span>

<span class="kn">constant</span> <span class="n">calculate</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="kn">namespace</span> <span class="n">tactic</span>
<span class="kn">namespace</span> <span class="n">interactive</span>
<span class="kn">open</span> <span class="n">interactive</span><span class="bp">.</span><span class="n">types</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">calculate</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span>
  <span class="bp">`</span><span class="o">(</span><span class="bp">_</span><span class="n">root_</span><span class="bp">.</span><span class="n">calculate</span> <span class="err">%%</span><span class="n">e</span><span class="o">)</span> <span class="err">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="n">n</span> <span class="err">←</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_nat</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ax</span> <span class="o">:=</span> <span class="n">mk_simple_name</span> <span class="o">(</span><span class="s2">&quot;calculate_&quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">n</span><span class="o">),</span>
  <span class="n">try</span> <span class="o">(</span><span class="n">add_decl</span> <span class="o">(</span><span class="n">declaration</span><span class="bp">.</span><span class="n">ax</span> <span class="n">ax</span> <span class="o">[]</span> <span class="bp">`</span><span class="o">(</span><span class="bp">_</span><span class="n">root_</span><span class="bp">.</span><span class="n">calculate</span> <span class="err">%%</span><span class="o">(</span><span class="n">reflect</span> <span class="n">n</span><span class="o">)))),</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">expr</span><span class="bp">.</span><span class="n">const</span> <span class="n">ax</span> <span class="o">[])</span>
<span class="kn">end</span> <span class="n">interactive</span>
<span class="kn">end</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">calculate</span> <span class="mi">5</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">calculate</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">calculate</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">calculate</span>
</code></pre></div>



<a name="196975956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975956">(May 09 2020 at 06:09)</a>:</h4>
<p>this achieves an infinite family of axioms by having the <code>calculate</code> tactic produce them on the fly</p>



<a name="196975960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196975960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196975960">(May 09 2020 at 06:10)</a>:</h4>
<p>you can't do induction on them</p>



<a name="196976068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196976068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196976068">(May 09 2020 at 06:14)</a>:</h4>
<p>The downsides of this method are that you get new axioms for every use of <code>calculate</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">T</span> <span class="o">:</span> <span class="n">calculate</span> <span class="mi">5</span> <span class="bp">∧</span> <span class="n">calculate</span> <span class="mi">7</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">split</span><span class="bp">;</span> <span class="n">calculate</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span> <span class="n">T</span>
<span class="c1">-- calculate</span>
<span class="c1">-- calculate_5</span>
<span class="c1">-- calculate_7</span>
</code></pre></div>


<p>and also that because theorems can't add axioms to the environment, you have to either mark the theorem as a <code>def</code> or prepare the state beforehand:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">T</span> <span class="o">:</span> <span class="n">calculate</span> <span class="mi">5</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">calculate</span> <span class="c1">-- fails</span>
<span class="n">def</span> <span class="n">T&#39;</span> <span class="o">:</span> <span class="n">calculate</span> <span class="mi">5</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">calculate</span> <span class="c1">-- ok</span>
<span class="kn">theorem</span> <span class="n">T&#39;&#39;</span> <span class="o">:</span> <span class="n">calculate</span> <span class="mi">5</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">calculate</span> <span class="c1">-- ok because T&#39; already added calculate_5</span>
</code></pre></div>



<a name="196976223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196976223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196976223">(May 09 2020 at 06:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/calculate/near/196975701" title="#narrow/stream/113488-general/topic/calculate/near/196975701">said</a>:</p>
<blockquote>
<p>Maybe another option would be to have a tactic <code>check_answer</code> that must be the last line of the tactic block?</p>
</blockquote>
<p>Rather than the last line, it should be the first line, with a block surrounding the rest of the proof. That way <code>check_answer</code> gets the state, calls the given user tactic, and then checks that the original goal has been solved appropriately. Or, rather than intercepting the expr before the proof is done, you can just examine the proof later with a <code>run_cmd</code> tactic at the end of the file</p>



<a name="196977111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977111">(May 09 2020 at 06:49)</a>:</h4>
<p>Hmm, I like this last idea.</p>



<a name="196977786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977786">(May 09 2020 at 07:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Would something like this be a start?</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">allowed_exprs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">good_exprs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">name</span><span class="o">)</span>

<span class="n">def</span> <span class="n">calculate</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">allowed_exprs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span>
</code></pre></div>



<a name="196977831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977831">(May 09 2020 at 07:10)</a>:</h4>
<p>When I ran into this sort of issue when formalising problem sheets I just told my students that it was their job to formalise the question.</p>



<a name="196977839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977839">(May 09 2020 at 07:10)</a>:</h4>
<p>what's in the list?</p>



<a name="196977848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977848">(May 09 2020 at 07:11)</a>:</h4>
<p>I realised that actually some questions we ask the students are hugely ambiguous. For example "for which n is it true that all groups of order n are abelian?"</p>



<a name="196977849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977849">(May 09 2020 at 07:11)</a>:</h4>
<p>Things like <code> [`bit0, `bit1, `has_zero.zero, `has_zero.one] </code></p>



<a name="196977851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977851">(May 09 2020 at 07:11)</a>:</h4>
<p>The answer is "it's the n for which all groups of order n are abelian"</p>



<a name="196977853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977853">(May 09 2020 at 07:11)</a>:</h4>
<p>Unless you get <code>calculate</code> working...</p>



<a name="196977854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977854">(May 09 2020 at 07:12)</a>:</h4>
<p>And this is computable</p>



<a name="196977893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977893">(May 09 2020 at 07:12)</a>:</h4>
<p>That doesn't matter. My tactic will reject your answer.</p>



<a name="196977898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977898">(May 09 2020 at 07:13)</a>:</h4>
<p>If the problem statement includes a list of <code>name</code>s that are allowed to occur in the answer, you can make it precise. At least that's my current hope</p>



<a name="196977899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977899">(May 09 2020 at 07:13)</a>:</h4>
<p>But this is part of a more general question -- what does a mathematician even <em>mean</em> when they ask that sort of a question?</p>



<a name="196977903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977903">(May 09 2020 at 07:13)</a>:</h4>
<p>It's easy to detect if a numeral is given by tactics, you don't need this</p>



<a name="196977904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977904">(May 09 2020 at 07:13)</a>:</h4>
<p>Right. They mean: give me an answer that is an <code>expr</code> that only uses <code>name</code>s from some <code>L : list name</code>. Only <code>L</code> is an implicit variable (-;</p>



<a name="196977905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977905">(May 09 2020 at 07:13)</a>:</h4>
<p>"For which real numbers x!=3 is (x+1)/(x-3) positive?"</p>



<a name="196977942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977942">(May 09 2020 at 07:14)</a>:</h4>
<p>The answer is "those ones"</p>



<a name="196977943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977943">(May 09 2020 at 07:14)</a>:</h4>
<p>but I think the problem is that numerals don't suffice for many problems</p>



<a name="196977944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977944">(May 09 2020 at 07:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/calculate/near/196977903" title="#narrow/stream/113488-general/topic/calculate/near/196977903">said</a>:</p>
<blockquote>
<p>It's easy to detect if a numeral is given by tactics, you don't need this</p>
</blockquote>
<p>But I want to be able to allow <code>real.pi</code> (sometimes)</p>



<a name="196977951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977951">(May 09 2020 at 07:14)</a>:</h4>
<p>you can write a tactic that detects terms of the required form</p>



<a name="196977954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977954">(May 09 2020 at 07:15)</a>:</h4>
<p>assuming you can define what the required form is</p>



<a name="196977958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977958">(May 09 2020 at 07:15)</a>:</h4>
<p>You mean "<em>you</em> can write a tactic that detects terms of the required form"</p>



<a name="196977959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977959">(May 09 2020 at 07:15)</a>:</h4>
<p>You still overestimate my skills</p>



<a name="196977962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977962">(May 09 2020 at 07:15)</a>:</h4>
<p>But this "required form". Do you think I'm on the right path with my <code>list name</code>?</p>



<a name="196977963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977963">(May 09 2020 at 07:15)</a>:</h4>
<p><code>expr.of_nat</code> does this for numerals</p>



<a name="196977966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196977966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196977966">(May 09 2020 at 07:15)</a>:</h4>
<p>the list name is probably underconstraining if you want a well formed numeral</p>



<a name="196978010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978010">(May 09 2020 at 07:16)</a>:</h4>
<p>There is also a way to do it without tactics, again using an indutive type to define the required form</p>



<a name="196978015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978015">(May 09 2020 at 07:17)</a>:</h4>
<p>But wouldn't I be able to prove by induction that every <code>n</code> satisfies the inductive predicate?</p>



<a name="196978018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978018">(May 09 2020 at 07:17)</a>:</h4>
<p><code>def foo : { n : nat_term // (n : nat) = 4 - 2 } := sorry</code></p>



<a name="196978058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978058">(May 09 2020 at 07:18)</a>:</h4>
<p>"oh and make it computable too please"</p>



<a name="196978311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978311">(May 09 2020 at 07:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> But can we turn that into something that has a slick UI?</p>



<a name="196978314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978314">(May 09 2020 at 07:27)</a>:</h4>
<p>Or would that still require tactics</p>



<a name="196978367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978367">(May 09 2020 at 07:28)</a>:</h4>
<p>I would like to create something that is foolproof and looks good.</p>



<a name="196978390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978390">(May 09 2020 at 07:28)</a>:</h4>
<p>looks good probably requires tactics</p>



<a name="196978393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978393">(May 09 2020 at 07:29)</a>:</h4>
<p>But that's lean's strength</p>



<a name="196978396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978396">(May 09 2020 at 07:29)</a>:</h4>
<p>I'm not opposed to tactics (-;</p>



<a name="196978397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978397">(May 09 2020 at 07:29)</a>:</h4>
<p>How would you do my real number question? It's somehow "clear" to mathematicians that the answer is expected to be a disjoint union of open/closed/semiopen intervals</p>



<a name="196978401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978401">(May 09 2020 at 07:29)</a>:</h4>
<p>then say that</p>



<a name="196978407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978407">(May 09 2020 at 07:29)</a>:</h4>
<p>But this seems to be as much a convention as anything else</p>



<a name="196978409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978409">(May 09 2020 at 07:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> You have to formalise the "language"</p>



<a name="196978411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978411">(May 09 2020 at 07:29)</a>:</h4>
<p>Right</p>



<a name="196978413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978413">(May 09 2020 at 07:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/calculate/near/196978407" title="#narrow/stream/113488-general/topic/calculate/near/196978407">said</a>:</p>
<blockquote>
<p>But this seems to be as much a convention as anything else</p>
</blockquote>
<p>Sure, so hide it in a type class</p>



<a name="196978414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978414">(May 09 2020 at 07:29)</a>:</h4>
<p>you can define "disjoint union of intervals" easily enough</p>



<a name="196978456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978456">(May 09 2020 at 07:30)</a>:</h4>
<p>"Express as your answer as a disjoint union of intervals" or something</p>



<a name="196978460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978460">(May 09 2020 at 07:30)</a>:</h4>
<p>of course you are stymied to some extent by various general theorems like "every open set is a disjoint union of intervals" and such</p>



<a name="196978462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978462">(May 09 2020 at 07:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/calculate/near/196978456" title="#narrow/stream/113488-general/topic/calculate/near/196978456">said</a>:</p>
<blockquote>
<p>"Express as your answer as a disjoint union of intervals" or something</p>
</blockquote>
<p>But every set is a disjoint union of intervals!</p>



<a name="196978465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978465">(May 09 2020 at 07:30)</a>:</h4>
<p>Rofl</p>



<a name="196978471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978471">(May 09 2020 at 07:31)</a>:</h4>
<p>not every set is the finite disjoint union of intervals, but if it's a polynomial then the options are pretty limited</p>



<a name="196978474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978474">(May 09 2020 at 07:31)</a>:</h4>
<p>That's great :-) This question is hard!</p>



<a name="196978478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978478">(May 09 2020 at 07:31)</a>:</h4>
<p>I think it's pretty clear that we want to inspect the <code>expr</code> that the user provides.</p>



<a name="196978518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978518">(May 09 2020 at 07:32)</a>:</h4>
<p>Did you know that you can inspect exprs using typeclass inference?</p>



<a name="196978519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978519">(May 09 2020 at 07:32)</a>:</h4>
<p>No?</p>



<a name="196978522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978522">(May 09 2020 at 07:32)</a>:</h4>
<p>But it sounds like that is maybe not "best practice"</p>



<a name="196978525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978525">(May 09 2020 at 07:33)</a>:</h4>
<p>My daughter is doing maths online nowadays for school and using various web pages which are supposed to inspect her text input and decide whether she got it right.</p>



<a name="196978527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978527">(May 09 2020 at 07:33)</a>:</h4>
<p>These systems are by no means perfect</p>



<a name="196978530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978530">(May 09 2020 at 07:33)</a>:</h4>
<p>But it never occurred to me to just tell her to type the question in as the answer</p>



<a name="196978572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978572">(May 09 2020 at 07:34)</a>:</h4>
<p>She normally has enough trouble with a correct answer not being accepted because of some grammar issue</p>



<a name="196978639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978639">(May 09 2020 at 07:37)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">is_numeral</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mk</span>

<span class="kn">instance</span> <span class="n">zero</span><span class="bp">.</span><span class="n">is_numeral</span> <span class="o">:</span> <span class="n">is_numeral</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">⟨⟩</span>
<span class="kn">instance</span> <span class="n">one</span><span class="bp">.</span><span class="n">is_numeral</span> <span class="o">:</span> <span class="n">is_numeral</span> <span class="mi">1</span> <span class="o">:=</span> <span class="bp">⟨⟩</span>
<span class="kn">instance</span> <span class="n">bit0</span><span class="bp">.</span><span class="n">is_numeral</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">[</span><span class="n">is_numeral</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_numeral</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨⟩</span>
<span class="kn">instance</span> <span class="n">bit1</span><span class="bp">.</span><span class="n">is_numeral</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">[</span><span class="n">is_numeral</span> <span class="n">n</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_numeral</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨⟩</span>

<span class="n">def</span> <span class="n">exists_numeral</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Exists</span> <span class="n">P</span>
<span class="kn">theorem</span> <span class="n">exists_numeral</span><span class="bp">.</span><span class="n">intro</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">is_numeral</span> <span class="n">n</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">exists_numeral</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">n</span> <span class="n">h</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">exists_numeral</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="mi">4</span> <span class="bp">-</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">exists_numeral</span><span class="bp">.</span><span class="n">intro</span> <span class="mi">2</span> <span class="n">rfl</span> <span class="c1">-- ok</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">exists_numeral</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="mi">4</span> <span class="bp">-</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">exists_numeral</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="mi">4</span> <span class="bp">-</span> <span class="mi">2</span><span class="o">)</span> <span class="n">rfl</span> <span class="c1">-- not ok</span>
</code></pre></div>



<a name="196978697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978697">(May 09 2020 at 07:38)</a>:</h4>
<p>this might satisfy your "looks good" criterion with a bit of notation, and gives helpful error messages, but it is not foolproof against hackers</p>



<a name="196978705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978705">(May 09 2020 at 07:39)</a>:</h4>
<p>so you would have to have a tactic as backup if you want more security</p>



<a name="196978785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196978785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196978785">(May 09 2020 at 07:41)</a>:</h4>
<p>(you should also add <code>attribute [irreducible] exists_numeral</code> so that you can't accidentally circumvent it using <code>split</code> or <code>existsi</code>)</p>



<a name="196979245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196979245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196979245">(May 09 2020 at 07:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/calculate/near/196978697" title="#narrow/stream/113488-general/topic/calculate/near/196978697">said</a>:</p>
<blockquote>
<p>this might satisfy your "looks good" criterion with a bit of notation, and gives helpful error messages, but it is not foolproof against hackers</p>
</blockquote>
<p>Right, I can still prove <code>exists_numeral</code> for arbitrary nats, right? Because it is almost the same as my first <code>calculate</code>.</p>



<a name="196979755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196979755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196979755">(May 09 2020 at 08:07)</a>:</h4>
<p>right, the idea here is that a good faith usage not using lots of @ signs will give errors in the right places</p>



<a name="196994399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196994399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196994399">(May 09 2020 at 14:34)</a>:</h4>
<p>I think this conversation is very interesting, but also that a solution is not important to the project of giving homework in Lean</p>



<a name="196994479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196994479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196994479">(May 09 2020 at 14:34)</a>:</h4>
<p>When I graded for a Haskell course in the CS department, checking that the solution compiled was just the first step in grading. If it didn't compile we sent it back to the student and asked them to fix and resubmit.</p>
<p>Once I have a compiling submission, I read the code and make comments about the parts I think could be cleaner or more understandable or more efficient. This is the same work that I did when grading for theorem-proving classes, just with the added benefit that I didn't have to decide how large of holes I let pass through.</p>



<a name="196994680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196994680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196994680">(May 09 2020 at 14:39)</a>:</h4>
<p>Maybe your grading rubric is such that anyone who submits compiling code gets a passing grade, but to get an A on an assignment you have to comment your proof in such a way that the comments on their own would pass for a proof in a normal math class</p>



<a name="196994754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196994754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196994754">(May 09 2020 at 14:41)</a>:</h4>
<p>and then you've still reduced the burden on the grader, they "only" have to check that </p>
<ol>
<li>the writing sounds like good math prose,</li>
<li>the comments mean the same thing as the nearby bits of Lean,</li>
<li>the path to the proof was reasonably direct / didn't rely on machinery that's "out of scope" for the class</li>
</ol>



<a name="196994817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196994817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196994817">(May 09 2020 at 14:42)</a>:</h4>
<p>Why not simply correlate the grade to the number of symbols in the proof script?<br>
Golfing FTW!</p>



<a name="196994840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/calculate/near/196994840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/calculate.html#196994840">(May 09 2020 at 14:43)</a>:</h4>
<p>where in a normal math class 2 is replaced by the significantly harder "verify that the ideas required to formalize this proof are 'out of scope' in the direction of being 'trivial'", or maybe "verify that the ideas required to formalize this proof are probably known to the author". I did the last one a lot and it leads to an awful bias against non-native english speakers.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
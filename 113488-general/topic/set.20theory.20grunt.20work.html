---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/set.20theory.20grunt.20work.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html">set theory grunt work</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="202020847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202020847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202020847">(Jun 25 2020 at 20:30)</a>:</h4>
<p>I need to prove the following (hoping I didn't mess up my lemma extraction):</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">U₁</span> <span class="n">V₁</span> <span class="n">U₂</span> <span class="n">V₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">VU₁</span> <span class="o">:</span> <span class="n">V₁</span> <span class="err">⊆</span> <span class="n">U₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">VU₂</span> <span class="o">:</span> <span class="n">V₂</span> <span class="err">⊆</span> <span class="n">U₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">U₁</span> <span class="err">∩</span> <span class="n">U₂</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u_in</span> <span class="o">:</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">V₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">v_in</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">huw</span> <span class="o">:</span> <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">U₂</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₂</span><span class="o">)</span> <span class="err">∪</span> <span class="o">((</span><span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∩</span> <span class="n">V₂</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="err">$</span> <span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∩</span> <span class="n">V₂</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">hwv</span> <span class="o">:</span> <span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">U₂</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₂</span><span class="o">)</span> <span class="err">∪</span> <span class="o">((</span><span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∩</span> <span class="n">V₂</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="err">$</span> <span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∩</span> <span class="n">V₂</span><span class="o">)))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="err">∈</span> <span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>


<p>Is there anything smart I could do here (besides taking an intern to prove it)?</p>



<a name="202020929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202020929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202020929">(Jun 25 2020 at 20:31)</a>:</h4>
<p>The real world proof is to draw four circles on a piece of paper.</p>



<a name="202020981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202020981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202020981">(Jun 25 2020 at 20:31)</a>:</h4>
<p>Or, if you have strong opinion about pictures like Bourbaki, not doing anything.</p>



<a name="202021751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202021751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202021751">(Jun 25 2020 at 20:38)</a>:</h4>
<p>I didn't even try to process what this is saying, but are you sure it's stated right? <code>simp [set.prod] at *, tauto!</code> reduces it to something unprovable.</p>



<a name="202021845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202021845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202021845">(Jun 25 2020 at 20:39)</a>:</h4>
<p><code>tauto</code> being the usual go-to for set theory grunt work.</p>



<a name="202022029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202022029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202022029">(Jun 25 2020 at 20:41)</a>:</h4>
<p>Yes, it's correct, although I forgot to remove that last assumption which is useless (it's used for the variant you have to prove next).</p>



<a name="202022147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202022147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202022147">(Jun 25 2020 at 20:42)</a>:</h4>
<p>Because V1 is disjoint from U2 and U3.</p>



<a name="202022291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202022291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202022291">(Jun 25 2020 at 20:43)</a>:</h4>
<p>Oh, sorry, the result of <code>tauto</code> is provable (there's a contradiction in the hypotheses).</p>



<a name="202022444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202022444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202022444">(Jun 25 2020 at 20:44)</a>:</h4>
<p>Indeed.</p>



<a name="202024433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202024433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alistair Tucker <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202024433">(Jun 25 2020 at 21:01)</a>:</h4>
<p>What's <code>U\3</code>? I don't see it</p>



<a name="202025098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025098">(Jun 25 2020 at 21:07)</a>:</h4>
<p>Sorry, U3 is <code>-(V₁ ∩ V₂)</code></p>



<a name="202025132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025132">(Jun 25 2020 at 21:07)</a>:</h4>
<p>Wait, I messed up something.</p>



<a name="202025277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025277">(Jun 25 2020 at 21:08)</a>:</h4>
<p>I meant union of V1 and V2, not intersection.</p>



<a name="202025353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025353">(Jun 25 2020 at 21:09)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">U₁</span> <span class="n">V₁</span> <span class="n">U₂</span> <span class="n">V₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">VU₁</span> <span class="o">:</span> <span class="n">V₁</span> <span class="err">⊆</span> <span class="n">U₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">VU₂</span> <span class="o">:</span> <span class="n">V₂</span> <span class="err">⊆</span> <span class="n">U₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">U₁</span> <span class="err">∩</span> <span class="n">U₂</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u_in</span> <span class="o">:</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">V₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">v_in</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">huw</span> <span class="o">:</span> <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">U₂</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₂</span><span class="o">)</span> <span class="err">∪</span> <span class="o">((</span><span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∩</span> <span class="n">V₂</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="err">$</span> <span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∩</span> <span class="n">V₂</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">hwv</span> <span class="o">:</span> <span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">U₂</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₂</span><span class="o">)</span> <span class="err">∪</span> <span class="o">((</span><span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∩</span> <span class="n">V₂</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="err">$</span> <span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∩</span> <span class="n">V₂</span><span class="o">))),</span>
  <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="err">∈</span> <span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="kn">using</span> <span class="bp">@</span><span class="n">h</span> <span class="n">bool</span> <span class="o">{</span><span class="n">tt</span><span class="o">}</span> <span class="o">{</span><span class="n">tt</span><span class="o">}</span> <span class="o">{</span><span class="n">ff</span><span class="o">}</span> <span class="o">{</span><span class="n">ff</span><span class="o">}</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span>
    <span class="o">(</span><span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">set</span><span class="bp">.</span><span class="n">ext_iff</span><span class="o">])</span> <span class="n">tt</span> <span class="n">ff</span> <span class="n">ff</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202025363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025363">(Jun 25 2020 at 21:09)</a>:</h4>
<p>It's false</p>



<a name="202025423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025423">(Jun 25 2020 at 21:10)</a>:</h4>
<p>Yes, I messed up the statement, as I wrote above.</p>



<a name="202025433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025433">(Jun 25 2020 at 21:10)</a>:</h4>
<p>Sorry about that.</p>



<a name="202025443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025443">(Jun 25 2020 at 21:10)</a>:</h4>
<p>It's too hot here.</p>



<a name="202025533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025533">(Jun 25 2020 at 21:11)</a>:</h4>
<p>In that case <code>finish [set.ext_iff, set.subset_def]</code> works</p>



<a name="202025564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025564">(Jun 25 2020 at 21:12)</a>:</h4>
<p>Thanks!</p>



<a name="202025817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202025817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202025817">(Jun 25 2020 at 21:14)</a>:</h4>
<p>My computer is stupid, but fortunately Chris isn't.</p>



<a name="202026129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202026129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202026129">(Jun 25 2020 at 21:17)</a>:</h4>
<p>(But Kenny will hate you for that)</p>



<a name="202026637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202026637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202026637">(Jun 25 2020 at 21:21)</a>:</h4>
<p>if you post the correct statement i'll look for something faster than finish</p>



<a name="202026806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202026806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202026806">(Jun 25 2020 at 21:23)</a>:</h4>
<p>The correct statement is:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">U₁</span> <span class="n">V₁</span> <span class="n">U₂</span> <span class="n">V₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">VU₁</span> <span class="o">:</span> <span class="n">V₁</span> <span class="err">⊆</span> <span class="n">U₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">VU₂</span> <span class="o">:</span> <span class="n">V₂</span> <span class="err">⊆</span> <span class="n">U₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">U₁</span> <span class="err">∩</span> <span class="n">U₂</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u_in</span> <span class="o">:</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">V₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">v_in</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">huw</span> <span class="o">:</span> <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">U₂</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₂</span><span class="o">)</span> <span class="err">∪</span> <span class="o">((</span><span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∪</span> <span class="n">V₂</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="err">$</span> <span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∪</span> <span class="n">V₂</span><span class="o">)))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="err">∈</span> <span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="202027510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202027510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202027510">(Jun 25 2020 at 21:28)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">set</span><span class="bp">.</span><span class="n">mem_prod</span><span class="bp">.</span><span class="mi">2</span> <span class="o">((</span><span class="n">huw</span><span class="bp">.</span><span class="n">resolve_right</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">u_in</span><span class="o">)))</span><span class="bp">.</span><span class="n">resolve_right</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">have</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">U₁</span> <span class="err">∩</span> <span class="n">U₂</span><span class="o">,</span> <span class="k">from</span> <span class="bp">⟨</span><span class="n">VU₁</span> <span class="n">u_in</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="mi">1</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">by</span> <span class="n">rwa</span> <span class="n">H</span> <span class="n">at</span> <span class="n">this</span><span class="o">))</span>
</code></pre></div>



<a name="202027608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202027608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202027608">(Jun 25 2020 at 21:29)</a>:</h4>
<p>I knew the smart thing do to was to take an intern.</p>



<a name="202027664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202027664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202027664">(Jun 25 2020 at 21:30)</a>:</h4>
<p>It's still a bit sad. Let's say <code>finish</code> will be fast in Lean 4.</p>



<a name="202027676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202027676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202027676">(Jun 25 2020 at 21:30)</a>:</h4>
<p>Thank you very much Chris!</p>



<a name="202027903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202027903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202027903">(Jun 25 2020 at 21:32)</a>:</h4>
<p>fwiw here's what I ended up with; i am a worse intern than chris</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">U₁</span> <span class="n">V₁</span> <span class="n">U₂</span> <span class="n">V₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">VU₁</span> <span class="o">:</span> <span class="n">V₁</span> <span class="err">⊆</span> <span class="n">U₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">VU₂</span> <span class="o">:</span> <span class="n">V₂</span> <span class="err">⊆</span> <span class="n">U₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">U₁</span> <span class="err">∩</span> <span class="n">U₂</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u_in</span> <span class="o">:</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">V₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">v_in</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">huw</span> <span class="o">:</span> <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">U₂</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₂</span><span class="o">)</span> <span class="err">∪</span> <span class="o">((</span><span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∪</span> <span class="n">V₂</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="err">$</span> <span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∪</span> <span class="n">V₂</span><span class="o">)))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="err">∈</span> <span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set</span><span class="bp">.</span><span class="n">ext_iff</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_def</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_empty_eq</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">compl_union</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_inter_eq</span><span class="o">,</span> <span class="n">not_and</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">prod_mk_mem_set_prod_eq</span><span class="o">,</span>
 <span class="n">set</span><span class="bp">.</span><span class="n">mem_union_eq</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_compl_eq</span><span class="o">,</span> <span class="n">iff_false</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span> <span class="o">{</span> <span class="n">tauto</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">H</span> <span class="n">u</span><span class="o">,</span>
  <span class="n">tauto</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202028142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202028142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202028142">(Jun 25 2020 at 21:35)</a>:</h4>
<p>Thanks anyway. <code>tauto</code> is way faster than <code>finish</code></p>



<a name="202028195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202028195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202028195">(Jun 25 2020 at 21:35)</a>:</h4>
<p>And I wouldn't be worried to be a worse intern that Chris...</p>



<a name="202029255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202029255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202029255">(Jun 25 2020 at 21:45)</a>:</h4>
<p>Working through this was kind of relaxing...</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">U₁</span> <span class="n">V₁</span> <span class="n">U₂</span> <span class="n">V₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">VU₁</span> <span class="o">:</span> <span class="n">V₁</span> <span class="err">⊆</span> <span class="n">U₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">VU₂</span> <span class="o">:</span> <span class="n">V₂</span> <span class="err">⊆</span> <span class="n">U₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">U₁</span> <span class="err">∩</span> <span class="n">U₂</span> <span class="bp">=</span> <span class="err">∅</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u_in</span> <span class="o">:</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">V₁</span><span class="o">)</span>
  <span class="o">(</span><span class="n">v_in</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">huw</span> <span class="o">:</span> <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">U₂</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₂</span><span class="o">)</span> <span class="err">∪</span> <span class="o">((</span><span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∪</span> <span class="n">V₂</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span> <span class="err">$</span> <span class="bp">-</span><span class="o">(</span><span class="n">V₁</span> <span class="err">∪</span> <span class="n">V₂</span><span class="o">)))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="err">∈</span> <span class="n">U₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U₁</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set</span><span class="bp">.</span><span class="n">ext_iff</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_def</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_empty_eq</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">compl_union</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_inter_eq</span><span class="o">,</span> <span class="n">not_and</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">prod_mk_mem_set_prod_eq</span><span class="o">,</span>
  <span class="n">set</span><span class="bp">.</span><span class="n">mem_union_eq</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_compl_eq</span><span class="o">,</span> <span class="n">iff_false</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">huw</span> <span class="k">with</span> <span class="bp">⟨⟨_</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">|</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_⟩⟩</span> <span class="bp">|</span> <span class="bp">⟨⟨_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">split</span><span class="o">,</span> <span class="n">assumption&#39;</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">H</span> <span class="n">u</span> <span class="o">(</span><span class="n">VU₁</span> <span class="n">u</span> <span class="n">u_in</span><span class="o">),</span> <span class="n">contradiction</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">contradiction</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>
</code></pre></div>



<a name="202029366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202029366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202029366">(Jun 25 2020 at 21:46)</a>:</h4>
<p>We should collaborate more, we have very complementary ways of relaxing.</p>



<a name="202370952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202370952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202370952">(Jun 29 2020 at 21:35)</a>:</h4>
<p>I have another one: what is the automated procedure that should have avoided proving by hand:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">chore</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="n">S</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">U</span> <span class="err">∩</span> <span class="n">S</span> <span class="err">∩</span> <span class="n">A</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">V</span> <span class="err">∩</span> <span class="n">S</span> <span class="err">∩</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="o">((</span><span class="n">U</span> <span class="err">∩</span> <span class="n">A</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">V</span> <span class="err">∩</span> <span class="n">B</span><span class="o">))</span> <span class="err">∩</span> <span class="n">S</span> <span class="o">:=</span>
<span class="k">by</span>  <span class="n">rw</span> <span class="o">[</span><span class="n">inter_right_comm</span><span class="o">,</span> <span class="n">inter_right_comm</span> <span class="n">V</span><span class="o">,</span> <span class="n">union_inter_distrib_right</span><span class="o">]</span>
</code></pre></div>



<a name="202371370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202371370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202371370">(Jun 29 2020 at 21:39)</a>:</h4>
<p><code>by { ext, simp, tauto! }</code></p>



<a name="202375028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202375028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202375028">(Jun 29 2020 at 22:21)</a>:</h4>
<p>Thanks! I didn't try the right combination. I still wish it could be only one tactic.</p>



<a name="202375181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/set%20theory%20grunt%20work/near/202375181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/set.20theory.20grunt.20work.html#202375181">(Jun 29 2020 at 22:22)</a>:</h4>
<p>you could have <code>meta def set_theory := `[ext; simp; tauto!]</code>. It's a pretty flexible approach</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
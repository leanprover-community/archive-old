---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/using_well_founded.20for.20a.20type.20mimicking.20programming.20structs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/using_well_founded.20for.20a.20type.20mimicking.20programming.20structs.html">using_well_founded for a type mimicking programming structs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="204013335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/using_well_founded%20for%20a%20type%20mimicking%20programming%20structs/near/204013335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/using_well_founded.20for.20a.20type.20mimicking.20programming.20structs.html#204013335">(Jul 15 2020 at 21:09)</a>:</h4>
<p>I'm modeling programming datatypes, including a type with fields that contain other datatypes.</p>
<div class="codehilite"><pre><span></span><code><span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">PrimType</span><span class="o">,</span> <span class="n">Struct</span>
  <span class="k">with</span> <span class="n">PrimType</span> <span class="o">:</span> <span class="kt">Type</span>
   <span class="bp">|</span> <span class="n">pInt</span> <span class="o">:</span> <span class="n">nat</span>  <span class="bp">→</span> <span class="n">PrimType</span>
   <span class="bp">|</span> <span class="n">pStr</span> <span class="o">:</span> <span class="n">string</span>  <span class="bp">→</span> <span class="n">PrimType</span>
   <span class="bp">|</span> <span class="n">pBool</span><span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">PrimType</span>
   <span class="bp">|</span> <span class="n">pStruct</span> <span class="o">{</span><span class="n">s</span><span class="o">:</span> <span class="n">string</span><span class="o">}:</span> <span class="n">Struct</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">PrimType</span>

  <span class="k">with</span> <span class="n">Struct</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="kt">Type</span>
   <span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">name</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">fields</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">PrimType</span><span class="o">))</span>
          <span class="o">:</span> <span class="n">Struct</span> <span class="n">name</span>
   <span class="bp">|</span> <span class="n">nil</span> <span class="o">(</span><span class="n">name</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">Struct</span> <span class="n">name</span>
<span class="kn">open</span> <span class="n">PrimType</span> <span class="kn">open</span> <span class="n">Struct</span>
</code></pre></div>


<p>I'm trying to prove decidable equality on this type (that function is in a #new_members thread), but doing that straightforwardly doesn't lead to something that Lean knows will terminate. Based on Floris' suggestion, I pattern matched off of <a href="https://leanprover-community.github.io/mathlib_docs/find/lists.equiv.decidable/src">src#lists.equiv.decidable</a> and add to the bottom </p>
<div class="codehilite"><pre><span></span><code><span class="n">using_well_founded</span> <span class="o">{</span>
  <span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="bp">_⟩</span><span class="o">],</span> <span class="c1">-- this last hole needs to be filled in with something specific to PrimType/Struct</span>
  <span class="n">dec_tac</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">assumption</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>


<p>The type that I need to implement (it seems) is  <code>psum (Σ' (a : PrimType), PrimType) (Σ' {s : string} (a : Struct s), Struct s) → ℕ</code></p>
<p>I'm still trying to understand what this <code>psum</code> really means. I started writing out an implementation but keep hitting roadblocks.</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">meas</span> <span class="o">:</span> <span class="n">psum</span> <span class="o">(</span><span class="err">Σ&#39;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">PrimType</span><span class="o">),</span> <span class="n">PrimType</span><span class="o">)</span> <span class="o">(</span><span class="err">Σ&#39;</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">Struct</span> <span class="n">s</span><span class="o">),</span> <span class="n">Struct</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">psum</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨</span><span class="n">pStruct</span> <span class="o">(</span><span class="n">mk</span> <span class="bp">_</span> <span class="n">x</span><span class="o">),</span> <span class="n">pStruct</span> <span class="o">(</span><span class="n">mk</span> <span class="bp">_</span> <span class="n">y</span><span class="o">)</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">0</span> <span class="c1">-- something with x and y</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">psum</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨</span><span class="n">pStruct</span> <span class="o">(</span><span class="n">mk</span> <span class="bp">_</span> <span class="n">x</span><span class="o">),</span> <span class="bp">_⟩</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">0</span> <span class="c1">-- something with x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">psum</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">pStruct</span> <span class="o">(</span><span class="n">mk</span> <span class="bp">_</span> <span class="n">x</span><span class="o">)</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">0</span> <span class="c1">-- something with x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">psum</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨_</span><span class="o">,</span><span class="bp">_⟩</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">psum</span><span class="bp">.</span><span class="n">inr</span> <span class="bp">⟨_</span><span class="o">,</span><span class="bp">⟨_</span><span class="o">,</span><span class="n">mk</span> <span class="bp">_</span> <span class="n">x</span><span class="bp">⟩⟩</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">0</span> <span class="c1">-- something with x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">psum</span><span class="bp">.</span><span class="n">inr</span> <span class="bp">⟨_</span><span class="o">,</span><span class="bp">⟨_</span><span class="o">,</span><span class="n">nil</span> <span class="bp">_⟩⟩</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
</code></pre></div>


<p>A simpler recursive function to prove termination for might look  like this </p>
<div class="codehilite"><pre><span></span><code><span class="n">mutual</span> <span class="n">def</span> <span class="n">sizeofp</span><span class="o">,</span> <span class="n">sizeofs</span>
<span class="k">with</span> <span class="n">sizeofp</span><span class="o">:</span> <span class="n">PrimType</span> <span class="bp">→</span> <span class="bp">ℕ</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pStruct</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">sizeofs</span> <span class="n">s</span>
 <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">with</span> <span class="n">sizeofs</span><span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">s</span><span class="o">:</span> <span class="n">string</span><span class="o">},</span> <span class="n">Struct</span> <span class="n">s</span> <span class="bp">→</span> <span class="bp">ℕ</span>
 <span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nil</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">mk</span> <span class="bp">_</span> <span class="o">[])</span> <span class="o">:=</span> <span class="mi">0</span>
 <span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">mk</span> <span class="n">s</span> <span class="o">((</span><span class="bp">_</span><span class="o">,</span> <span class="n">h</span><span class="o">)</span><span class="bp">::</span><span class="n">t</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sizeofp</span> <span class="n">h</span> <span class="bp">+</span> <span class="n">sizeofs</span> <span class="o">(</span><span class="n">mk</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span>
<span class="n">using_well_founded</span> <span class="o">{</span>
  <span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="n">meas</span><span class="bp">⟩</span><span class="o">],</span>
  <span class="n">dec_tac</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">assumption</span><span class="o">]</span> <span class="o">}</span> <span class="c1">-- fails to prove recursive application is decreasing</span>
</code></pre></div>


<p>Does anyone with experience with <code>using_well_founded</code> have suggestions for how to tackle this?</p>



<a name="204160071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/using_well_founded%20for%20a%20type%20mimicking%20programming%20structs/near/204160071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kris Brown <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/using_well_founded.20for.20a.20type.20mimicking.20programming.20structs.html#204160071">(Jul 17 2020 at 00:30)</a>:</h4>
<p>It turns out this problem could be solved without resorting to <code>using_well_founded</code> - it just requires adding  the right proofs immediately above the recursive calls.  There is one bizarre thing where I need to prove <code>a+b&lt;c+d</code> and Lean seems to nondeterministically need some permutation of that (possibly <code>a</code>,<code>b</code> swapped or <code>c</code>,<code>d</code> swapped). Sometimes the checker would approve with just one, but often it fails unless all four permutations are explicitly declared.</p>
<p>Posting my solution here in case anyone else comes across a similar problem</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">linarith</span>

<span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">PrimType</span><span class="o">,</span> <span class="n">Struct</span>
  <span class="k">with</span> <span class="n">PrimType</span> <span class="o">:</span> <span class="kt">Type</span>
   <span class="bp">|</span> <span class="n">pInt</span> <span class="o">:</span> <span class="n">nat</span>  <span class="bp">→</span> <span class="n">PrimType</span>
   <span class="bp">|</span> <span class="n">pStr</span> <span class="o">:</span> <span class="n">string</span>  <span class="bp">→</span> <span class="n">PrimType</span>
   <span class="bp">|</span> <span class="n">pBool</span><span class="o">:</span> <span class="n">bool</span> <span class="bp">→</span> <span class="n">PrimType</span>
   <span class="bp">|</span> <span class="n">pStruct</span> <span class="o">{</span><span class="n">s</span><span class="o">:</span> <span class="n">string</span><span class="o">}:</span> <span class="n">Struct</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">PrimType</span>

  <span class="k">with</span> <span class="n">Struct</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="kt">Type</span>
   <span class="bp">|</span> <span class="n">mk</span> <span class="o">(</span><span class="n">name</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">fields</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">PrimType</span><span class="o">))</span>
          <span class="o">:</span> <span class="n">Struct</span> <span class="n">name</span>
   <span class="bp">|</span> <span class="n">nil</span> <span class="o">(</span><span class="n">name</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">Struct</span> <span class="n">name</span>

<span class="kn">open</span> <span class="n">PrimType</span> <span class="kn">open</span> <span class="n">Struct</span>
<span class="c1">-------------------------------------------------------------</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">The head of a list of pairs is smaller than the whole list</span>
<span class="cm">-/</span>
<span class="kn">lemma</span> <span class="n">headsize</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_sizeof</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_sizeof</span> <span class="n">β</span><span class="o">]</span>
                <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span><span class="bp">×</span><span class="n">β</span><span class="o">)):</span>
                    <span class="n">sizeof</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">sizeof</span><span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="k">calc</span>
  <span class="n">sizeof</span> <span class="n">b</span> <span class="bp">&lt;=</span> <span class="n">sizeof</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">sizeof</span> <span class="n">b</span>                   <span class="o">:</span> <span class="k">by</span> <span class="n">linarith</span>
   <span class="bp">...</span>     <span class="bp">&lt;</span>  <span class="mi">1</span> <span class="bp">+</span> <span class="n">prod</span><span class="bp">.</span><span class="n">sizeof</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">list</span><span class="bp">.</span><span class="n">sizeof</span> <span class="n">t</span> <span class="o">:</span> <span class="k">by</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">prod</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">,</span>
                                                          <span class="n">linarith</span><span class="o">}</span>
   <span class="bp">...</span>     <span class="bp">=</span>  <span class="mi">1</span> <span class="bp">+</span> <span class="n">sizeof</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">list</span><span class="bp">.</span><span class="n">sizeof</span> <span class="n">t</span>      <span class="o">:</span> <span class="k">by</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">sizeof</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>
   <span class="bp">...</span>     <span class="bp">=</span>  <span class="n">list</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span>        <span class="o">:</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">list</span><span class="bp">.</span><span class="n">sizeof</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">The tail of a list of pairs is smaller than the whole list</span>
<span class="cm">-/</span>
<span class="kn">lemma</span> <span class="n">tailsize</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">has_sizeof</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_sizeof</span> <span class="n">β</span><span class="o">]</span>
                <span class="o">(</span><span class="n">ab</span><span class="o">:</span> <span class="n">α</span><span class="bp">×</span><span class="n">β</span><span class="o">)</span>  <span class="o">(</span><span class="n">t</span><span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span><span class="bp">×</span><span class="n">β</span><span class="o">)):</span>
                    <span class="n">sizeof</span> <span class="n">t</span> <span class="bp">&lt;</span> <span class="n">sizeof</span><span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="o">(</span><span class="n">ab</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="k">calc</span>
  <span class="n">sizeof</span> <span class="n">t</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">sizeof</span> <span class="o">(</span><span class="n">ab</span><span class="o">)</span> <span class="bp">+</span> <span class="n">sizeof</span> <span class="n">t</span>      <span class="o">:</span> <span class="k">by</span> <span class="o">{</span><span class="n">linarith</span><span class="o">}</span>
   <span class="bp">...</span>     <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">sizeof</span> <span class="o">(</span><span class="n">ab</span><span class="o">)</span> <span class="bp">+</span> <span class="n">list</span><span class="bp">.</span><span class="n">sizeof</span> <span class="n">t</span> <span class="o">:</span> <span class="k">by</span> <span class="o">{</span><span class="n">unfold</span> <span class="n">sizeof</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>
   <span class="bp">...</span>     <span class="bp">=</span>  <span class="n">list</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="o">(</span><span class="n">ab</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span>  <span class="o">:</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">list</span><span class="bp">.</span><span class="n">sizeof</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Sometimes we cannot use prod.decidable_eq, because that requires an instance of</span>
<span class="cm">[has_decidable_eq] for α and β, which is what we&#39;re trying to prove! Need a</span>
<span class="cm">version that works for specific elements, used in a proof by induction.</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">prod_eq_intro</span><span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a1</span> <span class="n">a2</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b1</span> <span class="n">b2</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span>
                <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">a1</span><span class="bp">=</span><span class="n">a2</span><span class="o">))</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">b1</span><span class="bp">=</span><span class="n">b2</span><span class="o">)),</span>
                    <span class="n">decidable</span> <span class="o">((</span><span class="n">a1</span><span class="o">,</span><span class="n">b1</span><span class="o">)</span><span class="bp">=</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span><span class="n">b2</span><span class="o">))</span> <span class="o">:=</span> <span class="k">by</span> <span class="k">begin</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">xfalse</span> <span class="n">xtrue</span><span class="o">,</span>
        <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">xfalse</span><span class="o">],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">},</span>
    <span class="o">{</span><span class="n">cases</span> <span class="n">y</span> <span class="k">with</span> <span class="n">yfalse</span> <span class="n">ytrue</span><span class="o">,</span>
        <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">yfalse</span><span class="o">],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">},</span>
        <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">xtrue</span><span class="o">,</span> <span class="n">ytrue</span><span class="o">],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">true</span><span class="o">}},</span>
<span class="kn">end</span>

<span class="c1">-------------------------------------------------------------</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">One caveat of this equality is that the NULL values for some given struct</span>
<span class="cm">are considered equal.</span>
<span class="cm">-/</span>
<span class="n">mutual</span> <span class="n">def</span> <span class="n">P_eq</span><span class="o">,</span> <span class="n">P_list_eq</span><span class="o">,</span> <span class="n">S_eq</span>
<span class="k">with</span> <span class="n">P_eq</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">PrimType</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pInt</span> <span class="bp">_</span><span class="o">)</span>    <span class="o">(</span><span class="n">pBool</span> <span class="bp">_</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pInt</span> <span class="bp">_</span><span class="o">)</span>    <span class="o">(</span><span class="n">pStr</span> <span class="bp">_</span><span class="o">)</span>     <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pInt</span> <span class="bp">_</span><span class="o">)</span>    <span class="o">(</span><span class="n">pStruct</span> <span class="bp">_</span><span class="o">)</span>  <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pBool</span> <span class="bp">_</span><span class="o">)</span>   <span class="o">(</span><span class="n">pInt</span> <span class="bp">_</span><span class="o">)</span>     <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pBool</span> <span class="bp">_</span><span class="o">)</span>   <span class="o">(</span><span class="n">pStr</span> <span class="bp">_</span><span class="o">)</span>     <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pBool</span> <span class="bp">_</span><span class="o">)</span>   <span class="o">(</span><span class="n">pStruct</span> <span class="bp">_</span><span class="o">)</span>  <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pStr</span> <span class="bp">_</span><span class="o">)</span>    <span class="o">(</span><span class="n">pInt</span> <span class="bp">_</span><span class="o">)</span>     <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pStr</span> <span class="bp">_</span><span class="o">)</span>    <span class="o">(</span><span class="n">pBool</span> <span class="bp">_</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pStr</span> <span class="bp">_</span><span class="o">)</span>     <span class="o">(</span><span class="n">pStruct</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pStruct</span> <span class="bp">_</span><span class="o">)</span>  <span class="o">(</span><span class="n">pInt</span> <span class="bp">_</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pStruct</span> <span class="bp">_</span><span class="o">)</span>  <span class="o">(</span><span class="n">pStr</span> <span class="bp">_</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pStruct</span> <span class="bp">_</span><span class="o">)</span>  <span class="o">(</span><span class="n">pBool</span> <span class="bp">_</span><span class="o">)</span>   <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pInt</span> <span class="n">x</span><span class="o">)</span>     <span class="o">(</span><span class="n">pInt</span> <span class="n">y</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">decidable_eq</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pBool</span> <span class="n">x</span><span class="o">)</span>    <span class="o">(</span><span class="n">pBool</span> <span class="n">y</span><span class="o">)</span>   <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">bool</span><span class="bp">.</span><span class="n">decidable_eq</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span>
 <span class="bp">|</span> <span class="o">(</span><span class="n">pStr</span> <span class="n">x</span><span class="o">)</span>     <span class="o">(</span><span class="n">pStr</span> <span class="n">y</span><span class="o">)</span>    <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span>
                                   <span class="n">exact</span> <span class="n">string</span><span class="bp">.</span><span class="n">has_decidable_eq</span> <span class="n">x</span> <span class="n">y</span><span class="o">}</span>

 <span class="bp">|</span> <span class="o">(</span><span class="bp">@</span><span class="n">pStruct</span> <span class="n">m</span> <span class="o">(</span><span class="n">mk</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="bp">@</span><span class="n">pStruct</span> <span class="n">n</span> <span class="o">(</span><span class="n">nil</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span>
        <span class="n">simp</span><span class="o">,</span> <span class="k">have</span> <span class="n">p</span><span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">a</span><span class="bp">=</span><span class="n">x</span><span class="o">),</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">string</span><span class="bp">.</span><span class="n">has_decidable_eq</span> <span class="n">a</span> <span class="n">x</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">pf</span> <span class="n">pt</span><span class="o">,</span>
        <span class="c1">-- two different Struct classes! definitely not equal.</span>
        <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">pf</span><span class="o">],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">},</span>
        <span class="c1">-- Even if same class, it&#39;s different constructors; still not equal</span>
        <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">pt</span><span class="o">],</span> <span class="n">rw</span> <span class="n">pt</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">heq_iff_eq</span><span class="o">],</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}}</span>

 <span class="bp">|</span> <span class="o">(</span><span class="bp">@</span><span class="n">pStruct</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nil</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="bp">@</span><span class="n">pStruct</span> <span class="n">m</span> <span class="o">(</span><span class="n">mk</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span>
        <span class="n">simp</span><span class="o">,</span> <span class="k">have</span> <span class="n">p</span><span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">x</span><span class="bp">=</span><span class="n">a</span><span class="o">),</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">string</span><span class="bp">.</span><span class="n">has_decidable_eq</span> <span class="n">x</span> <span class="n">a</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">pf</span> <span class="n">pt</span><span class="o">,</span> <span class="c1">-- (same as above block, with a flip)</span>
        <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">pf</span><span class="o">],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">},</span>
        <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">pt</span><span class="o">],</span> <span class="n">rw</span> <span class="n">pt</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">heq_iff_eq</span><span class="o">],</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}}</span>

 <span class="bp">|</span> <span class="o">(</span><span class="bp">@</span><span class="n">pStruct</span> <span class="n">n</span> <span class="o">(</span><span class="n">nil</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="bp">@</span><span class="n">pStruct</span> <span class="n">m</span> <span class="o">(</span><span class="n">nil</span> <span class="n">y</span><span class="o">))</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">p</span><span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">x</span><span class="bp">=</span><span class="n">y</span><span class="o">),</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">string</span><span class="bp">.</span><span class="n">has_decidable_eq</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">p</span><span class="o">,</span> <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">p</span><span class="o">],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">},</span> <span class="c1">-- different classes.</span>
        <span class="o">{</span><span class="n">rw</span> <span class="n">p</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">heq_iff_eq</span><span class="o">],</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">true</span><span class="o">}}</span> <span class="c1">-- both NULL</span>

 <span class="bp">|</span> <span class="o">(</span><span class="bp">@</span><span class="n">pStruct</span> <span class="n">n</span> <span class="o">(</span><span class="n">mk</span> <span class="n">a</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="bp">@</span><span class="n">pStruct</span> <span class="n">m</span> <span class="o">(</span><span class="n">mk</span> <span class="n">b</span> <span class="n">y</span><span class="o">))</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span>
        <span class="n">simp</span><span class="o">,</span> <span class="k">have</span> <span class="n">p</span><span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">a</span><span class="bp">=</span><span class="n">b</span><span class="o">),</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">string</span><span class="bp">.</span><span class="n">has_decidable_eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">pf</span> <span class="n">pt</span><span class="o">,</span>
        <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">pf</span><span class="o">],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">},</span> <span class="c1">-- different classes; not equal</span>
        <span class="o">{</span><span class="n">rw</span> <span class="n">pt</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">P_list_eq</span> <span class="n">x</span> <span class="n">y</span><span class="o">}}</span> <span class="c1">-- equal if arg lists are equal</span>

<span class="k">with</span> <span class="n">P_list_eq</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">PrimType</span><span class="o">))</span>
 <span class="bp">|</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">by</span> <span class="k">begin</span>
  <span class="n">cases</span> <span class="n">eqa</span> <span class="o">:</span> <span class="n">a</span> <span class="k">with</span> <span class="n">a_hd</span> <span class="n">a_tl</span><span class="o">,</span>
  <span class="o">{</span><span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">true</span><span class="o">},</span> <span class="c1">-- both lists nil, they&#39;re equal</span>
    <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}},</span> <span class="c1">-- false if only one list is nil</span>
  <span class="o">{</span><span class="n">cases</span> <span class="n">eqb</span> <span class="o">:</span> <span class="n">b</span> <span class="k">with</span> <span class="n">b_hd</span> <span class="n">b_tl</span><span class="o">,</span>
    <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">},</span> <span class="n">simp</span><span class="o">,</span> <span class="c1">-- false if only one list is nil</span>
    <span class="n">cases</span> <span class="n">a_hd</span> <span class="k">with</span> <span class="n">a_hds</span> <span class="n">a_hdp</span><span class="o">,</span> <span class="c1">-- split the head into its parts</span>
    <span class="n">cases</span> <span class="n">b_hd</span> <span class="k">with</span> <span class="n">b_hds</span> <span class="n">b_hdp</span><span class="o">,</span> <span class="c1">-- split the head into its parts</span>

    <span class="c1">-- Lemmas useful for proving recursive calls terminate</span>
    <span class="k">have</span> <span class="n">sizea</span> <span class="o">:</span> <span class="n">a_hdp</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="bp">.</span><span class="n">sizeof</span> <span class="o">:=</span>
        <span class="k">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">eqa</span><span class="o">,</span> <span class="n">exact</span> <span class="n">headsize</span> <span class="n">a_hds</span> <span class="n">a_hdp</span> <span class="n">a_tl</span><span class="o">},</span>
    <span class="k">have</span> <span class="n">sizea&#39;</span><span class="o">:</span> <span class="n">a_tl</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="bp">.</span><span class="n">sizeof</span> <span class="o">:=</span>
        <span class="k">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">eqa</span><span class="o">,</span> <span class="n">exact</span> <span class="n">tailsize</span> <span class="o">(</span><span class="n">a_hds</span><span class="o">,</span> <span class="n">a_hdp</span><span class="o">)</span> <span class="n">a_tl</span><span class="o">},</span>
    <span class="k">have</span> <span class="n">sizeb</span> <span class="o">:</span> <span class="n">b_hdp</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="bp">.</span><span class="n">sizeof</span> <span class="o">:=</span>
        <span class="k">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">eqb</span><span class="o">,</span> <span class="n">exact</span> <span class="n">headsize</span> <span class="n">b_hds</span> <span class="n">b_hdp</span> <span class="n">b_tl</span><span class="o">},</span>
    <span class="k">have</span> <span class="n">sizeb&#39;</span><span class="o">:</span> <span class="n">b_tl</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="bp">.</span><span class="n">sizeof</span> <span class="o">:=</span>
        <span class="k">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">eqb</span><span class="o">,</span> <span class="n">exact</span> <span class="n">tailsize</span> <span class="o">(</span><span class="n">b_hds</span><span class="o">,</span> <span class="n">b_hdp</span><span class="o">)</span> <span class="n">b_tl</span><span class="o">},</span>

    <span class="k">have</span> <span class="n">res1</span><span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">a_hdp</span> <span class="bp">=</span> <span class="n">b_hdp</span><span class="o">)</span> <span class="o">:=</span>
        <span class="c1">-- bizarre... but all four permutations are explicitly needed</span>
        <span class="k">have</span> <span class="n">H1</span><span class="o">:</span> <span class="n">a_hdp</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">b_hdp</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">),</span>
                <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">H2</span><span class="o">:</span> <span class="n">a_hdp</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">b_hdp</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">),</span>
                <span class="k">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">H1</span><span class="o">],</span>
        <span class="k">have</span> <span class="n">H3</span><span class="o">:</span> <span class="n">b_hdp</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">a_hdp</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">),</span>
                <span class="k">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">H1</span><span class="o">],</span>
        <span class="k">have</span> <span class="n">H4</span><span class="o">:</span> <span class="n">b_hdp</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">a_hdp</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">),</span>
                <span class="k">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">H1</span><span class="o">],</span>
        <span class="n">P_eq</span> <span class="n">a_hdp</span> <span class="n">b_hdp</span><span class="o">,</span> <span class="c1">-- the head is decidably equal (recursive call)</span>

    <span class="c1">-- Above case was just for the primtype half; extend to the whole head</span>
    <span class="k">have</span> <span class="n">res1&#39;</span><span class="o">:</span> <span class="n">decidable</span> <span class="o">((</span><span class="n">a_hds</span><span class="o">,</span> <span class="n">a_hdp</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b_hds</span><span class="o">,</span> <span class="n">b_hdp</span><span class="o">))</span> <span class="o">:=</span>
            <span class="n">prod_eq_intro</span> <span class="n">a_hds</span> <span class="n">b_hds</span> <span class="n">a_hdp</span> <span class="n">b_hdp</span>
                <span class="o">(</span><span class="n">string</span><span class="bp">.</span><span class="n">has_decidable_eq</span> <span class="n">a_hds</span> <span class="n">b_hds</span><span class="o">)</span> <span class="n">res1</span><span class="o">,</span>

    <span class="k">have</span> <span class="n">res2</span><span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">a_tl</span> <span class="bp">=</span> <span class="n">b_tl</span><span class="o">)</span> <span class="o">:=</span>
        <span class="k">have</span> <span class="n">H1</span><span class="o">:</span> <span class="n">a_tl</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">b_tl</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">,</span>
                <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
        <span class="k">have</span> <span class="n">H2</span><span class="o">:</span> <span class="n">b_tl</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">a_tl</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">,</span>
                <span class="k">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">H1</span><span class="o">],</span>
        <span class="k">have</span> <span class="n">H3</span><span class="o">:</span> <span class="n">a_tl</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">b_tl</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">,</span>
                <span class="k">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">H1</span><span class="o">],</span>
        <span class="k">have</span> <span class="n">H4</span><span class="o">:</span> <span class="n">b_tl</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">a_tl</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="bp">.</span><span class="n">sizeof</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">,</span>
                <span class="k">by</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">H1</span><span class="o">],</span>
        <span class="n">P_list_eq</span> <span class="n">a_tl</span> <span class="n">b_tl</span><span class="o">,</span> <span class="c1">-- the tail is decidably equal (recursive call)</span>

    <span class="c1">-- head and tail are both decidably equal, so we&#39;re done</span>
    <span class="n">exact</span> <span class="bp">@</span><span class="n">and</span><span class="bp">.</span><span class="n">decidable</span> <span class="o">((</span><span class="n">a_hds</span><span class="o">,</span> <span class="n">a_hdp</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b_hds</span><span class="o">,</span> <span class="n">b_hdp</span><span class="o">))</span> <span class="o">(</span><span class="n">a_tl</span> <span class="bp">=</span> <span class="n">b_tl</span><span class="o">)</span>
                         <span class="n">res1&#39;</span> <span class="n">res2</span>
    <span class="o">}</span>
<span class="kn">end</span>

<span class="k">with</span> <span class="n">S_eq</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">string</span><span class="o">),</span> <span class="n">decidable_eq</span> <span class="o">(</span><span class="n">Struct</span> <span class="n">s</span><span class="o">)</span>
 <span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">mk</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>      <span class="o">(</span><span class="n">nil</span> <span class="bp">_</span><span class="o">)</span>       <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nil</span> <span class="bp">_</span><span class="o">)</span>       <span class="o">(</span><span class="n">mk</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>      <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">}</span>
 <span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nil</span> <span class="bp">_</span><span class="o">)</span>       <span class="o">(</span><span class="n">nil</span> <span class="bp">_</span><span class="o">)</span>       <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">true</span><span class="o">}</span>
 <span class="bp">|</span> <span class="n">z</span> <span class="o">(</span><span class="n">Struct</span><span class="bp">.</span><span class="n">mk</span> <span class="n">m</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">Struct</span><span class="bp">.</span><span class="n">mk</span> <span class="n">n</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">P_list_eq</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="k">with</span> <span class="n">Hf</span> <span class="n">Ht</span><span class="o">,</span> <span class="c1">-- recursively check if lists are equal</span>
        <span class="o">{</span><span class="n">simp</span> <span class="o">[</span><span class="n">Hf</span><span class="o">],</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">false</span><span class="o">},</span>
        <span class="o">{</span><span class="n">rw</span> <span class="n">Ht</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">true</span><span class="o">}}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">{</span><span class="n">s</span><span class="o">:</span> <span class="n">string</span><span class="o">},</span> <span class="n">decidable_eq</span> <span class="o">(</span><span class="n">Struct</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">intros</span> <span class="n">s</span><span class="o">,</span> <span class="n">exact</span> <span class="n">S_eq</span> <span class="n">s</span><span class="o">}</span>

<span class="n">def</span> <span class="n">f</span> <span class="o">{</span><span class="n">s</span><span class="o">:</span> <span class="n">string</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">Struct</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span> <span class="n">Struct</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">f</span> <span class="o">(</span><span class="n">mk</span> <span class="s2">&quot;a&quot;</span> <span class="o">[])</span> <span class="o">(</span><span class="n">nil</span> <span class="s2">&quot;a&quot;</span><span class="o">)</span> <span class="c1">--ff</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
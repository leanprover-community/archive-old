---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/congr.20lemma.20for.20invertible.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html">congr lemma for invertible</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271422308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271422308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271422308">(Feb 10 2022 at 12:11)</a>:</h4>
<p>Right now this fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.invertible</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">[</span><span class="n">invertible</span> <span class="n">r₁</span><span class="o">]</span> <span class="o">[</span><span class="n">invertible</span> <span class="n">r₂</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟</span><span class="n">r₂</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="c1">-- fails</span>
</code></pre></div>
<p>Is there a way to provide a <code>congr</code> lemma so that this works?</p>



<a name="271422430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271422430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271422430">(Feb 10 2022 at 12:12)</a>:</h4>
<p>My naive attempt was:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">invertible_congr</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">[</span><span class="n">i₁</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">r₁</span><span class="o">]</span> <span class="o">[</span><span class="n">i₂</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">r₂</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟</span><span class="n">r₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">substI</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>but this doesn't accept a <code>@[congr]</code> attribute</p>



<a name="271423091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271423091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271423091">(Feb 10 2022 at 12:19)</a>:</h4>
<p>If I introduce a stupid alias for <code>invertible.inv_of</code> that takes a <code>monoid</code> argument, then <code>@[congr]</code> is happy:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.invertible</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">invertible</span> <span class="n">r₁</span><span class="o">]</span> <span class="o">[</span><span class="n">invertible</span> <span class="n">r₂</span><span class="o">]</span>

<span class="sd">/-- A duplicate of `⅟` that makes `congr` happy -/</span>
<span class="kd">abbreviation</span> <span class="n">invertible.inv_of'</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">invertible</span> <span class="n">r</span><span class="o">]</span> <span class="o">:=</span> <span class="bp">⅟</span><span class="n">r</span>
<span class="kd">notation</span> <span class="bp">`⅟'`</span> <span class="o">:=</span> <span class="n">invertible.inv_of'</span>

<span class="sd">/-- `congr` is happy as long as we use `⅟'`-/</span>
<span class="kd">@[congr]</span> <span class="kd">lemma</span> <span class="n">invertible_congr'</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟'</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟'</span><span class="n">r₂</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">substI</span> <span class="n">h</span><span class="o">,</span> <span class="n">congr</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm"> `simp` is happy as long as we use `⅟'` on the LHS-/</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟'</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟'</span><span class="n">r₂</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="c1">-- ok</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟'</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟</span><span class="n">r₂</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="c1">-- ok</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟'</span><span class="n">r₂</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="c1">-- fails</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟</span><span class="n">r₂</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="271423762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271423762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271423762">(Feb 10 2022 at 12:26)</a>:</h4>
<p>Yes, this is a known limitation in Lean 3.  It is already gone in Lean 4.</p>



<a name="271423839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271423839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271423839">(Feb 10 2022 at 12:27)</a>:</h4>
<p>Are there any known workarounds?</p>



<a name="271424021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271424021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271424021">(Feb 10 2022 at 12:29)</a>:</h4>
<p>I guess you could state the lemma like this (untested):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">is_monoid</span> <span class="o">(</span><span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">instance</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_monoid</span> <span class="n">R</span> <span class="o">:=</span> <span class="bp">...</span>

<span class="kd">@[congr]</span>
<span class="kd">lemma</span> <span class="n">invertible_congr</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">[</span><span class="n">i₁</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">r₁</span><span class="o">]</span> <span class="o">[</span><span class="n">i₂</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">r₂</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟</span><span class="n">r₂</span> <span class="o">:=</span>
</code></pre></div>



<a name="271424758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271424758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271424758">(Feb 10 2022 at 12:37)</a>:</h4>
<p>Nice, that does the trick:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.invertible</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">invertible</span> <span class="n">r₁</span><span class="o">]</span> <span class="o">[</span><span class="n">invertible</span> <span class="n">r₂</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">is_monoid</span> <span class="o">(</span><span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">out</span> <span class="o">[]</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">m</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">R</span><span class="o">,</span> <span class="n">mul_one_class.to_has_one</span> <span class="n">R</span> <span class="bp">=</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="bp">∧</span> <span class="n">mul_one_class.to_has_mul</span> <span class="n">R</span> <span class="bp">=</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span>

<span class="kd">instance</span> <span class="n">monoid.is_monoid</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_monoid</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨⟨‹</span><span class="n">_</span><span class="o">›,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩</span>

<span class="kd">@[congr]</span>
<span class="kd">lemma</span> <span class="n">invertible_congr</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">is_monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">[</span><span class="n">i₁</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">r₁</span><span class="o">]</span> <span class="o">[</span><span class="n">i₂</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">r₂</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟</span><span class="n">r₂</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span>
  <span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">m</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">R</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">is_monoid.out</span> <span class="n">R</span> <span class="o">},</span>
  <span class="n">substI</span> <span class="n">h</span><span class="o">,</span> <span class="n">congr</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟</span><span class="n">r₂</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="c1">-- ok</span>
</code></pre></div>



<a name="271424796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271424796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271424796">(Feb 10 2022 at 12:37)</a>:</h4>
<p>Is that something that is ok in mathlib? Perhaps renaming <code>is_monoid</code> to <code>invertible_congr_aux</code> or something to discourage widespread use?</p>



<a name="271424943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271424943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271424943">(Feb 10 2022 at 12:39)</a>:</h4>
<p>Don't know what's going on here but (a) <code>is_monoid</code> should be called <code>is_monoid</code> and not <code>invertible_congr_aux</code> (b) <code>is_monoid</code> shouldn't be a class, if you want a class, just use <code>monoid</code></p>



<a name="271424971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271424971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271424971">(Feb 10 2022 at 12:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, if I use <code>[monoid R]</code> then <code>@[congr]</code> complains. By using the <code>is_monoid R</code> hack above, it doesn't</p>



<a name="271426038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426038">(Feb 10 2022 at 12:51)</a>:</h4>
<p>Is this really worth fixing?</p>



<a name="271426078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426078">(Feb 10 2022 at 12:51)</a>:</h4>
<p>or at least, in this way? it seems like a quite generic sort of issue?</p>



<a name="271426158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426158">(Feb 10 2022 at 12:52)</a>:</h4>
<p>Right, but this is also a generic recipe for solving it - here's the version with it called <code>aux</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.invertible</span>

<span class="sd">/-- typeclass to hide arguments for `invertible_congr` that `congr` rejects.</span>
<span class="sd">The equalities are used to substitute arguments in `invertible_congr` with expressions built from</span>
<span class="sd">the data fields. -/</span>
<span class="kd">class</span> <span class="kd">inductive</span> <span class="n">invertible_congr.aux</span> <span class="o">(</span><span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">intro</span>
    <span class="o">(</span><span class="n">monoid</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">R</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h_one_eq</span> <span class="o">:</span> <span class="n">mul_one_class.to_has_one</span> <span class="n">R</span> <span class="bp">=</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span>
    <span class="o">(</span><span class="n">h_mul_eq</span> <span class="o">:</span> <span class="n">mul_one_class.to_has_mul</span> <span class="n">R</span> <span class="bp">=</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="o">:</span> <span class="n">invertible_congr.aux</span>

<span class="kd">instance</span> <span class="n">invertible_congr.aux.inst</span> <span class="o">{</span><span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">invertible_congr.aux</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">⟨‹</span><span class="n">_</span><span class="o">›,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">[</span><span class="n">invertible</span> <span class="n">r₁</span><span class="o">]</span> <span class="o">[</span><span class="n">invertible</span> <span class="n">r₂</span><span class="o">]</span>

<span class="sd">/--</span>
<span class="sd">This can't take a `[monoid]` argument as `@[congr]` does not allow the `mul_one_class.to_has_one`</span>
<span class="sd">term that appears in the goal. Instead we take a typeclass that allows us to replace the `has_one R`</span>
<span class="sd">term with such an expression within the proof. -/</span>
<span class="kd">@[congr]</span>
<span class="kd">lemma</span> <span class="n">invertible_congr</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">invertible_congr.aux</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">[</span><span class="n">i₁</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">r₁</span><span class="o">]</span> <span class="o">[</span><span class="n">i₂</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">r₂</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟</span><span class="n">r₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfreezingI</span> <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">‹</span><span class="n">invertible_congr.aux</span> <span class="n">R</span><span class="o">›</span> <span class="o">},</span>
  <span class="n">substI</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">congr</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟</span><span class="n">r₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="271426219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426219">(Feb 10 2022 at 12:53)</a>:</h4>
<p>I don't really think we should be adding a bunch of workarounds to mathlib like this</p>



<a name="271426261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426261">(Feb 10 2022 at 12:53)</a>:</h4>
<p>The alternative is facing annoying situations where <code>simp</code> makes no progress</p>



<a name="271426286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426286">(Feb 10 2022 at 12:53)</a>:</h4>
<p>seems okay!</p>



<a name="271426340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426340">(Feb 10 2022 at 12:54)</a>:</h4>
<p>There are other tactics</p>



<a name="271426647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426647">(Feb 10 2022 at 12:57)</a>:</h4>
<p>Sure, but the tradeoff is either:</p>
<ul>
<li>have a bizarre workaround like the one above, that no one ever looks at again, which gets silently removed in  mathlib4</li>
<li>have multiple users run into the same problem every time, and produce weird proofs as workarounds that stick around in mathlib4</li>
</ul>



<a name="271426666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426666">(Feb 10 2022 at 12:57)</a>:</h4>
<p>How would you solve this goal?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>  <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">bar</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">[</span><span class="n">invertible</span> <span class="o">(</span><span class="n">foo</span> <span class="mi">1</span><span class="o">)]</span> <span class="o">[</span><span class="n">invertible</span> <span class="o">(</span><span class="n">bar</span> <span class="mi">2</span><span class="o">)]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">foo</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">bar</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">37</span> <span class="bp">+</span> <span class="bp">⅟</span><span class="o">(</span><span class="n">foo</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="bp">+</span> <span class="bp">⅟</span><span class="o">(</span><span class="n">bar</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="271426781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426781">(Feb 10 2022 at 12:58)</a>:</h4>
<p>The natural sequence of thing to try is <code>rw h</code>, <code>simp_rw h</code>, and <code>simp [h]</code> in some order, and all of those fail.</p>



<a name="271426803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426803">(Feb 10 2022 at 12:58)</a>:</h4>
<p>With the code above hidden away in mathlib, <code>simp_rw h</code> works fine</p>



<a name="271426987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271426987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271426987">(Feb 10 2022 at 13:00)</a>:</h4>
<p>It just looks worse to me to add 20 lines of obscurities per instance of this issue. That's all</p>



<a name="271427177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271427177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271427177">(Feb 10 2022 at 13:01)</a>:</h4>
<p>I suppose there are two more options, which are:</p>
<ul>
<li>Fix the problem in Lean 3 core</li>
<li>Write a metaprogram to generate the above boilerplate</li>
</ul>
<p>I think having Lean 4 on the horizon makes these look less desirable than accumulating the 20 lines each time.</p>



<a name="271459880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271459880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271459880">(Feb 10 2022 at 16:53)</a>:</h4>
<p>I agree with Reid, you should just use <code>congr_arg</code> or something if this comes up, adding typeclasses seems like it will cause lots of downstream problems for a proof-local issue</p>



<a name="271463898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271463898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271463898">(Feb 10 2022 at 17:21)</a>:</h4>
<p>What proof would you suggest for the above <code>sorry</code>, Mario?</p>



<a name="271465660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271465660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271465660">(Feb 10 2022 at 17:34)</a>:</h4>
<p>I might be biased because I suggested the hack, but I don't think it will cause any technical issues (as long as it is only used for this congruence lemma).  It's a type class with a single instance, that is only required by a single lemma.  And this congruence lemma is only triggered when the simplifier sees an <code>inv_of</code> constant.  Any potential negative impact is extremely limited.</p>
<p>The simplifier <em>should</em> be able to rewrite under <code>inv_of</code>; we have similar congruence lemmas for <code>fintype.card</code> etc.  Adding this congruence lemma would only be consistent.</p>
<p>Finally, the hack is short-lived.  We can remove it immediately after switching to Lean 4.  (The congruence lemma will work when written with <code>[Monoid R]</code> instead of <code>[Mul R] [One R] [IsMonoid R]</code>.)</p>



<a name="271466668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271466668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271466668">(Feb 10 2022 at 17:41)</a>:</h4>
<p>I see, if it's a specialized typeclass then I agree it's more contained. The docs should make it clear that it's not intended for use beyond that though</p>



<a name="271466782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271466782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271466782">(Feb 10 2022 at 17:42)</a>:</h4>
<p>the <code>is_monoid</code> name sounds like it will get used elsewhere</p>



<a name="271466929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271466929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271466929">(Feb 10 2022 at 17:43)</a>:</h4>
<p>What about <code>monoid_congr_class_warning_do_not_use</code>?</p>



<a name="271467058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271467058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271467058">(Feb 10 2022 at 17:44)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Is that a MWE? <code>37 + ⅟(foo 1)</code> doesn't typecheck</p>



<a name="271467188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271467188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271467188">(Feb 10 2022 at 17:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/113488-general/topic/congr.20lemma.20for.20invertible/near/271466929">said</a>:</p>
<blockquote>
<p>What about <code>monoid_congr_class_warning_do_not_use</code>?</p>
</blockquote>
<p>At that point, <code>invertible_congr.aux</code> as I use above is better</p>



<a name="271467345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271467345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271467345">(Feb 10 2022 at 17:46)</a>:</h4>
<p>Fixed to be a MWE</p>



<a name="271467798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271467798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271467798">(Feb 10 2022 at 17:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.invertible</span>

<span class="kd">lemma</span> <span class="n">invertible_congr</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">r₁</span> <span class="n">r₂</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span>
  <span class="o">[</span><span class="n">i₁</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">r₁</span><span class="o">]</span> <span class="o">[</span><span class="n">i₂</span> <span class="o">:</span> <span class="n">invertible</span> <span class="n">r₂</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">r₁</span> <span class="bp">=</span> <span class="n">r₂</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⅟</span><span class="n">r₁</span> <span class="bp">=</span> <span class="bp">⅟</span><span class="n">r₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">substI</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">bar</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>
  <span class="o">[</span><span class="n">invertible</span> <span class="o">(</span><span class="n">foo</span> <span class="mi">1</span><span class="o">)]</span> <span class="o">[</span><span class="n">invertible</span> <span class="o">(</span><span class="n">bar</span> <span class="mi">2</span><span class="o">)]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">foo</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">bar</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">37</span> <span class="bp">+</span> <span class="bp">⅟</span><span class="o">(</span><span class="n">foo</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">37</span> <span class="bp">+</span> <span class="bp">⅟</span><span class="o">(</span><span class="n">bar</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">invertible_congr</span> <span class="n">h</span> <span class="o">}</span>
</code></pre></div>



<a name="271476843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/congr%20lemma%20for%20invertible/near/271476843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/congr.20lemma.20for.20invertible.html#271476843">(Feb 10 2022 at 18:53)</a>:</h4>
<p>Probably the argument goes that we should have <code>invertible_congr</code> in that form for human use anyway, and then provide <code>invertible_congr'</code> for Lean 3's sake with the weird typeclass</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
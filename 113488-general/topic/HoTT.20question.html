---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/HoTT.20question.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html">HoTT question</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="172809524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172809524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172809524">(Aug 08 2019 at 22:41)</a>:</h4>
<p>I've been chatting to Martin Escudo, someone who knows a lot more about univalence than me. My understanding of one of his claims was that it was impossible to define (in Lean) a predicate P on types such that P(nat) was provably true and P(int) was provably false. His argument seemed to be that a sufficiently large part of univalence was consistent with Lean. However he said that for functions from Type to Type one could find such functions P in the presence of global choice. My understanding of his claim is that he's saying the following is provable in Lean:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="o">(</span><span class="n">nonempty</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">X</span> <span class="n">Y</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≃</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span><span class="o">(</span><span class="n">Y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>In words: in the presence of what he calls "global choice" (c) one can find P : Type -&gt; Type such that P(X) is inhabited but P(Y) isn't, for some isomorphic X and Y. Have I understood him correctly?</p>



<a name="172809932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172809932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172809932">(Aug 08 2019 at 22:48)</a>:</h4>
<p>Your formal statement is certainly false, since you are claiming that this property holds of all P</p>



<a name="172809967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172809967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172809967">(Aug 08 2019 at 22:49)</a>:</h4>
<p>I don't think the claim you attribute to Martin is true either though; even in the presence of global choice it's still possible that <code>nat</code> and <code>int</code> are literally different names for the same underlying type</p>



<a name="172810078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172810078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172810078">(Aug 08 2019 at 22:51)</a>:</h4>
<blockquote>
<p>it was impossible to define (in Lean) a predicate P on types such that P(nat) was provably true and P(int) was provably false</p>
</blockquote>
<p>I agree with this</p>
<blockquote>
<p>However he said that for functions from Type to Type one could find such functions P in the presence of global choice. </p>
</blockquote>
<p>I disagree with this unless "find" is meant in a sense other than "there is a definable lean term P such that P(X) is provably true and P(Y) is provably false and X ~= Y is provable"</p>



<a name="172810538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172810538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172810538">(Aug 08 2019 at 22:59)</a>:</h4>
<p>Aren't I claiming that if univalence holds for all P then we have a contradiction?</p>



<a name="172810644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172810644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172810644">(Aug 08 2019 at 23:00)</a>:</h4>
<p>Of course anything Martin said about univalence could well have been mangled as it passed through my brain</p>



<a name="172811043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172811043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172811043">(Aug 08 2019 at 23:07)</a>:</h4>
<p>Oh I have made an elementary error, hang on</p>



<a name="172811258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172811258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172811258">(Aug 08 2019 at 23:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="o">(</span><span class="n">nonempty</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span><span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">P</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="err">≃</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">P</span><span class="o">(</span><span class="n">Y</span><span class="o">))</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>This is what I meant to claim that he was saying should be provable. Sorry.</p>



<a name="172811272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172811272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172811272">(Aug 08 2019 at 23:11)</a>:</h4>
<p>"global choice is inconsistent with univalence"</p>



<a name="172811629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172811629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172811629">(Aug 08 2019 at 23:18)</a>:</h4>
<p>That's also false</p>



<a name="172811652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172811652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172811652">(Aug 08 2019 at 23:19)</a>:</h4>
<p>It's not the same as "global choice is inconsistent with univalence" which is true</p>



<a name="172811669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172811669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172811669">(Aug 08 2019 at 23:19)</a>:</h4>
<p>The key data point is that "weak univalence", or <code>A ~= B -&gt; A = B</code>, is consistent with lean</p>



<a name="172811676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172811676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172811676">(Aug 08 2019 at 23:19)</a>:</h4>
<p>which implies that your example statement is not provable</p>



<a name="172811831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172811831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172811831">(Aug 08 2019 at 23:22)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">weak_ua</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">},</span> <span class="n">X</span> <span class="err">≃</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span><span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">P</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="err">≃</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">P</span><span class="o">(</span><span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">P</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">hX</span> <span class="n">e</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="bp">_</span> <span class="o">(</span><span class="n">weak_ua</span> <span class="n">e</span><span class="o">))</span> <span class="n">hX</span>
</pre></div>



<a name="172812287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172812287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172812287">(Aug 08 2019 at 23:30)</a>:</h4>
<p>Here is a proof that full univalence is false (using proof irrelevance, not choice)</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">transport</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span> <span class="err">≃</span> <span class="n">Y</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="o">)</span> <span class="n">h</span>
<span class="kn">constant</span> <span class="n">ua</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≃</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span>
<span class="kn">axiom</span> <span class="n">ua_left_inv</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">X</span> <span class="err">≃</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">transport</span> <span class="o">(</span><span class="n">ua</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">e</span>

<span class="n">def</span> <span class="n">bswap</span> <span class="o">:</span> <span class="n">bool</span> <span class="err">≃</span> <span class="n">bool</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">bnot</span><span class="o">,</span> <span class="n">bnot</span><span class="o">,</span> <span class="n">bnot_bnot</span><span class="o">,</span> <span class="n">bnot_bnot</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">transport</span> <span class="o">(</span><span class="n">ua</span> <span class="n">bswap</span><span class="o">)</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">ff</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span> <span class="o">:</span> <span class="n">bool</span> <span class="err">≃</span> <span class="n">bool</span><span class="o">,</span> <span class="n">e</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="n">ua_left_inv</span> <span class="n">bswap</span><span class="o">):</span><span class="bp">_</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">transport</span> <span class="o">(</span><span class="n">ua</span> <span class="n">bswap</span><span class="o">)</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span> <span class="o">:</span> <span class="n">bool</span> <span class="err">≃</span> <span class="n">bool</span><span class="o">,</span> <span class="n">e</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="n">ua_left_inv</span> <span class="o">(</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="o">)):</span><span class="bp">_</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">bool</span><span class="bp">.</span><span class="n">ff_ne_tt</span> <span class="o">(</span><span class="n">h1</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h2</span><span class="o">)</span>
<span class="kn">end</span>
</pre></div>



<a name="172812421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172812421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172812421">(Aug 08 2019 at 23:33)</a>:</h4>
<p>Thanks!</p>



<a name="172828877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172828877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172828877">(Aug 09 2019 at 06:35)</a>:</h4>
<p>That was written just as I went to bed but I now realise that it's just the standard <code>bool</code> thing again. Aut(bool) is not a subsingleton, which is problematic with an impredicative =. But what I'm trying to understand is why global choice contradicts univalence.</p>



<a name="172829551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172829551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172829551">(Aug 09 2019 at 06:54)</a>:</h4>
<p>I think it's more or less because if I choose from a non subsingleton type, that choice won't be preserved under a non identity permutation of that type.</p>



<a name="172831754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172831754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172831754">(Aug 09 2019 at 07:37)</a>:</h4>
<p>I had a go in HoTT Lean. There are a couple of sorries. Not sure if this is the right idea. Also HoTT Lean wants me to give explicit motives for every substitution. Thinking about it more, I'm not sure if <code>hb'</code> is provable.</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">hott</span><span class="o">]</span> <span class="n">def</span> <span class="n">bool_not</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">bool</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">equiv</span><span class="bp">.</span><span class="n">mk</span> <span class="n">bnot</span> <span class="err">$</span> <span class="n">is_equiv</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span> <span class="n">bnot</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">bool</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">b</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">bool</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">b</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">bool</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">b</span> <span class="n">rfl</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kn">axiom</span> <span class="n">choice</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">},</span> <span class="n">trunc</span> <span class="mi">0</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>

<span class="n">noncomputable</span> <span class="kn">example</span> <span class="o">:</span> <span class="n">empty</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">choice</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">tr</span> <span class="n">tt</span><span class="o">)</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">e</span> <span class="o">:</span> <span class="n">bool</span> <span class="bp">=</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">ua</span> <span class="n">bool_not</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">b&#39;</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">eq</span><span class="bp">.</span><span class="n">cast</span> <span class="n">e</span> <span class="n">b</span> <span class="k">in</span>
<span class="k">have</span> <span class="n">hb&#39;</span> <span class="o">:</span> <span class="n">b&#39;</span> <span class="bp">=</span> <span class="n">choice</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">tr</span> <span class="n">ff</span><span class="o">),</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">b&#39;</span> <span class="bp">=</span> <span class="n">bnot</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="n">cast_ua</span> <span class="n">bool_not</span> <span class="n">b</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="n">b&#39;</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="bp">_</span>
  <span class="o">(</span><span class="n">choice</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">tr</span> <span class="n">ff</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="bp">_</span><span class="o">,</span> <span class="n">b&#39;</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="bp">_</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="bp">_</span> <span class="o">(</span><span class="n">choice</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">tr</span> <span class="n">tt</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="bp">_</span><span class="o">,</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="bp">_</span>
      <span class="o">(</span><span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="bp">_</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">tr</span> <span class="n">ff</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">c</span> <span class="bp">_</span><span class="o">,</span> <span class="n">choice</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">choice</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">tr</span> <span class="n">ff</span><span class="o">))</span> <span class="bp">_</span>
        <span class="n">sorry</span>
        <span class="n">rfl</span><span class="o">)</span>
      <span class="n">rfl</span><span class="o">)</span>
    <span class="n">hb&#39;</span><span class="o">,</span>
</pre></div>



<a name="172832217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172832217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172832217">(Aug 09 2019 at 07:49)</a>:</h4>
<p>Martin says that I need to use "full univalence", as other people have pointed out, and because full univalence is just inconsistent with Lean, it's inconsistent with global choice in Lean, as Mario pointed out. I don't think I have a question any more. Thanks Mario and Chris.</p>



<a name="172858680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/172858680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#172858680">(Aug 09 2019 at 15:07)</a>:</h4>
<p>There are two separate claims here, both of which are true:</p>
<ul>
<li>Univalence is inconsistent with proof irrelevance;</li>
<li>Univalence is inconsistent with global choice.</li>
</ul>



<a name="290529345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/290529345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#290529345">(Jul 22 2022 at 15:53)</a>:</h4>
<p>I am able to formalize the proof in Lemma 3.8.5 in the HoTT book; the middle paragraph isn't used.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">hott.hit.trunc</span>
<span class="kn">open</span> <span class="n">hott</span>
<span class="n">hott_theory</span>

<span class="kd">axiom</span> <span class="n">choice</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">},</span> <span class="n">trunc</span> <span class="bp">-</span><span class="mi">1</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>

<span class="kd">@[hott]</span> <span class="kd">example</span> <span class="o">:</span> <span class="n">empty</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{</span><span class="n">A</span> <span class="bp">|</span> <span class="n">trunc</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">=</span> <span class="n">A</span><span class="o">)},</span>
  <span class="k">let</span> <span class="n">x₀</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">bool</span><span class="o">,</span> <span class="n">trunc.tr</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="k">let</span> <span class="o">:</span> <span class="n">is_contr</span> <span class="n">X</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨⟨</span><span class="n">x₀</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩⟩,</span> <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">x</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">choice</span> <span class="o">(</span><span class="n">trunc.trunc_functor</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">p</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">sigma.subtype_eq</span> <span class="n">h</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">is_prop</span> <span class="o">(</span><span class="n">x₀</span> <span class="bp">=</span> <span class="n">x₀</span><span class="o">),</span> <span class="o">{</span> <span class="n">resetI</span><span class="o">,</span> <span class="n">apply_instance</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">he</span> <span class="o">:</span> <span class="o">(</span><span class="n">x₀</span> <span class="bp">=</span> <span class="n">x₀</span><span class="o">)</span> <span class="bp">≃</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">=</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sigma.subtype_eq_equiv</span> <span class="n">x₀</span> <span class="n">x₀</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">bool.not_is_prop_bool_eq_bool</span> <span class="o">(</span><span class="n">is_trunc.is_trunc_equiv_closed</span> <span class="n">_</span> <span class="n">he</span> <span class="n">hp</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>
<p>Choice is stated as <code>trunc -1 α → α</code> as it normally is, not <code>trunc 0 α → α</code>. I don't know why <span class="user-mention" data-user-id="110044">@Chris Hughes</span> uses <code>trunc 0</code> and I don't know whether that version is consistent with univalence.</p>



<a name="290699173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/290699173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#290699173">(Jul 24 2022 at 20:50)</a>:</h4>
<p>Are you sure that with your conventions <code>trunc -1 α → α</code> is in <code>Prop</code>?</p>



<a name="290701054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/HoTT%20question/near/290701054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/HoTT.20question.html#290701054">(Jul 24 2022 at 21:35)</a>:</h4>
<p>I don't think <code>trunc -1 α → α</code> is in <code>Prop</code>, but <a href="https://github.com/gebner/hott3/blob/7ead7a8a2503049eacd45cbff6587802bae2add2/src/hott/hit/trunc.lean#L118"><code>trunc -1 α</code> is</a> (more precisely, the type <code>trunc -1 α</code> together with a proof that it <code>is_prop</code>, is a term of type <code>Prop</code>). I think <code>trunc -1</code> is the HoTT analogue of <a href="https://leanprover-community.github.io/mathlib_docs/find/nonempty">docs#nonempty</a>, so <code>axiom choice</code> above is the analogue of global choice (<a href="https://leanprover-community.github.io/mathlib_docs/find/classical.choice">docs#classical.choice</a>). <code>trunc 0 α</code> on the other hand truncates <code>α</code> to a set.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html">_match_1_ term in monad unfolding</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="245850615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245850615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joey Lupo <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245850615">(Jul 13 2021 at 16:29)</a>:</h4>
<p>I have been working on some crypto proofs (now on GitHub at <a href="https://github.com/Loops7/cryptolib">https://github.com/Loops7/cryptolib</a>) in Lean and ran into an interesting problem. Below is a MWE for proving the correctness of the ElGamal public key encryption algorithm, with code drawn from a few different files in my project: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.basic</span>
<span class="kn">import</span> <span class="n">measure_theory.probability_mass_function</span>

<span class="kd">noncomputable theory</span>

<span class="kd">lemma</span> <span class="n">zmod_ne_zero</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span> <span class="o">:</span> <span class="o">(</span><span class="n">zmod.fintype</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">elems.val</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">multiset.card_pos</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">multiset.card</span> <span class="o">(</span><span class="n">fintype.elems</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">zmod.card</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">_inst_1.out</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">uniform_zmod</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span> <span class="o">:</span> <span class="n">pmf</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">pmf.of_multiset</span> <span class="o">(</span><span class="n">zmod.fintype</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">elems.val</span> <span class="o">(</span><span class="n">zmod_ne_zero</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">monad</span> <span class="n">pmf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pure</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pmf.pure</span><span class="o">,</span>
  <span class="n">bind</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pmf.bind</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">is_lawful_functor</span> <span class="n">pmf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">id_map</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pmf.map_id</span><span class="o">,</span>
  <span class="n">comp_map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">pmf.map_comp</span> <span class="n">x</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">is_lawful_monad</span> <span class="n">pmf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pure_bind</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pmf.pure_bind</span><span class="o">,</span>
  <span class="n">bind_assoc</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pmf.bind_bind</span> <span class="o">}</span>

<span class="kn">section</span> <span class="n">mwe</span>

<span class="kd">parameters</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">G</span><span class="o">]</span>
           <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">hGg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">subgroup.gpowers</span> <span class="n">g</span><span class="o">)</span>
           <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">q</span><span class="o">)]</span> <span class="o">(</span><span class="n">hGq</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">q</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">G</span>
<span class="kd">def</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span>

<span class="c1">-- g^x is the public key, and x is the secret key</span>
<span class="kd">def</span> <span class="n">keygen</span> <span class="o">:</span> <span class="n">pmf</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">q</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">x</span> <span class="bp">←</span> <span class="n">uniform_zmod</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">return</span> <span class="o">(</span><span class="n">g</span><span class="bp">^</span><span class="n">x.val</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>

<span class="c1">-- encrypt takes a pair (pk, m)</span>
<span class="kd">def</span> <span class="n">encrypt</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">pmf</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">y</span> <span class="bp">←</span> <span class="n">uniform_zmod</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">return</span> <span class="o">(</span><span class="n">g</span><span class="bp">^</span><span class="n">y.val</span><span class="o">,</span> <span class="o">(</span><span class="n">m.1</span><span class="o">)</span><span class="bp">^</span><span class="n">y.val</span> <span class="bp">*</span> <span class="n">m.2</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">decrypt</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">c.2</span> <span class="bp">/</span> <span class="o">(</span><span class="n">c.1</span><span class="bp">^</span><span class="n">x.val</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">enc_dec_simplified</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">pmf</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="o">(</span><span class="n">α</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">←</span> <span class="n">keygen</span><span class="o">,</span>
  <span class="n">return</span> <span class="mi">1</span>

<span class="kd">theorem</span> <span class="n">elgamal_simplified_correct</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">enc_dec_simplified</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">return</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">enc_dec_simplified</span><span class="o">],</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">enc_dec</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">pmf</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="o">(</span><span class="n">α</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="bp">←</span> <span class="n">keygen</span><span class="o">,</span>
  <span class="o">(</span><span class="n">β</span><span class="o">,</span> <span class="n">ζ</span><span class="o">)</span> <span class="bp">←</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">α</span><span class="o">,</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">return</span> <span class="o">(</span><span class="k">if</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">decrypt</span> <span class="n">x</span> <span class="o">(</span><span class="n">β</span><span class="o">,</span> <span class="n">ζ</span><span class="o">)</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">elgamal_correct</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">enc_dec</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">return</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">enc_dec</span><span class="o">],</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
<span class="kd">end</span> <span class="n">mwe</span>
</code></pre></div>
<p>I am modeling the ElGamal encryption algorithm using mathlib's probability mass function <code>pmf</code> monad. My basic proof strategy at this (early) point in the process is to break down <code>enc_dec_simplified</code> into a sequence of monadic binds, at which point I can apply simple lemmas regarding binds and returns and which relate two pmfs which differ by one line.  However, after entering <code>simp [enc_dec_simplified]</code> to unfold the definition of <code>enc_dec_simplified</code>, a mysterious <code>enc_dec_simplified._match_1</code> term appears where <code>return 1</code> should appear. I have not encountered this phenomenon before and don't know how to get it to unfold nicely. My best guess is that it is a symptom of my use of parameters, but I really don't know why that would be the case. Any help or insight would be greatly appreciated.</p>



<a name="245850865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245850865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245850865">(Jul 13 2021 at 16:31)</a>:</h4>
<p><code>(α, x) ← keygen</code> is performing a pattern match, and pattern matches create an auxiliary function. You should be able to <code>simp</code> away <code>enc_dec_simplified._match_1</code> too.</p>



<a name="245851071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245851071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joey Lupo <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245851071">(Jul 13 2021 at 16:32)</a>:</h4>
<p>Yea, I have tried a few different things for that. I get <code>invalid simplification lemma</code> as a response.</p>



<a name="245851390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245851390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245851390">(Jul 13 2021 at 16:34)</a>:</h4>
<p>How about <code>dsimp</code>?</p>



<a name="245851560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245851560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245851560">(Jul 13 2021 at 16:36)</a>:</h4>
<p><code>dsimp</code> should work. Worst case scenario, you can use <code>change</code></p>



<a name="245851599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245851599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joey Lupo <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245851599">(Jul 13 2021 at 16:36)</a>:</h4>
<p><code>dsimp</code> gave me the same invalid response</p>



<a name="245852005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245852005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245852005">(Jul 13 2021 at 16:39)</a>:</h4>
<p>Try <code>delta enc_dec_simplified._match_1</code></p>



<a name="245852410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245852410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245852410">(Jul 13 2021 at 16:42)</a>:</h4>
<p>I think it doesn't work because <code>_match_1</code> only applies if there's a <code>(a, x)</code> term</p>



<a name="245852467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245852467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245852467">(Jul 13 2021 at 16:43)</a>:</h4>
<p>Ah, but <code>delta</code> does work!</p>



<a name="245852532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245852532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245852532">(Jul 13 2021 at 16:43)</a>:</h4>
<p>It's annoying because the <code>(a,x)</code> is in a monadic bind, so you can't break it up easily using <code>cases</code>.</p>



<a name="245852604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245852604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joey Lupo <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245852604">(Jul 13 2021 at 16:44)</a>:</h4>
<p>Yes, <code>delta</code> looks like it breaks through. That should help, much appreciated.</p>



<a name="245857781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245857781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245857781">(Jul 13 2021 at 17:21)</a>:</h4>
<p>I would just restructure the do notation to not do pattern matches on the left of the arrow, and rather use projection notation to access the prod.fst and prod.snd</p>



<a name="245857912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245857912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245857912">(Jul 13 2021 at 17:22)</a>:</h4>
<p>You're not even using the underlying things you got from the pattern match most of the time.</p>



<a name="245862432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245862432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joey Lupo <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245862432">(Jul 13 2021 at 17:54)</a>:</h4>
<p>Not sure what you mean. I use the things I get from pattern matching in every <code>pmf</code> except for the <code>enc_dec_simplified</code>, which is just a simplified example of the real <code>enc_dec</code> pmf for the purposes of illustrating my issue.</p>



<a name="245874927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245874927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245874927">(Jul 13 2021 at 19:26)</a>:</h4>
<p>Here's what I mean.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.zmod.basic</span>
<span class="kn">import</span> <span class="n">measure_theory.probability_mass_function</span>

<span class="kd">noncomputable theory</span>

<span class="kd">lemma</span> <span class="n">zmod_ne_zero</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span> <span class="o">:</span> <span class="o">(</span><span class="n">zmod.fintype</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">elems.val</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">multiset.card_pos</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">multiset.card</span> <span class="o">(</span><span class="n">fintype.elems</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">zmod.card</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">_inst_1.out</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">uniform_zmod</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)]</span> <span class="o">:</span> <span class="n">pmf</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">pmf.of_multiset</span> <span class="o">(</span><span class="n">zmod.fintype</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">elems.val</span> <span class="o">(</span><span class="n">zmod_ne_zero</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">monad</span> <span class="n">pmf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pure</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pmf.pure</span><span class="o">,</span>
  <span class="n">bind</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pmf.bind</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">is_lawful_functor</span> <span class="n">pmf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">id_map</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pmf.map_id</span><span class="o">,</span>
  <span class="n">comp_map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">pmf.map_comp</span> <span class="n">x</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">is_lawful_monad</span> <span class="n">pmf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">pure_bind</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pmf.pure_bind</span><span class="o">,</span>
  <span class="n">bind_assoc</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">pmf.bind_bind</span> <span class="o">}</span>

<span class="kn">section</span> <span class="n">mwe</span>

<span class="kd">parameters</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">G</span><span class="o">]</span>
           <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">hGg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">subgroup.gpowers</span> <span class="n">g</span><span class="o">)</span>
           <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">q</span><span class="o">)]</span> <span class="o">(</span><span class="n">hGq</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">q</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">G</span>
<span class="kd">def</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span>

<span class="c1">-- g^x is the public key, and x is the secret key</span>
<span class="kd">def</span> <span class="n">keygen</span> <span class="o">:</span> <span class="n">pmf</span> <span class="o">(</span><span class="n">G</span> <span class="bp">×</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">q</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">x</span> <span class="bp">←</span> <span class="n">uniform_zmod</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">return</span> <span class="o">(</span><span class="n">g</span><span class="bp">^</span><span class="n">x.val</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>

<span class="c1">-- encrypt takes a pair (pk, m)</span>
<span class="kd">def</span> <span class="n">encrypt</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">pmf</span> <span class="n">C</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">y</span> <span class="bp">←</span> <span class="n">uniform_zmod</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">return</span> <span class="o">(</span><span class="n">g</span><span class="bp">^</span><span class="n">y.val</span><span class="o">,</span> <span class="o">(</span><span class="n">m.1</span><span class="o">)</span><span class="bp">^</span><span class="n">y.val</span> <span class="bp">*</span> <span class="n">m.2</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">decrypt</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">c.2</span> <span class="bp">/</span> <span class="o">(</span><span class="n">c.1</span><span class="bp">^</span><span class="n">x.val</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">enc_dec_simplified</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">pmf</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">_</span> <span class="bp">←</span> <span class="n">keygen</span><span class="o">,</span>
  <span class="n">pure</span> <span class="mi">1</span>
<span class="c1">-- keygen &gt;&gt; pure 1</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">and_then_eq_bind</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">monad</span> <span class="n">m</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">m</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">m</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">&gt;&gt;</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">&gt;&gt;=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">return_eq_pure</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">return</span> <span class="n">pmf</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pure</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">lemma</span> <span class="n">pure_eq_pure</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">pure</span> <span class="n">pmf</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pmf.pure</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">pure_apply_self</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">@</span><span class="n">pure</span> <span class="n">pmf</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">pure_eq_pure</span><span class="o">,</span> <span class="n">pmf.pure_apply</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">pure_apply'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">pure</span> <span class="n">pmf</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pure_eq_pure</span><span class="o">,</span> <span class="n">pmf.pure_apply</span><span class="o">],</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">bind_eq_bind</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">pmf</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">pmf</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">v</span> <span class="bp">&gt;&gt;=</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">v.bind</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">elgamal_simplified_correct</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">enc_dec_simplified</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">return</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">enc_dec_simplified</span><span class="o">,</span> <span class="n">bind_eq_bind</span><span class="o">,</span> <span class="n">pure_apply'</span><span class="o">,</span> <span class="n">mul_boole</span><span class="o">,</span> <span class="n">and_then_eq_bind</span><span class="o">,</span>
    <span class="n">nnreal.coe_eq</span><span class="o">,</span> <span class="n">pmf.bind_apply</span><span class="o">],</span>
  <span class="n">split_ifs</span><span class="bp">;</span>
  <span class="n">simp</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">enc_dec</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">pmf</span> <span class="o">(</span><span class="n">zmod</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">αpair</span> <span class="bp">←</span> <span class="n">keygen</span><span class="o">,</span>
  <span class="n">βpair</span> <span class="bp">←</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">αpair.fst</span><span class="o">,</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">return</span> <span class="o">(</span><span class="k">if</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">decrypt</span> <span class="n">αpair.snd</span> <span class="n">βpair</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">mwe</span>
</code></pre></div>



<a name="245876244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245876244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joey Lupo <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245876244">(Jul 13 2021 at 19:37)</a>:</h4>
<p>I should have been clearer. My "not sure what you mean" was in response to "You're not even using the underlying things you got from the pattern match most of the time." In only one instance do I not use the underlying things from the pattern matching, and that was just for the purposes of not obfuscating the real issue I was having. </p>
<p>I understand what you mean by the restructuring to use projection, and appreciate you taking the time to write the code above.</p>



<a name="245877260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245877260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245877260">(Jul 13 2021 at 19:45)</a>:</h4>
<p>You're right, I misread the latter definition. There is some clunkiness about proving things about do-notation, matching is one. The other is that you have to have helper lemmas about how to convert from <code>&gt;&gt;=</code> to your specialized <code>bind</code>. And often the simplifcation only makes sense once you've applied the function, which leads to the <code>ext</code> steps. You can take a look at <code>data/buffer/parser/basic.lean</code> to see how I did it for another "computation" monad.</p>



<a name="245878806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/_match_1_%20term%20in%20monad%20unfolding/near/245878806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joey Lupo <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/_match_1_.20term.20in.20monad.20unfolding.html#245878806">(Jul 13 2021 at 19:59)</a>:</h4>
<p>Yes, I have been encountering exactly the clunkiness you are describing re: <code>pmf.bind</code> vs <code>&gt;&gt;=</code>. In one spot, using <code>simp[bind]</code> solved my goals completely unexpectedly! In others, I've had to do exactly the type of one-line lemmas with <code>rfl</code> proofs that you have used in your code above. Thank you for the suggestion, I will check out that file as I continue.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html">classical.em without funext / quot.sound</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207358170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207358170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207358170">(Aug 19 2020 at 00:20)</a>:</h4>
<p>After inlining and compression, I got this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">theorem</span> <span class="n">em&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">subs</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">P</span> <span class="n">Q</span><span class="o">,</span> <span class="o">(</span><span class="n">P</span><span class="o">,</span><span class="n">Q</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">true</span><span class="o">,</span><span class="n">p</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">P</span><span class="o">,</span><span class="n">Q</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">p</span><span class="o">,</span><span class="n">true</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">U</span> <span class="o">:</span> <span class="n">subs</span> <span class="n">true</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">V</span> <span class="o">:</span> <span class="n">subs</span> <span class="n">p</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">P</span> <span class="n">Q</span><span class="o">,</span> <span class="n">subs</span> <span class="n">P</span> <span class="n">Q</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">cond</span> <span class="n">b</span> <span class="n">P</span> <span class="n">Q</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">pt</span> <span class="n">pf</span> <span class="o">(</span><span class="bp">⟨⟨⟩⟩|⟨⟨⟩⟩</span><span class="o">)</span><span class="bp">;</span> <span class="o">[</span><span class="n">use</span> <span class="n">tt</span><span class="o">,</span> <span class="n">use</span> <span class="n">ff</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">choose</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">f</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">U</span> <span class="bp">≠</span> <span class="n">f</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">V</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">this</span><span class="bp">.</span><span class="n">imp_right</span> <span class="o">(</span><span class="n">mt</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">pp</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">cases</span> <span class="n">eq_true_intro</span> <span class="n">pp</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">up</span> <span class="o">:=</span> <span class="n">hf</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">U</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">f</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">U</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">up</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">vp</span> <span class="o">:=</span> <span class="n">hf</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">f</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">V</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">vp</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span> <span class="n">em&#39;</span> <span class="c1">-- classical.choice, propext</span>
</code></pre></div>



<a name="207361958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207361958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207361958">(Aug 19 2020 at 01:33)</a>:</h4>
<p>I made two essential adaptations to the original proof explained at <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle</a> : using <code>bool</code> instead of <code>Prop</code> as the type to choose from (just like the {0,1} used in the Wikipedia proof; not sure why <code>Prop</code> was chosen in Lean), and using <code>Prop × Prop</code> instead of the function type <code>bool → Prop</code> to get rid of function extensionality.</p>
<p>Not sure if this makes sense, but it seems that <code>nonempty_pi</code> preserves computability, while <code>choice</code> doesn't.</p>
<p>Obviously you can't prove <code>prop_decidable</code> and <code>type_decidable</code> this way; <code>choice</code> follows from <code>type_decidable</code>, which follows from <code>prop_decidable</code> without choice. It makes me wonder what advantage decidability really has over excluded middle for the purpose of doing math? You can't exhibit a function using <code>ite</code> or <code>dite</code> without decidability, but can prove such functions exist using <code>em</code> and <code>or.elim</code>. When using tactics, the difference between em and decidability only matters when the goal is a <code>Type</code> instead of a <code>Prop</code>. Most likely in those cases you are able to carry out a computable/recursive construction or the goal is a function that you can apply <code>nonempty_pi</code> show it exists. So maybe the <code>choose</code> tactic should produce a existential statement in the context when the goal is a <code>Type</code> using <code>nonempty_pi</code> rather than invoking <code>choice</code>, but when the goal is a <code>Prop</code> then it's free to exhibit an element proven to exist.</p>
<p>I am currently thinking of proving <code>em</code> with <code>quot.sound</code> but without <code>propext</code>. The rough idea is to quotient <code>Prop</code> by the equivalence relation <code>iff</code>.</p>



<a name="207362758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207362758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207362758">(Aug 19 2020 at 01:52)</a>:</h4>
<p>Fun to see and digest the statement of <code>nonempty_choice</code>, and nice observation that <code>nonempty_pi</code> follows from it! (Edit: it should prove nonempty_pi, as nonempty_pi is a Prop, so for the purpose of proving it, nonempty (something) is the same as something.)</p>



<a name="207362765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207362765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207362765">(Aug 19 2020 at 01:53)</a>:</h4>
<blockquote>
<p>Not sure if this makes sense, but it seems that nonempty_pi preserves computability, while choice doesn't.</p>
</blockquote>
<p>There have been discussions about the <code>trunc</code> version of <code>nonempty_pi</code>, which looks like it should be computable but isn't:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">trunc_pi</span><span class="bp">.</span><span class="n">impl</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">trunc</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">))</span> <span class="bp">→</span> <span class="n">trunc</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">unchecked_cast</span>

<span class="bp">@</span><span class="o">[</span><span class="n">vm_override</span> <span class="n">trunc_pi</span><span class="bp">.</span><span class="n">impl</span><span class="o">]</span> <span class="c1">-- this should be fine, right?</span>
<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">trunc_pi</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">trunc</span> <span class="o">(</span><span class="n">β</span> <span class="n">a</span><span class="o">))</span> <span class="bp">→</span> <span class="n">trunc</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">weird</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">trunc</span> <span class="o">(</span><span class="n">trunc</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">trunc_pi</span><span class="bp">.</span><span class="n">impl</span> <span class="n">id</span>

<span class="n">def</span> <span class="n">singl</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span><span class="o">}</span>
<span class="kn">instance</span> <span class="n">singl</span><span class="bp">.</span><span class="n">subsingleton</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">subsingleton</span> <span class="o">(</span><span class="n">singl</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="k">by</span> <span class="n">rintro</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩;</span> <span class="n">refl</span><span class="bp">⟩</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">lie</span> <span class="o">:</span> <span class="n">singl</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="n">trunc</span><span class="bp">.</span><span class="n">rec_on_subsingleton</span> <span class="o">(</span><span class="n">weird</span> <span class="n">bool</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="n">to_bool_tt</span> <span class="o">(</span><span class="k">by</span> <span class="n">congr</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="n">ff</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">trunc</span><span class="bp">.</span><span class="n">mk</span> <span class="n">tt</span><span class="o">))</span><span class="bp">⟩</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">lie</span><span class="bp">.</span><span class="mi">1</span> <span class="c1">-- ff</span>
</code></pre></div>



<a name="207362841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207362841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207362841">(Aug 19 2020 at 01:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> unfortunately my demonstration doesn't quite work with <code>vm_override</code> as I was hoping, because <code>trunc_pi</code> is still considered <code>noncomputable</code> and hence functions based on it don't get any VM implementation</p>



<a name="207363150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207363150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207363150">(Aug 19 2020 at 02:02)</a>:</h4>
<blockquote>
<p>It makes me wonder what advantage decidability really has over excluded middle for the purpose of doing math?</p>
</blockquote>
<p>You are omitting the most important part: ease of use. Yes, mathematicians like to prove theorems and as long as it's a Prop you can use <code>nonempty_choice</code> instead of <code>choice</code>, but the problem is that you have to be always working with respect to some choice function, and this is really inconvenient for things like choicy definitions (of which there are many in mathlib), like "the limit of the filter". You could probably cobble something together using a typeclass <code>[choicy.{u}]</code> to get a choice function, but we already have problems with typeclass unification when the class is a subsingleton, and the <code>choicy</code> typeclass is as non-unique as they come (that's sort of it's shtick)</p>



<a name="207363184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207363184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207363184">(Aug 19 2020 at 02:03)</a>:</h4>
<blockquote>
<p>The rough idea is to quotient Prop by the equivalence relation iff.</p>
</blockquote>
<p>I will be interested to see if this is successful. I tried and failed to do exactly this a few years ago</p>



<a name="207363418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207363418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207363418">(Aug 19 2020 at 02:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I think what it needs is for the <code>vm_override</code> attribute to remove the <code>noncomputable</code> mark when it is set. I didn't think of it before</p>



<a name="207363429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207363429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207363429">(Aug 19 2020 at 02:09)</a>:</h4>
<p>does that mean that we still write <code>noncomputable</code> but it's not actually noncomputable?</p>



<a name="207363501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207363501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207363501">(Aug 19 2020 at 02:11)</a>:</h4>
<p>Yeah, I know that's weird. The trouble is that the definition and its attribute are not added to the environment at the same time. First you add the definition and in all regards, it is <code>noncomputable</code> and that's only invalidated when the attribute is added</p>



<a name="207363581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207363581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207363581">(Aug 19 2020 at 02:13)</a>:</h4>
<p>maybe <code>noncomputable</code> should be an attribute</p>



<a name="207363814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207363814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Simon Hudon <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207363814">(Aug 19 2020 at 02:19)</a>:</h4>
<p>We would face a similar problem. I think we might need <code>vm_override</code> to be a keyword like <code>using_well_founded</code></p>



<a name="207363970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207363970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207363970">(Aug 19 2020 at 02:23)</a>:</h4>
<p>maybe we should call it <code>computable</code> :D</p>



<a name="207365646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207365646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207365646">(Aug 19 2020 at 03:00)</a>:</h4>
<p>Hmm, I thought <code>subtype.ext_val</code> must depend on <code>propext</code> (<code>true</code> has one constructor so any proven <code>Prop</code> has only one element), but it turns out it doesn't. Does the principle of proof irrelevance not need to be stated anywhere and is just directly applied by the kernel?<br>
<code>theorem pf_irrel (p : Prop) (a b : p) : a = b</code></p>



<a name="207365726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207365726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207365726">(Aug 19 2020 at 03:02)</a>:</h4>
<p>I have only learned Lean for three weeks (not counting natural number game or min/max game) so pardon my curiosity about many foundational issues.</p>



<a name="207365746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207365746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207365746">(Aug 19 2020 at 03:03)</a>:</h4>
<p>yes, proof irrelevance is a no axioms axiom</p>



<a name="207365813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207365813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207365813">(Aug 19 2020 at 03:04)</a>:</h4>
<p>I think I now have a good grasp of type theory by playing with Lean and it's maybe time to learn some HoTT.</p>



<a name="207365824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207365824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207365824">(Aug 19 2020 at 03:04)</a>:</h4>
<p>if you have the stomach for some type theory, <a href="https://github.com/digama0/lean-type-theory/releases/tag/v1.0">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a> has the description of the basic rules of lean in chapter 2</p>



<a name="207365850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207365850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207365850">(Aug 19 2020 at 03:04)</a>:</h4>
<p>Earlier today I was drawn to the problem what's the shortest proof from first principles of <code>tt≠ff</code>; it was used in the <code>em</code> proof above, but <code>trivial</code> solved it. Then I found <code>no_confusion</code> and <code>no_confusion_type</code> associated to every inductive type (just like <code>rec</code>, <code>rec_on</code> and <code>cases_on</code>), but am unable to find any documentation except brief mention in "Theorem Proving in Lean". Anyway, here is a relatively minimal proof of the fact:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">tt_ne_ff</span> <span class="o">:</span> <span class="n">bool</span><span class="bp">.</span><span class="n">tt</span> <span class="bp">≠</span> <span class="n">bool</span><span class="bp">.</span><span class="n">ff</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">set</span> <span class="n">f</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">bool</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="bp">λ_</span><span class="o">,</span> <span class="kt">Prop</span><span class="o">)</span> <span class="n">false</span> <span class="n">true</span> <span class="k">with</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="k">have</span> <span class="o">:</span> <span class="n">f</span> <span class="n">tt</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">ff</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hf</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">true</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">this</span> <span class="n">at</span> <span class="n">t</span><span class="o">,</span>
<span class="kn">end</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span> <span class="n">tt_ne_ff</span> <span class="c1">-- no axioms</span>
</code></pre></div>



<a name="207365939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207365939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207365939">(Aug 19 2020 at 03:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> has a blog post on <code>no_confusion</code>: <a href="https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/">https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/</a></p>



<a name="207366000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207366000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207366000">(Aug 19 2020 at 03:07)</a>:</h4>
<p>Thanks for pointing to that!<br>
Indeed</p>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">pf_irrel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">trivial</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span> <span class="n">pf_irrel</span> <span class="c1">-- no axioms</span>
</code></pre></div>


<p>requires no axioms</p>



<a name="207366266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207366266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207366266">(Aug 19 2020 at 03:12)</a>:</h4>
<p>it's more even than that. Two proofs are not just the same but <em>definitionally</em> the same - you can prove the equality using <code>rfl</code>, the proof that <code>a = a</code></p>



<a name="207366283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207366283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207366283">(Aug 19 2020 at 03:13)</a>:</h4>
<p>In fact, we exploit proof irrelevance in the proof of <code>em'</code>, in the <code>cases eq_true_intro pp, refl</code> part of my version of the proof</p>



<a name="207366323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/207366323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#207366323">(Aug 19 2020 at 03:14)</a>:</h4>
<p>the <code>refl</code> is a proof that <code>f true true U = f true true V</code></p>



<a name="208618153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/208618153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#208618153">(Aug 31 2020 at 21:34)</a>:</h4>
<p>I observed that the drinker paradox implies excluded middle in Lean, using a variation of the Diaconescu argument. However, Coq documentation <a href="https://coq.inria.fr/library/Coq.Logic.ClassicalFacts.html">https://coq.inria.fr/library/Coq.Logic.ClassicalFacts.html</a> (Section "Weak classical axioms") says the former is weaker. What could be the reason?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="c1">-- [Bell] John L. Bell, Choice principles in intuitionistic set theory, http://publish.uwo.ca/~jbell/Choice%20Principles.pdf</span>

<span class="n">def</span> <span class="n">sid</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span><span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span><span class="n">b</span><span class="o">,</span> <span class="n">p</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">a</span>
<span class="c1">-- [Lean] noncomputable theorem strong_indefinite_description {α : Sort u} (p : α → Prop) (h : nonempty α) : {x : α // (∃ y : α, p y) → p x}</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span> <span class="n">classical</span><span class="bp">.</span><span class="n">strong_indefinite_description</span> <span class="c1">-- all three (uses EM)</span>
<span class="c1">-- [Bell] Un = [Coq] Drinker = drinker&#39;s paradox (small form) (called Ex in Bell [Bell])</span>
<span class="c1">-- This is the Prop form, and the strong (Type) form is [Coq] D_epsilon = (weakly classical) indefinite description principle</span>
<span class="c1">-- ∃a, p a → ∀b, p b ([Bell] Ex) is also called drinker paradox (e.g. on codewars); sid implies only ∃a, p a → ∀b, ¬¬p b</span>

<span class="n">def</span> <span class="n">sid&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">r</span> <span class="bp">→</span> <span class="bp">∃</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span><span class="n">a</span><span class="o">,</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">a</span>
<span class="c1">-- [Coq] IGP = independence of general premises (an unconstrained generalisation of the constructive principle of independence of premises)</span>
<span class="c1">-- implies LC : (φ→ψ∨χ)→(φ→ψ)∨(φ→χ) immediately</span>

<span class="c1">-- Trivially interderivable:</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sid&#39;</span> <span class="n">p</span> <span class="o">(</span><span class="bp">∃</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">sid</span> <span class="n">p</span> <span class="o">:=</span>  <span class="bp">λ</span><span class="n">s</span><span class="o">,</span> <span class="n">s</span> <span class="n">id</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sid</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">sid&#39;</span> <span class="n">p</span> <span class="n">r</span> <span class="o">:=</span>  <span class="bp">λ⟨</span><span class="n">a</span><span class="o">,</span><span class="n">ha</span><span class="bp">⟩</span> <span class="n">h</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">ha</span><span class="err">∘</span><span class="n">h</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">em_of_sid&#39;</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">sid&#39;</span> <span class="o">{</span><span class="n">u</span><span class="o">:</span><span class="n">bool</span> <span class="bp">//</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">u</span><span class="bp">=</span><span class="n">tt</span><span class="o">}</span> <span class="bp">⟨⟨</span><span class="n">tt</span><span class="o">,</span><span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">rfl</span><span class="bp">⟩⟩</span> <span class="o">(</span><span class="bp">λ</span><span class="n">u</span><span class="o">,</span> <span class="err">↑</span><span class="n">u</span><span class="bp">=</span><span class="n">ff</span><span class="o">)</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span><span class="n">s</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨⟨</span><span class="n">u</span><span class="o">,</span><span class="n">h1</span><span class="bp">⟩</span><span class="o">,</span><span class="n">h2</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">s</span> <span class="o">(</span><span class="bp">λ</span><span class="n">h</span><span class="o">,</span> <span class="bp">⟨⟨</span><span class="n">ff</span><span class="o">,</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">h1</span><span class="bp">.</span><span class="n">elim</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="bp">λ</span><span class="n">h</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="n">dsimp</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">triv</span><span class="o">}</span> <span class="err">∘</span> <span class="n">h2</span><span class="o">))</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span> <span class="n">em_of_sid&#39;</span> <span class="c1">-- no axioms, not even proof irrelevance</span>
</code></pre></div>



<a name="208619200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/208619200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#208619200">(Aug 31 2020 at 21:45)</a>:</h4>
<p>This is part of my write-up of my investigation into proving em without propext. The attempt was unsuccessful, but I make connections between em, quotient exactness and choice principles.</p>
<p>I also introduced the function extension principle saying that you can extend a function from a subtype to a nonempty sort can be extended to the whole type, which I don't see discussed anywhere else. I showed that it's equivalent to the drinker paradox under nonempty_pi/choice.</p>



<a name="208637681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/208637681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#208637681">(Sep 01 2020 at 02:07)</a>:</h4>
<p>This is very interesting. You should try replaying your proof in Coq to see if there are any non obvious foundational differences, but it seems like this proof would also go through in Coq, and if so it looks like it would be news</p>



<a name="211337766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/211337766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#211337766">(Sep 26 2020 at 02:41)</a>:</h4>
<p>Releasing this "formal" write-up and wrapping up this expedition :)<br>
<a href="https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e">https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e</a><br>
I didn't end up porting the implication <code>sid→em</code> to Coq; I found the same argument in [Bell] (relativized ε-scheme), so it's not new. According to [Bell], the version of <code>sid</code> that only quantifies over the whole universe (called <code>Ex</code> in [Bell]) is weaker than LEM, but if quantification over arbitrary set (or type, in type theory) is allowed (e.g. with the relativized ε-scheme), then it's equivalent to LEM. The Coq people might have missed this point and went on to claim that <code>sid</code> (their <code>IGP</code>) is weaker than LEM.</p>



<a name="211452647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/211452647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#211452647">(Sep 28 2020 at 05:14)</a>:</h4>
<p>Update: choice + proof irrelevance =&gt; decidable equality for any type<br>
<a href="https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L29">https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L29</a></p>



<a name="211579888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/211579888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#211579888">(Sep 29 2020 at 04:29)</a>:</h4>
<p>Update: I managed to prove weak excluded middle <code>∀p, ¬p ∨ ¬¬p</code> using choice, quot.sound (and PI) only:<br>
<a href="https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L52">https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L52</a><br>
In fact the argument implies <code>∀p q, (¬¬p ∧ ¬¬q) ∨ (¬p ∧ ¬q) ∨ ¬(p → q) ∨ ¬(q → p)</code> which seems to be stronger.</p>



<a name="211584625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/211584625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#211584625">(Sep 29 2020 at 06:22)</a>:</h4>
<p>You should write these things down / contribute them to mathlib / etc. Thoughts published only as gists are not going to last long in this world. :-)</p>



<a name="211622344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/211622344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#211622344">(Sep 29 2020 at 13:44)</a>:</h4>
<p>These aren't just thoughts, but formalized thoughts, so should last a bit longer :) I also specified the Lean version and mathlib commits in leanpkg format so they won't bitrot unless someone deletes the commit history.<br>
I agree that I need to add a list of contents that includes the line number of each section, state main results/highlights in an introduction section, and explain ideas of nontrivial proofs in more detail.<br>
Regarding mathlib, would you like to see the current proof of classical.em be replaced by one that doesn't use quot.sound?</p>



<a name="211623013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/211623013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#211623013">(Sep 29 2020 at 13:49)</a>:</h4>
<p>I seem to be able to prove we have a homomorphism from the Heyting algebra on <code>Prop</code> to {0,1} respecting true,false,or,and,imp,neg (all logical connectives) mapping p to 1 iff <code>⟦ff⟧=⟦tt⟧</code> in the quotient of <code>bool</code> by <code>λ_ _,p</code>. What strongest consequence does this have? It implies the Heyting algebra is a Stone algebra (satisfies weak excluded middle), for example.</p>



<a name="211697164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/211697164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#211697164">(Sep 29 2020 at 23:20)</a>:</h4>
<p>Formalized thoughts rot even faster, because they are dependent on a big software stack. We have seen many examples now of work that was not updated being lost quickly.</p>



<a name="211697214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/211697214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#211697214">(Sep 29 2020 at 23:20)</a>:</h4>
<p>Making PRs into mathlib is one good option. Another is <span class="user-mention" data-user-id="110596">@Rob Lewis</span>'s recent efforts to provide continuous integration for outside-of-mathlib projects, although I now can't find any links to it...</p>



<a name="211725969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/211725969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#211725969">(Sep 30 2020 at 07:51)</a>:</h4>
<p><a href="https://leanprover-community.github.io/lean_projects.html">https://leanprover-community.github.io/lean_projects.html</a></p>



<a name="289644360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/289644360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#289644360">(Jul 14 2022 at 20:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound/near/207363184">said</a>:</p>
<blockquote>
<blockquote>
<p>The rough idea is to quotient Prop by the equivalence relation iff.</p>
</blockquote>
<p>I will be interested to see if this is successful. I tried and failed to do exactly this a few years ago</p>
</blockquote>
<p>any success?</p>



<a name="289644544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/classical.em%20without%20funext%20/%20quot.sound/near/289644544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/classical.2Eem.20without.20funext.20.2F.20quot.2Esound.html#289644544">(Jul 14 2022 at 20:22)</a>:</h4>
<p>I think it's probably not impossible, and the best I could get is at <a href="https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L50">this gist</a>. (PI stands for proof irrelevance)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
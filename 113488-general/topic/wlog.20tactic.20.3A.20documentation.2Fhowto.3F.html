---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html">wlog tactic : documentation/howto?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="259204310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204310">(Oct 27 2021 at 08:00)</a>:</h4>
<p>I am wondering whether there is a documentation or howto for the wlog tactic.<br>
In one of the theorems I'm proving, I have <code>m n : nat</code> plus some properties such as <code>a: s m</code> <code>b : s n </code> and I wish to sort according <code>m ≤ n</code> or <code>n ≤ m</code>, while exchanging the roles of <code>a</code>, <code>b</code> if needed.</p>
<p>I have seen a few examples but they don't seem to happen in my case.</p>



<a name="259204395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204395">(Oct 27 2021 at 08:01)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> unfortunately, the wlog tactic is not so easy to use.</p>



<a name="259204501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204501">(Oct 27 2021 at 08:02)</a>:</h4>
<p>That's unfortunate !</p>



<a name="259204504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204504">(Oct 27 2021 at 08:02)</a>:</h4>
<p>Mario recently wrote a variant. It would be interesting to see if you find it better.</p>



<a name="259204527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204527">(Oct 27 2021 at 08:02)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">take_pi_args</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">name</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">expr.pi</span> <span class="n">h</span> <span class="n">_</span> <span class="n">_</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span> <span class="o">::</span> <span class="n">take_pi_args</span> <span class="n">n</span> <span class="n">e</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="o">[]</span>

<span class="kn">namespace</span> <span class="n">interactive</span>
<span class="n">setup_tactic_parser</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">doneif</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">ident</span><span class="bp">?</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">parse</span> <span class="o">(</span><span class="n">tk</span> <span class="s2">":"</span> <span class="bp">*&gt;</span> <span class="n">texpr</span><span class="o">))</span>
  <span class="o">(</span><span class="n">revert</span> <span class="o">:</span> <span class="n">parse</span> <span class="o">(</span>
    <span class="o">(</span><span class="n">tk</span> <span class="s2">"generalizing"</span> <span class="bp">*&gt;</span> <span class="o">((</span><span class="n">none</span> <span class="bp">&lt;$</span> <span class="n">tk</span> <span class="s2">"*"</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span> <span class="n">some</span> <span class="bp">&lt;$&gt;</span> <span class="n">ident</span><span class="bp">*</span><span class="o">))</span> <span class="bp">&lt;|&gt;</span> <span class="n">pure</span> <span class="o">(</span><span class="n">some</span> <span class="o">[])))</span> <span class="o">:</span>
  <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h.get_or_else</span> <span class="bp">`</span><span class="n">this</span><span class="o">,</span>
  <span class="n">t</span> <span class="bp">←</span> <span class="n">i_to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">%%</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">),</span>
  <span class="o">(</span><span class="n">num_generalized</span><span class="o">,</span> <span class="n">goal</span><span class="o">)</span> <span class="bp">←</span> <span class="n">retrieve</span> <span class="o">(</span><span class="k">do</span>
    <span class="n">assert_core</span> <span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
    <span class="n">num_generalized</span> <span class="bp">←</span> <span class="k">match</span> <span class="n">revert</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">revert_all</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">revert</span> <span class="o">:=</span> <span class="n">revert.mmap</span> <span class="n">tactic.get_local</span> <span class="bp">&gt;&gt;=</span> <span class="n">revert_lst</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="n">goal</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
    <span class="n">return</span> <span class="o">(</span><span class="n">num_generalized</span><span class="o">,</span> <span class="n">goal</span><span class="o">)),</span>
  <span class="n">tactic.assert</span> <span class="n">h</span> <span class="n">goal</span><span class="o">,</span>
  <span class="n">goal</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="o">(</span><span class="n">take_pi_args</span> <span class="n">num_generalized</span> <span class="n">goal</span><span class="o">)</span><span class="bp">.</span><span class="n">reverse.mmap'</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">try</span> <span class="o">(</span><span class="n">tactic.get_local</span> <span class="n">h</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic.clear</span><span class="o">),</span>
  <span class="n">intron</span> <span class="o">(</span><span class="n">num_generalized</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">wlog'</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">ident</span><span class="bp">?</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">parse</span> <span class="o">(</span><span class="n">tk</span> <span class="s2">":"</span> <span class="bp">*&gt;</span> <span class="n">texpr</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">doneif</span> <span class="n">h</span> <span class="n">t</span> <span class="n">none</span> <span class="bp">&gt;&gt;</span> <span class="n">swap</span>

<span class="kd">end</span> <span class="n">interactive</span>
<span class="kd">end</span> <span class="n">tactic</span>
</code></pre></div>



<a name="259204572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204572">(Oct 27 2021 at 08:03)</a>:</h4>
<p>Could you please paste that somewhere near the top of your file, and then write <code>wlog' hmn : m ≤ n</code> in your proof?</p>



<a name="259204657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204657">(Oct 27 2021 at 08:04)</a>:</h4>
<p>This wlog does not (yet) try to close any trivial goals for you. But it does create goals that you would otherwise have to setup manually.</p>



<a name="259204724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204724">(Oct 27 2021 at 08:05)</a>:</h4>
<blockquote>
<p>This wlog does not (yet) try to close any trivial goals for you. But it does create goals that you would otherwise have to setup manually.</p>
</blockquote>
<p>This is so much better than the current wlog!</p>



<a name="259204823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204823">(Oct 27 2021 at 08:06)</a>:</h4>
<p>Honestly, the current <code>wlog</code> is not so bad. Does</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">wlog</span> <span class="n">hmn</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">le_total</span> <span class="n">m</span> <span class="n">n</span> <span class="n">using</span> <span class="o">[</span><span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="n">m</span><span class="o">]</span> <span class="n">tactic.skip</span><span class="o">,</span>
</code></pre></div>
<p>work for you?</p>



<a name="259204871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204871">(Oct 27 2021 at 08:07)</a>:</h4>
<p>I would love to see the pushout of both wlog variants.</p>



<a name="259204890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259204890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259204890">(Oct 27 2021 at 08:07)</a>:</h4>
<p>I think we have pushouts in category theory</p>



<a name="259208906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259208906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259208906">(Oct 27 2021 at 08:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>  No, not quite because I needed to introduce a lot of stuff before:<br>
<code>m</code> and <code>n</code> come from other objects <code>a</code> and <code>b</code>,  and I need to exchange them as well, <br>
as well as sets <code>u</code> and <code>v</code> such that <code>hau: a ∈ u</code> and <code>hbv: b ∈ v</code>…</p>
<p>When I try to add <code>hau</code> and <code>hbv</code> in the permutation, Lean complains that <code>hau</code> depends on <code>u</code>.</p>
<p>IDK, maybe that'll better wait for the moment when I have to PL this material.</p>



<a name="259209444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259209444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259209444">(Oct 27 2021 at 08:54)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  Neither. Strangely, the object <code>hmn</code> has more or less the same type as the theorem I need to prove, and not the type <code>m  ≤ n</code> which is expected…</p>



<a name="259209721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259209721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259209721">(Oct 27 2021 at 08:58)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> The <code>hmn</code> should indeed have almost the same type as what you want to prove. But with an additional assumption <code>m ≤ n</code> somewhere in the middle. With this "bare bones" <code>wlog'</code> you have to do the case split on <code>m ≤ n ∨ n ≤ m</code> manually. And you also have to do all the permutation stuff manually.</p>



<a name="259209843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259209843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259209843">(Oct 27 2021 at 08:59)</a>:</h4>
<p>What <code>wlog'</code> does is: you claim that it suffices to treat the case with <code>m ≤ n</code>, now you have to do two thing: (1) prove that it is sufficient to do that (2) prove the goal under this added assumption.</p>



<a name="259209875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259209875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259209875">(Oct 27 2021 at 08:59)</a>:</h4>
<p>But it doesn't give you any help with (1). It only sets up the goal state for you.</p>



<a name="259210308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259210308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259210308">(Oct 27 2021 at 09:02)</a>:</h4>
<p>If you have a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>, we can have a more detailed look.</p>



<a name="259211644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259211644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259211644">(Oct 27 2021 at 09:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F/near/259210308">said</a>:</p>
<blockquote>
<p>If you have a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>, we can have a more detailed look.</p>
</blockquote>
<p>The following example is a working example,  minimal in the sense that deleting any line makes it break ;-) , but not that small.<br>
But Idk how to make it smaller (the complexity comes from the <code>is_preconnected</code> function).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.connected</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">classical</span> <span class="n">topological_space</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">topological_space</span>

<span class="kd">universes</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>


<span class="sd">/--</span>
<span class="sd">The union Union s of an increasing mapping s of preconnected sets</span>
<span class="sd">is preconnected</span>
<span class="sd">-/</span>

<span class="kd">variable</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span>
<span class="kd">variables</span> <span class="o">[</span> <span class="n">linear_order</span> <span class="n">ι</span> <span class="o">]</span>

<span class="kd">theorem</span> <span class="n">is_preconnected.Union_of_directed</span>  <span class="o">{</span> <span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span> <span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="n">is_preconnected</span> <span class="o">(</span><span class="n">s</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span><span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">s</span> <span class="n">m</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_preconnected</span> <span class="o">(</span> <span class="n">Union</span> <span class="n">s</span> <span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">is_preconnected</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">u</span> <span class="n">v</span> <span class="n">hu</span> <span class="n">hv</span> <span class="n">Huv</span> <span class="n">Ku</span> <span class="n">Kv</span> <span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span> <span class="n">a</span><span class="o">,</span> <span class="n">Kua</span> <span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">Union</span> <span class="n">s</span> <span class="bp">∩</span> <span class="n">u</span><span class="o">,</span> <span class="k">from</span> <span class="n">Ku</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span> <span class="n">b</span><span class="o">,</span> <span class="n">Kvb</span> <span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">Union</span> <span class="n">s</span> <span class="bp">∩</span> <span class="n">v</span><span class="o">,</span> <span class="k">from</span> <span class="n">Kv</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span> <span class="n">m</span><span class="o">,</span> <span class="n">Kam</span> <span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">m</span><span class="o">,</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span> <span class="n">m</span> <span class="o">,</span> <span class="k">from</span> <span class="n">mem_Union.1</span> <span class="n">Kua.left</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span> <span class="n">n</span><span class="o">,</span> <span class="n">Kbn</span> <span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span> <span class="n">n</span> <span class="o">,</span> <span class="k">from</span> <span class="n">mem_Union.1</span> <span class="n">Kvb.left</span><span class="o">,</span>

  <span class="n">cases</span> <span class="n">le_total</span> <span class="n">m</span> <span class="n">n</span> <span class="k">with</span> <span class="n">hmn</span> <span class="n">hnm</span><span class="o">,</span>

  <span class="c">/-</span><span class="cm"> Le cas où m ≤ n -/</span>
  <span class="k">have</span> <span class="n">Kan</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">s</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">mem_of_mem_of_subset</span> <span class="n">Kam</span> <span class="o">((</span><span class="n">K</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="n">hmn</span><span class="o">),</span>

  <span class="k">have</span> <span class="n">Hnuv</span> <span class="o">:</span> <span class="o">((</span><span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">u</span> <span class="bp">∩</span> <span class="n">v</span><span class="o">))</span><span class="bp">.</span><span class="n">nonempty</span> <span class="o">:=</span>
  <span class="kd">begin</span>
      <span class="n">apply</span> <span class="o">(</span><span class="n">H</span> <span class="n">n</span><span class="o">),</span> <span class="n">apply</span> <span class="n">hu</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hv</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">has_subset.subset.trans</span> <span class="o">(</span><span class="n">subset_Union</span> <span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="n">Huv</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">nonempty_of_mem</span>  <span class="o">(</span><span class="n">mem_inter</span> <span class="n">Kan</span> <span class="n">Kua.right</span><span class="o">),</span>
      <span class="n">apply</span> <span class="n">nonempty_of_mem</span> <span class="o">(</span><span class="n">mem_inter</span> <span class="n">Kbn</span> <span class="n">Kvb.right</span><span class="o">),</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">Knuv</span> <span class="o">:</span> <span class="o">((</span><span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">u</span> <span class="bp">∩</span> <span class="n">v</span><span class="o">))</span> <span class="bp">⊆</span> <span class="n">Union</span> <span class="n">s</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">u</span> <span class="bp">∩</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">inter_subset_inter</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">subset_Union</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq.subset</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nonempty.mono</span> <span class="n">Knuv</span> <span class="n">Hnuv</span><span class="o">,</span>

  <span class="c">/-</span><span class="cm"> Le cas où n ≤ m -/</span>
  <span class="k">have</span> <span class="n">Kbm</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">s</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">mem_of_mem_of_subset</span> <span class="n">Kbn</span> <span class="o">((</span><span class="n">K</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="n">hnm</span><span class="o">),</span>

  <span class="k">have</span> <span class="n">Hnuv</span> <span class="o">:</span> <span class="o">((</span><span class="n">s</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">u</span> <span class="bp">∩</span> <span class="n">v</span><span class="o">))</span><span class="bp">.</span><span class="n">nonempty</span> <span class="o">:=</span>
  <span class="kd">begin</span>
      <span class="n">apply</span> <span class="o">(</span><span class="n">H</span> <span class="n">m</span><span class="o">),</span> <span class="n">apply</span> <span class="n">hu</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hv</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">has_subset.subset.trans</span> <span class="o">(</span><span class="n">subset_Union</span> <span class="n">s</span> <span class="n">m</span><span class="o">)</span> <span class="n">Huv</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">nonempty_of_mem</span> <span class="o">(</span><span class="n">mem_inter</span> <span class="n">Kam</span> <span class="n">Kua.right</span><span class="o">),</span>
      <span class="n">apply</span> <span class="n">nonempty_of_mem</span> <span class="o">(</span><span class="n">mem_inter</span> <span class="n">Kbm</span> <span class="n">Kvb.right</span><span class="o">),</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">Kmuv</span> <span class="o">:</span> <span class="o">((</span><span class="n">s</span> <span class="n">m</span><span class="o">)</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">u</span> <span class="bp">∩</span> <span class="n">v</span><span class="o">))</span> <span class="bp">⊆</span> <span class="n">Union</span> <span class="n">s</span> <span class="bp">∩</span> <span class="o">(</span><span class="n">u</span> <span class="bp">∩</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">inter_subset_inter</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">subset_Union</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq.subset</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nonempty.mono</span> <span class="n">Kmuv</span> <span class="n">Hnuv</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="259213327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259213327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259213327">(Oct 27 2021 at 09:35)</a>:</h4>
<p>You can try with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">revert</span> <span class="n">a</span> <span class="n">b</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">wlog</span> <span class="n">hmn</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">le_total</span> <span class="n">m</span> <span class="n">n</span> <span class="n">using</span> <span class="o">[</span><span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="n">m</span><span class="o">]</span> <span class="n">tactic.skip</span><span class="o">,</span>
</code></pre></div>
<p>Does it help?</p>



<a name="259216961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259216961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259216961">(Oct 27 2021 at 10:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F/near/259213327">said</a>:</p>
<blockquote>
<p>You can try with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">revert</span> <span class="n">a</span> <span class="n">b</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">wlog</span> <span class="n">hmn</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">le_total</span> <span class="n">m</span> <span class="n">n</span> <span class="n">using</span> <span class="o">[</span><span class="n">m</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="n">m</span><span class="o">]</span> <span class="n">tactic.skip</span><span class="o">,</span>
</code></pre></div>
<p>Does it help?</p>
</blockquote>
<p>Yes! <br>
I could then just prove the second case using</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">u</span> <span class="n">v</span> <span class="n">hu</span> <span class="n">hv</span> <span class="n">Huv</span> <span class="n">Ku</span> <span class="n">Kv</span> <span class="n">Kau</span> <span class="n">Kbv</span> <span class="n">Kam</span> <span class="n">Kbn</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">union_comm</span> <span class="n">at</span> <span class="n">Huv</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">inter_comm</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span> <span class="n">b</span> <span class="n">a</span> <span class="n">v</span> <span class="n">u</span> <span class="n">hv</span> <span class="n">hu</span> <span class="n">Huv</span> <span class="n">Kv</span> <span class="n">Ku</span> <span class="n">Kbv</span> <span class="n">Kau</span> <span class="n">Kbn</span> <span class="n">Kam</span>
</code></pre></div>
<p>(and, by the way, I understood a bit more how this <code>wlog</code> tactic works, thanks!).<br>
Thanks a lot!</p>



<a name="259217380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259217380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259217380">(Oct 27 2021 at 10:16)</a>:</h4>
<p>This works with <code>wlog'</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">wlog'</span> <span class="n">H</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">le_total</span> <span class="n">m</span> <span class="n">n</span> <span class="k">with</span> <span class="n">hmn</span> <span class="n">hnm</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">H</span><span class="o">,</span> <span class="n">assumption'</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">set.inter_comm</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span> <span class="n">apply</span> <span class="n">H</span><span class="o">,</span> <span class="n">assumption'</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">set.union_comm</span><span class="o">,</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">rename</span> <span class="n">H_1</span> <span class="n">hmn</span><span class="o">,</span>
</code></pre></div>



<a name="259217524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259217524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259217524">(Oct 27 2021 at 10:17)</a>:</h4>
<p>That <code>rename</code> is a "bug" in <code>wlog'</code>. It should allow the user to specify the name of the hypothesis.</p>



<a name="259447272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259447272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259447272">(Oct 28 2021 at 20:26)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> and <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> where did this variant of wlog come from, I ended up writing my own version of this wlog' today (at <a href="https://github.com/leanprover-community/flt-regular/blob/may-assume/src/tactic/may_assume.lean">https://github.com/leanprover-community/flt-regular/blob/may-assume/src/tactic/may_assume.lean</a> called may assume) without realising it basically already existed till after I was done! It would be great to have one or the other in mathlib</p>



<a name="259448466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/wlog%20tactic%20%3A%20documentation/howto%3F/near/259448466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/wlog.20tactic.20.3A.20documentation.2Fhowto.3F.html#259448466">(Oct 28 2021 at 20:36)</a>:</h4>
<p>It was requested by <span class="user-mention" data-user-id="422638">@Tom Barnet-Lamb</span>  in another stream a few weeks ago</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
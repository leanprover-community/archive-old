---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html">`nat.iterate` vs `stream.iterate`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="262665775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262665775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262665775">(Nov 25 2021 at 04:25)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/nat.iterate">docs#nat.iterate</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/stream.iterate">docs#stream.iterate</a> are propositionally equal but one of them uses <code>iterate f a (n + 1) = iterate f (f a) n</code> while the other uses <code>iterate f a (n + 1) = f (iterate f a n)</code>. Which one is faster in Lean? How do I run a benchmark?</p>



<a name="262665900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262665900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262665900">(Nov 25 2021 at 04:29)</a>:</h4>
<p>Wouldn't it depend on the f? Does lean do any stream fusion? In Haskell, this is why foldr is preferred over foldl, because there are fewer thunks in foldr. Which of these two is foldl or foldr?</p>



<a name="262666024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666024">(Nov 25 2021 at 04:32)</a>:</h4>
<p>In Lean, <code>stream</code> is just a fancy name for <code>nat → α</code>, no special handling at all.</p>



<a name="262666047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666047">(Nov 25 2021 at 04:33)</a>:</h4>
<p>I see that <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.fib">docs#nat.fib</a> is defined using <code>stream.iterate</code> and I wonder if it's faster than with <code>nat.iterate</code>.</p>



<a name="262666135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666135">(Nov 25 2021 at 04:35)</a>:</h4>
<p>(for reference, I meant stream fusion as in <a href="https://stackoverflow.com/a/38910170/7690601">https://stackoverflow.com/a/38910170/7690601</a>)</p>



<a name="262666169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666169">(Nov 25 2021 at 04:36)</a>:</h4>
<p>Maybe not relevant because lean is strict, AFAIK.</p>



<a name="262666216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666216">(Nov 25 2021 at 04:36)</a>:</h4>
<p>"set_option profiler true" and then test various #evals?</p>



<a name="262666239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666239">(Nov 25 2021 at 04:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.compiler.optimize_bytecode</span> <span class="n">true</span>
<span class="kd">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">nat.iterate'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">k</span><span class="o">)</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">op</span> <span class="o">(</span><span class="n">nat.iterate'</span> <span class="n">k</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">nat.iterate₂</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">k</span><span class="o">)</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">nat.iterate₂</span> <span class="n">k</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>
<span class="k">#eval</span> <span class="n">nat.iterate</span> <span class="n">id</span> <span class="mi">2000000</span> <span class="mi">1</span>
<span class="k">#eval</span> <span class="n">nat.iterate'</span> <span class="n">id</span> <span class="mi">2000000</span> <span class="mi">1</span>
</code></pre></div>
<p>They are actually quite similar in generated code and performance. Ideally <code>nat.iterate</code> would perform better because it is tail recursive, but lean 3 does not implement tail call optimization so it looks like a wash</p>



<a name="262666294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666294">(Nov 25 2021 at 04:38)</a>:</h4>
<p>Is the memory usage the same?</p>



<a name="262666401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666401">(Nov 25 2021 at 04:41)</a>:</h4>
<p>that's harder to profile, but I would guess that <code>nat.iterate'</code> (the non-tail recursive version) has better memory usage because unlike the situation with TCO where <code>nat.iterate</code> would be O(1) and the other O(n), without it they are both O(n) but <code>nat.iterate</code> has <code>f 1, ..., f n</code> on the stack and <code>nat.iterate'</code> has a bunch of copies of <code>f</code></p>



<a name="262666449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666449">(Nov 25 2021 at 04:42)</a>:</h4>
<p>So similar to the foldl vs foldr situation?</p>



<a name="262666456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666456">(Nov 25 2021 at 04:43)</a>:</h4>
<p>yes, foldl vs foldr analysis is basically the same</p>



<a name="262666482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666482">(Nov 25 2021 at 04:43)</a>:</h4>
<p>Off topic, but do you think lean4 can be used to help support evaluation using rewrite rules?</p>



<a name="262666567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666567">(Nov 25 2021 at 04:45)</a>:</h4>
<p>Yes, I was talking about this with Leo just today. Rewrite rules during compilation are definitely on the agenda, although not super near term</p>



<a name="262666883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666883">(Nov 25 2021 at 04:53)</a>:</h4>
<p>Is it OK if I redefine <code>nat.fib</code> using <code>nat.iterate</code>? We have more theory about <code>nat.iterate</code> than about <code>stream.iterate</code>.</p>



<a name="262666894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262666894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262666894">(Nov 25 2021 at 04:53)</a>:</h4>
<p>(and I'm going to PR a rewrite of <code>stream.iterate</code> in terms of <code>nat.iterate</code>)</p>



<a name="262667404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262667404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262667404">(Nov 25 2021 at 05:03)</a>:</h4>
<p>sounds good to me. No need to have two functions for this</p>



<a name="262676701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262676701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262676701">(Nov 25 2021 at 08:16)</a>:</h4>
<p>Note that <code>nat.iterate</code> is the "wrong" way to do induction. If you know that <code>P a -&gt; P(f a)</code>, you need to <code>rw iterate_succ'</code> to apply it. I was considering changing it in core. What do you think?</p>



<a name="262676937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262676937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262676937">(Nov 25 2021 at 08:20)</a>:</h4>
<p>I would just make <code>iterate_succ'</code> a simp lemma and not the other one</p>



<a name="262677382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262677382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262677382">(Nov 25 2021 at 08:25)</a>:</h4>
<p>Yeah but about cases where the function isn't Prop-valued?</p>



<a name="262701235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/262701235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#262701235">(Nov 25 2021 at 12:45)</a>:</h4>
<p>Then you still can't choose between different <code>n</code> in case of a periodic orbit.</p>



<a name="319970488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/319970488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#319970488">(Jan 07 2023 at 14:55)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60/near/262666894">said</a>:</p>
<blockquote>
<p>(and I'm going to PR a rewrite of <code>stream.iterate</code> in terms of <code>nat.iterate</code>)</p>
</blockquote>
<p>Did this PR ever happen?</p>



<a name="319970647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/319970647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#319970647">(Jan 07 2023 at 14:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60/near/262666894">said</a>:</p>
<blockquote>
<p>(and I'm going to PR a rewrite of <a href="https://leanprover-community.github.io/mathlib_docs/find/stream.iterate">docs#stream.iterate</a> in terms of <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.iterate">docs#nat.iterate</a>)</p>
</blockquote>
<p>is there a PR anywhere for this?</p>



<a name="319982293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/319982293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#319982293">(Jan 07 2023 at 16:34)</a>:</h4>
<p>I have <a href="https://github.com/leanprover-community/mathlib/tree/YK-stream-struct">branch#YK-stream-struct</a></p>



<a name="319982348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/319982348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#319982348">(Jan 07 2023 at 16:34)</a>:</h4>
<p>Unfortunately, I mixed many changes into 1 branch. I'll try to split smaller changes into reviewable PRs.</p>



<a name="319996299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/319996299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#319996299">(Jan 07 2023 at 18:54)</a>:</h4>
<p>Should we redefine <code>nat.iterate</code> to align with <code>stream.iterate</code> defeq?</p>



<a name="319996308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/319996308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#319996308">(Jan 07 2023 at 18:54)</a>:</h4>
<p>Or <code>stream.iterate</code>?</p>



<a name="319999349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/319999349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#319999349">(Jan 07 2023 at 19:29)</a>:</h4>
<p>I think we should change nat.iterate since then it would be defeq to <a href="https://leanprover-community.github.io/mathlib_docs/find/nsmul_rec">docs#nsmul_rec</a> on <a href="https://leanprover-community.github.io/mathlib_docs/find/function.End">docs#function.End</a></p>



<a name="320013875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320013875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320013875">(Jan 07 2023 at 22:58)</a>:</h4>
<p>That will take a bit longer because it's in the core.</p>



<a name="320014904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320014904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320014904">(Jan 07 2023 at 23:14)</a>:</h4>
<p>That would make my life much easier in <a href="https://github.com/leanprover-community/mathlib/pull/18077">#18077</a>, as Eric alludes to.</p>



<a name="320017605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320017605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320017605">(Jan 07 2023 at 23:57)</a>:</h4>
<p>I'll try to do it tomorrow.</p>



<a name="320017683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320017683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320017683">(Jan 07 2023 at 23:58)</a>:</h4>
<p>This is of course assuming we no longer care at all about tail recursion, in either Lean 3 or Lean 4</p>



<a name="320018176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320018176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320018176">(Jan 08 2023 at 00:05)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.iterate#doc">docs4#Nat.iterate</a> is also in core, right?</p>



<a name="320018301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320018301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320018301">(Jan 08 2023 at 00:06)</a>:</h4>
<p>Oh it is not! Then I guess we're quite free to change the definition.</p>



<a name="320021622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320021622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320021622">(Jan 08 2023 at 00:51)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Could you please provide more details?</p>



<a name="320022093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320022093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320022093">(Jan 08 2023 at 00:57)</a>:</h4>
<p>It would be nice to make the <code>npow</code> field of <a href="https://leanprover-community.github.io/mathlib_docs/find/function.End.Monoid">docs#function.End.Monoid</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/module.End.monoid">docs#module.End.monoid</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid.End.monoid">docs#add_monoid.End.monoid</a> etc defeq to <code>nat.iterate</code>. We certainly could do this by manually specifying the <code>npow</code> field, but since the algorithm is just "iterate" and the default <a href="https://leanprover-community.github.io/mathlib_docs/find/npow_rec">docs#npow_rec</a> is also just "iterate", it seems like we don't need both algorithms</p>



<a name="320022181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320022181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320022181">(Jan 08 2023 at 00:58)</a>:</h4>
<p>So essentially, there are three declarations that I think we should merge: <a href="https://leanprover-community.github.io/mathlib_docs/find/npow_rec">docs#npow_rec</a>  as <code>iterate ((*) n)</code> or similar, <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.iterate">docs#nat.iterate</a>, and <a href="https://leanprover-community.github.io/mathlib_docs/find/stream.iterate">docs#stream.iterate</a></p>



<a name="320022190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320022190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320022190">(Jan 08 2023 at 00:58)</a>:</h4>
<p>My comment about tail recursion is just referencing the thread above</p>



<a name="320022246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320022246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320022246">(Jan 08 2023 at 00:59)</a>:</h4>
<blockquote>
<p>but lean 3 does not implement tail call optimization so it looks like a wash</p>
</blockquote>
<p>Clearly we can pick whatever we like in Lean 3; but we should make sure that the choice is also fine for Lean 4, either due to possible tail recursion support there, or because <code>@[csimp]</code> makes non-optimal implementations irrelevant.</p>



<a name="320024595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320024595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320024595">(Jan 08 2023 at 01:31)</a>:</h4>
<p>What is <code>@[csimp]</code>?</p>



<a name="320024667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320024667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320024667">(Jan 08 2023 at 01:32)</a>:</h4>
<p>Which implementation works better with tail recursion?</p>



<a name="320025473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320025473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320025473">(Jan 08 2023 at 01:43)</a>:</h4>
<p>Both of those are probably questions for <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>



<a name="320026008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026008">(Jan 08 2023 at 01:52)</a>:</h4>
<p>which implementations are we talking about? <code>stream.iterate</code> is implemented using a direct call to <code>nat.rec_on</code>, which does not work in lean 4</p>



<a name="320026040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026040">(Jan 08 2023 at 01:53)</a>:</h4>
<p><code>@[csimp]</code> is a mechanism for replacing one definition with an equal one, like a simp lemma but only for the compiler</p>



<a name="320026131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026131">(Jan 08 2023 at 01:54)</a>:</h4>
<p>you can use it to get both good defeqs and good performance by using a naive definition with good defeqs for the main definition and then using <code>@[csimp]</code> to rewrite it to a tail-recursive version for the compiler</p>



<a name="320026154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026154">(Jan 08 2023 at 01:55)</a>:</h4>
<p>There are two natural ways to define <code>nat.iterate</code>, as a left fold or a right fold. TBH they are probably both useful</p>



<a name="320026187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026187">(Jan 08 2023 at 01:55)</a>:</h4>
<p>the tail recursive one is <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.iterate/src">src#nat.iterate</a></p>



<a name="320026500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026500">(Jan 08 2023 at 02:00)</a>:</h4>
<p>So, we should use something like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">Function</span>

<span class="kd">def</span> <span class="n">iterate'</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
 <span class="bp">|</span> <span class="mi">0</span><span class="o">,</span>      <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">a</span>
 <span class="bp">|</span> <span class="n">succ</span> <span class="n">k</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">iterate'</span> <span class="n">op</span> <span class="n">k</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">iterate</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
 <span class="bp">|</span> <span class="mi">0</span><span class="o">,</span>      <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">a</span>
 <span class="bp">|</span> <span class="n">succ</span> <span class="n">k</span><span class="o">,</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">op</span> <span class="o">(</span><span class="n">iterate</span> <span class="n">op</span> <span class="n">k</span><span class="o">)</span>

<span class="kd">@[csimp]</span> <span class="kd">lemma</span> <span class="n">iterate_eq_iterate'</span> <span class="o">:</span> <span class="bp">@</span><span class="n">iterate</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">iterate'</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">end</span> <span class="n">Function</span>
</code></pre></div>



<a name="320026605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026605">(Jan 08 2023 at 02:01)</a>:</h4>
<p>(I moved lemmas about <code>iterate</code> to <code>function</code> in Lean 3 and I suggest that we move the definition to <code>function</code> as well)</p>



<a name="320026633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026633">(Jan 08 2023 at 02:01)</a>:</h4>
<p>I've changed my mind, it's not <code>nat.iterate</code> that's backwards, it's <a href="https://leanprover-community.github.io/mathlib_docs/find/nsmul_rec">docs#nsmul_rec</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/npow_rec">docs#npow_rec</a></p>



<a name="320026680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026680">(Jan 08 2023 at 02:02)</a>:</h4>
<p><code>nsmul_rec (n + 1) a = a + nsmul_rec n a</code> is not a sensible defeq</p>



<a name="320026724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026724">(Jan 08 2023 at 02:03)</a>:</h4>
<p><del>AFAIR, this was aligned with <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.mul">docs#nat.mul</a></del> I'm wrong.</p>



<a name="320026734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026734">(Jan 08 2023 at 02:03)</a>:</h4>
<p>(deleted)</p>



<a name="320026855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026855">(Jan 08 2023 at 02:05)</a>:</h4>
<ol>
<li>IMHO, <code>a ^ (n + 1) = a ^ n * a</code> is a more reasonable defeq.</li>
<li>This corresponds to <code>a ^ n = ((* a)^[n] 1)</code> with another definition of <code>nat.iterate</code>.</li>
</ol>



<a name="320026919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320026919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320026919">(Jan 08 2023 at 02:06)</a>:</h4>
<p>With the current definition of <code>nat.iterate</code>, <code>(* a)^[n+1] 1</code> unfolds to <code>(* a)^[n] (1 * a)</code>.</p>



<a name="320027408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320027408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320027408">(Jan 08 2023 at 02:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60/near/320026724">said</a>:</p>
<blockquote>
<p><del>AFAIR, this was aligned with <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.mul">docs#nat.mul</a></del> I'm wrong.</p>
</blockquote>
<p>I think you're right but it was a historical accident and no longer is relevant</p>



<a name="320027550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320027550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320027550">(Jan 08 2023 at 02:17)</a>:</h4>
<p>Just to confirm your post above:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.stream.init</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">npow_rec'</span> <span class="o">[</span><span class="n">has_one</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">n</span> <span class="n">a</span><span class="o">,</span> <span class="n">stream.iterate</span> <span class="o">(</span><span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="mi">1</span> <span class="n">n</span>

<span class="kd">example</span>  <span class="o">[</span><span class="n">has_one</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">npow_rec'</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">npow_rec'</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="320027864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320027864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320027864">(Jan 08 2023 at 02:21)</a>:</h4>
<p>Actually, this doesn't help <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> anyway:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">function.End</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">npow_rec'</span> <span class="n">n</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">stream.iterate</span> <span class="n">f</span> <span class="n">x</span> <span class="n">n</span>  <span class="o">:=</span>
<span class="n">rfl</span> <span class="c1">-- fails, can't commute application with recursor</span>
</code></pre></div>



<a name="320028773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320028773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320028773">(Jan 08 2023 at 02:39)</a>:</h4>
<p>We should redefine <code>stream.iterate</code> using <code>nat.iterate</code>, then this will work.</p>



<a name="320028827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320028827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320028827">(Jan 08 2023 at 02:40)</a>:</h4>
<p>But I want to decide which defeq should be preserved before doing the refactor.</p>



<a name="320048484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320048484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320048484">(Jan 08 2023 at 08:20)</a>:</h4>
<p>I am of the opinion that <code>nat.iterate</code> is backwards regardless. You can't prove <code>P (f^[n] a)</code> from <code>P a</code> and <code>∀ b, P b → P (f b)</code> without rewriting <code>function.iterate_succ'</code>.</p>



<a name="320051435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320051435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320051435">(Jan 08 2023 at 09:01)</a>:</h4>
<p>You can. You just need <code>induction n generalizing a</code>.</p>



<a name="320056696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60nat.iterate%60%20vs%20%60stream.iterate%60/near/320056696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60.html#320056696">(Jan 08 2023 at 10:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113488-general/topic/.60nat.2Eiterate.60.20vs.20.60stream.2Eiterate.60/near/320028773">said</a>:</p>
<blockquote>
<p>We should redefine <code>stream.iterate</code> using <code>nat.iterate</code>, then this will work.</p>
</blockquote>
<p>I'm pretty sure no refactor will maker my last example <code>rfl</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html">unfold definition in tactic mode</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265873819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265873819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265873819">(Dec 23 2021 at 01:19)</a>:</h4>
<p>Which tactic do I use to unfold a defintion. For example, say I have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span>

<span class="kd">theorem</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>The context has <code>h : foo</code>. I would like it to read <code>h : 1 = 0</code> after some tactic magic.</p>



<a name="265875019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265875019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265875019">(Dec 23 2021 at 01:41)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#unfold">tactic#unfold</a></p>



<a name="265875160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265875160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265875160">(Dec 23 2021 at 01:44)</a>:</h4>
<p>I tried <code>unfold at h</code>. It doesn't do anything.</p>



<a name="265875164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265875164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265875164">(Dec 23 2021 at 01:44)</a>:</h4>
<p><code>unfold foo at h</code></p>



<a name="265875176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265875176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265875176">(Dec 23 2021 at 01:45)</a>:</h4>
<p>If that doesn't work, try <code>dsimp [foo] at h</code></p>



<a name="265875184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265875184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265875184">(Dec 23 2021 at 01:45)</a>:</h4>
<p>Ah. Yes, that works.</p>



<a name="265875257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265875257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265875257">(Dec 23 2021 at 01:47)</a>:</h4>
<p>If <code>foo</code> takes parameters, I still write <code>unfold foo</code> right?</p>



<a name="265875268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265875268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265875268">(Dec 23 2021 at 01:47)</a>:</h4>
<p>Yeah, that's right</p>



<a name="265875308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265875308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265875308">(Dec 23 2021 at 01:48)</a>:</h4>
<p>Nice. Thanks.</p>



<a name="265877007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265877007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265877007">(Dec 23 2021 at 02:24)</a>:</h4>
<p>Often, one is able to say "rw foo at ..." depending on how complex your definition is.</p>



<a name="265948227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265948227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265948227">(Dec 23 2021 at 19:53)</a>:</h4>
<p>Apparently you can't unfold complex definitions. For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">order.filter.partial</span>
<span class="kn">import</span> <span class="n">algebra.support</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">filter</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">let</span>
  <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span>
<span class="k">in</span>
  <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span>

<span class="kd">theorem</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">,</span> <span class="n">foo</span> <span class="n">p</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">p</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">foo</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>The context shows me <code>h : foo._match_1 p</code>.</p>



<a name="265948383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265948383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265948383">(Dec 23 2021 at 19:56)</a>:</h4>
<p>Right, because that is how foo is defined, you're doing the equivalent of a match statement when you deconstruct in your let statement. You might make some progress with "cases p". A helper rfl lemma like "foo (m, n) &lt;-&gt; m = n := iff.rfl" is very helpful fight after you make a definition.</p>



<a name="265948439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265948439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265948439">(Dec 23 2021 at 19:56)</a>:</h4>
<p>Then you make another lemma, "foo p &lt;-&gt; p.1 = p.2 := by cases p; refl"</p>



<a name="265948601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265948601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265948601">(Dec 23 2021 at 19:58)</a>:</h4>
<p>The reason is that let statements aren't reduced instantly, I forget which Greek letter they correspond to, beta reduction/expansion? And there's also the eta reduction here, which in lean3 isn't definitionally true. Is "p = (p.1, p.2)" true by refl? My recollection is that, no, it's not.</p>



<a name="265948792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265948792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265948792">(Dec 23 2021 at 20:00)</a>:</h4>
<p>OK. It's not show-stopper. I can always look at the definition in the code.</p>



<a name="265951219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265951219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265951219">(Dec 23 2021 at 20:35)</a>:</h4>
<p>I'm trying the following, but it doesn't work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">let</span>
  <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span>
<span class="k">in</span>
  <span class="n">some</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">n</span>

<span class="kd">lemma</span> <span class="n">lem1</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">some</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
<span class="kd">lemma</span> <span class="n">lem2</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">some</span> <span class="n">p.1</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">p.2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases</span><span class="bp">;</span> <span class="n">rfl</span> <span class="bp">&lt;</span><span class="c1">-- COMPLAINS HERE</span>

<span class="kd">theorem</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">,</span> <span class="n">foo</span> <span class="n">p</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">p</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265951496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265951496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265951496">(Dec 23 2021 at 20:38)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lem2</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">some</span> <span class="n">p.1</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">p.2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">p</span><span class="bp">;</span> <span class="n">refl</span>
</code></pre></div>



<a name="265951524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265951524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265951524">(Dec 23 2021 at 20:39)</a>:</h4>
<p>You have to indicate what you're deconstructing in the <code>cases</code> tactic. Also,<code>rfl</code> is a term, <code>refl</code> is a tactic.</p>



<a name="265951547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265951547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265951547">(Dec 23 2021 at 20:39)</a>:</h4>
<p>Ah, OK.</p>



<a name="265951778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265951778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265951778">(Dec 23 2021 at 20:42)</a>:</h4>
<p>So I have this now:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">,</span> <span class="n">foo</span> <span class="n">p</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">p</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">lem2</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">some_injective</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I'm trying to get rid of the <code>some</code> but it's not working.</p>



<a name="265951928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265951928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265951928">(Dec 23 2021 at 20:45)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/some_injective">docs#some_injective</a></p>



<a name="265951958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265951958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265951958">(Dec 23 2021 at 20:45)</a>:</h4>
<p>What are your imports? This works for me:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.option.defs</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">let</span>
  <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span>
<span class="k">in</span>
  <span class="n">some</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">n</span>

<span class="kd">lemma</span> <span class="n">lem1</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">some</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
<span class="kd">lemma</span> <span class="n">lem2</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">some</span> <span class="n">p.1</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">p.2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">p</span><span class="bp">;</span> <span class="n">refl</span>

<span class="kd">theorem</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">,</span> <span class="n">foo</span> <span class="n">p</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">p</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">lem2</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">option.some_inj</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265952042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265952042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265952042">(Dec 23 2021 at 20:46)</a>:</h4>
<p>This is why I have now:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">order.filter.partial</span>
<span class="kn">import</span> <span class="n">algebra.support</span>

<span class="kd">noncomputable theory</span>
<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">classical</span> <span class="n">option</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="n">filter</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="k">let</span>
  <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span>
<span class="k">in</span>
  <span class="n">some</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">n</span>

<span class="kd">lemma</span> <span class="n">lem1</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">some</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
<span class="kd">lemma</span> <span class="n">lem2</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">}</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">some</span> <span class="n">p.1</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">p.2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">p</span><span class="bp">;</span> <span class="n">refl</span>

<span class="kd">theorem</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">,</span> <span class="n">foo</span> <span class="n">p</span> <span class="bp">→</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">p</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">lem2</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">some_injective</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265952135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265952135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265952135">(Dec 23 2021 at 20:48)</a>:</h4>
<p>It seems there is a difference between <code>option.some_inj</code> and <code>some_injective</code>.</p>



<a name="265952147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265952147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265952147">(Dec 23 2021 at 20:48)</a>:</h4>
<p><code>some_injective</code> is not something you can rewrite with. Do you mean something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">rw</span> <span class="o">[(</span><span class="n">some_injective</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">eq_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
</code></pre></div>



<a name="265952678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265952678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265952678">(Dec 23 2021 at 20:56)</a>:</h4>
<p>OK, then I am confused about the purpose of <code>some_injective</code>.</p>



<a name="265952719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265952719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265952719">(Dec 23 2021 at 20:57)</a>:</h4>
<p>I'll stick to <code>some_inj</code> for now. Thanks.</p>



<a name="265953103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265953103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265953103">(Dec 23 2021 at 21:01)</a>:</h4>
<p><code>some_injective</code> is <code>function.injective some</code>, for some type <code>T</code> sending to <code>option T</code>. <code>function.injective</code> is not an "iff", it is only the implication that "f x = f y -&gt; x = y`.<br>
Consider:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="n">some_injective</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">some_injective : ∀ (α : Type u_1), function.injective some</span>
<span class="cm">-/</span>
<span class="k">#print</span> <span class="n">function.injective</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">def function.injective : Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop :=</span>
<span class="cm">λ {α : Sort u₁} {β : Sort u₂} (f : α → β), ∀ ⦃a₁ a₂ : α⦄, f a₁ = f a₂ → a₁ = a₂</span>
<span class="cm">-/</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">function.injective.eq_iff</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">function.injective.eq_iff :</span>
<span class="cm">  ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, function.injective f → ∀ {a b : α}, f a = f b ↔ a = b</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="265953219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265953219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265953219">(Dec 23 2021 at 21:03)</a>:</h4>
<p>Usually we avoid pattern matching in definitions (as opposed to proofs) for this reason, even though it looks nicer--you had to write the non-pattern matching definition in the statement of <code>lem2</code> anyways, so just use that.</p>



<a name="265953506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/265953506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#265953506">(Dec 23 2021 at 21:07)</a>:</h4>
<p>Yeah, it's a trade-off it seems.</p>



<a name="268611961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268611961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268611961">(Jan 19 2022 at 22:19)</a>:</h4>
<p>Another question about unfolding: How do you unfold something like <code>b ≈ a</code> all the way. I had to do <code>unfold has_equiv.equiv</code> and then <code>unfold setoid.r</code>. Is there a quicker way?</p>



<a name="268612371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268612371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268612371">(Jan 19 2022 at 22:23)</a>:</h4>
<p>Can you explain what you hope to do by unfolding?</p>



<a name="268612457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268612457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268612457">(Jan 19 2022 at 22:23)</a>:</h4>
<p>By the way, in the widget view, one can click on any term, including a <code>=</code> or <code>\~-</code> or anything like that and see how it's defined and what implicit arguments it uses. I know that you don't use an editor with widget view, just declaring for posterity.</p>



<a name="268612763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268612763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268612763">(Jan 19 2022 at 22:26)</a>:</h4>
<p>What type are <code>a</code> and <code>b</code>? Either you made a wrong turn when you introduced <code>b ≈ a</code> into your goal, or there's a lemma missing</p>



<a name="268613271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268613271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268613271">(Jan 19 2022 at 22:31)</a>:</h4>
<p><code>a</code> and <code>b</code> are just examples. I'm interested in unfolding what <code>≈</code> means.</p>



<a name="268613349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268613349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268613349">(Jan 19 2022 at 22:32)</a>:</h4>
<p>Here's my proof where I had to do multiple unfoldings:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">act_congr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁y₁</span> <span class="n">h₂y₂</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">h₁y₁</span> <span class="bp">≈</span> <span class="n">h₂y₂</span><span class="o">),</span> <span class="n">envelope.act</span> <span class="n">g</span> <span class="n">h₁y₁</span> <span class="bp">=</span> <span class="n">envelope.act</span> <span class="n">g</span> <span class="n">h₂y₂</span> <span class="o">:=</span> <span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(⟨</span><span class="n">h₁</span><span class="o">,</span><span class="n">y₁</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">X</span><span class="o">)</span> <span class="o">(⟨</span><span class="n">h₂</span><span class="o">,</span><span class="n">y₂</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">X</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">act</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">quotient.eq</span><span class="o">],</span>
  <span class="n">unfold</span> <span class="n">has_equiv.equiv</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">setoid.r</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">envelope</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">],</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="268613368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268613368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268613368">(Jan 19 2022 at 22:32)</a>:</h4>
<p><del>I assume you're working with something like <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient.lift">docs#quotient.lift</a>?</del></p>



<a name="268613678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268613678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268613678">(Jan 19 2022 at 22:35)</a>:</h4>
<p>I agree with Eric, there should be a lemma along the lines of <code>quotient.eq</code> expressed in terms of <code>envelope.act</code>.</p>



<a name="268613784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268613784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268613784">(Jan 19 2022 at 22:36)</a>:</h4>
<p>So you're saying I should abstract the three <code>unfolds</code> into a lemma?</p>



<a name="268613926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268613926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268613926">(Jan 19 2022 at 22:38)</a>:</h4>
<p>Or even the whole thing between <code>unfold act</code> and <code>unfold envelope</code>. <code>unfold</code> in a finished proof is a bit of a code smell, suggesting you need to abstract a lemma.</p>



<a name="268613964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268613964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268613964">(Jan 19 2022 at 22:38)</a>:</h4>
<p>(During development <code>unfold</code> can be useful to get a sense of what's going on. Or clicking on the relevant widgets.)</p>



<a name="268613989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268613989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268613989">(Jan 19 2022 at 22:39)</a>:</h4>
<p>Oh really? I didn't know that.</p>



<a name="268614184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268614184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268614184">(Jan 19 2022 at 22:41)</a>:</h4>
<p>At least, that is my vision on the idiomatic style in the parts of mathlib I run into. It may be very different if there are many small definitions.</p>



<a name="268614732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268614732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268614732">(Jan 19 2022 at 22:46)</a>:</h4>
<p>Alright. Thanks for the input.</p>



<a name="268615156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268615156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268615156">(Jan 19 2022 at 22:50)</a>:</h4>
<p>I think the API around quotients is a bit messy at the moment - <code>has_equiv.equiv</code>vs <code>setoid.r</code> vs <a href="https://leanprover-community.github.io/mathlib_docs/find/setoid.rel">docs#setoid.rel</a> vs <code>the_actual_relation_name</code>, <code>quot.mk</code> vs <code>quotient.mk</code> vs <code>quotient.mk'</code> vs <code>submodule.quotient.mk</code> vs ...</p>



<a name="268615252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unfold%20definition%20in%20tactic%20mode/near/268615252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/unfold.20definition.20in.20tactic.20mode.html#268615252">(Jan 19 2022 at 22:51)</a>:</h4>
<p>Don't forget <code>submodule.quotient.mk</code> versus <code>submodule.mkq</code> <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html">Multiple orders on the same type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="298609581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298609581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298609581">(Sep 13 2022 at 15:22)</a>:</h4>
<p>Say, I have a type like <code>fin n → ℕ</code> and want to work with two different partial orders (say, the product order and the lexicographic order) on this type at the same time (e.g., to prove that <code>a ≤prod b</code> implies <code>a ≤lex b</code> [fixed this]). Is there a recommended way of doing this?</p>



<a name="298610002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298610002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298610002">(Sep 13 2022 at 15:24)</a>:</h4>
<p>Probably it is best to use a type synonym.</p>



<a name="298610009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298610009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298610009">(Sep 13 2022 at 15:24)</a>:</h4>
<p>I guess the default one is the product order?</p>



<a name="298610077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298610077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298610077">(Sep 13 2022 at 15:25)</a>:</h4>
<p>Does <a href="https://leanprover-community.github.io/mathlib_docs/find/lex">docs#lex</a> lead to a useful type synonym?</p>



<a name="298612395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298612395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298612395">(Sep 13 2022 at 15:35)</a>:</h4>
<p>And maybe <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.to_lex_monotone">docs#pi.to_lex_monotone</a>?</p>



<a name="298612559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298612559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298612559">(Sep 13 2022 at 15:36)</a>:</h4>
<p>If <code>n</code> is non-zero, then there is also <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.lex">docs#finsupp.lex</a> which may or may not be better to use!  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="298613372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298613372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298613372">(Sep 13 2022 at 15:40)</a>:</h4>
<p>Oh wait, Damiano, did you introduce a new type synonym rather than using <code>lex (α →₀ β)</code>?</p>



<a name="298613570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298613570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298613570">(Sep 13 2022 at 15:41)</a>:</h4>
<p>I did.  I thought that the one you had for <code>pi</code> used some <code>wf</code> stuff that was not needed for the one on <code>finsupp</code>.  Maybe this is a wrong reason?</p>



<a name="298613947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298613947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298613947">(Sep 13 2022 at 15:43)</a>:</h4>
<blockquote>
<p>a ≤lex b implies a ≤prod b</p>
</blockquote>
<p>Backwards?</p>
<p>In case you really want relations on the same type: in e.g. <a href="https://leanprover-community.github.io/mathlib_docs/find/prod.rprod_sub_lex">docs#prod.rprod_sub_lex</a> the relations are referred to explicitly; you may declare local notation for them for convenience. Instead of using <a href="https://leanprover-community.github.io/mathlib_docs/find/has_le.le_trans">docs#has_le.le_trans</a> etc. you may have to use <a href="https://leanprover-community.github.io/mathlib_docs/find/is_trans.trans">docs#is_trans.trans</a> from a <a href="https://leanprover-community.github.io/mathlib_docs/find/is_partial_order">docs#is_partial_order</a> instance.</p>



<a name="298614170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298614170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298614170">(Sep 13 2022 at 15:44)</a>:</h4>
<blockquote>
<p><code>lex (α →₀ β)</code></p>
</blockquote>
<p>What does this even mean? Which <code>lex</code> makes this type check?</p>



<a name="298614235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298614235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298614235">(Sep 13 2022 at 15:44)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/lex">docs#lex</a> is a general type synonym. <code>lex (Π i, α i)</code> is the lexicographic pi type, and I meant <code>lex (ι →₀ α)</code> to mean the lexicographic finite supported functions.</p>



<a name="298614367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298614367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298614367">(Sep 13 2022 at 15:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type/near/298612559">said</a>:</p>
<blockquote>
<p>If <code>n</code> is non-zero, then there is also <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.lex">docs#finsupp.lex</a> which may or may not be better to use!  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>
</blockquote>
<p>Why <code>n</code> nonzero makes a difference for whether to use <code>pi</code> or <code>finsupp</code>? I think if n=0 both <code>pi.lex</code> and <code>finsupp.lex</code> are not reflexive.</p>



<a name="298614545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298614545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298614545">(Sep 13 2022 at 15:46)</a>:</h4>
<p>The point of a single type synonym is that you can carry over everything you don't care about. You don't want to write <a href="https://github.com/leanprover-community/mathlib/pull/16122">#16122</a> for each lexicographic type synonym <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="298614616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298614616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298614616">(Sep 13 2022 at 15:46)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span>  I just wanted to point out that <code>fin n -&gt; anything</code> is automatically a finsupp only when <code>n = 0</code>.</p>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>  maybe I can remove the <code>finsupp.lex</code> definition.  Is this what you are saying?</p>



<a name="298614870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298614870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298614870">(Sep 13 2022 at 15:47)</a>:</h4>
<p>Hmm, it's automatically a <code>finsupp</code> for all <code>n</code> because <code>fin n</code> is always a <code>fintype</code>, right?</p>



<a name="298615106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298615106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298615106">(Sep 13 2022 at 15:49)</a>:</h4>
<p>Also <code>fin 0</code>?</p>



<a name="298615193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298615193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298615193">(Sep 13 2022 at 15:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.equiv_fun_on_fintype">docs#finsupp.equiv_fun_on_fintype</a> (a bit hard to find!)</p>



<a name="298615245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298615245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298615245">(Sep 13 2022 at 15:49)</a>:</h4>
<p>I know that I am always confused about this... <code>fin 0</code> is empty, while <code>zmod 0</code> is <code>int</code>?</p>



<a name="298615381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298615381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298615381">(Sep 13 2022 at 15:50)</a>:</h4>
<p>Ok, my last comment makes sense.  Yes, <code>fin n</code> should always be a fintype!</p>



<a name="298615455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298615455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298615455">(Sep 13 2022 at 15:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type/near/298614616">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span>  maybe I can remove the <code>finsupp.lex</code> definition.  Is this what you are saying?</p>
</blockquote>
<p>Should we use <code>lex</code> for <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.lex">docs#pi.lex</a> as well?</p>



<a name="298615719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298615719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298615719">(Sep 13 2022 at 15:52)</a>:</h4>
<p>Ok, so <code>lex</code> is a "blanket" synonym, that will have all the whatever-<code>lex</code>-order-you-can-think-of instances, right?</p>



<a name="298616130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298616130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298616130">(Sep 13 2022 at 15:54)</a>:</h4>
<p>What I actually have is a preorder on <code>fin n → ℕ</code> obtained by pulling back a partial order under a map and the product order. I just want to be able to talk about both of them. Right now, I define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">weight</span> <span class="o">(</span><span class="n">n</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">fin</span> <span class="n">n.succ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="kd">def</span> <span class="n">f</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">weight</span> <span class="n">n</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">blah</span> <span class="o">:=</span> <span class="bp">...</span>
<span class="kd">instance</span> <span class="n">preorder</span> <span class="o">:</span> <span class="n">preorder</span> <span class="o">(</span><span class="n">weight</span> <span class="n">n</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="n">preorder.lift</span> <span class="n">f</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">≤</span><span class="n">d</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">has_le.le</span> <span class="o">(</span><span class="n">weight</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">≤</span><span class="n">c</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">has_le.le</span> <span class="o">(</span><span class="n">fin</span> <span class="n">_</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">_</span>
</code></pre></div>
<p>This allows me to use notation for the two different (pre)orders. But in the infoview, both are just printed as <code>≤</code>, which can be confusing.</p>



<a name="298616788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298616788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298616788">(Sep 13 2022 at 15:58)</a>:</h4>
<p>Oh wait, it turns out we are already using <a href="https://leanprover-community.github.io/mathlib_docs/find/lex">docs#lex</a> for the type carrying pi.lex and finsupp.lex. pi.lex and finsupp.lex operate on the relations instead. Sorry for the confusion!</p>



<a name="298625008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298625008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298625008">(Sep 13 2022 at 16:42)</a>:</h4>
<p>Yes, I got confused as well.  I did not introduce a new type synonym, I introduced the <em>relation</em> <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.lex">docs#finsupp.lex</a>, analogous to the <em>relation</em> <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.lex">docs#pi.lex</a> as an instance on the same type synonym <a href="https://leanprover-community.github.io/mathlib_docs/find/lex">docs#lex</a>.</p>
<p>This and <code>fin 0</code> caused a short circuit in my brain!</p>



<a name="298638811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298638811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298638811">(Sep 13 2022 at 18:03)</a>:</h4>
<p>Ah great! That's what I was hoping for.</p>



<a name="298650048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Multiple%20orders%20on%20the%20same%20type/near/298650048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Multiple.20orders.20on.20the.20same.20type.html#298650048">(Sep 13 2022 at 19:10)</a>:</h4>
<p>After having derailed Michael's question, let me go back to it.</p>
<p>I think that it will be clearer, in the long run, to have the two instances defined on <em>different-but-synonymous</em> types.  In your case, the two types are <code>fin n.succ → ℕ</code> and <code>weight n</code>.</p>
<p>You have one Type <code>X</code> with its order and a copy of <code>X</code> like your <code>weight n</code> with the other order.  You give names to the identity maps to <code>weight n</code> and from <code>weight n</code> and you pretend that they are different.  You then prove lemmas about monotonicity of these maps (like <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.to_lex.monotone">docs#pi.to_lex.monotone</a>) or whatever you want to prove.  It is a little laborious, but having two orders on the same type is ultimately very confusing.</p>
<p>It is possible that the notation can help to avoid this, especially if you only need very limited interaction between the types.  But anything more substantial will likely be easier with type synonyms with different order instances.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
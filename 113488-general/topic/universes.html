---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/universes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html">universes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="193025730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/193025730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Phiroc <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#193025730">(Apr 06 2020 at 11:08)</a>:</h4>
<p>Hello,<br>
in <em>Theorem Proving in Lean,</em> the authors provide the following examples:</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">list</span> <span class="c1">-- Type u_1 -&gt; Type u_1</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">prod</span> <span class="c1">-- Type u_1 -&gt; Type u_2 -&gt; Type (max u_1 u_2)</span>
</pre></div>


<p>Why is the universe the same in the first case, and different in the second?</p>



<a name="193026351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/193026351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#193026351">(Apr 06 2020 at 11:14)</a>:</h4>
<p>there is one input in the first case and two in the second</p>



<a name="193026407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/193026407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#193026407">(Apr 06 2020 at 11:15)</a>:</h4>
<p>in general, we want the output type to be determined by the inputs, and the output type will usually be the max of the universes of all the inputs</p>



<a name="213879221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879221">(Oct 20 2020 at 06:30)</a>:</h4>
<p>Are there foundational problems with allowing mild(?) quantification over universe variables?</p>



<a name="213879231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879231">(Oct 20 2020 at 06:30)</a>:</h4>
<p>yes, it increases the axiomatic strength</p>



<a name="213879260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879260">(Oct 20 2020 at 06:31)</a>:</h4>
<p>That's the only problem?</p>



<a name="213879266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879266">(Oct 20 2020 at 06:31)</a>:</h4>
<p>Sounds like a good thing to me <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="213879294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879294">(Oct 20 2020 at 06:32)</a>:</h4>
<p>I mean it doesn't really solve any problems, you just get more universes that you aren't allowed to quantify over</p>



<a name="213879349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879349">(Oct 20 2020 at 06:32)</a>:</h4>
<p>Well, it might solve my problems</p>



<a name="213879357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879357">(Oct 20 2020 at 06:32)</a>:</h4>
<p>if you add the ability to quantify over <em>all</em> universes, including the ones you are adding, then you get a second impredicative universe and then it's hello paradox</p>



<a name="213879361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879361">(Oct 20 2020 at 06:33)</a>:</h4>
<p>I think I only care about rings/modules/schemes that live in <code>Type n</code> for <code>n : nat</code></p>



<a name="213879388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879388">(Oct 20 2020 at 06:33)</a>:</h4>
<p>I think I would prefer the solution Kevin often talks about, where you have <em>less</em> universes, preferably none</p>



<a name="213879459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879459">(Oct 20 2020 at 06:34)</a>:</h4>
<p>And since most mathematicians still pretend they only work in <code>Type 0</code>, I think it will take some time before we get a profound mathematical construction that genuinely takes a limit construction over <code>Type n</code> (<code>n : nat</code>) to produce something that lives in <code>Type \omega</code></p>



<a name="213879482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879482">(Oct 20 2020 at 06:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/universes/near/213879388">said</a>:</p>
<blockquote>
<p>I think I would prefer the solution Kevin often talks about, where you have <em>less</em> universes, preferably none</p>
</blockquote>
<p>But then, why all this trouble of being universe polymorphic?</p>



<a name="213879507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879507">(Oct 20 2020 at 06:35)</a>:</h4>
<p>The thing is, once you are doing limit constructions you don't just get to Type \omega, you get to <code>Type (aleph omega)</code> or an even higher cardinal</p>



<a name="213879556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879556">(Oct 20 2020 at 06:36)</a>:</h4>
<p>We have to be universe polymorphic because someone had the poor sense to put universes in the type theory</p>



<a name="213879557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879557">(Oct 20 2020 at 06:36)</a>:</h4>
<p>Right, but my point is that I don't see such constructions happening.</p>



<a name="213879573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879573">(Oct 20 2020 at 06:36)</a>:</h4>
<p>Whereas I do hope that we might be able to have etale cohomology soonish. The ingredients are slowly dripping into mathlib.</p>



<a name="213879576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879576">(Oct 20 2020 at 06:36)</a>:</h4>
<p>so if you want to be generic over things you can construct in lean then you have to be universe polymorphic</p>



<a name="213879604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879604">(Oct 20 2020 at 06:37)</a>:</h4>
<p>But without universes, you'll have a major pain when you try to define sheaf cohomology</p>



<a name="213879652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879652">(Oct 20 2020 at 06:38)</a>:</h4>
<p>I don't think universes actually solve that pain, they just put it somewhere else</p>



<a name="213879676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879676">(Oct 20 2020 at 06:38)</a>:</h4>
<p>Why?</p>



<a name="213879703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879703">(Oct 20 2020 at 06:39)</a>:</h4>
<p>because you can't iterate any universe bumping construction, so inevitably you still have to figure out how to do whatever you are doing without any universe bumps</p>



<a name="213879756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879756">(Oct 20 2020 at 06:40)</a>:</h4>
<p>Right, but my point is that I don't know of any construction in maths that (even informally) is iterating universe bumps.</p>



<a name="213879767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879767">(Oct 20 2020 at 06:40)</a>:</h4>
<p>and at the end of it you realize it all fit in ZFC to begin with</p>



<a name="213879799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879799">(Oct 20 2020 at 06:41)</a>:</h4>
<p>I've said it before: what category theorists actually want is Type in Type, not this universe nonsense</p>



<a name="213879823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879823">(Oct 20 2020 at 06:41)</a>:</h4>
<p>and if and when you make all the reasoning consistent you find it's just plain old ZFC</p>



<a name="213879884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213879884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213879884">(Oct 20 2020 at 06:42)</a>:</h4>
<p>universes make everything more complicated and don't solve the problem they set out to solve</p>



<a name="213921303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213921303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213921303">(Oct 20 2020 at 13:50)</a>:</h4>
<p>I totally disagree with the above 3 lines, with the caveat that math universes are not the same as type theory universes</p>



<a name="213921417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213921417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213921417">(Oct 20 2020 at 13:51)</a>:</h4>
<p>It all fits in ZFC+U--if we're redefining ZFC to mean that then great</p>



<a name="213922959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213922959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213922959">(Oct 20 2020 at 14:01)</a>:</h4>
<p>It's also probably the case in a given application (in algebraic geometry say) that you can remove the "U" axiom, in the reverse mathematics sense--but this doesn't mean the category theory itself lives in ZFC, any more than the modularity theorem lives in PA</p>



<a name="213937502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213937502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213937502">(Oct 20 2020 at 15:39)</a>:</h4>
<p>I think most real category theory still fits in higher order ZFC, with no actual universes</p>



<a name="213937720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213937720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213937720">(Oct 20 2020 at 15:41)</a>:</h4>
<p>and higher order ZFC fits in ZFC for most concrete arguments if you play enough logical tricks</p>



<a name="213948143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213948143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213948143">(Oct 20 2020 at 16:58)</a>:</h4>
<p>There are certainly some instances where mathematicians do stuff with universes and then force everything back into ZFC. However it is getting to the point where there are things which some mathematicians (e.g. Scholze) do which cannot be forced back into ZFC, or, at least, nobody is trying to force it back into ZFC right now. We're quite a way away from this in mathlib so whether this will matter to us in practice is unclear to me -- but perhaps Reid knows other areas of maths which are also falling out of ZFC. </p>
<p>I am not looking forward to all this "force everything back into ZFC" issue when we run into etale cohomology. We want to take a limit over a universe and then there's a theorem saying that it's "equal to" a limit over a type. Nowadays I am quite conflicted about to how important this descent is.</p>



<a name="213955400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213955400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213955400">(Oct 20 2020 at 17:48)</a>:</h4>
<p>Mike Shulman has a paper <a href="https://arxiv.org/pdf/0810.1279.pdf">https://arxiv.org/pdf/0810.1279.pdf</a> discussing size issues in category theory and the possible ways to resolve them (including universes).</p>



<a name="213955784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213955784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213955784">(Oct 20 2020 at 17:51)</a>:</h4>
<p>Here's a simple example where ZFC is inadequate. Suppose I already have a theory of monoidal categories and monoid objects in them and their modules. Now a friendly Haskell programmer informs me that a monad on a category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> is "just a monoid in the category of endofunctors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>C</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C, C]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">]</span></span></span></span>". Great, now I can apply my existing theory to get a theory of monads and their modules (usually known as algebras).</p>



<a name="213955949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213955949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213955949">(Oct 20 2020 at 17:52)</a>:</h4>
<p>However, if I try to apply this to a large category (like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">C = \mathrm{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">S</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><msub><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">C = \mathrm{Mod}_R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">M</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) this breaks down, because the "endofunctor category" <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>C</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C, C]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">]</span></span></span></span> is "too large" to fit in ZFC even as a proper class (basically because its objects are already class-sized).</p>



<a name="213956013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213956013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213956013">(Oct 20 2020 at 17:53)</a>:</h4>
<p>So, I'm forced to develop a parallel but separate theory of monads on large categories.</p>



<a name="213956814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213956814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213956814">(Oct 20 2020 at 17:58)</a>:</h4>
<p>For a much fancier example, in algebraic geometry, there's no difficulty in ZFC in defining a stack of small categories on a small site. But, putting aside the issue of the size of the site, it's also very useful to consider stacks of large categories. For example, there is a stack which assigns to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mtext> </mtext><mi>R</mi></mrow><annotation encoding="application/x-tex">\mathrm{Spec}\,R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm">S</span><span class="mord mathrm">p</span><span class="mord mathrm">e</span><span class="mord mathrm">c</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> the category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{Mod}_R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">M</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-modules. On a scheme <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>, the "global sections" of this stack is the category of quasicoherent modules on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>.</p>



<a name="213956973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213956973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213956973">(Oct 20 2020 at 17:59)</a>:</h4>
<p>It would not surprise me if some mathematicians thought that we were in some kind of second foundational crisis -- ZFC worked fine for 100 years but now people really want to do stuff which pushes it to the limits and possibly beyond. However there are many areas of mathematics for which ZFC is completely adequate; I was talking to Hairer about this and he seemed absolutely convinced that he didn't even need full AC, and that ZF + countable dependent choice could get him a Fields Medal in the kind of analysis he did.</p>



<a name="213957289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213957289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213957289">(Oct 20 2020 at 18:01)</a>:</h4>
<p>I've never thought about precisely how much AC I need, but I have this uncomfortable feeling that the ZFC crisis I had in my 20s, when I carefully checked that a bunch of stuff I wanted/needed could be done in ZFC, is now going to be repeated if I ever want to dive into condensed mathematics, and this time I'm not entirely sure what the answer will be.</p>



<a name="213959144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213959144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213959144">(Oct 20 2020 at 18:15)</a>:</h4>
<p>With my category theorist hat on, I want to make two points:</p>
<ol>
<li>It really is important to make some size distinctions, at least to the extent of "small" and "large" , because you can't do very much category theory without talking about Set and other large categories, and here we already find for example that Set has (co)limits indexed by small categories but not large ones. The beginning of Shulman's paper gives more examples of this kind.</li>
<li>It's useful <em>at least for conceptual reasons</em> to talk about "very large" categories like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow><mo separator="true">,</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\mathrm{Set}, \mathrm{Set}]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">S</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">S</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span><span class="mclose">]</span></span></span></span> or the 2-category of all stacks of locally presentable categories on a scheme (or whatever). These objects are too big to exist in ZFC(at least  if we interpret <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\mathrm{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">S</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span></span></span></span> as referring to the category of <em>all</em> sets, and similarly for locally presentable categories).</li>
</ol>



<a name="213960154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213960154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213960154">(Oct 20 2020 at 18:24)</a>:</h4>
<p>Now,</p>
<ul>
<li>In the end, one might be interested in a specific theorem about monads or quasicoherent modules or whatever, and then one could ask whether or not this theorem is provable in ZFC. In my view, this is basically a question of reverse mathematics, and those who aren't interested in such questions shouldn't feel obliged to care about them.</li>
<li>A lot of category theory can be presented in a way which is agnostic to the specific foundations, while still making the basic small/large distinction. In this case, the reader can choose whether to interpret "small/large" as "set/class" or "element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">U</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">U</span></span></span></span></span>/non-element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">U</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">U</span></span></span></span></span>" or in some other way.</li>
</ul>
<p>Personally, I find the interpretation using Grothendieck universes convenient because it allows me to make sense of all category theory using ordinary sets, and doesn't need classes or fancy logic. However, it does have the disadvantages that the interpretation is relative to a fixed inaccessible cardinal and that, for example, a group constructed to have a certain universal property <em>a priori</em> only has this universal property with respect to other groups that are small with respect to the reference cardinal, and not with respect to all groups.</p>



<a name="213960893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213960893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213960893">(Oct 20 2020 at 18:30)</a>:</h4>
<p>Reid, since you are in this foundational mood, and I don't know anything about all this, do you have a definitive answer to the question: if I have a set S, can I define free groups over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> as groups <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> equipped with a map from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">i : S \to F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> such that, for <em>all</em> groups <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">f : S \to G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> there is a unique morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>:</mo><mi>F</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\varphi : F \to G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>∘</mo><mi>i</mi><mo>=</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\varphi \circ i = f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>? Or is it forbidden because there is no set of groups? If it's forbidden, what can be done?</p>



<a name="213960960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213960960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213960960">(Oct 20 2020 at 18:31)</a>:</h4>
<p>I have the vague impression this is forbidden as a definition but somewhat allowed as a theorem about a given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>, but this doesn't seem to make any sense.</p>



<a name="213961275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213961275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213961275">(Oct 20 2020 at 18:34)</a>:</h4>
<p>At least in Lean the answer seems to be that you cannot make it the definition, but you can make it a theorem.</p>



<a name="213961388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213961388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213961388">(Oct 20 2020 at 18:34)</a>:</h4>
<p>Yes, this is my impression, but it's weird and I'd like to understand this one day (or at least have the feeling to understand a bit and get a reference I can read from times to times)</p>



<a name="213961559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213961559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213961559">(Oct 20 2020 at 18:36)</a>:</h4>
<p>Yes that's no definition. You can only quantify over all G in some universe, so really you end up with infinitely many universal properties in some sense.</p>



<a name="213961618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213961618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213961618">(Oct 20 2020 at 18:36)</a>:</h4>
<p>But still it can be a property, right?</p>



<a name="213961676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213961676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213961676">(Oct 20 2020 at 18:37)</a>:</h4>
<p>Because if I define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> using reduced words etc. then certainly it satisfies the universal property for all groups, right?</p>



<a name="213961968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213961968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213961968">(Oct 20 2020 at 18:39)</a>:</h4>
<p>In ZFC the predicate "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">f : S \to F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> exhibits <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> as the free group on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>" defined in this way (for <em>all</em> groups <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> and maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">S \to G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> there exists ...) is totally fine. For example, it could be a hypothesis to a theorem. (Of course you need to do something else to prove that there actually exists such an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, but I don't think that's what you were asking about.)</p>



<a name="213962168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213962168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213962168">(Oct 20 2020 at 18:40)</a>:</h4>
<p>Then where is the problem? Is it that we want more than ZFC for other purposes and this breaks this definition?</p>



<a name="213962226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213962226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213962226">(Oct 20 2020 at 18:41)</a>:</h4>
<p>The problem with doing category theory in ZFC?</p>



<a name="213962275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213962275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213962275">(Oct 20 2020 at 18:41)</a>:</h4>
<p>The problem with defining stuff using universal properties</p>



<a name="213962435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213962435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213962435">(Oct 20 2020 at 18:43)</a>:</h4>
<p>If I have several universes, I can still prove that my favorite free groups satisfies the universal property for all groups in any universe but this cannot be an assumption in a theorem, right?</p>



<a name="213962726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213962726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213962726">(Oct 20 2020 at 18:45)</a>:</h4>
<p>... which means you can end up writing essentially the same proof over and over again for each of your favorite free groups, right?</p>



<a name="213962768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213962768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213962768">(Oct 20 2020 at 18:45)</a>:</h4>
<p>And if I have a low-tech definition of free groups (something like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(S)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> generates <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> and there is no relation between elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(S)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>, which can be defined properly), I cannot state something like "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F, i)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> is a free group on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> iff it satisfies the universal property for every group in every universe" right?</p>



<a name="213962891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213962891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213962891">(Oct 20 2020 at 18:46)</a>:</h4>
<p>What do you mean with "any"?</p>



<a name="213962962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213962962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213962962">(Oct 20 2020 at 18:46)</a>:</h4>
<p>If it means "all", then you indeed cannot,<br>
if it means "there exists a universe", then you can</p>



<a name="213962986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213962986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213962986">(Oct 20 2020 at 18:46)</a>:</h4>
<p>If you're doing category theory in ZFC+U with the "all categories implicitly relativized to a universe <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">U</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">U</span></span></span></span></span>" convention, then it is still meaningful to talk about whether a morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>U</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">f : S \to UF</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>:</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow><mo>→</mo><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">p</mi></mrow></mrow><annotation encoding="application/x-tex">U : \mathrm{Set} \to \mathrm{Grp}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">S</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">r</span><span class="mord mathrm">p</span></span></span></span></span> the forgetful functor) has the universal property of making <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> a free group with respect to <em>all</em> groups. It just isn't the condition that falls out from the category theory, because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">p</mi></mrow><annotation encoding="application/x-tex">\mathrm{Grp}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">r</span><span class="mord mathrm">p</span></span></span></span></span> now means "all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">U</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">U</span></span></span></span></span>-small groups" (and likewise for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow><annotation encoding="application/x-tex">\mathrm{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">S</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span></span></span></span>).</p>



<a name="213963013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213963013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213963013">(Oct 20 2020 at 18:47)</a>:</h4>
<p>English is a really awful language, but hopefully I disambiguated.</p>



<a name="213963172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213963172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213963172">(Oct 20 2020 at 18:48)</a>:</h4>
<p>At least not by definition--of course in this case the two conditions really are equivalent, but the easiest way to see that might be to note that you can construct the free group in a way that does not depend upon the reference universe <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">U</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">U</span></span></span></span></span>.</p>



<a name="213963300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213963300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213963300">(Oct 20 2020 at 18:49)</a>:</h4>
<p>Johan's answer is right for Lean, but not for ZFC+U, I think.</p>



<a name="213963313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213963313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213963313">(Oct 20 2020 at 18:49)</a>:</h4>
<p>But why is there this assymetry that I can state this as a property of a given concrete <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F, i)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> but not as an assumption of a theorem?</p>



<a name="213963319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213963319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213963319">(Oct 20 2020 at 18:49)</a>:</h4>
<p>You can state that, and even prove it.</p>



<a name="213963519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213963519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213963519">(Oct 20 2020 at 18:50)</a>:</h4>
<p>In Lean, it works differently because you can only quantify over types in a specific universe, and quantifiers over universes can only occur at the outside of a top-level definition.</p>



<a name="213963772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213963772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213963772">(Oct 20 2020 at 18:52)</a>:</h4>
<p>In ZFC I think that statements which use bounded quantification, i.e., only have quantifiers like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>X</mi><mo separator="true">,</mo><mi>X</mi><mo>∈</mo><mi>S</mi><mo>→</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">\forall X, X \in S \to \ldots</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span> is a notion which is useful, but you're not restricted to only making such statements.</p>



<a name="213963872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213963872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213963872">(Oct 20 2020 at 18:53)</a>:</h4>
<p>(Sorry, that was a poorly-constructed sentence but I hope it makes sense.)</p>



<a name="213964316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213964316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213964316">(Oct 20 2020 at 18:56)</a>:</h4>
<p>So what is impossible with ZFC + universes then?</p>



<a name="213965126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213965126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213965126">(Oct 20 2020 at 19:02)</a>:</h4>
<p>The drawback of this approach isn't that anything is impossible, but rather that if you really care about (let's say) "Universal" properties that quantify over <em>all</em> groups, or whatever, you will have to do some extra work to know that you have one.</p>



<a name="213965200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213965200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213965200">(Oct 20 2020 at 19:03)</a>:</h4>
<p>Whereas if you really did category theory with the category of all groups in the first place, then universal properties in category theory would be true Universal properties.</p>



<a name="213965403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213965403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213965403">(Oct 20 2020 at 19:05)</a>:</h4>
<p>(Plus of course you might be concerned about accepting the universe axiom, which does prove additional arithmetic statements like Con(ZFC).)</p>



<a name="213965453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213965453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213965453">(Oct 20 2020 at 19:05)</a>:</h4>
<p>What is Con(ZFC)?</p>



<a name="213965474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213965474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213965474">(Oct 20 2020 at 19:05)</a>:</h4>
<p>consistency?</p>



<a name="213965615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213965615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213965615">(Oct 20 2020 at 19:06)</a>:</h4>
<p>Yes, or more precisely, some encoding of it in terms of natural numbers.</p>



<a name="213965779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213965779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213965779">(Oct 20 2020 at 19:07)</a>:</h4>
<p>Some particular, rather large polynomial in a few variables has no integer solution.</p>



<a name="213966153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213966153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213966153">(Oct 20 2020 at 19:10)</a>:</h4>
<p>The later parts of Shulman's paper go into ways to systematically turn universe-relative universal properties into true Universal properties, and ways you might be able to talk about "very large" categories without increasing the consistency strength of the background theory.</p>



<a name="213966463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213966463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213966463">(Oct 20 2020 at 19:12)</a>:</h4>
<p>Ok, thanks for all you explanations! I'll try to think about all that.</p>



<a name="213975002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213975002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213975002">(Oct 20 2020 at 20:26)</a>:</h4>
<p>I have a question related to this issue about defining things in terms of their universal properties. I know of one example in mathlib which does (more-or-less) exactly this: <a href="https://leanprover-community.github.io/mathlib_docs/find/stone_cech_setoid/src">src#stone_cech_setoid</a><br>
Does this mean that mathlib only has the universal property of the Stone-Cech compactification for topological spaces which live in the same universe? Is there any way around this (without changing the definition of <code>stone_cech</code>)?</p>



<a name="213998351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213998351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213998351">(Oct 21 2020 at 01:11)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> It is a curious consequence of "internal definitions" (for example, a free group is a certain quotient of lists) that they imply and are implied by the "external definition" (a free group is one that maps in an appropriate way to all groups) at every universe. This fact means that even a definition using an external definition at Type u is equivalent to the external definition at all types, so <code>stone_cech</code>'s universal property applies even to larger universes even though you can't apply it directly</p>



<a name="213998837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/213998837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#213998837">(Oct 21 2020 at 01:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113488-general/topic/universes/near/213963313">said</a>:</p>
<blockquote>
<p>But why is there this assymetry that I can state this as a property of a given concrete <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F, i)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> but not as an assumption of a theorem?</p>
</blockquote>
<p>The key to this ability for us to prove external properties that we didn't quantify over to start with at the foundational level is the extra universe argument in <code>T.rec</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">nat'</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">nat'</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">nat'</span> <span class="bp">→</span> <span class="n">nat'</span>
<span class="k">#print</span> <span class="n">nat'.rec</span>
<span class="c1">-- protected eliminator nat'.rec : Π {C : nat' → Sort l},</span>
<span class="c1">--  C nat'.zero → (Π (a : nat'), C a → C a.succ) → Π (n : nat'), C n</span>
</code></pre></div>

<p>Note that <code>nat'</code> has no universe parameters but it has a recursor that quantifies over a universe parameter <code>l</code>. If recursors didn't do this, for example if <code>nat'.rec</code> only quantified over <code>C : nat' -&gt; Type</code>, then we wouldn't need the inductive axioms at all; we could use church encodings to do everything. But this universe lifting property is truly magical, as it allows you to prove that a universal property at one type implies a universal property for one specifically crafted inductive type, which then implies the universal property at a higher universe using that inductive type's recursor.</p>



<a name="214049241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214049241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214049241">(Oct 21 2020 at 13:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> As a concrete example, is it possible to make the second example in the following code work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.stone_cech</span>

<span class="kd">noncomputable theory</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">compact_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">β</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">γ</span><span class="o">]</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">γ</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">cont</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">stone_cech</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="n">stone_cech_extend</span> <span class="n">cont</span> <span class="c1">-- works</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">cont</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">stone_cech</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">stone_cech_extend</span> <span class="n">cont</span> <span class="c1">-- doesn't work</span>
</code></pre></div>

<p>I understand that it's possible to prove that the stone cech compactification of a topological space in <code>Type u</code>, which is defined so that it satisfies the universal property with respect to every topological space of <code>Type u</code>, also satisfies the universal property for every topological space of <code>Type v</code>. But it seems to me that doing this is essentially equivalent to redefining the stone cech compactification, or more specifically in this case, the equivalence relation <code>stone_cech_setoid</code>, so that it doesn't quantify over types in the first place.</p>



<a name="214049661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214049661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214049661">(Oct 21 2020 at 13:32)</a>:</h4>
<p>that's right</p>



<a name="214049720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214049720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214049720">(Oct 21 2020 at 13:33)</a>:</h4>
<p>you can't apply <code>stone_cech_extend</code> directly</p>



<a name="214049722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214049722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214049722">(Oct 21 2020 at 13:33)</a>:</h4>
<p>Okay, so life isn't as easy as I would have hoped.</p>



<a name="214049783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214049783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214049783">(Oct 21 2020 at 13:33)</a>:</h4>
<p>but you can hide this construction inside a proof, for example, if you wanted to keep the definition "clean"</p>



<a name="214049861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214049861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214049861">(Oct 21 2020 at 13:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/universes/near/214049783">said</a>:</p>
<blockquote>
<p>but you can hide this construction inside a proof, for example, if you wanted to keep the definition "clean"</p>
</blockquote>
<p>What do you mean by this?</p>



<a name="214049974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214049974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214049974">(Oct 21 2020 at 13:35)</a>:</h4>
<p>you can construct an inductive type with the requisite properties in order to prove that the universal property at u implies the universal property at v</p>



<a name="214050040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050040">(Oct 21 2020 at 13:35)</a>:</h4>
<p>and then that is the theorem you would be applying instead of <code>stone_cech_extend</code></p>



<a name="214050244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050244">(Oct 21 2020 at 13:37)</a>:</h4>
<p>Oh, I'm not sure what such an inductive type would like like. You mean something similar to <code>ulift</code>?</p>



<a name="214050317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050317">(Oct 21 2020 at 13:38)</a>:</h4>
<p>no, it depends on the universal property</p>



<a name="214050396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050396">(Oct 21 2020 at 13:38)</a>:</h4>
<p>for free groups it's lists on the basic elements</p>



<a name="214050436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050436">(Oct 21 2020 at 13:38)</a>:</h4>
<p>in a lot of categorical proofs this is where we show that the presheaf is representable</p>



<a name="214050443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050443">(Oct 21 2020 at 13:38)</a>:</h4>
<p>Ah okay. So this would just redefine the object altogether then.</p>



<a name="214050483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050483">(Oct 21 2020 at 13:39)</a>:</h4>
<p>When I wrote the <code>stone_cech</code> stuff I think I just followed some notes I found online--if there's a way to describe the required topology directly, without quantifying over <code>Type u</code>, then that's probably a better definition.</p>



<a name="214050537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050537">(Oct 21 2020 at 13:39)</a>:</h4>
<p>I think there is a way to do it, using the monadic properties of ultrafilters, but of course it's more complicated.</p>



<a name="214050742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050742">(Oct 21 2020 at 13:41)</a>:</h4>
<p>I think the internal definition of stone cech uses the set of ultrafilters</p>



<a name="214050760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050760">(Oct 21 2020 at 13:41)</a>:</h4>
<p>Actually, maybe it's not too bad with what's in this file:<br>
<a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/category/Compactum.lean">https://github.com/leanprover-community/mathlib/blob/master/src/topology/category/Compactum.lean</a></p>



<a name="214050800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050800">(Oct 21 2020 at 13:41)</a>:</h4>
<p>For example maybe it's enough to consider all quotients of <code>ultrafilter α</code> itself</p>



<a name="214050940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214050940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214050940">(Oct 21 2020 at 13:42)</a>:</h4>
<p>or maybe you don't even need to allow a quotient</p>



<a name="214051108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214051108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214051108">(Oct 21 2020 at 13:44)</a>:</h4>
<p>Isn't the stone cech compactification the largest quotient of <code>ultrafilter \a</code> which is an algebra for the ultrafilter monad, and for which the canonical map from <code>\a</code> is continuous?</p>



<a name="214051211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214051211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214051211">(Oct 21 2020 at 13:44)</a>:</h4>
<p>This would be a description that says nothing about any type other than <code>\a</code> itself.</p>



<a name="214051328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214051328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214051328">(Oct 21 2020 at 13:45)</a>:</h4>
<p>@_<strong>Wikipedia</strong> <a href="https://en.wikipedia.org/wiki/Stone%E2%80%93%C4%8Cech_compactification#Construction_using_products">said</a>:</p>
<blockquote>
<p>There are several ways to modify this idea to make it work; for example, one can restrict the compact Hausdorff spaces K to have underlying set P(P(X)) (the power set of the power set of X), which is sufficiently large that it has cardinality at least equal to that of every compact Hausdorff set to which X can be mapped with dense image.</p>
</blockquote>



<a name="214051583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214051583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214051583">(Oct 21 2020 at 13:47)</a>:</h4>
<p>The constructions in terms of maps to the unit interval (from wiki) would also work, I guess.</p>



<a name="214051590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214051590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214051590">(Oct 21 2020 at 13:47)</a>:</h4>
<p>This reminds me that hausdorff sets have an interesting cardinality bound: they are at most the double powerset of any dense subset A because you can uniquely pick out every element of X by a filter in A</p>



<a name="214051728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214051728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214051728">(Oct 21 2020 at 13:48)</a>:</h4>
<p>I think this proof would be easiest (I've done it in metamath before, it follows from the axioms pretty easily)</p>



<a name="214051761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214051761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214051761">(Oct 21 2020 at 13:48)</a>:</h4>
<p>the unit interval requires partitions of unity, which I think are more complicated</p>



<a name="214217563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217563">(Oct 22 2020 at 17:09)</a>:</h4>
<p>By the way, what was the original point of this thread? <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="214217599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217599">(Oct 22 2020 at 17:09)</a>:</h4>
<p>What was quantifying over universe levels intended to be used for?</p>



<a name="214217723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217723">(Oct 22 2020 at 17:10)</a>:</h4>
<p>I think specifying universal properties?</p>



<a name="214217753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217753">(Oct 22 2020 at 17:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113488-general/topic/universes/near/213879221">said</a>:</p>
<blockquote>
<p>Are there foundational problems with allowing mild(?) quantification over universe variables?</p>
</blockquote>
<p>Why can't I write a <code>bundled_hom</code> class that is universe polymorphic...</p>



<a name="214217793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217793">(Oct 22 2020 at 17:10)</a>:</h4>
<p>That's what my motivation was</p>



<a name="214217824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217824">(Oct 22 2020 at 17:10)</a>:</h4>
<p>Because I want <code>bundled_hom.funext</code> and <code>bundled_hom.congr_arg</code> and <code>bundled_hom.congr_fun</code>, etc...</p>



<a name="214217853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217853">(Oct 22 2020 at 17:11)</a>:</h4>
<p>what is a bundled hom in this context?</p>



<a name="214217880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217880">(Oct 22 2020 at 17:11)</a>:</h4>
<p>Instead of having to reprove them for <code>mul_hom</code>, <code>zero_hom</code>, <code>monoid_hom</code>, <code>one_hom</code>, <code>ring_hom</code>, <code>alg_hom</code>, the list goes on...</p>



<a name="214217882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217882">(Oct 22 2020 at 17:11)</a>:</h4>
<p>E.g. a group homomorphism from a group of <code>Type u</code> to a group of <code>Type v</code>.</p>



<a name="214217891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217891">(Oct 22 2020 at 17:11)</a>:</h4>
<p><code>equiv</code> is a universe polymorphic bundled hom</p>



<a name="214217903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217903">(Oct 22 2020 at 17:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/universes/near/214217853">said</a>:</p>
<blockquote>
<p>what is a bundled hom in this context?</p>
</blockquote>
<p>It is <code>bundled_hom</code> in the sense of <a href="https://leanprover-community.github.io/mathlib_docs/find/bundled_hom">docs#bundled_hom</a></p>



<a name="214217917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217917">(Oct 22 2020 at 17:12)</a>:</h4>
<p>Snap!</p>



<a name="214217968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214217968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214217968">(Oct 22 2020 at 17:12)</a>:</h4>
<p>It's not clear to me why this needs more universe quantification than Lean provides</p>



<a name="214218063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218063">(Oct 22 2020 at 17:13)</a>:</h4>
<p>I think it's because of <code>bundled</code> as in <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled">docs#category_theory.bundled</a></p>



<a name="214218218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218218">(Oct 22 2020 at 17:14)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled_hom">docs#category_theory.bundled_hom</a> is a predicate on homs from Type u to Type u. It could be a predicate on homs from Type u to Type v but then you couldn't compose them</p>



<a name="214218226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218226">(Oct 22 2020 at 17:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">⦃</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">⦄</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">β</span><span class="o">),</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>

<span class="sd">/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `monoid_hom`.</span>
<span class="sd">This way we can use `⟨@monoid_hom.to_fun, @monoid_hom.id ...⟩` in an instance. -/</span>
<span class="kd">structure</span> <span class="n">bundled_hom</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">β</span><span class="o">),</span> <span class="n">hom</span> <span class="n">Iα</span> <span class="n">Iβ</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">id</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">),</span> <span class="n">hom</span> <span class="n">I</span> <span class="n">I</span><span class="o">)</span>
<span class="o">(</span><span class="n">comp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">Iγ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">γ</span><span class="o">),</span>
  <span class="n">hom</span> <span class="n">Iβ</span> <span class="n">Iγ</span> <span class="bp">→</span> <span class="n">hom</span> <span class="n">Iα</span> <span class="n">Iβ</span> <span class="bp">→</span> <span class="n">hom</span> <span class="n">Iα</span> <span class="n">Iγ</span><span class="o">)</span>
<span class="o">(</span><span class="n">hom_ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">β</span><span class="o">),</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">Iα</span> <span class="n">Iβ</span><span class="o">)</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">id_to_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">),</span> <span class="n">to_fun</span> <span class="n">I</span> <span class="n">I</span> <span class="o">(</span><span class="n">id</span> <span class="n">I</span><span class="o">)</span> <span class="bp">=</span> <span class="n">_root_.id</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">comp_to_fun</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">Iα</span> <span class="o">:</span> <span class="n">c</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">Iβ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">Iγ</span> <span class="o">:</span> <span class="n">c</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">Iα</span> <span class="n">Iβ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">Iβ</span> <span class="n">Iγ</span><span class="o">),</span>
  <span class="n">to_fun</span> <span class="n">Iα</span> <span class="n">Iγ</span> <span class="o">(</span><span class="n">comp</span> <span class="n">Iα</span> <span class="n">Iβ</span> <span class="n">Iγ</span> <span class="n">g</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">Iβ</span> <span class="n">Iγ</span> <span class="n">g</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">Iα</span> <span class="n">Iβ</span> <span class="n">f</span><span class="o">)</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</code></pre></div>



<a name="214218267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218267">(Oct 22 2020 at 17:14)</a>:</h4>
<p>You can't even define them with two universe variables</p>



<a name="214218276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218276">(Oct 22 2020 at 17:14)</a>:</h4>
<p>Because you need <code>id</code></p>



<a name="214218301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218301">(Oct 22 2020 at 17:14)</a>:</h4>
<p>Actually I think <code>c</code> could be <code>Type u -&gt; Type v</code></p>



<a name="214218311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218311">(Oct 22 2020 at 17:14)</a>:</h4>
<p>It would be cool to define the "category" of groups as having underlying object type <code>\Sigma {u : universe} (G : Type u) (is_group : group G)</code></p>



<a name="214218324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218324">(Oct 22 2020 at 17:15)</a>:</h4>
<p>oh <code>bundled_hom</code> isn't a bundled hom</p>



<a name="214218333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218333">(Oct 22 2020 at 17:15)</a>:</h4>
<p>But nevertheless <code>ring_hom.id</code> is a thing</p>



<a name="214218389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218389">(Oct 22 2020 at 17:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/113488-general/topic/universes/near/214218311">said</a>:</p>
<blockquote>
<p>It would be cool to define the "category" of groups as having underlying object type <code>\Sigma {u : universe} (G : Type u) (is_group : group G)</code></p>
</blockquote>
<p>Is that an example of a \HUGE category?</p>



<a name="214218407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218407">(Oct 22 2020 at 17:15)</a>:</h4>
<p>I'm trying to understand what the end goal is though</p>



<a name="214218418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218418">(Oct 22 2020 at 17:15)</a>:</h4>
<p>type in type</p>



<a name="214218494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218494">(Oct 22 2020 at 17:16)</a>:</h4>
<p>So that the universal property of the free group is actually the left adjoint to the forgetful functor for example.</p>



<a name="214218553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218553">(Oct 22 2020 at 17:16)</a>:</h4>
<p>But <code>bundled_hom.funext</code> and so on sounds a lot simpler than talking about universal properties</p>



<a name="214218754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218754">(Oct 22 2020 at 17:18)</a>:</h4>
<p>also don't forget the "metatheorem" approach: write a tactic to generate all instantiations of a schematic theorem</p>



<a name="214218818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218818">(Oct 22 2020 at 17:18)</a>:</h4>
<p>you can quite often write higher order theorems than the logic actually supports this way</p>



<a name="214218839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214218839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214218839">(Oct 22 2020 at 17:19)</a>:</h4>
<p>This was on my mind too but I wanted to understand what those theorems are first.</p>



<a name="214219058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219058">(Oct 22 2020 at 17:20)</a>:</h4>
<p>I think a tactic that writes the theory of <code>foo_hom</code>s would be more useful than literal category theory</p>



<a name="214219204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219204">(Oct 22 2020 at 17:21)</a>:</h4>
<p>and as long as everything is in meta-land the high consistency strength requirements of general category theory is no problem</p>



<a name="214219320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219320">(Oct 22 2020 at 17:22)</a>:</h4>
<p>Well, I think Johan's intention was also not to literally do category theory but just be able to abstract over what it means to be a "foo hom" when multiple universes are involved</p>



<a name="214219380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219380">(Oct 22 2020 at 17:22)</a>:</h4>
<p>sure, but I assume this is going to be used for something</p>



<a name="214219437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219437">(Oct 22 2020 at 17:23)</a>:</h4>
<p>like perhaps proving theorems generic over different kinds of bundled homs</p>



<a name="214219448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219448">(Oct 22 2020 at 17:23)</a>:</h4>
<p>For <code>ext</code> this problem is already solved by <code>@[ext]</code>, right?</p>



<a name="214219518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219518">(Oct 22 2020 at 17:23)</a>:</h4>
<p>I think the interesting problem is explicating the actual set of theorems we'd like to generate for foo homs</p>



<a name="214219525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219525">(Oct 22 2020 at 17:23)</a>:</h4>
<p>What's an example of a theorem in mathlib which would be a special case of one of these generalized theorems?</p>



<a name="214219714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219714">(Oct 22 2020 at 17:25)</a>:</h4>
<p>I am still stuck at the stage where everything category theory appears to deliver is utterly trivial results about associativity pentagons that are one line proofs in the concrete case, which is why I have a poor opinion of the subject</p>



<a name="214219742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219742">(Oct 22 2020 at 17:25)</a>:</h4>
<p>In particular, it's not clear to me that we couldn't solve whatever the problem is by just having a class like <code>class has_hom (foo : Type*) (bar : Type*)</code> without it knowing that we're always going to set e.g. <code>foo = ring.{u}</code> and <code>bar = ring.{v}</code>.</p>



<a name="214219749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219749">(Oct 22 2020 at 17:25)</a>:</h4>
<p>I would like to be able to write the following, for example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">is_free_group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">incl</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">lift</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="kd">universe</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">H</span><span class="o">)</span>
<span class="o">(</span><span class="n">lift_comp_incl</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="kd">universe</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">H</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">lift</span> <span class="n">f</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">incl</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>
<span class="o">(</span><span class="n">lift_unique</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="kd">universe</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">H</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">H</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">g</span> <span class="bp">∘</span> <span class="n">incl</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">lift</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>



<a name="214219862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219862">(Oct 22 2020 at 17:26)</a>:</h4>
<p>No, this universal property example I understand and it seems hard but it sounded like the things Johan wanted might be easy.</p>



<a name="214219888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214219888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214219888">(Oct 22 2020 at 17:27)</a>:</h4>
<p>Oh, then I misunderstood what the goal was.</p>



<a name="214220433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214220433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214220433">(Oct 22 2020 at 17:31)</a>:</h4>
<p>you can get reasonably close to a general theory using</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">is_free_group_lift</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">incl</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">H</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lift</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">H</span><span class="o">)</span>
<span class="o">(</span><span class="n">lift_comp_incl</span> <span class="o">:</span> <span class="n">lift</span> <span class="bp">∘</span> <span class="n">incl</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>
<span class="o">(</span><span class="n">lift_unique</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">H</span><span class="o">}</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">∘</span> <span class="n">incl</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">lift</span><span class="o">)</span>
</code></pre></div>



<a name="214220698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214220698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214220698">(Oct 22 2020 at 17:33)</a>:</h4>
<p>Oh interesting.</p>



<a name="214220901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214220901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214220901">(Oct 22 2020 at 17:34)</a>:</h4>
<p>But of course this wouldn't give a specification of the free group.</p>



<a name="214220966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214220966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214220966">(Oct 22 2020 at 17:35)</a>:</h4>
<p>no but I'm not trying to do that, I'm trying to do everything a specification of the free group would do</p>



<a name="214221111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221111">(Oct 22 2020 at 17:36)</a>:</h4>
<p>anyway we know how to specify free groups, you can just restrict to universe u and that works because free groups have some presentability property</p>



<a name="214221242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221242">(Oct 22 2020 at 17:37)</a>:</h4>
<p>you can always say "I wish my foundations were more expressive than they are, because they miss &lt;use case X&gt;", that's godel incompleteness</p>



<a name="214221257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221257">(Oct 22 2020 at 17:37)</a>:</h4>
<p>Right, the fact that you can't directly state what I called the "Universal property" is kind of annoying, but in specific cases you can find alternative definitions (e.g., by restricting the universe to an appropriate one) and then prove an "improved" eliminator which removes the universe restriction.</p>



<a name="214221471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221471">(Oct 22 2020 at 17:39)</a>:</h4>
<p>My contention above is actually that you can use <code>is_free_group_lift</code> to work with the unreduced <code>is_free_group</code> predicate by referring to it obliquely</p>



<a name="214221492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221492">(Oct 22 2020 at 17:39)</a>:</h4>
<p>For example in your original <code>is_free_group</code>, if we replace <code>v</code> by <code>u</code> (since we know the free group construction doesn't increase the universe level, this should be fine), then the type of <code>is_free_group.lift</code> is something like <code>Pi (G : Type u) (S : Type u) [group G] [is_free_group G S] {H : Type u} [group H] (f : S -&gt; H) : G -&gt;* H</code>, but we can define a better projection with the type <code>Pi (G : Type u) (S : Type u) [group G] [is_free_group G S] {H : Type v} [group H] (f : S -&gt; H) : G -&gt;* H</code>.</p>



<a name="214221595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221595">(Oct 22 2020 at 17:40)</a>:</h4>
<p>And for the construction side, obviously it's fine to only have to pass the fields in in the special case <code>v = u</code>.</p>



<a name="214221662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221662">(Oct 22 2020 at 17:40)</a>:</h4>
<p>I think for every foo in <code>one</code>, <code>mul</code>, <code>monoid</code>, <code>ring</code>,  we have about 100 lines of quasi-consistent api for <code>foo_hom</code> (and <code>linear_map</code> and <code>alg_hom</code> maybe, although they depend on <code>R</code>), and then another 100 lines for <code>foo_equiv</code>.</p>



<a name="214221713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221713">(Oct 22 2020 at 17:41)</a>:</h4>
<p>so let's automate it</p>



<a name="214221717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221717">(Oct 22 2020 at 17:41)</a>:</h4>
<p>But these APIs are currently not all homogeneous, there are gaps all over the place.</p>



<a name="214221739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221739">(Oct 22 2020 at 17:41)</a>:</h4>
<p>Our only hope is that Yury will refactor them....</p>



<a name="214221890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221890">(Oct 22 2020 at 17:42)</a>:</h4>
<p>We want <code>ext</code>, <code>ext_iff</code>, <code>coe</code>, <code>coe_injective</code>, <code>funext</code>, <code>congr_arg</code>, <code>congr_fun</code>, <code>coe_mk</code>, and another 10 common lemmas</p>



<a name="214221912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221912">(Oct 22 2020 at 17:42)</a>:</h4>
<p>It would be nice to have a framework for writing entire theory templates that will be multiply instantiated</p>



<a name="214221963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214221963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214221963">(Oct 22 2020 at 17:42)</a>:</h4>
<p><code>id</code>, <code>comp</code>, <code>id_comp</code>, <code>comp_id</code>, <code>comp_assoc</code>, <code>id_apply</code>, <code>comp_apply</code></p>



<a name="214222063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222063">(Oct 22 2020 at 17:43)</a>:</h4>
<p>those lemmas are all inputs to the category theory though, you get no help in proving them</p>



<a name="214222225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222225">(Oct 22 2020 at 17:44)</a>:</h4>
<p>I don't think abstracting over the category is really viable anyways when using the style of unbundled objects and arrows that specify which structure they preserve</p>



<a name="214222248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222248">(Oct 22 2020 at 17:45)</a>:</h4>
<p>Not all of them are input, and some of them the automation should be able to guess</p>



<a name="214222270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222270">(Oct 22 2020 at 17:45)</a>:</h4>
<p>I mean, I guess it might be but it's not the way the category theory library is set up at least</p>



<a name="214222375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222375">(Oct 22 2020 at 17:45)</a>:</h4>
<p>it's certainly viable for meta code to abstract over the category</p>



<a name="214222460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222460">(Oct 22 2020 at 17:46)</a>:</h4>
<p>even if it's a large/universe polymorphic category</p>



<a name="214222570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222570">(Oct 22 2020 at 17:46)</a>:</h4>
<p>Right, I meant trying to prove the theorems like <code>comp_assoc</code> for all the variants like <code>-&gt;*</code> simultaneously (or even making them all instances of the same type class or whatever).</p>



<a name="214222589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222589">(Oct 22 2020 at 17:47)</a>:</h4>
<p>it does seem like a good idea to focus on the concrete category case though, because almost all our examples are of that form</p>



<a name="214222599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222599">(Oct 22 2020 at 17:47)</a>:</h4>
<p>By simultaneously I mean in a single Lean definition</p>



<a name="214222641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222641">(Oct 22 2020 at 17:47)</a>:</h4>
<p>I feel like we're going back to all those discussions about universal algebra ;)</p>



<a name="214222653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222653">(Oct 22 2020 at 17:47)</a>:</h4>
<p>Yay!</p>



<a name="214222791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214222791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214222791">(Oct 22 2020 at 17:48)</a>:</h4>
<p>didn't someone write a program that would do some of this? Subgroups and submonoids and other subthings?</p>



<a name="214223056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214223056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214223056">(Oct 22 2020 at 17:49)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/Free.20stuff/near/209873309">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Free.20stuff/near/209873309</a></p>



<a name="214223461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214223461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214223461">(Oct 22 2020 at 17:52)</a>:</h4>
<p>Clearly a framework for doing this in a more ergonomic way would be good</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">homomorphism_comp</span> <span class="o">(</span><span class="n">struct_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">declaration</span> <span class="o">:=</span>
<span class="k">do</span> <span class="o">(</span><span class="n">params</span><span class="o">,</span> <span class="n">fields</span><span class="o">)</span> <span class="bp">←</span> <span class="n">get_parameters_and_data_fields</span> <span class="n">struct_name</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">base_type</span> <span class="o">:=</span> <span class="n">params.head</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">struct_u</span> <span class="o">:</span> <span class="n">expr</span> <span class="o">:=</span>  <span class="n">expr.const</span> <span class="n">struct_name</span> <span class="o">[</span><span class="n">level.param</span> <span class="bp">`</span><span class="n">u</span><span class="o">],</span>
   <span class="k">let</span> <span class="n">struct_v</span> <span class="o">:</span> <span class="n">expr</span> <span class="o">:=</span>  <span class="n">expr.const</span> <span class="n">struct_name</span> <span class="o">[</span><span class="n">level.param</span> <span class="bp">`</span><span class="n">v</span><span class="o">],</span>
   <span class="k">let</span> <span class="n">struct_w</span> <span class="o">:</span> <span class="n">expr</span> <span class="o">:=</span>  <span class="n">expr.const</span> <span class="n">struct_name</span> <span class="o">[</span><span class="n">level.param</span> <span class="bp">`</span><span class="n">w</span><span class="o">],</span>
   <span class="n">α</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="bp">`</span><span class="n">α</span> <span class="n">binder_info.implicit</span> <span class="o">(</span><span class="n">sort</span> <span class="o">(</span><span class="n">level.succ</span> <span class="o">(</span><span class="n">level.param</span> <span class="bp">`</span><span class="n">u</span><span class="o">))),</span>
   <span class="n">ia</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="bp">`</span><span class="n">ia</span> <span class="n">binder_info.inst_implicit</span> <span class="o">(</span><span class="n">struct_u</span> <span class="n">α</span><span class="o">),</span>
   <span class="n">β</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="bp">`</span><span class="n">β</span> <span class="n">binder_info.implicit</span> <span class="o">(</span><span class="n">sort</span> <span class="o">(</span><span class="n">level.succ</span> <span class="o">(</span><span class="n">level.param</span> <span class="bp">`</span><span class="n">v</span><span class="o">))),</span>
   <span class="n">ib</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="bp">`</span><span class="n">ib</span> <span class="n">binder_info.inst_implicit</span> <span class="o">(</span><span class="n">struct_v</span> <span class="n">β</span><span class="o">),</span>
   <span class="n">γ</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="bp">`</span><span class="n">γ</span> <span class="n">binder_info.implicit</span> <span class="o">(</span><span class="n">sort</span> <span class="o">(</span><span class="n">level.succ</span> <span class="o">(</span><span class="n">level.param</span> <span class="bp">`</span><span class="n">w</span><span class="o">))),</span>
   <span class="n">ic</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="bp">`</span><span class="n">ic</span> <span class="n">binder_info.inst_implicit</span> <span class="o">(</span><span class="n">struct_w</span> <span class="n">γ</span><span class="o">),</span>
   <span class="n">f</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="bp">`</span><span class="n">f</span> <span class="n">binder_info.implicit</span> <span class="o">(</span><span class="n">pi</span> <span class="bp">`</span><span class="n">_x</span> <span class="n">binder_info.default</span> <span class="n">α</span> <span class="n">β</span><span class="o">),</span>
   <span class="n">g</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="bp">`</span><span class="n">g</span> <span class="n">binder_info.implicit</span> <span class="o">(</span><span class="n">pi</span> <span class="bp">`</span><span class="n">_x</span> <span class="n">binder_info.default</span> <span class="n">β</span> <span class="n">γ</span><span class="o">),</span>
   <span class="k">let</span> <span class="n">hom_name</span> <span class="o">:=</span> <span class="n">mk_simple_name</span> <span class="o">(</span><span class="n">string.append</span> <span class="n">struct_name.to_string</span> <span class="s2">"_homomorphism"</span><span class="o">),</span>
   <span class="k">let</span> <span class="n">hom_constr_name</span> <span class="o">:=</span> <span class="n">hom_name</span> <span class="bp">&lt;.&gt;</span> <span class="s2">"mk"</span><span class="o">,</span>
   <span class="n">hom_f</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="n">hom_name</span> <span class="o">[</span><span class="n">α</span><span class="o">,</span> <span class="n">β</span><span class="o">,</span> <span class="n">ia</span><span class="o">,</span> <span class="n">ib</span><span class="o">,</span> <span class="n">f</span><span class="o">],</span>
   <span class="n">hom_g</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="n">hom_name</span> <span class="o">[</span><span class="n">β</span><span class="o">,</span> <span class="n">γ</span><span class="o">,</span> <span class="n">ib</span><span class="o">,</span> <span class="n">ic</span><span class="o">,</span> <span class="n">g</span><span class="o">],</span>
   <span class="n">hf</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="bp">`</span><span class="n">hf</span> <span class="n">binder_info.default</span> <span class="n">hom_f</span><span class="o">,</span>
   <span class="n">hg</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="bp">`</span><span class="n">hg</span> <span class="n">binder_info.default</span> <span class="n">hom_g</span><span class="o">,</span>
   <span class="n">compos</span> <span class="bp">←</span> <span class="n">mk_mapp</span> <span class="bp">`</span><span class="n">function.comp</span> <span class="o">[</span><span class="n">none</span><span class="o">,</span> <span class="n">none</span><span class="o">,</span> <span class="n">none</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">f</span><span class="o">],</span>
   <span class="n">stmt</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="n">hom_name</span> <span class="o">[</span><span class="n">α</span><span class="o">,</span> <span class="n">γ</span><span class="o">,</span> <span class="n">ia</span><span class="o">,</span> <span class="n">ic</span><span class="o">,</span> <span class="n">compos</span><span class="o">],</span>
   <span class="k">let</span> <span class="n">field_numbers</span> <span class="o">:=</span> <span class="n">list.range</span> <span class="n">fields.length</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">fields_enum</span> <span class="o">:=</span> <span class="n">list.zip</span> <span class="n">fields</span> <span class="n">field_numbers</span><span class="o">,</span>
   <span class="n">compatibilities</span> <span class="bp">←</span> <span class="n">fields_enum.mmap</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">field_enum</span><span class="o">,</span> <span class="n">homomorphism_comp_part</span> <span class="n">struct_name</span> <span class="n">base_type</span> <span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">ia</span> <span class="n">ib</span> <span class="n">ic</span> <span class="n">f</span> <span class="n">g</span> <span class="n">hf</span> <span class="n">hg</span>
                    <span class="n">field_enum.fst</span> <span class="n">field_enum.snd</span> <span class="n">fields_enum.length</span><span class="o">),</span>
   <span class="n">constr</span> <span class="bp">←</span> <span class="n">mk_mapp</span> <span class="n">hom_constr_name</span> <span class="o">[</span><span class="n">some</span> <span class="n">α</span><span class="o">,</span> <span class="n">some</span> <span class="n">γ</span><span class="o">,</span> <span class="n">some</span> <span class="n">ia</span><span class="o">,</span> <span class="n">some</span> <span class="n">ic</span><span class="o">,</span> <span class="n">some</span> <span class="n">compos</span><span class="o">],</span>
   <span class="k">let</span> <span class="n">body</span> <span class="o">:=</span> <span class="n">expr.app_of_list</span> <span class="n">constr</span> <span class="n">compatibilities</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">decl_body</span> <span class="o">:=</span> <span class="n">expr.lambdas</span> <span class="o">[</span><span class="n">α</span><span class="o">,</span> <span class="n">β</span><span class="o">,</span> <span class="n">γ</span><span class="o">,</span> <span class="n">ia</span><span class="o">,</span> <span class="n">ib</span><span class="o">,</span> <span class="n">ic</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">hf</span><span class="o">,</span> <span class="n">hg</span><span class="o">]</span> <span class="n">body</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">decl_type</span> <span class="o">:=</span> <span class="n">expr.pis</span> <span class="o">[</span><span class="n">α</span><span class="o">,</span> <span class="n">β</span><span class="o">,</span> <span class="n">γ</span><span class="o">,</span> <span class="n">ia</span><span class="o">,</span> <span class="n">ib</span><span class="o">,</span> <span class="n">ic</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">hf</span><span class="o">,</span> <span class="n">hg</span><span class="o">]</span> <span class="n">stmt</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">decl_name</span> <span class="o">:=</span> <span class="n">mk_simple_name</span> <span class="o">(</span><span class="n">string.append</span> <span class="n">struct_name.to_string</span> <span class="s2">"_homomorphism_comp"</span><span class="o">),</span>
   <span class="n">return</span> <span class="bp">$</span> <span class="n">declaration.thm</span> <span class="n">decl_name</span> <span class="o">(</span><span class="n">collect_univ_params</span> <span class="n">decl_type</span><span class="o">)</span> <span class="n">decl_type</span> <span class="o">(</span><span class="n">task.pure</span> <span class="n">decl_body</span><span class="o">)</span>
<span class="c1">-- for any transitive target? eq, if, iff, ...</span>
</code></pre></div>



<a name="214223910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214223910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214223910">(Oct 22 2020 at 17:55)</a>:</h4>
<p>One possibility, similar to <code>to_additive</code>, would be to write a sort of "sample definition" and extract the template to instantiate from it, changing the names of constants and possibly applying a substitution but otherwise keeping things as is</p>



<a name="214223921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214223921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214223921">(Oct 22 2020 at 17:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110193">@Cyril Cohen</span> How hard is it to tie your algebra framework into Lean?</p>



<a name="214224676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214224676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214224676">(Oct 22 2020 at 18:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/universes/near/214223910">said</a>:</p>
<blockquote>
<p>One possibility, similar to <code>to_additive</code>, would be to write a sort of "sample definition" and extract the template to instantiate from it, changing the names of constants and possibly applying a substitution but otherwise keeping things as is</p>
</blockquote>
<p>I believe you'll find that such a tool already exists and is known as "the C preprocessor" <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="214224924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214224924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214224924">(Oct 22 2020 at 18:02)</a>:</h4>
<p>I guess stuff like "preserves the algebraic structure" needs to iterate over a variable number of operations (e.g. <code>+</code>, <code>*</code> or both)</p>



<a name="214225057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214225057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214225057">(Oct 22 2020 at 18:03)</a>:</h4>
<p>But the proof of <code>ext_iff</code> doesn't care about algebraic structure. And neither does <code>comp_assoc</code>, nor does <code>comp_id</code> or <code>id_apply</code>.</p>



<a name="214226554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214226554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214226554">(Oct 22 2020 at 18:13)</a>:</h4>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>lemma one_hom.to_fun_eq_coe
lemma one_hom.coe_mk
lemma one_hom.coe_inj
lemma one_hom.ext
lemma one_hom.ext_iff
lemma one_hom.id_apply
lemma one_hom.comp_apply
lemma one_hom.comp_assoc
lemma one_hom.cancel_right
lemma one_hom.cancel_left
lemma one_hom.comp_id
lemma one_hom.id_comp
</code></pre></div>

<p>this is what I extracted about <code>one_hom</code>s</p>
<p>The proofs don't use any properties of <code>one_hom</code>, except that it behaves like a function.<br>
It's all <code>rfl</code> or <code>cases, cases, congr</code> or some generic logic lemmas.</p>



<a name="214226627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214226627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214226627">(Oct 22 2020 at 18:14)</a>:</h4>
<p>The list is incomplete, because things like <code>funext</code> and <code>congr_arg</code> are missing.</p>



<a name="214227530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214227530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214227530">(Oct 22 2020 at 18:20)</a>:</h4>
<p>Right, so while I think it's probably better to autogenerate these lemmas at the same time as we autogenerate the rest of the theory of <code>has_one</code>s and <code>sub_has_one</code>s and so on, I claim you don't need any fancy universe polymorphism to implement <code>one_hom.comp_assoc</code>, say, in terms of ingredients that say that "taking the underlying function" is injective and commutes with composition.</p>



<a name="214227603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214227603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214227603">(Oct 22 2020 at 18:21)</a>:</h4>
<p>I'm not really sure, though.</p>



<a name="214227844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214227844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214227844">(Oct 22 2020 at 18:23)</a>:</h4>
<p>Could those particular lemmas be written in terms of a <code>has_to_fun</code> typeclass?</p>



<a name="214228005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214228005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214228005">(Oct 22 2020 at 18:24)</a>:</h4>
<p>Which provides <code>has_coe_to_fun</code> in term of the member</p>



<a name="214228131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214228131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214228131">(Oct 22 2020 at 18:25)</a>:</h4>
<p>Right, I would just start with things like <code>class has_comp (a b : Type) (c : out_param Type)</code> and compatibility classes and see whether that's good enough</p>



<a name="214228620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214228620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214228620">(Oct 22 2020 at 18:28)</a>:</h4>
<p>So I'm trying something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">hom</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">),</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_faithful_coe_to_fun</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">coe</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_faithful</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">coe</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">coe</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">has_faithful_coe_to_fun</span>

<span class="kd">variable</span> <span class="o">[</span><span class="n">has_faithful_coe_to_fun</span> <span class="n">hom</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">hom</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">coe</span> <span class="n">f</span><span class="o">⟩</span>

<span class="kd">@[ext]</span>
<span class="kd">lemma</span> <span class="n">ext</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⇑</span><span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">is_faithful</span> <span class="n">h</span>

<span class="kd">end</span> <span class="n">has_faithful_coe_to_fun</span>
</code></pre></div>



<a name="214228895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214228895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214228895">(Oct 22 2020 at 18:30)</a>:</h4>
<p>But I'm getting an error at <code>ext</code> saying <code>only constants and Pi types are supported: hom α β</code>.</p>



<a name="214229033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214229033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214229033">(Oct 22 2020 at 18:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113488-general/topic/universes/near/214224676">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113488-general/topic/universes/near/214223910">said</a>:</p>
<blockquote>
<p>One possibility, similar to <code>to_additive</code>, would be to write a sort of "sample definition" and extract the template to instantiate from it, changing the names of constants and possibly applying a substitution but otherwise keeping things as is</p>
</blockquote>
<p>I believe you'll find that such a tool already exists and is known as "the C preprocessor" <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>
</blockquote>
<p>You know, we have something that is just as flexible/hackish as the C preprocessor: <code>emit_code_here</code></p>



<a name="214229161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214229161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214229161">(Oct 22 2020 at 18:32)</a>:</h4>
<p>that's definitely one way to make theory templates, just do string replacement in a big code block in quotes</p>



<a name="214229308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214229308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214229308">(Oct 22 2020 at 18:34)</a>:</h4>
<p>plus, unlike the tactic approach, it actually lets you write <code>def</code>s that are just as good as the real thing</p>



<a name="214229509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214229509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214229509">(Oct 22 2020 at 18:35)</a>:</h4>
<p>How do you use it? Can I just write the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">run_cmd</span> <span class="n">emit_code_here</span> <span class="s2">"def foo := 1"</span>
</code></pre></div>



<a name="214229852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214229852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214229852">(Oct 22 2020 at 18:38)</a>:</h4>
<p>Can we use this: <a href="#narrow/stream/113488-general/topic/Generate.20homomorphism.20types.20for.20algebraic.20structures/">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generate.20homomorphism.20types.20for.20algebraic.20structures/</a> ?</p>



<a name="214230078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214230078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214230078">(Oct 22 2020 at 18:39)</a>:</h4>
<p>huh, I guess we need a <code>run_parser</code> command to make this easier</p>



<a name="214230207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214230207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214230207">(Oct 22 2020 at 18:40)</a>:</h4>
<p>There must be some <code>tactic unit</code> that takes a parser and runs it no?</p>



<a name="214231973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214231973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214231973">(Oct 22 2020 at 18:54)</a>:</h4>
<p>I have absolutely no idea what I'm doing... Can I make this work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[user_command]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">add_thing</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">interactive.parse</span> <span class="bp">$</span> <span class="n">lean.parser.tk</span> <span class="s2">"add_thing"</span><span class="o">)</span> <span class="o">:</span> <span class="n">lean.parser</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">s</span> <span class="bp">←</span> <span class="n">lean.parser.ident</span><span class="o">,</span>
  <span class="n">lean.parser.emit_code_here</span> <span class="o">(</span><span class="n">to_string</span> <span class="n">s</span><span class="o">)</span>
</code></pre></div>



<a name="214232401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232401">(Oct 22 2020 at 18:57)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.core</span>

<span class="kd">@[user_command]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">add_thing</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">interactive.parse</span> <span class="bp">$</span> <span class="n">lean.parser.tk</span> <span class="s2">"add_thing"</span><span class="o">)</span> <span class="o">:</span> <span class="n">lean.parser</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">s</span> <span class="bp">←</span> <span class="n">lean.parser.ident</span><span class="o">,</span>
  <span class="n">lean.parser.emit_code_here</span> <span class="o">(</span><span class="n">to_string</span> <span class="n">s</span><span class="o">)</span>
<span class="bp">.</span>

<span class="n">add_thing</span> <span class="bp">«</span><span class="k">#check</span> <span class="mi">5</span><span class="bp">»</span>
</code></pre></div>



<a name="214232452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232452">(Oct 22 2020 at 18:57)</a>:</h4>
<p>Oh, the <code>.</code> is necessary?</p>



<a name="214232548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232548">(Oct 22 2020 at 18:58)</a>:</h4>
<p>Well <code>add_thing</code> isn't a user command until the declaration ends, and if <code>add_thing</code> is not a user command then writing it will not end the declaration.</p>



<a name="214232554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232554">(Oct 22 2020 at 18:58)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.basic</span>

<span class="kn">open</span> <span class="n">tactic</span> <span class="n">lean.parser</span> <span class="n">interactive</span> <span class="n">interactive.types</span>
<span class="kd">@[user_command]</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">run_parser_cmd</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">parse</span> <span class="bp">$</span> <span class="n">tk</span> <span class="s2">"run_parser"</span><span class="o">)</span> <span class="o">:</span> <span class="n">lean.parser</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">e</span> <span class="bp">←</span> <span class="n">lean.parser.pexpr</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">e</span> <span class="bp">←</span> <span class="n">tactic.to_expr</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">p</span> <span class="bp">←</span> <span class="n">eval_expr</span> <span class="o">(</span><span class="n">lean.parser</span> <span class="n">unit</span><span class="o">)</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">p.</span>

<span class="n">run_parser</span> <span class="n">emit_code_here</span> <span class="s2">"def foo := 1"</span>

<span class="k">#print</span> <span class="n">foo</span>
</code></pre></div>



<a name="214232637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232637">(Oct 22 2020 at 18:59)</a>:</h4>
<p>You could also put any other command in between.</p>



<a name="214232707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232707">(Oct 22 2020 at 18:59)</a>:</h4>
<p>Like I said, I really had no idea what I was doing. That's the first piece of <code>meta</code> code I've even tried to write.</p>



<a name="214232747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232747">(Oct 22 2020 at 18:59)</a>:</h4>
<p>I don't know if it's what you intended but I'm amused at the idea of writing entire Lean definitions inside <code>«...»</code>.</p>



<a name="214232888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232888">(Oct 22 2020 at 19:00)</a>:</h4>
<p>oh, you are using ident quoting? That's an interesting way to get highlighting</p>



<a name="214232948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232948">(Oct 22 2020 at 19:00)</a>:</h4>
<p>It's not highlighting in vscode</p>



<a name="214232963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232963">(Oct 22 2020 at 19:01)</a>:</h4>
<p>it doesn't give the correct highlighting in emacs though, does it work well in ...</p>



<a name="214232976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232976">(Oct 22 2020 at 19:01)</a>:</h4>
<p>it also doesn't work with newlines apparently</p>



<a name="214232985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214232985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214232985">(Oct 22 2020 at 19:01)</a>:</h4>
<p>ok well at least it works in Zulip! <span aria-label="octopus" class="emoji emoji-1f419" role="img" title="octopus">:octopus:</span></p>



<a name="214233006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233006">(Oct 22 2020 at 19:01)</a>:</h4>
<p>oh, no newlines is bad</p>



<a name="214233008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233008">(Oct 22 2020 at 19:01)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">run_parser</span> <span class="n">emit_code_here</span> <span class="bp">«</span>
  <span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">»</span>
<span class="c1">-- error: illegal character in escaped identifier</span>
</code></pre></div>



<a name="214233286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233286">(Oct 22 2020 at 19:03)</a>:</h4>
<p>I don't suppose there's a <code>parser</code> for an entire top-level command?</p>



<a name="214233289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233289">(Oct 22 2020 at 19:03)</a>:</h4>
<p>this also doesn't seem to work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">run_parser</span> <span class="n">emit_code_here</span> <span class="s2">"</span>
<span class="s2">  def foo := 1</span>
<span class="s2">"</span>
</code></pre></div>

<p>something funny happens when the last <code>"</code> is not indented</p>



<a name="214233320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233320">(Oct 22 2020 at 19:03)</a>:</h4>
<p>there is</p>



<a name="214233330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233330">(Oct 22 2020 at 19:03)</a>:</h4>
<p><code>command_like</code></p>



<a name="214233340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233340">(Oct 22 2020 at 19:03)</a>:</h4>
<p>can you get the source string out?</p>



<a name="214233441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233441">(Oct 22 2020 at 19:04)</a>:</h4>
<p><code>meta constant command_like : parser unit</code></p>



<a name="214233450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233450">(Oct 22 2020 at 19:04)</a>:</h4>
<p>no, it executes on the spot</p>



<a name="214233464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233464">(Oct 22 2020 at 19:04)</a>:</h4>
<p>doesn't seem <em>entirely</em> helpful</p>



<a name="214233473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233473">(Oct 22 2020 at 19:04)</a>:</h4>
<p>ah, I see</p>



<a name="214233501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233501">(Oct 22 2020 at 19:04)</a>:</h4>
<p>it's actually the way <code>emit_code_here</code> works</p>



<a name="214233532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233532">(Oct 22 2020 at 19:05)</a>:</h4>
<p>it's just <code>with_input command_like</code></p>



<a name="214233598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233598">(Oct 22 2020 at 19:05)</a>:</h4>
<p>It would be slick if instead of doing any quoting at all like <code>foo "def ..."</code>, you could just write <code>foo def ...</code></p>



<a name="214233625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233625">(Oct 22 2020 at 19:05)</a>:</h4>
<p>Anyone have any idea why the <code>faithful_has_coe_to_fun</code> a little ways above didn't work? It seems unfortunate to have to resort to code generation to define basic stuff about morphisms, where we don't have to do so for structures</p>



<a name="214233726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233726">(Oct 22 2020 at 19:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/113488-general/topic/universes/near/214233625">said</a>:</p>
<blockquote>
<p>Anyone have any idea why the <code>faithful_has_coe_to_fun</code> a little ways above didn't work? It seems unfortunate to have to resort to code generation to define basic stuff about morphisms, where we don't have to do so for structures</p>
</blockquote>
<p>I think it has to do with the <code>@[ext]</code> attribute itself.</p>



<a name="214233727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233727">(Oct 22 2020 at 19:06)</a>:</h4>
<p>Do you mean the error about <code>ext</code>?</p>



<a name="214233783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233783">(Oct 22 2020 at 19:06)</a>:</h4>
<p><code>ext</code> expects the lemmas to have a certain form, kind of like <code>simp</code></p>



<a name="214233870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214233870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214233870">(Oct 22 2020 at 19:07)</a>:</h4>
<p><code>hom</code> is a variable, not a constant</p>



<a name="214234023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214234023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214234023">(Oct 22 2020 at 19:08)</a>:</h4>
<p>Ah, so we'd need code generation at least for populating <code>ext</code> attributes</p>



<a name="214234082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214234082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214234082">(Oct 22 2020 at 19:08)</a>:</h4>
<p>Or we could change how <code>ext</code> works. But I think doing code generation is preferable anyways.</p>



<a name="214234217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214234217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214234217">(Oct 22 2020 at 19:10)</a>:</h4>
<p>yeah, right now this string interpolation approach seems better than alternatives, even for the more complex use cases with a variable number of operations</p>



<a name="214234303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214234303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214234303">(Oct 22 2020 at 19:10)</a>:</h4>
<p>in fact it might not even be horrible looking if you use <code>format!</code></p>



<a name="214234326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214234326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214234326">(Oct 22 2020 at 19:10)</a>:</h4>
<p>which I don't find enough uses for</p>



<a name="214234525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214234525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214234525">(Oct 22 2020 at 19:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">run_parser</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">foo</span> <span class="o">:=</span> <span class="s2">"bar"</span><span class="o">,</span>
  <span class="n">emit_code_here</span> <span class="o">(</span><span class="n">format</span><span class="bp">!</span><span class="s2">"</span>
<span class="s2">    def {foo} := 1</span>
<span class="s2">    "</span><span class="o">)</span><span class="bp">.</span><span class="n">to_string</span>

<span class="k">#print</span> <span class="n">bar</span>
</code></pre></div>



<a name="214235369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214235369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214235369">(Oct 22 2020 at 19:18)</a>:</h4>
<p>Does lean have something like python's multiline strings with <code>"""</code>?</p>



<a name="214235476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214235476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214235476">(Oct 22 2020 at 19:19)</a>:</h4>
<p>Or can I just write multiline strings with <code>"</code>?</p>



<a name="214235574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214235574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214235574">(Oct 22 2020 at 19:19)</a>:</h4>
<p>Cool. It's strange about the indentation of <code>"</code>, in Mario's comment above.</p>



<a name="214235797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214235797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214235797">(Oct 22 2020 at 19:21)</a>:</h4>
<p>Looks like it's about the final newline.<br>
E.g. this works</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">str</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span>
<span class="s2">"</span>
<span class="s2">def foo := 1</span>
<span class="s2">def bar := 2"</span>

<span class="n">run_parser</span> <span class="n">emit_code_here</span> <span class="n">str</span>
</code></pre></div>



<a name="214235822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214235822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214235822">(Oct 22 2020 at 19:21)</a>:</h4>
<p>But this doesn't (or at least it looks like <code>run_parser</code> loops forever)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">str</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span>
<span class="s2">"</span>
<span class="s2">def foo := 1</span>
<span class="s2">def bar := 2</span>
<span class="s2">"</span>

<span class="n">run_parser</span> <span class="n">emit_code_here</span> <span class="n">str</span>
</code></pre></div>



<a name="214236277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214236277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214236277">(Oct 22 2020 at 19:25)</a>:</h4>
<p><code>run_parser</code> PR'd in <a href="https://github.com/leanprover-community/mathlib/issues/4745">#4745</a></p>



<a name="214236466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214236466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214236466">(Oct 22 2020 at 19:26)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">run_parser</span> <span class="n">emit_code_here</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span> <span class="c1">-- loops</span>
</code></pre></div>



<a name="214236578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214236578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214236578">(Oct 22 2020 at 19:27)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">run_parser</span> <span class="k">do</span> <span class="n">with_input</span> <span class="n">command_like</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="o">,</span> <span class="n">pure</span> <span class="o">()</span> <span class="c1">-- no loop</span>
</code></pre></div>



<a name="214236580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214236580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214236580">(Oct 22 2020 at 19:27)</a>:</h4>
<p>I guess we could make a new function <code>emit_code_here'</code> which removes trailing newlines</p>



<a name="214236721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214236721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214236721">(Oct 22 2020 at 19:28)</a>:</h4>
<p>Oh I see:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">emit_code_here</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">lean.parser</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="n">str</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">left</span> <span class="bp">←</span> <span class="n">emit_command_here</span> <span class="n">str</span><span class="o">,</span>
            <span class="k">if</span> <span class="n">left.length</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">return</span> <span class="o">()</span>
            <span class="k">else</span> <span class="n">emit_code_here</span> <span class="n">left</span>
</code></pre></div>

<p>this has no termination condition</p>



<a name="214236761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214236761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214236761">(Oct 22 2020 at 19:29)</a>:</h4>
<p>It should check that <code>left.length &lt; str.length</code></p>



<a name="214237950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214237950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214237950">(Oct 22 2020 at 19:38)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/4746">#4746</a></p>



<a name="214238013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214238013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214238013">(Oct 22 2020 at 19:38)</a>:</h4>
<p>Already failing CI...</p>



<a name="214239047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214239047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214239047">(Oct 22 2020 at 19:47)</a>:</h4>
<blockquote>
<p>I don't always test my code, but when I do, I do it in production.</p>
</blockquote>
<p>-- Mario's shirt</p>



<a name="214243961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214243961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214243961">(Oct 22 2020 at 20:28)</a>:</h4>
<p>Hm, I wasn't really planning on using <code>run_parser</code> to actually parse something in the source, but it is possible:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">run_parser</span> <span class="k">do</span> <span class="c1">-- 4</span>
  <span class="n">tk</span> <span class="s2">"."</span><span class="o">,</span>
  <span class="n">e</span> <span class="bp">←</span> <span class="n">texpr</span><span class="o">,</span>
  <span class="bp">↑</span><span class="o">(</span><span class="n">to_expr</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">eval_expr</span> <span class="n">ℕ</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span><span class="o">)</span>
<span class="bp">.</span>
<span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span>
</code></pre></div>



<a name="214244121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214244121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214244121">(Oct 22 2020 at 20:30)</a>:</h4>
<p>unfortunately parsers can't parse command keywords like <code>def</code> so this isn't quite what reid was looking for</p>



<a name="214247264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214247264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214247264">(Oct 22 2020 at 20:57)</a>:</h4>
<p>This is fun!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">monoid_stuff</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[(</span><span class="s2">"mul"</span><span class="o">,</span><span class="mi">2</span><span class="o">),(</span><span class="s2">"one"</span><span class="o">,</span><span class="mi">0</span><span class="o">)]</span>

<span class="kd">def</span> <span class="n">mk_op_str_aux</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">s</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">s</span> <span class="bp">++</span> <span class="s2">" → "</span> <span class="bp">++</span> <span class="o">(</span><span class="n">mk_op_str_aux</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">mk_op_str</span> <span class="o">(</span><span class="n">nn</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span> <span class="n">nn</span> <span class="bp">++</span> <span class="s2">" : "</span> <span class="bp">++</span> <span class="n">mk_op_str_aux</span> <span class="n">s</span> <span class="n">n</span>

<span class="kd">def</span> <span class="n">mk_class_str_aux</span> <span class="o">(</span><span class="n">nn</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="s2">""</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">list.cons</span> <span class="n">hd</span> <span class="n">tl</span><span class="o">)</span> <span class="o">:=</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">( "</span> <span class="bp">++</span> <span class="n">mk_op_str</span> <span class="n">hd.1</span> <span class="n">nn</span> <span class="n">hd.2</span> <span class="bp">++</span> <span class="s2">" )"</span> <span class="bp">++</span> <span class="n">mk_class_str_aux</span> <span class="n">tl</span>

<span class="kd">def</span> <span class="n">mk_class_str</span> <span class="o">(</span><span class="n">class_name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">string</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">ls</span><span class="o">,</span> <span class="s2">"class "</span> <span class="bp">++</span> <span class="n">class_name</span> <span class="bp">++</span> <span class="s2">" (α : Type*) :="</span> <span class="bp">++</span> <span class="n">mk_class_str_aux</span> <span class="s2">"α"</span> <span class="n">ls</span>

<span class="n">run_parser</span> <span class="n">emit_code_here</span> <span class="o">(</span><span class="n">mk_class_str</span> <span class="s2">"raw_monoid"</span> <span class="n">monoid_stuff</span><span class="o">)</span>

<span class="k">#print</span> <span class="n">raw_monoid</span>
</code></pre></div>



<a name="214248786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214248786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214248786">(Oct 22 2020 at 21:11)</a>:</h4>
<p>Ah, but I get a "deep recursion" error if I try to define a typeclass with a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10000</mn></mrow><annotation encoding="application/x-tex">10000</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>-ary operation.</p>



<a name="214248859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214248859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214248859">(Oct 22 2020 at 21:12)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3679</mn></mrow><annotation encoding="application/x-tex">3679</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mord">7</span><span class="mord">9</span></span></span></span>-ary operations are okay though</p>



<a name="214248997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214248997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214248997">(Oct 22 2020 at 21:13)</a>:</h4>
<p>Well, hopefully Lean 4 will let us supoport 3680-ary operations</p>



<a name="214250956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214250956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214250956">(Oct 22 2020 at 21:32)</a>:</h4>
<p>It's a bit slow for some reason, but this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">monoid_stuff</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[(</span><span class="s2">"mul"</span><span class="o">,</span><span class="mi">10000</span><span class="o">),(</span><span class="s2">"one"</span><span class="o">,</span><span class="mi">0</span><span class="o">)]</span>

<span class="kd">def</span> <span class="n">arity</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">arity</span> <span class="n">n</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mk_class_str_aux</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="s2">""</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">list.cons</span> <span class="o">(</span><span class="n">nn</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="n">tl</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">format</span><span class="bp">!</span><span class="s2">"</span><span class="se">\n</span><span class="s2">({nn} : arity {s} {to_string n})"</span><span class="o">)</span><span class="bp">.</span><span class="n">to_string</span> <span class="bp">++</span> <span class="n">mk_class_str_aux</span> <span class="n">tl</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mk_class_str</span> <span class="o">(</span><span class="n">class_name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">string</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">ls</span><span class="o">,</span> <span class="s2">"class "</span> <span class="bp">++</span> <span class="n">class_name</span> <span class="bp">++</span> <span class="s2">" (α : Type*) :="</span> <span class="bp">++</span> <span class="n">mk_class_str_aux</span> <span class="s2">"α"</span> <span class="n">ls</span>

<span class="n">run_parser</span> <span class="n">emit_code_here</span> <span class="o">(</span><span class="n">mk_class_str</span> <span class="s2">"raw_monoid"</span> <span class="n">monoid_stuff</span><span class="o">)</span>

<span class="k">#print</span> <span class="n">raw_monoid</span>
</code></pre></div>



<a name="214251099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214251099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214251099">(Oct 22 2020 at 21:34)</a>:</h4>
<p>Oh interesting. So the the deep recursion is only a problem when you generate a large string, and not when you generate a long type expression</p>



<a name="214251130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214251130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214251130">(Oct 22 2020 at 21:34)</a>:</h4>
<p>This <code>arity</code> type is in  mathlib somewhere...</p>



<a name="214251143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214251143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214251143">(Oct 22 2020 at 21:35)</a>:</h4>
<p>no, the deep recursion isn't for the string, it's for the parsing of the notation <code>A -&gt; A -&gt; A -&gt; ... -&gt; A</code></p>



<a name="214251158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214251158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214251158">(Oct 22 2020 at 21:35)</a>:</h4>
<p>Oh ok</p>



<a name="214251178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214251178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214251178">(Oct 22 2020 at 21:35)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/arity">docs#arity</a></p>



<a name="214251210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214251210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214251210">(Oct 22 2020 at 21:35)</a>:</h4>
<p>although I think that you can also get into deep recursion trouble when constructing the strings too</p>



<a name="214251257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214251257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214251257">(Oct 22 2020 at 21:36)</a>:</h4>
<p>or at least quadratic behavior</p>



<a name="214251338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214251338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214251338">(Oct 22 2020 at 21:37)</a>:</h4>
<p>you should probably stick to the iterated arrows instead of arity though, since it requires unfolding at point of use</p>



<a name="214251436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214251436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214251436">(Oct 22 2020 at 21:38)</a>:</h4>
<p>Ooh, I had another idea...</p>



<a name="214252331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214252331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214252331">(Oct 22 2020 at 21:48)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">monoid_stuff</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="o">[(</span><span class="s2">"mul"</span><span class="o">,</span><span class="mi">10000</span><span class="o">),(</span><span class="s2">"one"</span><span class="o">,</span><span class="mi">0</span><span class="o">)]</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">arity</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">α</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">tactic.exact</span> <span class="bp">$</span> <span class="o">(</span><span class="n">expr.pi</span> <span class="bp">`</span><span class="n">_x</span> <span class="n">binder_info.default</span> <span class="n">α</span><span class="o">)</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="n">α</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mk_class_str_aux</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="s2">""</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">list.cons</span> <span class="o">(</span><span class="n">nn</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="n">tl</span><span class="o">)</span> <span class="o">:=</span>
  <span class="s2">"</span><span class="se">\n</span><span class="s2">("</span> <span class="bp">++</span> <span class="n">nn</span> <span class="bp">++</span> <span class="s2">" : by arity ```("</span> <span class="bp">++</span> <span class="n">s</span> <span class="bp">++</span> <span class="s2">") "</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">n</span> <span class="bp">++</span> <span class="s2">")"</span> <span class="bp">++</span> <span class="n">mk_class_str_aux</span> <span class="n">tl</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mk_class_str</span> <span class="o">(</span><span class="n">class_name</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">string</span> <span class="bp">×</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">string</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">ls</span><span class="o">,</span> <span class="s2">"class "</span> <span class="bp">++</span> <span class="n">class_name</span> <span class="bp">++</span> <span class="s2">" (α : Type*) :="</span> <span class="bp">++</span> <span class="n">mk_class_str_aux</span> <span class="s2">"α"</span> <span class="n">ls</span>

<span class="n">run_parser</span> <span class="n">emit_code_here</span> <span class="o">(</span><span class="n">mk_class_str</span> <span class="s2">"raw_monoid"</span> <span class="n">monoid_stuff</span><span class="o">)</span>

<span class="k">#print</span> <span class="n">raw_monoid</span>
</code></pre></div>



<a name="214252422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214252422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214252422">(Oct 22 2020 at 21:49)</a>:</h4>
<p>it times out, unfortunately. I think it's getting stuck somewhere in the aux defs of the structure</p>



<a name="214252685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214252685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214252685">(Oct 22 2020 at 21:52)</a>:</h4>
<p>it's a metametametaprogram</p>



<a name="214252773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214252773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214252773">(Oct 22 2020 at 21:53)</a>:</h4>
<p>That's cool, even just to be able to write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">arity</span> <span class="bp">```</span><span class="o">(</span><span class="n">ℕ</span><span class="o">)</span> <span class="mi">3</span>
<span class="k">#print</span> <span class="n">fo</span>
</code></pre></div>



<a name="214252877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214252877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214252877">(Oct 22 2020 at 21:54)</a>:</h4>
<p>it makes the parser's job easier here, since there are no long chains in the source text</p>



<a name="214252928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214252928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214252928">(Oct 22 2020 at 21:55)</a>:</h4>
<p>I think lean still has to go through them all when dealing with the exprs later in elaboration and typechecking</p>



<a name="214253102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214253102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214253102">(Oct 22 2020 at 21:57)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">arity</span> <span class="bp">```</span><span class="o">(</span><span class="n">ℕ</span><span class="o">)</span> <span class="mi">24525</span>
</code></pre></div>

<p>Lean is happy with that, but not with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>24526</mn></mrow><annotation encoding="application/x-tex">24526</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">5</span><span class="mord">2</span><span class="mord">6</span></span></span></span>.</p>



<a name="214253288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214253288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214253288">(Oct 22 2020 at 21:59)</a>:</h4>
<p>to be fair, if you have a structure with a 24526-ary operation then perhaps you would rather generalize to <code>n</code>-ary</p>



<a name="214260166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/214260166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#214260166">(Oct 22 2020 at 23:36)</a>:</h4>
<p>Ping <span class="user-mention" data-user-id="315523">@Colter MacDonald</span></p>



<a name="273327630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/273327630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#273327630">(Feb 26 2022 at 08:37)</a>:</h4>
<p>Type theory/logic noob here. We currently cannot state universe restrictions. And I understand that this is a box of pandora. We want equality of expressions of universe levels to be decidable. However, since the theory of linearly ordered abelian groups is decidable, I was wondering whether it is possible to add <code>u &lt; v</code> constraints to the theory of universe levels and still have a system that works well in practice.<br>
I guess this would mean that the kernel might need to run some version of <code>omega</code> during typechecking, which is maybe not very performant/practical. On the other hand, 99% of the time, we would be inside the current fragment of universe logic. So maybe it can be made to work.</p>
<p>Being able to write <code>u &lt; v</code> or <code>u ≤ v</code> constraints would be really useful for statements in category theory.</p>



<a name="273329880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/273329880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#273329880">(Feb 26 2022 at 09:30)</a>:</h4>
<p>We basically can already write <code>u ≤ v</code> and <code>u &lt; v</code> because <code>u ≤ max u w</code> and <code>u &lt; max (u+1) w</code> so you can let <code>v = max u w</code> or <code>v = max (u+1) w</code>.</p>



<a name="273340836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/273340836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#273340836">(Feb 26 2022 at 13:31)</a>:</h4>
<p>Yes, that's a very good point. But these expressions can potentially get quite complicated, right? This is the approach that we recently started using in the category theory library. We'll have to find out how far we can push it in practice.</p>



<a name="273343769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universes/near/273343769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/universes.html#273343769">(Feb 26 2022 at 14:28)</a>:</h4>
<p>Didn't we already see this failing earlier this week? Lean failed to unify <code>max u v = max v ?m_1</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
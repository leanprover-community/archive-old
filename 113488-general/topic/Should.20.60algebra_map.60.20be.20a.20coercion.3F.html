---
layout: archive
title: Zulip Chat Archive
permalink: /stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/113488-general/index.html">general</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html">Should `algebra_map` be a coercion?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="297077308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297077308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297077308">(Sep 04 2022 at 09:28)</a>:</h4>
<p>I have a Xena project student working on partial fraction decomposition. Here's an example of the sort of lemma they're proving: if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is an integral domain and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>R</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f\in R[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span> is a polynomial and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>j</mi></msub><mo>∈</mo><mi>R</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g_j\in R[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span> are monic polynomials for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> running through a finite set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ι</span></span></span></span>, then one can write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi mathvariant="normal">/</mi><msub><mo>∏</mo><mi>j</mi></msub><msub><mi>g</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">f/\prod_j g_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> in the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>+</mo><msub><mo>∑</mo><mi>j</mi></msub><msub><mi>r</mi><mi>j</mi></msub><mi mathvariant="normal">/</mi><msub><mi>g</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">q+\sum_j r_j/g_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">r_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> polynomials and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>deg</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>r</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>&lt;</mo><mi>deg</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>f</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\deg(r_j)&lt;\deg(f_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop">de<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> is the field of fractions of the polynomial ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span>. This is lemma <code>div_eq_quo_add_sum_rem_div</code> in file <code>data/polynomial/partial_fractions.lean</code> on branch <code>xena-partial-fractions</code>. The divisions are all taking place in the field of fractions of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span> and right now this statement in Lean looks like the rather unwieldy</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∃</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]),</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">f</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span>
      <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">q</span> <span class="bp">+</span>
        <span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">r</span> <span class="n">x</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>If however, after <code>variables (K : Type) [field K] [algebra R[X] K]  [is_fraction_ring R[X] K]
</code> I put </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">⟩</span>
</code></pre></div>
<p>then the goal becomes the far more readable</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∃</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]),</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">↑</span><span class="n">f</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">q</span> <span class="bp">+</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="bp">↑</span><span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span> <span class="bp">/</span> <span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>
<p>So this is some evidence that at least in this situation, <code>algebra_map</code> being a coercion leads to less clutter. If you add lemmas such as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[norm_cast]</span> <span class="kd">lemma</span> <span class="n">coe_algebra_map_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">map_add</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span>

<span class="kd">@[simp, norm_cast]</span> <span class="kd">lemma</span> <span class="n">coe_algebra_map_zero</span> <span class="o">:</span> <span class="o">((</span><span class="mi">0</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">map_zero</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span>

<span class="kd">@[norm_cast]</span> <span class="kd">lemma</span> <span class="n">coe_algebra_map_neg</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:</span> <span class="o">((</span><span class="bp">-</span><span class="n">x</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">x</span> <span class="o">:=</span> <span class="n">map_neg</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span> <span class="n">x</span>

<span class="kd">@[norm_cast]</span> <span class="kd">lemma</span> <span class="n">coe_algebra_map_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">map_mul</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span>

<span class="kd">@[simp, norm_cast]</span> <span class="kd">lemma</span> <span class="n">coe_algebra_map_one</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">map_one</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span>
</code></pre></div>
<p>then <code>simp</code> and <code>norm_cast</code> work how you would expect and it's been a more pleasant experience all round.</p>
<p>Are there arguments against making <code>algebra_map</code> a coercion in general? For me, <code>algebra_map R A</code> means not just "there is a ring hom from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>" but the stronger "there is a canonical ring hom from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>", which is the kind of situation where one might expect a coercion.</p>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> you suggested making it a <code>lift</code> but then I don't think I can do <code>(f : K)</code> when <code>f : R[X]</code>.</p>



<a name="297078237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297078237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297078237">(Sep 04 2022 at 09:38)</a>:</h4>
<p><code>(↑k : K)</code> isn't much longer to write, and often you can drop the <code>: K</code> due to context. Thinking of <code>(_ : _)</code> as a coercion is the wrong mental model anyway.</p>



<a name="297078283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297078283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297078283">(Sep 04 2022 at 09:39)</a>:</h4>
<p>Also this should probably be <code>has_lift_t</code> not <code>has_lift</code>.</p>



<a name="297079160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297079160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297079160">(Sep 04 2022 at 09:47)</a>:</h4>
<p>Wasn't Anne having projects for a <code>has_ring_coe</code> typeclass? That would be basically the same as <code>algebra</code> except that the hom is supposed canonical, which seems to be what you want.</p>



<a name="297079530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297079530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297079530">(Sep 04 2022 at 09:51)</a>:</h4>
<p>That also has the advantage that it helps for towers of non-commutative rings (it can replace <a href="https://leanprover-community.github.io/mathlib_docs/find/polynomial.C">docs#polynomial.C</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.scalar">docs#matrix.scalar</a>)</p>



<a name="297080888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297080888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297080888">(Sep 04 2022 at 10:04)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> can I help with this? What's your vision here? </p>
<p>My impression is that one way to push forward with the UG degree project now is not, as in the past, just to wait for things to organically happen, but to take these annoying things which are still on the list and actually match them up with undergraduates I run into who are interested in doing projects and then actually supervising them through the process. The student in question for the partial fractions project, Sidharth Hariharan, has got to the point now where he can start making PRs for partial fractions and this question of how, if at all, to coerce from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span> to its field of fractions is what's currently stopping us.</p>



<a name="297085017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297085017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297085017">(Sep 04 2022 at 10:49)</a>:</h4>
<p>If you add the instance as a coercion in <code>algebra.algebra.basic</code> then <code>alg_hom.coe_mk</code> explodes.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp, norm_cast]</span> <span class="kd">lemma</span> <span class="n">coe_mk</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span> <span class="n">h₄</span> <span class="n">h₅</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">⇑</span><span class="o">(⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">h₃</span><span class="o">,</span> <span class="n">h₄</span><span class="o">,</span> <span class="n">h₅</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span>
<span class="c1">-- error on last `f`, maximum class-instance resolution depth has been reached</span>
</code></pre></div>
<p>Proof used to be <code>rfl</code>, now statement doesn't compile.</p>



<a name="297085585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297085585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297085585">(Sep 04 2022 at 10:55)</a>:</h4>
<p>MWE</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.algebra.basic</span>

<span class="kd">instance</span> <span class="n">foo</span> <span class="o">(</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_coe</span> <span class="n">R</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">r</span><span class="o">⟩</span>

<span class="kd">@[simp, norm_cast]</span> <span class="kd">lemma</span> <span class="n">alg_hom.coe_mk''</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">B</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span> <span class="n">h₄</span> <span class="n">h₅</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">⇑</span><span class="o">(⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">h₃</span><span class="o">,</span> <span class="n">h₄</span><span class="o">,</span> <span class="n">h₅</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="c1">-- boom</span>
</code></pre></div>



<a name="297086046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297086046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297086046">(Sep 04 2022 at 10:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp, norm_cast]</span> <span class="kd">lemma</span> <span class="n">alg_hom.coe_mk''</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">B</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span> <span class="n">h₄</span> <span class="n">h₅</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">⇑</span><span class="o">(⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">h₃</span><span class="o">,</span> <span class="n">h₄</span><span class="o">,</span> <span class="n">h₅</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>works. I am coercing the function <code>f</code> to a function?</p>



<a name="297086244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297086244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297086244">(Sep 04 2022 at 11:00)</a>:</h4>
<p>Do I need to worry about priorities here? Why did that just happen?</p>



<a name="297086319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297086319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297086319">(Sep 04 2022 at 11:01)</a>:</h4>
<p>Sorry about the primes, turns out there's already a <code>coe_mk'</code></p>



<a name="297086901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297086901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297086901">(Sep 04 2022 at 11:06)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp, norm_cast]</span> <span class="kd">lemma</span> <span class="n">coe_mk</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h₃</span> <span class="n">h₄</span> <span class="n">h₅</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">⇑</span><span class="o">(⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">h₃</span><span class="o">,</span> <span class="n">h₄</span><span class="o">,</span> <span class="n">h₅</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">set_option</span> <span class="n">pp.all</span> <span class="n">true</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">coe_mk</span> <span class="c1">-- ∀ blah, blah = f even with pp.all true</span>
</code></pre></div>
<p>Why do I have to change <code>f</code> to <code>(f : A \to B)</code> and does lean not even detect this change afterwards?</p>



<a name="297087430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297087430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297087430">(Sep 04 2022 at 11:10)</a>:</h4>
<p>Proof of <code>rat.smul_one_eq_coe</code> breaks, I think because <code>rat.cast_coe = coe_base</code> is no longer <code>rfl</code> or something? I'm way out of my depth.</p>



<a name="297088950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297088950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297088950">(Sep 04 2022 at 11:24)</a>:</h4>
<p>Can't seem to fix with priorities on the new instance.</p>



<a name="297090084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297090084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297090084">(Sep 04 2022 at 11:35)</a>:</h4>
<p>Oh <code>has_lift</code> seems to be OK (this was Eric's original suggestion) in the sense that it doesn't break <code>algebra.algebra.basic</code>. I've now understood that I can still do <code>(↑r : A)</code> if I want to direct the coercion.</p>



<a name="297091496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297091496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297091496">(Sep 04 2022 at 11:51)</a>:</h4>
<p>Oh this is great. I can confirm that <code>has_lift</code> solves my original problem very nicely, so my current proposal is that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">algebra.has_lift</span> <span class="o">(</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_lift</span> <span class="n">R</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">r</span><span class="o">⟩</span>
</code></pre></div>
<p>be added to <code>mathlib</code>. Right now I'm compiling to see if it breaks anything else.</p>



<a name="297095319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297095319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297095319">(Sep 04 2022 at 12:29)</a>:</h4>
<p>My claim is that should be <code>has_lift_t</code> so that if we have a tower <code>R S A</code> the coercion from <code>R</code> to <code>A</code> doesn't try <a href="https://leanprover-community.github.io/mathlib_docs/find/lift_trans">docs#lift_trans</a></p>



<a name="297095402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297095402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297095402">(Sep 04 2022 at 12:30)</a>:</h4>
<p>Also, we should probably decide which spelling to make the simp-normal form</p>



<a name="297096032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297096032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297096032">(Sep 04 2022 at 12:37)</a>:</h4>
<p>My instinct is to make the coercion the simp normal form. The fact that you always have to spell it out makes it very appealing, instead of <code>algebra_map R A r</code> you have <code>(\u r : A)</code> and I think that the latter is much more readable for mathematicians.</p>



<a name="297096576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297096576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297096576">(Sep 04 2022 at 12:42)</a>:</h4>
<p>I can confirm that <code>has_lift_t</code> also works great in my use case, so the current proposal is to make it a <code>has_lift_t</code> and also to make the coercion the simp normal form.</p>



<a name="297107139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297107139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297107139">(Sep 04 2022 at 14:28)</a>:</h4>
<p>I'm a fan of this assuming it works essentially everywhere. When I'm dealing with <code>algebra_map</code>  frequently I introduce local notation for it.</p>



<a name="297109065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297109065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297109065">(Sep 04 2022 at 14:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∃</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]),</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">f</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span>
      <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">q</span> <span class="bp">+</span>
        <span class="bp">∑</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">r</span> <span class="n">x</span><span class="o">)</span> <span class="bp">/</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]</span> <span class="n">K</span><span class="o">)</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>I'm wondering why in you write <code>.to_fun</code> instead of simply <code>algebra_map R[X] K f</code> etc.?</p>



<a name="297109298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297109298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297109298">(Sep 04 2022 at 14:53)</a>:</h4>
<p>Oh lol you're totally right. I wrote the Zulip post after I'd got the coercion working and so I had to reverse-engineer what I had before the coercion; I used the <code>unfold_coes</code> tactic to do this but it appears to have unfolded more than I expected...</p>



<a name="297109371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297109371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297109371">(Sep 04 2022 at 14:54)</a>:</h4>
<p>Even without the <code>.to_fun</code> the point stands</p>



<a name="297109514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297109514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297109514">(Sep 04 2022 at 14:56)</a>:</h4>
<p>The point is that that a mathematician like me can just <em>read</em></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∃</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]),</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">↑</span><span class="n">f</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">q</span> <span class="bp">+</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="bp">↑</span><span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span> <span class="bp">/</span> <span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>
<p>without having to think too much, we can just switch the arrows off mentally and occasionally <code>norm_cast</code> or <code>push_cast</code> to keep us on track.</p>



<a name="297109710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297109710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297109710">(Sep 04 2022 at 14:57)</a>:</h4>
<p>With this notation I found that I could use Lean as a calculator when I was working out the algebra relating to partial fraction decomposition. It was really great.</p>



<a name="297123441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297123441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297123441">(Sep 04 2022 at 17:21)</a>:</h4>
<p>On my branch with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">has_lift_t</span> <span class="o">(</span><span class="n">R</span> <span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_lift_t</span> <span class="n">R</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span> <span class="n">r</span><span class="o">⟩</span>
</code></pre></div>
<p>there are now two non-defeq coercions from <code>fin n</code> to <code>fin n</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="bp">↑</span><span class="n">a</span> <span class="c1">-- defined recursively</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">algebra_map.has_lift_t</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">zmod</span> <span class="n">n</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- fails</span>
<span class="c1">-- because foo is recursively defined and my coercion is id.</span>
</code></pre></div>



<a name="297123969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297123969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297123969">(Sep 04 2022 at 17:27)</a>:</h4>
<p>The proof of <code>int.cast_id</code> is now <code>rfl</code>as opposed to an induction.</p>



<a name="297124730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297124730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297124730">(Sep 04 2022 at 17:36)</a>:</h4>
<p>I can tone down the priority of <code>algebra_map.has_lift_t</code> but is this acceptable or are diamonds banned?</p>



<a name="297125404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297125404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297125404">(Sep 04 2022 at 17:45)</a>:</h4>
<p>urgh this is the char_p diamond that needs fixing</p>



<a name="297125409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297125409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297125409">(Sep 04 2022 at 17:45)</a>:</h4>
<p>(at least this is my guess)</p>



<a name="297128707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297128707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297128707">(Sep 04 2022 at 18:18)</a>:</h4>
<p>The part of the diamond already in mathlib is <a href="https://leanprover-community.github.io/mathlib_docs/find/zmod.has_coe_t">docs#zmod.has_coe_t</a>, which is the (mathematically crazy) map (not a ring hom in general!) from <code>zmod n</code> to an arbitary ring <code>R</code>. But it's being used in a situation where n=0 in R where you could certainly argue that it was a natural coercion, unfortunately defined recursively in general. There should be a subsingleton instance I guess.</p>



<a name="297130238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297130238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297130238">(Sep 04 2022 at 18:36)</a>:</h4>
<p>there is a subsingleton instance I think</p>



<a name="297130243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297130243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297130243">(Sep 04 2022 at 18:36)</a>:</h4>
<p>or is that again in the char_p case?</p>



<a name="297136129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297136129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297136129">(Sep 04 2022 at 19:52)</a>:</h4>
<p>Oh the issue is that it's not in general a ring hom so it's not a subsingleton</p>



<a name="297147782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297147782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297147782">(Sep 04 2022 at 23:36)</a>:</h4>
<p>The proof of <a href="https://leanprover-community.github.io/mathlib_docs/find/int.cast_id/src">src#int.cast_id</a> should already be rfl</p>



<a name="297206409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297206409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297206409">(Sep 05 2022 at 11:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F/near/297080888">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> can I help with this? What's your vision here? </p>
</blockquote>
<p><a href="#narrow/stream/113488-general/topic/.22has.20canonical.20morphism.22.20class">Here's the original thread</a>. I did try to get some undergrad to do it for us <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span> but I don't expect there will be undergrads available until the end of this academic year.</p>
<p>I think there is a relatively safe upgrade path as follows:</p>
<ul>
<li>Define a new <code>class coe_ring_hom [semiring R] [semiring S] [has_lift_t R S] := (coe_add := ↑(x + y) = ↑x + ↑ y) (coe_etc : etc)</code>, flesh out the API somewhat. I think unbundled inheritance would the best choice, so we don't have to worry about extra diamonds arising from transitivity. It also means we can extend <code>has_lift_t</code> here while defining the instances on <code>has_coe_t</code> instead.</li>
<li>Define a new map <code>ring_hom.coe : R →+* S := { to_fun := coe, map_foo := coe_foo }</code> which will take the role of <code>algebra_map</code> whenever a bundled map is needed.</li>
<li>Add a way to translate between <code>algebra</code> and <code>coe_ring_hom</code>. I don't expect we can really do this automatically, so this probably means adding a <code>has_lift_t + coe_ring_hom</code> instance for each existing <code>algebra</code> instance.</li>
<li>Switch over <code>simp</code> normal form to prefer <code>coe</code> or <code>ring_hom.coe</code> over <code>algebra_map</code></li>
<li>Maybe add an instance <code>coe_ring_hom.to_algebra</code>?</li>
<li>Maybe totally remove <code>algebra_map</code> from the <code>algebra</code> class so the non-unital people are satisfied.</li>
</ul>



<a name="297219400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297219400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297219400">(Sep 05 2022 at 12:34)</a>:</h4>
<p>I don't see why point 3 can't be automatic, via new <code>algebra.to_has_lift_t</code> and <code>algebra.to_coe_ring_hom</code> instances</p>



<a name="297219459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297219459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297219459">(Sep 05 2022 at 12:34)</a>:</h4>
<p>Point 4 sounds like a bad idea to me, algebras have more structure than ring home coercions</p>



<a name="297224112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297224112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297224112">(Sep 05 2022 at 13:08)</a>:</h4>
<p>We have lots of existing instances of <code>algebra</code> and <code>has_coe</code> on the same types, and those are not always defeq. Add in transitivity and it starts to get quite hairy to avoid diamonds.</p>



<a name="297247218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297247218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297247218">(Sep 05 2022 at 15:50)</a>:</h4>
<p>Can you give an example of where they're not defeq?</p>



<a name="297252091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297252091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297252091">(Sep 05 2022 at 16:25)</a>:</h4>
<p>We just had this with the adjoin_root coe</p>



<a name="297252140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297252140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297252140">(Sep 05 2022 at 16:25)</a>:</h4>
<p>Obviously there was an underlying issue but these will be everywhere and crop up a lot more now</p>



<a name="297342208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297342208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297342208">(Sep 06 2022 at 10:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F/near/297109514">said</a>:</p>
<blockquote>
<p>The point is that that a mathematician like me can just <em>read</em></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∃</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">])</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span><span class="o">[</span><span class="n">X</span><span class="o">]),</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">degree</span><span class="o">)</span> <span class="bp">∧</span>
    <span class="bp">↑</span><span class="n">f</span> <span class="bp">/</span> <span class="bp">∏</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">q</span> <span class="bp">+</span> <span class="bp">∑</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">)</span> <span class="k">in</span> <span class="n">s</span><span class="o">,</span> <span class="bp">↑</span><span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span> <span class="bp">/</span> <span class="bp">↑</span><span class="o">(</span><span class="n">g</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>
<p>without having to think too much, we can just switch the arrows off mentally and occasionally <code>norm_cast</code> or <code>push_cast</code> to keep us on track.</p>
</blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Don't you need some coprimality assumption on the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">g_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>? Think of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⋅</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">?</mo><mi mathvariant="normal">/</mi><mi>x</mi><mo>+</mo><mo stretchy="false">?</mo><mi mathvariant="normal">/</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">1/(x \cdot x) = ?/x+ ?/x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">?</span><span class="mord">/</span><span class="mord mathnormal">x</span><span class="mord">+</span><span class="mclose">?</span><span class="mord">/</span><span class="mord mathnormal">x</span></span></span></span>...</p>



<a name="297345786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/297345786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#297345786">(Sep 06 2022 at 11:06)</a>:</h4>
<p>Ha ha yes, I deleted some hypotheses to make the result look clearer :-)</p>



<a name="304672006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/304672006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#304672006">(Oct 18 2022 at 12:57)</a>:</h4>
<p>Remember this old thread? <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span> I just got <a href="https://github.com/leanprover-community/mathlib/tree/coe_hom">branch#coe_hom</a> to build (on an old mathlib), which provides classes for e.g. <code>↑(x + y) = ↑x + ↑y</code> and <code>ring_hom.coe</code>.</p>



<a name="304692477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Should%20%60algebra_map%60%20be%20a%20coercion%3F/near/304692477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F.html#304692477">(Oct 18 2022 at 14:34)</a>:</h4>
<p>Now in PR form: <a href="https://github.com/leanprover-community/mathlib/pull/17048">#17048</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>